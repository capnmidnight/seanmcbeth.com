{
  "version": 3,
  "sources": ["../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/src/typeChecks.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/arrays.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/src/identity.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/mapMap.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/makeLookup.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/PriorityList.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/PriorityMap.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/EventTarget.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/Task.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/once.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/src/using.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/indexdb/src/index.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/mapJoin.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/sleep.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/withRetry.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/TypedEventTarget.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/src/BaseProgress.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/src/ChildProgressCallback.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/src/BaseParentProgressCallback.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/src/progressSplit.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/src/translateResponse.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/src/util.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/src/text.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/src/FetchingServiceImplXHR.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/src/flags.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/workers/src/WorkerServer.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/src/FetchingService.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/src/FetchingServiceServer.ts", "../../../../workers/fetcher/index.ts"],
  "sourcesContent": ["function t(o: any, s: string, c: Function) {\n    return typeof o === s\n        || o instanceof c;\n}\n\nexport function isFunction(obj: any): obj is Function {\n    return t(obj, \"function\", Function);\n}\n\nexport function isString(obj: any): obj is string {\n    return t(obj, \"string\", String);\n}\n\nexport function isBoolean(obj: any): obj is boolean {\n    return t(obj, \"boolean\", Boolean);\n}\n\nexport function isNumber(obj: any): obj is number {\n    return t(obj, \"number\", Number);\n}\n\n/**\n * Check a value to see if it is of a number type\n * and is the special NaN value or one of the Infinities.\n */\nexport function isBadNumber(num: number): boolean {\n    return isNullOrUndefined(num)\n        || !Number.isFinite(num)\n        || Number.isNaN(num);\n}\n\n/**\n * Check a value to see if it is of a number type\n * and is not the special NaN value nor one of the Infinities.\n */\nexport function isGoodNumber(obj: any): obj is number {\n    return isNumber(obj)\n        && !isBadNumber(obj);\n}\n\nexport function isObject(obj: any): obj is object {\n    return isDefined(obj)\n        && t(obj, \"object\", Object);\n}\n\nexport function isPromise<T>(obj: any): obj is Promise<T> {\n    return obj instanceof Promise;\n}\n\nexport function isDate(obj: any): obj is Date {\n    return obj instanceof Date;\n}\n\nexport function isArray(obj: any): obj is Array<any> {\n    return obj instanceof Array;\n}\n\nexport function assertNever(x: never, msg?: string): never {\n    throw new Error((msg || \"Unexpected object: \") + x);\n}\n\nexport function isNullOrUndefined<T>(obj: T | null | undefined): obj is null | undefined {\n    return obj === null\n        || obj === undefined;\n}\n\nexport function isDefined<T>(obj: T | null | undefined): obj is T {\n    return !isNullOrUndefined(obj);\n}\n\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\n    return isFunction(obj);\n}\n\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\n    return !isEventListener(obj);\n}\n\nexport function isArrayBufferView(obj: any): obj is ArrayBufferView {\n    return obj instanceof Uint8Array\n        || obj instanceof Uint8ClampedArray\n        || obj instanceof Int8Array\n        || obj instanceof Uint16Array\n        || obj instanceof Int16Array\n        || obj instanceof Uint32Array\n        || obj instanceof Int32Array\n        || obj instanceof Float32Array\n        || obj instanceof Float64Array\n        || \"BigUint64Array\" in globalThis && obj instanceof globalThis[\"BigUint64Array\"]\n        || \"BigInt64Array\" in globalThis && obj instanceof globalThis[\"BigInt64Array\"];\n}\n\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\n    return val && typeof ArrayBuffer !== \"undefined\" &&\n        (val instanceof ArrayBuffer ||\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\n}", "import { isDefined, isFunction, isNullOrUndefined, isNumber, isObject, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\n\ninterface IComparable<T> {\n    compareTo(b: T): number;\n}\n\nfunction isIComparable<T>(obj: any): obj is IComparable<T> {\n    return isObject(obj)\n        && \"compareTo\" in obj\n        && isFunction(obj.compareTo);\n}\n\nexport type Comparable = number | Date | string | IComparable<any>;\nexport type CompareDirection = \"ascending\" | \"descending\";\nexport type CompareFunction<T> = ((a: T, b: T) => number) & {\n    direction: CompareDirection;\n}\n\nexport type ComparableSelector<T> = (obj: T) => Comparable;\n\nexport function compareBy<T>(direction: CompareDirection, ...getKeys: ComparableSelector<T>[]): CompareFunction<T>;\nexport function compareBy<T>(...getKeys: ComparableSelector<T>[]): CompareFunction<T>;\nexport function compareBy<T>(directionOrFirstKeyGetter: CompareDirection | ComparableSelector<T>, ...getKeys: ((obj: T) => Comparable)[]): CompareFunction<T> {\n    let direction: CompareDirection = null;\n    if (isString(directionOrFirstKeyGetter)) {\n        direction = directionOrFirstKeyGetter;\n    }\n    else {\n        direction = \"ascending\";\n        getKeys.unshift(directionOrFirstKeyGetter);\n    }\n\n    const d = direction === \"ascending\" ? 1 : -1;\n\n    const comparer = (a: T, b: T) => {\n        if (a === b) {\n            return 0;\n        }\n\n        for (const getKey of getKeys) {\n            const keyA = isNullOrUndefined(a) ? null : getKey(a);\n            const keyB = isNullOrUndefined(b) ? null : getKey(b);\n            const relation = keyA === keyB\n                ? 0\n                : isString(keyA) && isString(keyB)\n                    ? d * keyA.localeCompare(keyB)\n                    : isIComparable(keyA) && isIComparable(keyB)\n                        ? d * keyA.compareTo(keyB)\n                        : direction === \"ascending\" && keyA > keyB\n                            || direction === \"descending\" && keyA < keyB\n                            ? 1 : -1;\n\n            if (relation !== 0) {\n                return relation;\n            }\n        }\n\n        return 0;\n    };\n\n    return Object.assign(comparer, {\n        direction\n    });\n}\n\nexport type SearchMode = \"append\" | \"prepend\" | \"search\";\n\nexport function binarySearch<T>(arr: ArrayLike<T>, searchValue: T, comparer: CompareFunction<T>, mode: SearchMode = \"search\") {\n    let left = 0;\n    let right = arr.length - 1;\n    while (left <= right) {\n        let mid = (left + right) >> 1;\n        let relation = comparer(arr[mid], searchValue);\n        if (relation === 0) {\n            if (mode !== \"search\") {\n                const scanDirection = mode === \"append\" ? 1 : -1;\n                if (scanDirection > 0) {\n                    mid += scanDirection;\n                }\n                while (0 <= mid\n                    && mid < arr.length\n                    && (relation = comparer(arr[mid], searchValue)) === 0) {\n                    mid += scanDirection;\n                }\n                if (scanDirection < 0) {\n                    mid -= scanDirection;\n                }\n            }\n\n            return mid;\n        }\n        else if (relation < 0) {\n            left = mid - relation;\n        }\n        else {\n            right = mid - relation;\n        }\n    }\n\n    return -left - 1;\n}\n\nexport type InsertMode = \"set\" | SearchMode;\n\nexport function insertSorted<T>(arr: T[], val: T, idx: number): number;\nexport function insertSorted<T>(arr: T[], val: T, comparer: CompareFunction<T>): number;\nexport function insertSorted<T>(arr: T[], val: T, comparer: CompareFunction<T>, mode: InsertMode): number;\nexport function insertSorted<T>(arr: T[], val: T, comparerOrIdx: CompareFunction<T> | number, mode: InsertMode = \"search\"): number {\n    const allowDuplicates = mode !== \"set\";\n    if (mode === \"set\") {\n        mode = \"search\";\n    }\n\n    let idx: number = null;\n    if (isNumber(comparerOrIdx)) {\n        idx = comparerOrIdx;\n    }\n    else {\n        idx = binarySearch(arr, val, comparerOrIdx, mode);\n    }\n\n    if (idx < 0) {\n        idx = -idx - 1;\n    }\n    else if (!allowDuplicates) {\n        return -1;\n    }\n\n    arrayInsertAt(arr, val, idx);\n    return idx;\n}\n\nexport function removeSorted<T>(arr: T[], val: T, comparer: CompareFunction<T>): number {\n    const idx = binarySearch(arr, val, comparer);\n    if (idx >= 0) {\n        arrayRemoveAt(arr, idx);\n        return idx;\n    }\n    return -1;\n}\n\n\n/**\n * Empties out an array, returning the items that were in the array.\n * \n * @param arr the array to empty\n */\nexport function arrayClear<T>(arr: T[]) {\n    return arr.splice(0);\n}\n\n/**\n * Checks to see if two arrays contain the same elements\n * @returns -1 if the arrays match, the index of the first mismatched item if they don't.\n * @param arr1\n * @param arr2\n */\n\nexport function arrayCompare<T>(arr1: ReadonlyArray<T>, arr2: ReadonlyArray<T>): number {\n    for (let i = 0; i < arr1.length; ++i) {\n        if (arr1[i] !== arr2[i]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n\nexport function arrayGen<T>(count: number, thunk: (i: number) => T): T[] {\n    return Array.from(iterableGen(count, thunk));\n}\n\nexport function* iterableGen<T>(count: number, thunk: (i: number) => T) {\n    for (let i = 0; i < count; ++i) {\n        yield thunk(i);\n    }\n}\n\n\n/**\n * Inserts an item at the given index into an array.\n * @param arr\n * @param item\n * @param idx\n */\n\nexport function arrayInsertAt<T>(arr: T[], item: T, idx: number) {\n    arr.splice(idx, 0, item);\n}\n\n/**\n * Returns a random item from an array of items.\n *\n * Provides an option to consider an additional item as part of the collection\n * for random selection.\n */\nexport function arrayRandom<T>(arr: T[], defaultValue?: T): T | undefined {\n    const offset = defaultValue != null ? 1 : 0,\n        idx = Math.floor(Math.random() * (arr.length + offset)) - offset;\n    if (idx < 0) {\n        return defaultValue;\n    }\n    else {\n        return arr[idx];\n    }\n}\n\n\n/**\n * Removes a given item from an array, returning true if the item was removed.\n */\nexport function arrayRemove<T>(arr: T[], value: T) {\n    const idx = arr.indexOf(value);\n    if (idx > -1) {\n        arrayRemoveAt(arr, idx);\n        return true;\n    }\n\n    return false;\n}\n\nexport function arrayFilter<T>(arr: T[], predicate: (v: T) => boolean): T | null {\n    for (let i = arr.length - 1; i >= 0; --i) {\n        if (predicate(arr[i])) {\n            return arrayRemoveAt(arr, i);\n        }\n    }\n\n    return null;\n}\n\nexport function arrayRemoveByKey<T, K>(arr: T[], key: K, getKey: (v: T) => K): T | null {\n    return arrayFilter(arr, (v) => getKey(v) === key);\n}\n\n/**\n * Removes an item at the given index from an array.\n */\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\n    return arr.splice(idx, 1)[0];\n}\n\n/**\n * Replaces all of the items in an array with the given items.\n *\n * This helps reduce GC pressure as you're not creating arrays\n * and then dropping them on the floor.\n * \n * @param arr the array to fill\n * @param items the items to put into the array\n */\nexport function arrayReplace<T>(arr: T[], ...items: T[]) {\n    arr.splice(0, arr.length, ...items);\n}\n\nexport function arrayCreate<T>(count: number, make: (i: number, len?: number) => T): T[] {\n    const arr = new Array<T>(count);\n    for (let i = 0; i < count; ++i) {\n        arr[i] = make(i, count);\n    }\n    return arr;\n}\n\n\nfunction _arrayScan<T>(forward: boolean, arr: readonly T[], tests: ((val: T) => boolean)[]): T {\n    const start = forward ? 0 : arr.length - 1;\n    const end = forward ? arr.length : -1;\n    const inc = forward ? 1 : -1;\n    for (const test of tests) {\n        for (let i = start; i != end; i += inc) {\n            const item = arr[i];\n            if (test(item)) {\n                return item;\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * Scans through a series of filters to find an item that matches\n * any of the filters. The first item of the first filter that matches\n * will be returned.\n */\nexport function arrayScan<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;\nexport function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T\nexport function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T {\n    return _arrayScan(true, arr, tests);\n}\n\n/**\n * Scans through a series of filters to find an item that matches\n * any of the filters. The last item of the first filter that matches\n * will be returned.\n */\nexport function arrayScanReverse<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;\nexport function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T;\nexport function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T {\n    return _arrayScan(false, arr, tests);\n}\n\nexport function arrayShuffleInplace<T>(arr: T[]): void {\n    for (let i = 0; i < arr.length - 1; ++i) {\n        const subLength = arr.length - i;\n        const subIndex = Math.floor(Math.random() * subLength);\n        const temp = arr[i];\n        const j = subIndex + i;\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n\nexport function arrayShuffle<T>(arr: readonly T[]): T[] {\n    const output = arr.slice();\n    arrayShuffleInplace(output);\n    return output;\n}\n\nconst numericPattern = /^(-?(?:\\d+\\.)\\d+)/;\n/**\n * Creates a new array that is sorted by the key extracted\n * by the keySelector callback, not modifying the input array,\n * (unlike JavaScript's own Array.prototype.sort).\n *\n * If the values have a number at the beginning, they'll be sorted\n * by that number.\n * @param arr\n * @param keySelector\n */\nexport function arraySortNumericByKey<T>(arr: ReadonlyArray<T>, keySelector: (obj: T) => string): T[] {\n    const comparer = compareBy<T>(v => {\n        const key = keySelector(v);\n        const match = key.match(numericPattern);\n        if (isDefined(match)) {\n            return parseFloat(match[1]);\n        }\n        return key;\n    });\n\n    return Array\n        .from(arr)\n        .sort(comparer);\n}\n\nexport function arrayZip<T, V>(arr1: readonly T[], arr2: readonly T[], combine: (a: T, b: T) => V): V[] {\n    const len = Math.max(arr1.length, arr2.length);\n    const output = new Array<V>(len);\n    for (let i = 0; i < len; ++i) {\n        output[i] = combine(arr1[i], arr2[i]);\n    }\n\n    return output;\n}\n", "export function identity<T>(item: T): T {\n    return item;\n}\n\nexport function nothing(): void {\n}\n\nexport function negate(value: number) {\n    return -value;\n}\n\nexport function alwaysTrue(): true {\n    return true;\n}\n\nexport function alwaysFalse(): false {\n    return false;\n}\n\nexport function not(value: boolean) {\n    return !value;\n}\n\nexport function and(a: boolean, b: boolean): boolean {\n    return a && b;\n}\n\nexport function or(a: boolean, b: boolean): boolean {\n    return a || b;\n}\n\nexport function xor(a: boolean, b: boolean): boolean {\n    return a !== b;\n}\n\nexport function nand(a: boolean, b: boolean): boolean {\n    return not(and(a, b));\n}\n\nexport function nor(a: boolean, b: boolean): boolean {\n    return not(or(a, b));\n}\n\nexport function equal<T>(a: T, b: T): boolean {\n    return a === b;\n}\n\nexport function reflectValue<T>(v: T): () => T {\n    return () => v;\n}\n\nexport type AsyncCallback = () => Promise<void>;", "export function mapMap<T, U, V>(items: readonly T[], makeID: (item: T) => U, makeValue: (item: T) => V) {\n    return new Map(items.map((item) => [makeID(item), makeValue(item)]));\n}", "import { identity } from \"@juniper-lib/tslib/dist/identity\";\nimport { mapMap } from \"./mapMap\";\n\nexport function makeLookup<T, U>(items: readonly T[], makeID: (item: T) => U): Map<U, T> {\n    return mapMap(items, makeID, identity);\n}", "import { isDefined, isNullOrUndefined } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { arrayClear, arrayRemove } from \"./arrays\";\n\nexport class PriorityList<KeyT, ValueT> {\n    private readonly items = new Map<KeyT, ValueT[]>();\n    private readonly defaultItems = new Array<ValueT>();\n\n    constructor(init?: [KeyT, ValueT][]) {\n        if (isDefined(init)) {\n            for (const [key, value] of init) {\n                this.add(key, value);\n            }\n        }\n    }\n\n    add(key: KeyT, ...values: ValueT[]): this {\n        for (const value of values) {\n            if (isNullOrUndefined(key)) {\n                this.defaultItems.push(value);\n            }\n            else {\n                let list = this.items.get(key);\n                if (isNullOrUndefined(list)) {\n                    this.items.set(key, list = []);\n                }\n\n                list.push(value);\n            }\n        }\n\n        return this;\n    }\n\n    entries(): IterableIterator<[KeyT, ValueT[]]> {\n        return this.items.entries();\n    }\n\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n\n    keys(): IterableIterator<KeyT> {\n        return this.items.keys();\n    }\n\n    *values(): IterableIterator<ValueT> {\n        for (const item of this.defaultItems) {\n            yield item;\n        }\n        for (const list of this.items.values()) {\n            for (const item of list) {\n                yield item;\n            }\n        }\n    }\n\n    has(key: KeyT): boolean {\n        if (isDefined(key)) {\n            return this.items.has(key);\n        }\n        else {\n            return this.defaultItems.length > 0;\n        }\n    }\n\n    get(key: KeyT): ValueT[] {\n        if (isNullOrUndefined(key)) {\n            return this.defaultItems;\n        }\n\n        return this.items.get(key) || [];\n    }\n\n    count(key: KeyT): number {\n        if (isNullOrUndefined(key)) {\n            return this.defaultItems.length;\n        }\n\n        const list = this.get(key);\n        if (isDefined(list)) {\n            return list.length;\n        }\n\n        return 0;\n    }\n\n    get size(): number {\n        let size = this.defaultItems.length;\n        for (const list of this.items.values()) {\n            size += list.length;\n        }\n        return size;\n    }\n\n    delete(key: KeyT) {\n        if (isNullOrUndefined(key)) {\n            return arrayClear(this.defaultItems).length > 0;\n        }\n        else {\n            return this.items.delete(key);\n        }\n    }\n\n    remove(key: KeyT, value: ValueT) {\n        if (isNullOrUndefined(key)) {\n            arrayRemove(this.defaultItems, value);\n        }\n        else {\n            const list = this.items.get(key);\n            if (isDefined(list)) {\n                arrayRemove(list, value);\n                if (list.length === 0) {\n                    this.items.delete(key);\n                }\n            }\n        }\n    }\n\n    clear(): void {\n        this.items.clear();\n        arrayClear(this.defaultItems);\n    }\n}\n\n\n", "import { isDefined, isNullOrUndefined } from \"@juniper-lib/tslib/dist/typeChecks\";\n\n\n\nexport class PriorityMap<Key1T, Key2T, ValueT> {\n    private readonly items = new Map<Key1T, Map<Key2T, ValueT>>();\n\n    constructor(init?: Iterable<[Key1T, Key2T, ValueT]>) {\n        if (isDefined(init)) {\n            for (const [key1, key2, value] of init) {\n                this.add(key1, key2, value);\n            }\n        }\n    }\n\n    add(key1: Key1T, key2: Key2T, value: ValueT): this {\n        let level1 = this.items.get(key1);\n        if (isNullOrUndefined(level1)) {\n            this.items.set(key1, level1 = new Map());\n        }\n\n        level1.set(key2, value);\n\n        return this;\n    }\n\n    *entries(): IterableIterator<[Key1T, Key2T, ValueT]> {\n        for (const [key1, level1] of this.items) {\n            for (const [key2, value] of level1) {\n                yield [key1, key2, value];\n            }\n        }\n    }\n    keys(): IterableIterator<Key1T>;\n    keys(key1: Key1T): IterableIterator<Key2T>;\n    keys(key1?: Key1T): IterableIterator<Key1T | Key2T> {\n        if (isNullOrUndefined(key1)) {\n            return this.items.keys();\n        }\n        else {\n            return this.items.get(key1).keys();\n        }\n    }\n\n    *values(): IterableIterator<ValueT> {\n        for (const level1 of this.items.values()) {\n            for (const value of level1.values()) {\n                yield value;\n            }\n        }\n    }\n\n    has(key1: Key1T, key2?: Key2T): boolean {\n        return this.items.has(key1)\n            && (isNullOrUndefined(key2)\n                || this.items.get(key1).has(key2));\n    }\n\n    get(key1: Key1T): Map<Key2T, ValueT>;\n    get(key1: Key1T, key2: Key2T): ValueT;\n    get(key1: Key1T, key2?: Key2T): ValueT | Map<Key2T, ValueT> {\n        if (isNullOrUndefined(key2)) {\n            return this.items.get(key1);\n        }\n        else if (this.items.has(key1)) {\n            return this.items.get(key1).get(key2);\n        }\n        else {\n            return null;\n        }\n    }\n\n    count(key1: Key1T): number {\n        if (this.items.has(key1)) {\n            return this.items.get(key1).size;\n        }\n\n        return null;\n    }\n\n    get size(): number {\n        let size = 0;\n        for (const list of this.items.values()) {\n            size += list.size;\n        }\n        return size;\n    }\n\n    delete(key1: Key1T, key2?: Key2T) {\n        if (isNullOrUndefined(key2)) {\n            return this.items.delete(key1);\n        }\n        else if (this.items.has(key1)) {\n            const items = this.items.get(key1);\n            const deleted = items.delete(key2);\n            if (items.size === 0) {\n                this.items.delete(key1);\n            }\n\n            return deleted;\n        }\n        else {\n            return false;\n        }\n    }\n\n    clear(): void {\n        this.items.clear();\n    }\n}\n", "\uFEFFimport { arrayClear, arrayRemoveAt } from \"@juniper-lib/collections/dist/arrays\";\nimport { isBoolean, isDefined, isFunction, isNullOrUndefined } from \"@juniper-lib/tslib/dist/typeChecks\";\n\nexport interface EventMap {\n    [type: string]: Event;\n}\n\nexport interface IEventTarget extends EventTarget {\n    clearEventListeners(type?: string): void;\n    addBubbler(bubbler: EventTarget): void;\n    removeBubbler(bubbler: EventTarget): void;\n    addScopedEventListener(scope: object, type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeScope(scope: object): void;\n}\n\nexport class CustomEventTarget implements IEventTarget {\n    private readonly listeners = new Map<string, EventListenerOrEventListenerObject[]>();\n    private readonly listenerOptions = new Map<EventListenerOrEventListenerObject, boolean | AddEventListenerOptions>();\n    private readonly bubblers = new Set<EventTarget>();\n    private readonly scopes = new WeakMap<object, Array<[any, any]>>();\n\n    addBubbler(bubbler: EventTarget) {\n        this.bubblers.add(bubbler);\n    }\n\n    removeBubbler(bubbler: EventTarget) {\n        this.bubblers.delete(bubbler);\n    }\n\n    addScopedEventListener(scope: object, type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\n        if (!this.scopes.has(scope)) {\n            this.scopes.set(scope, []);\n        }\n        this.scopes.get(scope).push([type, callback]);\n        this.addEventListener(type, callback as any, options);\n    }\n\n    removeScope(scope: object) {\n        const listeners = this.scopes.get(scope);\n        if (listeners) {\n            this.scopes.delete(scope);\n            for (const [type, listener] of listeners) {\n                this.removeEventListener(type, listener);\n            }\n        }\n    }\n\n    addEventListener(type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\n        let listeners = this.listeners.get(type);\n        if (!listeners) {\n            listeners = new Array<EventListenerOrEventListenerObject>();\n            this.listeners.set(type, listeners);\n        }\n\n        if (!listeners.find((c) => c === callback)) {\n            listeners.push(callback);\n\n            if (options) {\n                this.listenerOptions.set(callback, options);\n            }\n        }\n    }\n\n    removeEventListener(type: string, callback: EventListenerOrEventListenerObject) {\n        const listeners = this.listeners.get(type);\n        if (listeners) {\n            this.removeListener(listeners, callback);\n        }\n    }\n\n    clearEventListeners(type?: string) {\n        for (const [evtName, handlers] of this.listeners) {\n            if (isNullOrUndefined(type) || type === evtName) {\n                for (const handler of handlers) {\n                    this.removeEventListener(type, handler);\n                }\n                arrayClear(handlers);\n                this.listeners.delete(evtName);\n            }\n        }\n    }\n\n    private removeListener(listeners: EventListenerOrEventListenerObject[], callback: EventListenerOrEventListenerObject) {\n        const idx = listeners.findIndex((c) => c === callback);\n        if (idx >= 0) {\n            arrayRemoveAt(listeners, idx);\n            if (this.listenerOptions.has(callback)) {\n                this.listenerOptions.delete(callback);\n            }\n        }\n    }\n\n    dispatchEvent(evt: Event): boolean {\n        const listeners = this.listeners.get(evt.type);\n        if (listeners) {\n            for (const callback of listeners) {\n                const options = this.listenerOptions.get(callback);\n                if (isDefined(options)\n                    && !isBoolean(options)\n                    && options.once) {\n                    this.removeListener(listeners, callback);\n                }\n\n                if (isFunction(callback)) {\n                    callback.call(this, evt);\n                }\n                else {\n                    callback.handleEvent(evt);\n                }\n            }\n        }\n\n        if (evt.defaultPrevented) {\n            return false;\n        }\n\n        for (const bubbler of this.bubblers) {\n            if (!bubbler.dispatchEvent(evt)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\nexport class EventTargetMixin implements IEventTarget {\n    private readonly listeners = new Map<string, EventListenerOrEventListenerObject[]>();\n    private readonly listenerOptions = new Map<EventListenerOrEventListenerObject, boolean | AddEventListenerOptions>();\n    private readonly bubblers = new Set<EventTarget>();\n    private readonly scopes = new WeakMap<object, Array<[any, any]>>();\n\n    constructor(\n        private readonly _addEventListener: (type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions) => void,\n        private readonly _removeEventListener: (type: string, callback: EventListenerOrEventListenerObject) => void,\n        private readonly _dispatchEvent: (evt: Event) => boolean\n    ) {\n    }\n\n    addBubbler(bubbler: EventTarget): void {\n        this.bubblers.add(bubbler);\n    }\n\n    removeBubbler(bubbler: EventTarget): void {\n        this.bubblers.delete(bubbler);\n    }\n\n    addScopedEventListener(scope: object, type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\n        if (!this.scopes.has(scope)) {\n            this.scopes.set(scope, []);\n        }\n        this.scopes.get(scope).push([type, callback]);\n        this.addEventListener(type, callback as any, options);\n    }\n\n    removeScope(scope: object) {\n        const listeners = this.scopes.get(scope);\n        if (listeners) {\n            this.scopes.delete(scope);\n            for (const [type, listener] of listeners) {\n                this.removeEventListener(type, listener);\n            }\n        }\n    }\n\n    addEventListener(type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\n        let listeners = this.listeners.get(type);\n        if (!listeners) {\n            listeners = new Array<EventListenerOrEventListenerObject>();\n            this.listeners.set(type, listeners);\n        }\n\n        if (!listeners.find((c) => c === callback)) {\n            listeners.push(callback);\n\n            if (options) {\n                this.listenerOptions.set(callback, options);\n            }\n        }\n\n        this._addEventListener(type, callback, options);\n    }\n\n    removeEventListener(type: string, callback: EventListenerOrEventListenerObject): void {\n        const listeners = this.listeners.get(type);\n        if (listeners) {\n            this.removeListener(listeners, callback);\n        }\n\n        this._removeEventListener(type, callback);\n    }\n\n    private removeListener(listeners: EventListenerOrEventListenerObject[], callback: EventListenerOrEventListenerObject) {\n        const idx = listeners.findIndex((c) => c === callback);\n        if (idx >= 0) {\n            arrayRemoveAt(listeners, idx);\n            if (this.listenerOptions.has(callback)) {\n                this.listenerOptions.delete(callback);\n            }\n        }\n    }\n\n    clearEventListeners(type?: string): void {\n        for (const [evtName, handlers] of this.listeners) {\n            if (isNullOrUndefined(type) || type === evtName) {\n                for (const handler of handlers) {\n                    this.removeEventListener(type, handler);\n                }\n                arrayClear(handlers);\n                this.listeners.delete(evtName);\n            }\n        }\n    }\n\n    dispatchEvent(evt: Event): boolean {\n        const result = this._dispatchEvent(evt);\n\n        const listeners = this.listeners.get(evt.type);\n        if (listeners) {\n            for (const callback of listeners) {\n                const options = this.listenerOptions.get(callback);\n                if (isDefined(options)\n                    && !isBoolean(options)\n                    && options.once) {\n                    this.removeListener(listeners, callback);\n                }\n            }\n        }\n\n        if (!result) {\n            return false;\n        }\n\n        for (const bubbler of this.bubblers) {\n            if (!bubbler.dispatchEvent(evt)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n/**\n * Don't actually instantiate or subclass this class. Use it as template to create new classes.\n * Make sure to decorate your custom element with the `@CustomElement` decorator.\n * \n * I know this sucks, but I can't get the type system to do what I want right now.\n */\nexport abstract class CustomHTMLElementExample extends HTMLElement implements IEventTarget {\n\n    private readonly eventTarget: EventTargetMixin;\n\n    constructor() {\n        super();\n        this.eventTarget = new EventTargetMixin(\n            super.addEventListener.bind(this),\n            super.removeEventListener.bind(this),\n            super.dispatchEvent.bind(this)\n        );\n    }\n\n    override addEventListener(type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\n        this.eventTarget.addEventListener(type, callback, options);\n    }\n\n    override removeEventListener(type: string, callback: EventListenerOrEventListenerObject) {\n        this.eventTarget.removeEventListener(type, callback);\n    }\n\n    override dispatchEvent(evt: Event): boolean {\n        return this.eventTarget.dispatchEvent(evt);\n    }\n\n    addBubbler(bubbler: EventTarget) {\n        this.eventTarget.addBubbler(bubbler);\n    }\n\n    removeBubbler(bubbler: EventTarget) {\n        this.eventTarget.removeBubbler(bubbler);\n    }\n\n    addScopedEventListener(scope: object, type: string, callback: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void {\n        this.eventTarget.addScopedEventListener(scope, type, callback, options);\n    }\n\n    removeScope(scope: object) {\n        this.eventTarget.removeScope(scope);\n    }\n\n    clearEventListeners(type?: string): void {\n        this.eventTarget.clearEventListeners(type);\n    }\n}\n", "import { arrayClear } from \"@juniper-lib/collections/dist/arrays\";\nimport { isDefined } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { TypedEventTarget, TypedEventMap } from \"./TypedEventTarget\";\n\nexport type TaskExecutionState =\n    | \"waiting\"\n    | \"running\"\n    | \"finished\"\n\nexport type TaskResultState =\n    | \"none\"\n    | \"resolved\"\n    | \"errored\";\n\n/**\n * A Task represents a Promise that exposes its resolve/reject functions\n * as methods, rather than requiring a callback being passed to its constructor.\n * Tasks can be used to build manually-resolved Promises with less\n * boilerplate of nested function blocks.\n **/\nexport class Task<ResultsT = void> implements Promise<ResultsT> {\n    private readonly onThens = new Array<(v: ResultsT) => any>();\n    private readonly onCatches = new Array<(reason?: any) => void>();\n\n    private _result: ResultsT = undefined;\n    private _error: any = undefined;\n    private _executionState: TaskExecutionState = \"waiting\";\n    private _resultState: TaskResultState = \"none\";\n\n    /**\n     * Signal success for the Task\n     *\n     * @param value - the value to store with the resolved Task.\n     **/\n    public readonly resolve: (value: ResultsT) => void;\n\n    /**\n     * Signal failrue for the Task\n     *\n     * @param value - the error to store with the rejected Task.\n     **/\n    public readonly reject: (reason: any) => void;\n\n\n    /**\n     * Create a new Task\n     *\n     * @param autoStart - set to false to require manually starting the Task. Useful\n     * for reusable tasks that run on timers.\n     */\n    constructor(private readonly autoStart = true) {\n        // It's very likely that we will want to use resolve/reject\n        // as values to pass to another function/method, so we create\n        // them not as methods, but as bound lambda expressions stored\n        // in public fields.\n        this.resolve = (value) => {\n            if (this.running) {\n                this._result = value;\n                this._resultState = \"resolved\";\n\n                for (const thenner of this.onThens) {\n                    thenner(value);\n                }\n\n                this.clear();\n                this._executionState = \"finished\";\n            }\n        };\n\n        this.reject = (reason) => {\n            if (this.running) {\n                this._error = reason;\n                this._resultState = \"errored\";\n\n                for (const catcher of this.onCatches) {\n                    catcher(reason);\n                }\n\n                this.clear();\n                this._executionState = \"finished\";\n            }\n        };\n\n        if (this.autoStart) {\n            this.start();\n        }\n    }\n\n    private clear() {\n        arrayClear(this.onThens);\n        arrayClear(this.onCatches);\n    }\n\n    /**\n     * If the task was not auto-started, signal that the task is now ready to recieve\n     * resolutions or rejections.\n     **/\n    start() {\n        this._executionState = \"running\";\n    }\n\n    /**\n     * Creates a resolving callback for a static value.\n     * @param value\n     */\n    resolver(value: ResultsT) {\n        return () => this.resolve(value);\n    }\n\n    resolveOn<EventMapT extends TypedEventMap<string>, EventT extends keyof EventMapT = keyof EventMapT>(\n        target: TypedEventTarget<EventMapT> | EventTarget,\n        resolveEvt: EventT,\n        value: ResultsT) {\n        const resolver = this.resolver(value);\n        target.addEventListener(resolveEvt as any, resolver);\n        this.finally(() =>\n            target.removeEventListener(resolveEvt as any, resolver));\n    }\n\n    /**\n     * Get the last result that the task had resolved to, if any is available.\n     *\n     * If the Task had been rejected, attempting to get the result will rethrow\n     * the error that had rejected the task.\n     **/\n    get result(): ResultsT {\n        if (isDefined(this.error)) {\n            throw this.error;\n        }\n\n        return this._result;\n    }\n\n    /**\n     * Get the last error that the task had been rejected by, if any.\n     **/\n    get error(): any {\n        return this._error;\n    }\n\n    /**\n     * Get the current state of the task.\n     **/\n    get executionState() {\n        return this._executionState;\n    }\n\n    /**\n     * Returns true when the Task is hasn't started yet.\n     **/\n    get waiting(): boolean {\n        return this.executionState === \"waiting\";\n    }\n\n    /**\n     * Returns true when the Task is waiting to be resolved or rejected.\n     **/\n    get started(): boolean {\n        return this.executionState !== \"waiting\";\n    }\n\n    /**\n     * Returns true after the Task has started, but before it has finished.\n     **/\n    get running(): boolean {\n        return this.executionState === \"running\";\n    }\n\n    /**\n     * Returns true when the Task has been resolved or rejected.\n     **/\n    get finished(): boolean {\n        return this.executionState === \"finished\";\n    }\n\n    get resultState() {\n        return this._resultState;\n    }\n\n    /**\n     * Returns true if the Task had been resolved successfully.\n     **/\n    get resolved(): boolean {\n        return this.resultState === \"resolved\";\n    }\n\n    /**\n     * Returns true if the Task had been rejected, regardless of any\n     * reason being given.\n     **/\n    get errored(): boolean {\n        return this.resultState === \"errored\";\n    }\n\n    get [Symbol.toStringTag](): string {\n        return this.toString();\n    }\n\n    /**\n     * Calling Task.then(), Task.catch(), or Task.finally() creates a new Promise.\n     * This method creates that promise and links it with the task.\n     **/\n    private project(): Promise<ResultsT> {\n        return new Promise<ResultsT>((resolve, reject) => {\n            if (!this.finished) {\n                this.onThens.push(resolve);\n                this.onCatches.push(reject);\n            }\n            else if (this.errored) {\n                reject(this.error);\n            }\n            else {\n                resolve(this.result);\n            }\n        });\n    }\n\n    /**\n     * Attach a handler to the task that fires when the task is resolved.\n     * \n     * @param onfulfilled\n     * @param onrejected\n     */\n    then<TResult1 = ResultsT, TResult2 = never>(onfulfilled?: (value: ResultsT) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\n        return this.project().then(onfulfilled, onrejected);\n    }\n\n    /**\n     * Attach a handler that fires when the Task is rejected.\n     * \n     * @param onrejected\n     */\n    catch<TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>): Promise<ResultsT | TResult> {\n        return this.project().catch(onrejected);\n    }\n\n    /**\n     * Attach a handler that fires regardless of whether the Task is resolved\n     * or rejected.\n     * \n     * @param onfinally\n     */\n    finally(onfinally?: () => void): Promise<ResultsT> {\n        return this.project().finally(onfinally);\n    }\n\n    /**\n     * Resets the Task to an unsignalled state, which is useful for\n     * reducing GC pressure when working with lots of tasks.\n     **/\n    reset() {\n        this._reset(this.autoStart);\n    }\n\n    restart() {\n        this._reset(true);\n    }\n\n    private _reset(start: boolean) {\n        if (this.running) {\n            this.reject(\"Resetting previous invocation\");\n        }\n\n        this.clear();\n        this._result = undefined;\n        this._error = undefined;\n        this._executionState = \"waiting\";\n        this._resultState = \"none\";\n\n        if (start) {\n            this.start();\n        }\n    }\n}", "import { alwaysFalse, alwaysTrue } from \"@juniper-lib/tslib/dist/identity\";\nimport { isNullOrUndefined, isNumber, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { CustomEventTarget, EventMap } from \"./EventTarget\";\nimport { Task } from \"./Task\";\nimport { TypedEventTarget, TypedEventMap } from \"./TypedEventTarget\";\n\nfunction targetValidateEvent(target: EventTarget, type: string) {\n    return (\"on\" + type) in target;\n}\n\n/**\n * Wait for a specific event, one time.\n * @param target - the event target.\n * @param resolveEvt - the name of the event that will resolve the Promise this method creates.\n * @param [rejectEvt] - the name of the event that could reject the Promise this method creates.\n * @param [timeout] - the number of milliseconds to wait for the resolveEvt, before rejecting.\n */\nexport function once<EventMapT extends TypedEventMap<string>, EventT extends keyof EventMapT = keyof EventMapT>(target: TypedEventTarget<EventMapT>, resolveEvt: EventT, timeout: number, ...rejectEvts: (keyof EventMapT & string)[]): Task<EventMapT[EventT]>;\nexport function once<EventMapT extends TypedEventMap<string>, EventT extends keyof EventMapT = keyof EventMapT>(target: TypedEventTarget<EventMapT>, resolveEvt: EventT, ...rejectEvts: (keyof EventMapT & string)[]): Task<EventMapT[EventT]>;\nexport function once<EventMapT extends EventMap, EventT extends keyof EventMapT = keyof EventMapT>(target: EventTarget, resolveEvt: EventT, rejectEvtOrTimeout?: number | string, ...rejectEvts: EventT[]): Task<Event>\nexport function once(target: EventTarget, resolveEvt: string, rejectEvtOrTimeout?: number | string, ...rejectEvts: string[]): Task<Event> {\n\n    if (isNullOrUndefined(rejectEvts)) {\n        rejectEvts = [];\n    }\n\n    let timeout: number = undefined;\n    if (isString(rejectEvtOrTimeout)) {\n        rejectEvts.unshift(rejectEvtOrTimeout);\n    }\n    else if (isNumber(rejectEvtOrTimeout)) {\n        timeout = rejectEvtOrTimeout;\n    }\n\n    if (!(target instanceof CustomEventTarget)) {\n        if (!targetValidateEvent(target, resolveEvt)) {\n            throw new Error(`Target does not have a ${resolveEvt} rejection event`);\n        }\n\n        for (const evt of rejectEvts) {\n            if (!targetValidateEvent(target, evt)) {\n                throw new Error(`Target does not have a ${evt} rejection event`);\n            }\n        }\n    }\n\n    const task = new Task<Event>();\n\n    if (isNumber(timeout)) {\n        const timeoutHandle = setTimeout(task.reject, timeout, `'${resolveEvt}' has timed out.`);\n        task.finally(clearTimeout.bind(globalThis, timeoutHandle));\n    }\n\n    const register = (evt: string, callback: (evt: Event) => void) => {\n        target.addEventListener(evt, callback);\n        task.finally(() => target.removeEventListener(evt, callback));\n    };\n\n    register(resolveEvt, (evt) => task.resolve(evt));\n\n    const onReject = (evt: Event) => task.reject(evt);\n    for (const rejectEvt of rejectEvts) {\n        register(rejectEvt, onReject);\n    }\n\n    return task;\n}\n\nexport function success<T>(task: Task<T>): Promise<boolean> {\n    return task.then(alwaysTrue)\n        .catch(alwaysFalse);\n}", "import { isDefined, isFunction, isObject } from \"./typeChecks\";\n\nexport interface IDisposable {\n    dispose(): void;\n}\n\nexport interface IClosable {\n    close(): void;\n}\n\nexport interface ICloneable {\n    clone(): unknown;\n}\n\nexport interface IDestroyable {\n    destroy(): void;\n}\n\nfunction interfaceSigCheck<T>(obj: any, ...funcNames: string[]): obj is T {\n    if (!isObject(obj)) {\n        return false;\n    }\n\n    obj = obj as any;\n\n    for (const funcName of funcNames) {\n        if (!(funcName in obj)) {\n            return false;\n        }\n\n        const func = obj[funcName];\n        if (!isFunction(func)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function isDisposable(obj: any): obj is IDisposable {\n    return interfaceSigCheck(obj, \"dispose\");\n}\n\nexport function isDestroyable(obj: any): obj is IDestroyable {\n    return interfaceSigCheck(obj, \"destroy\");\n}\n\nexport function isClosable(obj: any): obj is IClosable {\n    return interfaceSigCheck(obj, \"close\");\n}\n\nexport function isCloneable(obj: any): obj is ICloneable {\n    return interfaceSigCheck(obj, \"clone\");\n}\n\nexport function dispose(val: any): void {\n    if (isDisposable(val)) {\n        val.dispose();\n    }\n\n    if (isClosable(val)) {\n        val.close();\n    }\n\n    if (isDestroyable(val)) {\n        val.destroy();\n    }\n}\n\ntype Cleanupable = IDisposable | IClosable | IDestroyable;\n\nexport function using<T extends Cleanupable, U>(val: T, thunk: (val: T) => U): U {\n    try {\n        return thunk(val);\n    } finally {\n        dispose(val);\n    }\n}\n\nexport function usingArray<T extends Cleanupable, U>(vals: T[], thunk: (val: T[]) => U): U {\n    try {\n        return thunk(vals);\n    } finally {\n        if (isDefined(vals)) {\n            for (const val of vals) {\n                dispose(val);\n            }\n        }\n    }\n}\n\nexport async function usingAsync<T extends Cleanupable, U>(val: T, thunk: (val: T) => Promise<U>): Promise<U> {\n    try {\n        return await thunk(val);\n    } finally {\n        dispose(val);\n    }\n}\n\n\nexport async function usingArrayAsync<T extends Cleanupable, U>(vals: T[], thunk: (val: T[]) => Promise<U>): Promise<U> {\n    try {\n        return await thunk(vals);\n    } finally {\n        if (isDefined(vals)) {\n            for (const val of vals) {\n                dispose(val);\n            }\n        }\n    }\n}\n\nclass TrashHeap implements IDisposable {\n    constructor(private readonly objs: IDisposable[]) {\n    }\n\n    dispose() {\n        for (const obj of this.objs) {\n            dispose(obj);\n        }\n    }\n\n    add(obj: IDisposable) {\n        this.objs.push(obj);\n    }\n}\n\nexport function trashHeap(...objs: IDisposable[]): TrashHeap {\n    return new TrashHeap(objs);\n}", "import { arrayCompare } from \"@juniper-lib/collections/dist/arrays\";\nimport { makeLookup } from \"@juniper-lib/collections/dist/makeLookup\";\nimport { PriorityList } from \"@juniper-lib/collections/dist/PriorityList\";\nimport { PriorityMap } from \"@juniper-lib/collections/dist/PriorityMap\";\nimport { once, success } from \"@juniper-lib/events/dist/once\";\nimport { Task } from \"@juniper-lib/events/dist/Task\";\nimport { isArray, isDefined, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { dispose, IDisposable } from \"@juniper-lib/tslib/dist/using\";\n\nexport interface IDexDBIndexDef<T = any> {\n    name: string;\n    keyPath: (keyof T & string) | (keyof T & string)[];\n    options?: IDBIndexParameters;\n}\n\nexport interface IDexDBOptionsDef<T = any> {\n    autoIncrement?: boolean;\n    keyPath?: (keyof T & string) | (keyof T & string)[];\n}\n\ninterface StoreDef {\n    name: string;\n    options?: IDexDBOptionsDef;\n    indexes?: IDexDBIndexDef[];\n}\n\nexport class IDexDB implements IDisposable {\n\n    static delete(dbName: string) {\n        const deleteRequest = indexedDB.deleteDatabase(dbName);\n        const task = once(deleteRequest, \"success\", \"error\", \"blocked\");\n        return success(task);\n    }\n\n    static async open(name: string, ...storeDefs: StoreDef[]): Promise<IDexDB> {\n        const storesByName = makeLookup(storeDefs, (v) => v.name);\n        const indexesByName = new PriorityMap<string, string, IDexDBIndexDef>(\n            storeDefs\n                .filter((storeDef) => isDefined(storeDef.indexes))\n                .flatMap<[string, string, IDexDBIndexDef]>((storeDef) =>\n                    storeDef.indexes.map<[string, string, IDexDBIndexDef]>((indexDef) =>\n                        [storeDef.name, indexDef.name, indexDef])));\n\n        const storesToAdd = new Array<string>();\n        const storesToRemove = new Array<string>();\n        const storesToChange = new Array<string>();\n        const indexesToAdd = new PriorityList<string, string>();\n        const indexesToRemove = new PriorityList<string, string>();\n\n        let version: number = null;\n\n        const D = indexedDB.open(name);\n        if (await success(once(D, \"success\", \"error\", \"blocked\"))) {\n            const db = D.result;\n            version = db.version;\n            const storesToScrutinize = new Array<string>();\n\n            for (const storeName of db.objectStoreNames) {\n                if (!storesByName.has(storeName)) {\n                    storesToRemove.push(storeName);\n                }\n            }\n\n            for (const storeName of storesByName.keys()) {\n                if (!db.objectStoreNames.contains(storeName)) {\n                    storesToAdd.push(storeName);\n                }\n                else {\n                    storesToScrutinize.push(storeName);\n                }\n            }\n            if (storesToScrutinize.length > 0) {\n                const transaction = db.transaction(storesToScrutinize);\n                const transacting = once(transaction, \"complete\", \"error\", \"abort\");\n                const transacted = success(transacting);\n\n                for (const storeName of storesToScrutinize) {\n                    const store = transaction.objectStore(storeName);\n                    const storeDef = storesByName.get(storeName);\n                    if (isDefined(storeDef.options) && store.keyPath !== storeDef.options.keyPath) {\n                        storesToRemove.push(storeName);\n                        storesToAdd.push(storeName);\n                    }\n\n                    for (const indexName of store.indexNames) {\n                        if (!indexesByName.has(storeName, indexName)) {\n                            if (storesToChange.indexOf(storeName) === -1) {\n                                storesToChange.push(storeName);\n                            }\n                            indexesToRemove.add(storeName, indexName);\n                        }\n                    }\n\n                    if (indexesByName.has(storeName)) {\n                        for (const indexName of indexesByName.get(storeName).keys()) {\n                            if (!store.indexNames.contains(indexName)) {\n                                if (storesToChange.indexOf(storeName) === -1) {\n                                    storesToChange.push(storeName);\n                                }\n                                indexesToAdd.add(storeName, indexName);\n                            }\n                            else {\n                                const indexDef = indexesByName.get(storeName, indexName);\n                                const index = store.index(indexName);\n                                if (isString(indexDef.keyPath) !== isString(index.keyPath)\n                                    || isString(indexDef.keyPath) && isString(index.keyPath) && indexDef.keyPath !== index.keyPath\n                                    || isArray(indexDef.keyPath) && isArray(index.keyPath) && arrayCompare(indexDef.keyPath, index.keyPath)) {\n                                    if (storesToChange.indexOf(storeName) === -1) {\n                                        storesToChange.push(storeName);\n                                    }\n                                    indexesToRemove.add(storeName, indexName);\n                                    indexesToAdd.add(storeName, indexName);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                transaction.commit();\n                await transacted;\n            }\n\n            dispose(db);\n        }\n        else {\n            version = 0;\n            storesToAdd.push(...storesByName.keys());\n            for (const storeDef of storeDefs) {\n                if (isDefined(storeDef.indexes)) {\n                    for (const indexDef of storeDef.indexes) {\n                        indexesToAdd.add(storeDef.name, indexDef.name);\n                    }\n                }\n            }\n        }\n\n        if (storesToAdd.length > 0\n            || storesToRemove.length > 0\n            || indexesToAdd.size > 0\n            || indexesToRemove.size > 0) {\n            ++version;\n        }\n\n        const upgrading = new Task<boolean>();\n        const openRequest = isDefined(version)\n            ? indexedDB.open(name, version)\n            : indexedDB.open(name);\n        const opening = once(openRequest, \"success\", \"error\", \"blocked\");\n        const upgraded = success(upgrading);\n        const opened = success(opening);\n\n        const noUpgrade = upgrading.resolver(false);\n        openRequest.addEventListener(\"success\", noUpgrade);\n\n        openRequest.addEventListener(\"upgradeneeded\", () => {\n            const transacting = once(openRequest.transaction, \"complete\", \"error\", \"abort\");\n            const db = openRequest.result;\n            for (const storeName of storesToRemove) {\n                db.deleteObjectStore(storeName);\n            }\n\n            const stores = new Map<string, IDBObjectStore>();\n\n            for (const storeName of storesToAdd) {\n                const storeDef = storesByName.get(storeName);\n                const store = db.createObjectStore(storeName, storeDef.options);\n                stores.set(storeName, store);\n            }\n\n            for (const storeName of storesToChange) {\n                const store = openRequest.transaction.objectStore(storeName);\n                stores.set(storeName, store);\n            }\n\n            for (const [storeName, store] of stores) {\n                for (const indexName of indexesToRemove.get(storeName)) {\n                    store.deleteIndex(indexName);\n                }\n\n                for (const indexName of indexesToAdd.get(storeName)) {\n                    const indexDef = indexesByName.get(storeName, indexName);\n                    store.createIndex(indexName, indexDef.keyPath, indexDef.options);\n                }\n            }\n\n            success(transacting)\n                .then(upgrading.resolve)\n                .catch(upgrading.reject)\n                .finally(() => openRequest.removeEventListener(\"success\", noUpgrade));\n        });\n\n        if (!(await upgraded)) {\n            throw upgrading.error;\n        }\n\n        if (!(await opened)) {\n            throw opening.error;\n        }\n\n        return new IDexDB(openRequest.result);\n    }\n\n    constructor(private readonly db: IDBDatabase) {\n\n    }\n\n    dispose() {\n        dispose(this.db);\n    }\n\n    get name() {\n        return this.db.name;\n    }\n\n    get version() {\n        return this.db.version;\n    }\n\n    get storeNames() {\n        return Array.from(this.db.objectStoreNames);\n    }\n\n    getStore<T>(storeName: string): IDexStore<T> {\n        return new IDexStore<T>(this.db, storeName);\n    }\n}\n\nexport class IDexStore<T> {\n    constructor(private readonly db: IDBDatabase, private readonly storeName: string) {\n\n    }\n\n    private async request<T>(makeRequest: (store: IDBObjectStore) => IDBRequest<T>, mode: IDBTransactionMode): Promise<T> {\n        const transaction = this.db.transaction(this.storeName, mode);\n        const transacting = once(transaction, \"complete\", \"error\");\n\n        const store = transaction.objectStore(this.storeName);\n        const request = makeRequest(store);\n        const requesting = once(request, \"success\", \"error\");\n\n        if (!(await success(requesting))) {\n            transaction.abort();\n            throw requesting.error;\n        }\n\n        transaction.commit();\n        if (!(await success(transacting))) {\n            throw transacting.error;\n        }\n\n        return request.result;\n    }\n\n    add<T>(value: T, key?: IDBValidKey): Promise<IDBValidKey> {\n        return this.request((store) => store.add(value, key), \"readwrite\");\n    }\n\n    clear() {\n        return this.request((store) => store.clear(), \"readwrite\");\n    }\n\n    getCount(query?: IDBValidKey | IDBKeyRange): Promise<number> {\n        return this.request((store) => store.count(query), \"readonly\");\n    }\n\n    async has(query: IDBValidKey): Promise<boolean> {\n        return (await this.getCount(query)) > 0;\n    }\n\n    delete(query: IDBValidKey | IDBKeyRange) {\n        return this.request((store) => store.delete(query), \"readwrite\");\n    }\n\n    get(key: IDBValidKey): Promise<T> {\n        return this.request((store) => store.get<T>(key), \"readonly\");\n    }\n\n    getAll(): Promise<T[]> {\n        return this.request((store) => store.getAll<T>(), \"readonly\");\n    }\n\n    getAllKeys(): Promise<IDBValidKey[]> {\n        return this.request((store) => store.getAllKeys(), \"readonly\");\n    }\n\n    getKey(query: IDBValidKey | IDBKeyRange): Promise<IDBValidKey | undefined> {\n        return this.request((store) => store.getKey(query), \"readonly\");\n    }\n\n    openCursor(query?: IDBValidKey | IDBKeyRange | null, direction?: IDBCursorDirection): Promise<IDBCursorWithValue | null> {\n        return this.request((store) => store.openCursor(query, direction), \"readonly\");\n    }\n\n    openKeyCursor(query?: IDBValidKey | IDBKeyRange | null, direction?: IDBCursorDirection): Promise<IDBCursor | null> {\n        return this.request((store) => store.openKeyCursor(query, direction), \"readonly\");\n    }\n\n    put(value: T, key?: IDBValidKey): Promise<IDBValidKey> {\n        return this.request((store) => store.put(value, key), \"readwrite\");\n    }\n}", "import { isDefined } from \"@juniper-lib/tslib/dist/typeChecks\";\n\nexport function mapJoin<KeyT, ValueT>(dest: Map<KeyT, ValueT>, ...sources: Map<KeyT, ValueT>[]): Map<KeyT, ValueT> {\n    for (const source of sources) {\n        if (isDefined(source)) {\n            for (const [key, value] of source) {\n                dest.set(key, value);\n            }\n        }\n    }\n\n    return dest;\n}\n", "import { isDefined } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { Task } from \"./Task\";\n\nexport class SleepTask extends Task {\n\n    private _timer: number = null;\n\n    constructor(private readonly milliseconds: number) {\n        super(false);\n    }\n\n    override start(): void {\n        super.start();\n        this._timer = setTimeout(() => {\n            this._timer = null;\n            this.resolve();\n        }, this.milliseconds) as unknown as number;\n    }\n\n    override reset(): void {\n        super.reset();\n        if (isDefined(this._timer)) {\n            clearTimeout(this._timer);\n            this._timer = null;\n        }\n    }\n}\n\nexport function sleep(milliseconds: number): SleepTask {\n    const task = new SleepTask(milliseconds);\n    task.start();\n    return task;\n}\n", "import { sleep } from \"./sleep\";\n\n/**\n * Performs an awaitable action, and if it fails, retries it up to `retryCount` times.\n *\n * If the action failed, the retry system will sleep for a geometrically growing amount of\n * time before retrying. This is to let potentially swamped resources have time to hopefully\n * recover before we hammer them again.\n *\n * The first wait time is 0.5s. Each subsequent wait time is twice the previous wait time.\n * \n * @param retryCount the number of times to re-attempt the action, after the first failed attempt.\n * @param action the action to perform.\n * @returns A promise that resolves to the same value as the action.\n **/\nexport function withRetry<T>(retryCount: number, action: () => Promise<T>): () => Promise<T> {\n    return async () => {\n        let lastError: Error = null;\n        let retryTime = 500;\n        for (let retry = 0; retry <= retryCount; ++retry) {\n            try {\n                if (retry > 0) {\n                    await sleep(retryTime);\n                    retryTime *= 2;\n                }\n                return await action();\n            }\n            catch (error) {\n                lastError = error;\n            }\n        }\n\n        throw lastError;\n    };\n}\n", "import { CustomEventTarget, EventMap, IEventTarget } from \"./EventTarget\";\n\nexport class TypedEvent<EventTypeT extends string> extends Event {\n    override get type(): EventTypeT {\n        return super.type as EventTypeT;\n    }\n\n    constructor(type: EventTypeT, eventInitDict?: EventInit) {\n        super(type, eventInitDict);\n    }\n}\n\nexport type TypedEventMap<EventTypeT extends string> =\n    EventMap\n    | Record<EventTypeT, TypedEvent<EventTypeT>>;\n\ntype TypedEventHandler<EventT> =\n    (evt: EventT) => void;\n\nexport type TypedEventListener<EventMapT, EventTypeT extends keyof EventMapT> =\n    TypedEventHandler<EventMapT[EventTypeT]>;\n\nexport interface TypedEventListenerObject<EventMapT, EventTypeT extends keyof EventMapT> {\n    handleEvent: TypedEventListener<EventMapT, EventTypeT>;\n}\n\nexport type TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT extends keyof EventMapT> =\n    TypedEventListener<EventMapT, EventTypeT>\n    | TypedEventListenerObject<EventMapT, EventTypeT>;\n\nexport interface ITypedEventTarget<EventMapT extends TypedEventMap<string> = TypedEventMap<string>> extends IEventTarget {\n    clearEventListeners<EventTypeT extends keyof EventMapT>(type?: EventTypeT): void;\n    addBubbler(bubbler: ITypedEventTarget<EventMapT>): void;\n    removeBubbler(bubbler: ITypedEventTarget<EventMapT>): void;\n    addScopedEventListener<EventTypeT extends keyof EventMapT>(scope: object, type: EventTypeT, callback: TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT>, options?: boolean | AddEventListenerOptions): void;\n    addEventListener<EventTypeT extends keyof EventMapT>(type: EventTypeT, callback: TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT>, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<EventTypeT extends keyof EventMapT>(type: EventTypeT, callback: TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT>): void;\n}\n\nexport class TypedEventTarget<EventMapT extends TypedEventMap<string> = TypedEventMap<string>> extends CustomEventTarget implements ITypedEventTarget<EventMapT> {\n    override addBubbler(bubbler: ITypedEventTarget<EventMapT>) {\n        super.addBubbler(bubbler);\n    }\n\n    override removeBubbler(bubbler: ITypedEventTarget<EventMapT>) {\n        super.removeBubbler(bubbler);\n    }\n\n    override addScopedEventListener<EventTypeT extends keyof EventMapT>(scope: object, type: EventTypeT, callback: TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT>, options?: boolean | AddEventListenerOptions): void {\n        super.addScopedEventListener(scope, type as string, callback as EventListenerOrEventListenerObject, options);\n    }\n\n    override addEventListener<EventTypeT extends keyof EventMapT>(type: EventTypeT, callback: TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT>, options?: boolean | AddEventListenerOptions): void {\n        super.addEventListener(type as string, callback as EventListenerOrEventListenerObject, options);\n    }\n\n    override removeEventListener<EventTypeT extends keyof EventMapT>(type: EventTypeT, callback: TypedEventListenerOrEventListenerObject<EventMapT, EventTypeT>): void {\n        super.removeEventListener(type as string, callback as EventListenerOrEventListenerObject);\n    }\n\n    override clearEventListeners<EventTypeT extends keyof EventMapT>(type?: EventTypeT): void {\n        return super.clearEventListeners(type as string);\n    }\n}\n", "import { arrayClear } from \"@juniper-lib/collections/dist/arrays\";\nimport { TypedEventTarget, TypedEventMap } from \"@juniper-lib/events/dist/TypedEventTarget\";\nimport type { IProgress } from \"./IProgress\";\n\nexport class BaseProgress<T extends TypedEventMap<string> = TypedEventMap<string>>\n    extends TypedEventTarget<T>\n    implements IProgress {\n    private readonly attached = new Array<IProgress>();\n    private soFar: number = null;\n    private total: number = null;\n    private msg: string = null;\n    private est: number = null;\n\n    protected get p() {\n        return this.total > 0\n            ? this.soFar / this.total\n            : 0;\n    }\n\n    report(soFar: number, total: number, msg?: string, est?: number): void {\n        this.soFar = soFar;\n        this.total = total;\n        this.msg = msg;\n        this.est = est;\n        for (const attach of this.attached) {\n            attach.report(soFar, total, msg, est);\n        }\n    }\n\n    attach(prog: IProgress): void {\n        this.attached.push(prog);\n        prog.report(this.soFar, this.total, this.msg, this.est);\n    }\n\n    clear() {\n        this.report(0, 0);\n        this._clear();\n    }\n\n    start(msg?: string) {\n        this.report(0, 1, msg || \"starting\");\n    }\n\n    end(msg?: string) {\n        this.report(1, 1, msg || \"done\");\n        this._clear();\n    }\n\n    private _clear() {\n        this.soFar = null;\n        this.total = null;\n        this.msg = null;\n        this.est = null;\n        arrayClear(this.attached);\n    }\n}", "import type { BaseParentProgressCallback } from \"./BaseParentProgressCallback\";\nimport { BaseProgress } from \"./BaseProgress\";\n\nexport class ChildProgressCallback extends BaseProgress {\n    constructor(private readonly i: number, private readonly prog: BaseParentProgressCallback) {\n        super();\n    }\n\n    override report(soFar: number, total: number, msg?: string, est?: number) {\n        super.report(soFar, total, msg, est);\n        this.prog.update(this.i, soFar, total, msg);\n    }\n}\n", "import { ChildProgressCallback } from \"./ChildProgressCallback\";\nimport type { IProgress } from \"./IProgress\";\n\nexport class BaseParentProgressCallback {\n    private weightTotal = 0;\n    private readonly start: number;\n\n    readonly subProgressCallbacks = new Array<IProgress>();\n    private readonly subProgressWeights = new Array<number>();\n    private readonly subProgressValues = new Array<number>();\n\n    constructor(private readonly prog: IProgress) {\n        this.start = performance.now();\n\n        for (let i = 0; i < this.subProgressWeights.length; ++i) {\n            this.subProgressValues[i] = 0;\n            this.subProgressCallbacks[i] = new ChildProgressCallback(i, this);\n        }\n    }\n\n    protected addSubProgress(weight?: number): IProgress {\n        weight = weight || 1;\n        this.weightTotal += weight;\n        this.subProgressWeights.push(weight);\n        this.subProgressValues.push(0);\n        const child = new ChildProgressCallback(this.subProgressCallbacks.length, this);\n        this.subProgressCallbacks.push(child);\n        return child;\n    }\n\n\n    update(i: number, subSoFar: number, subTotal: number, msg?: string) {\n        if (this.prog) {\n            this.subProgressValues[i] = subSoFar / subTotal;\n            let soFar = 0;\n            for (let j = 0; j < this.subProgressWeights.length; ++j) {\n                soFar += this.subProgressValues[j] * this.subProgressWeights[j];\n            }\n\n            const end = performance.now();\n            const delta = end - this.start;\n            const est = this.start - end + delta * this.weightTotal / soFar;\n            this.prog.report(soFar, this.weightTotal, msg, est);\n        }\n    }\n}\n", "import { BaseParentProgressCallback } from \"./BaseParentProgressCallback\";\nimport { IProgress } from \"./IProgress\";\n\nexport function progressSplitWeighted(prog: IProgress, subProgressWeights: number[]) {\n    const subProg = new WeightedParentProgressCallback(subProgressWeights, prog);\n    return subProg.subProgressCallbacks;\n}\n\n\nexport function progressSplit(prog: IProgress, taskCount: number) {\n    const subProgressWeights = new Array<number>(taskCount);\n    for (let i = 0; i < taskCount; ++i) {\n        subProgressWeights[i] = 1;\n    }\n\n    return progressSplitWeighted(prog, subProgressWeights);\n}\n\nclass WeightedParentProgressCallback extends BaseParentProgressCallback {\n\n    constructor(subProgressWeights: number[], prog: IProgress) {\n        super(prog);\n\n        for (const weight of subProgressWeights) {\n            this.addSubProgress(weight);\n        }\n    }\n}\n", "import { isDefined } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { IResponse } from \"./IResponse\";\n\nexport async function translateResponse<T>(response: IResponse<T>): Promise<IResponse>;\nexport async function translateResponse<T, U>(response: IResponse<T>, translate: (v: T) => U | Promise<U>): Promise<IResponse<U>>;\nexport async function translateResponse<T, U>(response: IResponse<T>, translate?: (v: T) => U | Promise<U>): Promise<IResponse<U>> {\n    const {\n        status,\n        requestPath,\n        responsePath,\n        content,\n        contentType,\n        contentLength,\n        fileName,\n        headers,\n        date\n    } = response;\n\n    return {\n        status,\n        requestPath,\n        responsePath,\n        content: isDefined(translate)\n            ? await translate(content)\n            : undefined,\n        contentType,\n        contentLength,\n        fileName,\n        headers,\n        date\n    };\n}", "import { isDefined, isNullOrUndefined, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\n\nexport const typePattern = /([^\\/]+)\\/(.+)/;\nconst subTypePattern = /(?:([^\\.]+)\\.)?([^\\+;]+)(?:\\+([^;]+))?((?:; *([^=]+)=([^;]+))*)/;\n\nexport function mediaTypesToAcceptValue(types: MediaType[]): string {\n    return types\n        .flatMap(type =>\n            type.extensions.map(ext =>\n                \".\" + ext))\n        .sort()\n        .join(\", \");\n}\n\nexport class MediaType {\n    private readonly _tree: string;\n    private readonly _subType: string;\n    private readonly _suffix: string;\n    private readonly _parameters: ReadonlyMap<string, string>;\n\n    private readonly _value: string;\n    private readonly _fullValue: string;\n\n    private readonly _extensions: ReadonlyArray<string>;\n    private readonly _primaryExtension: string = null;\n\n    private depMessage: string = null;\n\n\n    constructor(\n        private readonly _type: string,\n        private readonly _fullSubType: string,\n        extensions?: ReadonlyArray<string>) {\n\n        const parameters = new Map<string, string>();\n        this._parameters = parameters;\n\n        const subTypeParts = this._fullSubType.match(subTypePattern);\n        this._tree = subTypeParts[1];\n        this._subType = subTypeParts[2];\n        this._suffix = subTypeParts[3];\n        const paramStr = subTypeParts[4];\n\n        this._value = this._fullValue = this._type + \"/\";\n\n        if (isDefined(this._tree)) {\n            this._value = this._fullValue += this._tree + \".\";\n        }\n\n        this._value = this._fullValue += this._subType;\n\n        if (isDefined(this._suffix)) {\n            this._value = this._fullValue += \"+\" + this._suffix;\n        }\n\n        if (isDefined(paramStr)) {\n            const pairs = paramStr.split(\";\")\n                .map((p) => p.trim())\n                .filter((p) => p.length > 0)\n                .map((p) => p.split(\"=\"));\n            for (const [key, ...values] of pairs) {\n                const value = values.join(\"=\");\n                parameters.set(key, value);\n                const slug = `; ${key}=${value}`;\n                this._fullValue += slug;\n                if (key !== \"q\") {\n                    this._value += slug;\n                }\n            }\n        }\n\n        this._extensions = extensions || [];\n        this._primaryExtension = this._extensions[0] || null;\n    }\n\n    static parse(value: string): MediaType {\n        if (!value) {\n            return null;\n        }\n\n        const match = value.match(typePattern);\n        if (!match) {\n            return null;\n        }\n\n        const type = match[1];\n        const subType = match[2];\n        return new MediaType(type, subType);\n    }\n\n    deprecate(message: string): this {\n        this.depMessage = message;\n        return this;\n    }\n\n    private check() {\n        if (isDefined(this.depMessage)) {\n            console.warn(`${this._value} is deprecated ${this.depMessage}`);\n        }\n    }\n\n    matches(value: MediaType | string): boolean {\n        if (isNullOrUndefined(value)) {\n            return false;\n        }\n\n        if (this.typeName === \"*\" && this.subTypeName === \"*\") {\n            return true;\n        }\n\n        let typeName: string = null;\n        let subTypeName: string = null;\n        if (isString(value)) {\n            const match = value.match(typePattern);\n            if (!match) {\n                return false;\n            }\n\n            typeName = match[1];\n            subTypeName = match[2];\n        }\n        else {\n            typeName = value.typeName;\n            subTypeName = value._fullSubType;\n        }\n\n        return this.typeName === typeName\n            && (this._fullSubType === \"*\" || this._fullSubType === subTypeName);\n    }\n\n    withParameter(key: string, value: string): MediaType {\n        const newSubType = `${this._fullSubType}; ${key}=${value}`;\n        return new MediaType(this.typeName, newSubType, this.extensions);\n    }\n\n    get typeName(): string {\n        this.check();\n        return this._type;\n    }\n\n    get tree(): string {\n        this.check();\n        return this._tree;\n    }\n\n    get suffix(): string {\n        return this._suffix;\n    }\n\n    get subTypeName(): string {\n        this.check();\n        return this._subType;\n    }\n\n    get value(): string {\n        this.check();\n        return this._value;\n    }\n\n    __getValueUnsafe() {\n        return this._value;\n    }\n\n    get fullValue(): string {\n        this.check();\n        return this._fullValue;\n    }\n\n    get parameters(): ReadonlyMap<string, string> {\n        this.check();\n        return this._parameters;\n    }\n\n    get extensions(): ReadonlyArray<string> {\n        this.check();\n        return this._extensions;\n    }\n\n    __getExtensionsUnsafe() {\n        return this._extensions;\n    }\n\n    get primaryExtension(): string {\n        this.check();\n        return this._primaryExtension;\n    }\n\n    toString() {\n        if (this.parameters.get(\"q\") === \"1\") {\n            return this.value;\n        }\n        else {\n            return this.fullValue;\n        }\n    }\n\n    toFileSystemAPIAccepts(): Record<string, string | string[]> {\n        return {\n            [this.value]: this.extensions.map(v => \".\" + v)\n        };\n    }\n\n    addExtension(fileName: string): string {\n        if (!fileName) {\n            throw new Error(\"File name is not defined\");\n        }\n\n        if (this.primaryExtension) {\n            fileName = MediaType.removeExtension(fileName);\n            fileName = `${fileName}.${this.primaryExtension}`;\n        }\n\n        return fileName;\n    }\n\n    static removeExtension(fileName: string) {\n        const idx = fileName.lastIndexOf(\".\");\n        if (idx > -1) {\n            fileName = fileName.substring(0, idx);\n        }\n        return fileName;\n    }\n}\n\nexport function create(group: string, value: string, ...extensions: string[]): MediaType {\n    return new MediaType(group, value, extensions);\n}\n\nexport function specialize(group: string) {\n    return create.bind(null, group);\n}", "import { specialize } from \"./util\";\n\nconst text = /*@__PURE__*/ specialize(\"text\");\n\nexport const Text_Cache_Manifest = /*@__PURE__*/ text(\"cache-manifest\", \"appcache\");\nexport const Text_Calendar = /*@__PURE__*/ text(\"calendar\", \"ics\", \"ifb\");\nexport const Text_Calender = /*@__PURE__*/ text(\"calender\");\nexport const Text_Cmd = /*@__PURE__*/ text(\"cmd\");\nexport const Text_Coffeescript = /*@__PURE__*/ text(\"coffeescript\", \"coffee\", \"litcoffee\");\nexport const Text_Css = /*@__PURE__*/ text(\"css\", \"css\");\nexport const Text_Csv = /*@__PURE__*/ text(\"csv\", \"csv\");\nexport const Text_Csv_Schema = /*@__PURE__*/ text(\"csv-schema\");\nexport const Text_Directory = /*@__PURE__*/ text(\"directory\").deprecate(\"by RFC6350\");\nexport const Text_Dns = /*@__PURE__*/ text(\"dns\");\nexport const Text_Ecmascript = /*@__PURE__*/ text(\"ecmascript\").deprecate(\"in favor of application/ecmascript\");\nexport const Text_Encaprtp = /*@__PURE__*/ text(\"encaprtp\");\nexport const Text_Enriched = /*@__PURE__*/ text(\"enriched\");\nexport const Text_Event_Stream = /*@__PURE__*/ text(\"event-stream\");\nexport const Text_Example = /*@__PURE__*/ text(\"example\");\nexport const Text_Flexfec = /*@__PURE__*/ text(\"flexfec\");\nexport const Text_Fwdred = /*@__PURE__*/ text(\"fwdred\");\nexport const Text_Grammar_Ref_List = /*@__PURE__*/ text(\"grammar-ref-list\");\nexport const Text_Html = /*@__PURE__*/ text(\"html\", \"html\", \"htm\");\nexport const Text_Jade = /*@__PURE__*/ text(\"jade\", \"jade\");\nexport const Text_Javascript = /*@__PURE__*/ text(\"javascript\").deprecate(\"in favor of application/javascript\");\nexport const Text_Jcr_Cnd = /*@__PURE__*/ text(\"jcr-cnd\");\nexport const Text_Jsx = /*@__PURE__*/ text(\"jsx\", \"jsx\");\nexport const Text_Less = /*@__PURE__*/ text(\"less\", \"less\");\nexport const Text_Markdown = /*@__PURE__*/ text(\"markdown\");\nexport const Text_Mdx = /*@__PURE__*/ text(\"mdx\", \"mdx\");\nexport const Text_Mizar = /*@__PURE__*/ text(\"mizar\");\nexport const Text_N3 = /*@__PURE__*/ text(\"n3\", \"n3\");\nexport const Text_Parameters = /*@__PURE__*/ text(\"parameters\");\nexport const Text_Parityfec = /*@__PURE__*/ text(\"parityfec\");\nexport const Text_Plain = /*@__PURE__*/ text(\"plain\", \"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\", \"in\");\nexport const Text_PlainUTF8 = /*@__PURE__*/ text(\"plain; charset=UTF-8\", \"txt\", \"text\", \"conf\", \"def\", \"list\", \"log\", \"in\");\nexport const Text_Provenance_Notation = /*@__PURE__*/ text(\"provenance-notation\");\nexport const Text_PrsFallensteinRst = /*@__PURE__*/ text(\"prs.fallenstein.rst\");\nexport const Text_PrsLinesTag = /*@__PURE__*/ text(\"prs.lines.tag\", \"dsc\");\nexport const Text_PrsPropLogic = /*@__PURE__*/ text(\"prs.prop.logic\");\nexport const Text_Raptorfec = /*@__PURE__*/ text(\"raptorfec\");\nexport const Text_RED = /*@__PURE__*/ text(\"red\");\nexport const Text_Rfc822_Headers = /*@__PURE__*/ text(\"rfc822-headers\");\nexport const Text_Richtext = /*@__PURE__*/ text(\"richtext\", \"rtx\");\nexport const Text_Rtf = /*@__PURE__*/ text(\"rtf\");\nexport const Text_Rtp_Enc_Aescm128 = /*@__PURE__*/ text(\"rtp-enc-aescm128\");\nexport const Text_Rtploopback = /*@__PURE__*/ text(\"rtploopback\");\nexport const Text_Rtx = /*@__PURE__*/ text(\"rtx\");\nexport const Text_Sgml = /*@__PURE__*/ text(\"sgml\", \"sgml\", \"sgm\");\nexport const Text_Shex = /*@__PURE__*/ text(\"shex\", \"shex\");\nexport const Text_Slim = /*@__PURE__*/ text(\"slim\", \"slim\", \"slm\");\nexport const Text_Strings = /*@__PURE__*/ text(\"strings\");\nexport const Text_Stylus = /*@__PURE__*/ text(\"stylus\", \"stylus\", \"styl\");\nexport const Text_T140 = /*@__PURE__*/ text(\"t140\");\nexport const Text_Tab_Separated_Values = /*@__PURE__*/ text(\"tab-separated-values\", \"tsv\");\nexport const Text_Troff = /*@__PURE__*/ text(\"troff\", \"t\", \"tr\", \"roff\", \"man\", \"me\", \"ms\");\nexport const Text_Turtle = /*@__PURE__*/ text(\"turtle\", \"ttl\");\nexport const Text_Ulpfec = /*@__PURE__*/ text(\"ulpfec\");\nexport const Text_Uri_List = /*@__PURE__*/ text(\"uri-list\", \"uri\", \"uris\", \"urls\");\nexport const Text_Vcard = /*@__PURE__*/ text(\"vcard\", \"vcard\");\nexport const Text_Vendor_1d_Interleaved_Parityfec = /*@__PURE__*/ text(\"1d-interleaved-parityfec\");\nexport const Text_Vendor_A = /*@__PURE__*/ text(\"vnd.a\");\nexport const Text_Vendor_Abc = /*@__PURE__*/ text(\"vnd.abc\");\nexport const Text_Vendor_Ascii_Art = /*@__PURE__*/ text(\"vnd.ascii-art\");\nexport const Text_Vendor_Curl = /*@__PURE__*/ text(\"vnd.curl\", \"curl\");\nexport const Text_Vendor_CurlDcurl = /*@__PURE__*/ text(\"vnd.curl.dcurl\", \"dcurl\");\nexport const Text_Vendor_CurlMcurl = /*@__PURE__*/ text(\"vnd.curl.mcurl\", \"mcurl\");\nexport const Text_Vendor_CurlScurl = /*@__PURE__*/ text(\"vnd.curl.scurl\", \"scurl\");\nexport const Text_Vendor_DebianCopyright = /*@__PURE__*/ text(\"vnd.debian.copyright\");\nexport const Text_Vendor_DMClientScript = /*@__PURE__*/ text(\"vnd.dmclientscript\");\nexport const Text_Vendor_DvbSubtitle = /*@__PURE__*/ text(\"vnd.dvb.subtitle\", \"sub\");\nexport const Text_Vendor_EsmertecTheme_Descriptor = /*@__PURE__*/ text(\"vnd.esmertec.theme-descriptor\");\nexport const Text_Vendor_FiclabFlt = /*@__PURE__*/ text(\"vnd.ficlab.flt\");\nexport const Text_Vendor_Fly = /*@__PURE__*/ text(\"vnd.fly\", \"fly\");\nexport const Text_Vendor_FmiFlexstor = /*@__PURE__*/ text(\"vnd.fmi.flexstor\", \"flx\");\nexport const Text_Vendor_Gml = /*@__PURE__*/ text(\"vnd.gml\");\nexport const Text_Vendor_Graphviz = /*@__PURE__*/ text(\"vnd.graphviz\", \"gv\");\nexport const Text_Vendor_Hgl = /*@__PURE__*/ text(\"vnd.hgl\");\nexport const Text_Vendor_In3d3dml = /*@__PURE__*/ text(\"vnd.in3d.3dml\", \"3dml\");\nexport const Text_Vendor_In3dSpot = /*@__PURE__*/ text(\"vnd.in3d.spot\", \"spot\");\nexport const Text_Vendor_IPTCNewsML = /*@__PURE__*/ text(\"vnd.iptc.newsml\");\nexport const Text_Vendor_IPTCNITF = /*@__PURE__*/ text(\"vnd.iptc.nitf\");\nexport const Text_Vendor_Latex_Z = /*@__PURE__*/ text(\"vnd.latex-z\");\nexport const Text_Vendor_MotorolaReflex = /*@__PURE__*/ text(\"vnd.motorola.reflex\");\nexport const Text_Vendor_Ms_Mediapackage = /*@__PURE__*/ text(\"vnd.ms-mediapackage\");\nexport const Text_Vendor_Net2phoneCommcenterCommand = /*@__PURE__*/ text(\"vnd.net2phone.commcenter.command\");\nexport const Text_Vendor_RadisysMsml_Basic_Layout = /*@__PURE__*/ text(\"vnd.radisys.msml-basic-layout\");\nexport const Text_Vendor_SenxWarpscript = /*@__PURE__*/ text(\"vnd.senx.warpscript\");\nexport const Text_Vendor_SiUricatalogue = /*@__PURE__*/ text(\"vnd.si.uricatalogue\").deprecate(\"by request\");\nexport const Text_Vendor_Sosi = /*@__PURE__*/ text(\"vnd.sosi\");\nexport const Text_Vendor_SunJ2meApp_Descriptor = /*@__PURE__*/ text(\"vnd.sun.j2me.app-descriptor\", \"jad\");\nexport const Text_Vendor_TrolltechLinguist = /*@__PURE__*/ text(\"vnd.trolltech.linguist\");\nexport const Text_Vendor_WapSi = /*@__PURE__*/ text(\"vnd.wap.si\");\nexport const Text_Vendor_WapSl = /*@__PURE__*/ text(\"vnd.wap.sl\");\nexport const Text_Vendor_WapWml = /*@__PURE__*/ text(\"vnd.wap.wml\", \"wml\");\nexport const Text_Vendor_WapWmlscript = /*@__PURE__*/ text(\"vnd.wap.wmlscript\", \"wmls\");\nexport const Text_Vtt = /*@__PURE__*/ text(\"vtt\");\nexport const Text_X_Asm = /*@__PURE__*/ text(\"x-asm\", \"s\", \"asm\");\nexport const Text_X_C = /*@__PURE__*/ text(\"x-c\", \"c\", \"cc\", \"cxx\", \"cpp\", \"h\", \"hh\", \"dic\");\nexport const Text_X_Fortran = /*@__PURE__*/ text(\"x-fortran\", \"f\", \"for\", \"f77\", \"f90\");\nexport const Text_X_Gwt_Rpc = /*@__PURE__*/ text(\"x-gwt-rpc\");\nexport const Text_X_Handlebars_Template = /*@__PURE__*/ text(\"x-handlebars-template\", \"hbs\");\nexport const Text_X_Java_Source = /*@__PURE__*/ text(\"x-java-source\", \"java\");\nexport const Text_X_Jquery_Tmpl = /*@__PURE__*/ text(\"x-jquery-tmpl\");\nexport const Text_X_Lua = /*@__PURE__*/ text(\"x-lua\", \"lua\");\nexport const Text_X_Markdown = /*@__PURE__*/ text(\"x-markdown\", \"mkd\");\nexport const Text_X_Nfo = /*@__PURE__*/ text(\"x-nfo\", \"nfo\");\nexport const Text_X_Opml = /*@__PURE__*/ text(\"x-opml\", \"opml\");\nexport const Text_X_Org = /*@__PURE__*/ text(\"x-org\", \"org\");\nexport const Text_X_Pascal = /*@__PURE__*/ text(\"x-pascal\", \"p\", \"pas\");\nexport const Text_X_Processing = /*@__PURE__*/ text(\"x-processing\", \"pde\");\nexport const Text_X_Sass = /*@__PURE__*/ text(\"x-sass\", \"sass\");\nexport const Text_X_Scss = /*@__PURE__*/ text(\"x-scss\", \"scss\");\nexport const Text_X_Setext = /*@__PURE__*/ text(\"x-setext\", \"etx\");\nexport const Text_X_Sfv = /*@__PURE__*/ text(\"x-sfv\", \"sfv\");\nexport const Text_X_Suse_Ymp = /*@__PURE__*/ text(\"x-suse-ymp\", \"ymp\");\nexport const Text_X_Uuencode = /*@__PURE__*/ text(\"x-uuencode\", \"uu\");\nexport const Text_X_Vcalendar = /*@__PURE__*/ text(\"x-vcalendar\", \"vcs\");\nexport const Text_X_Vcard = /*@__PURE__*/ text(\"x-vcard\", \"vcf\");\nexport const Text_Xml = /*@__PURE__*/ text(\"xml\");\nexport const Text_Xml_External_Parsed_Entity = /*@__PURE__*/ text(\"xml-external-parsed-entity\");\nexport const Text_Yaml = /*@__PURE__*/ text(\"yaml\", \"yaml\", \"yml\");", "import { IDexDB, IDexDBOptionsDef, IDexStore } from \"@juniper-lib/indexdb\";\nimport { mapJoin } from \"@juniper-lib/collections/dist/mapJoin\";\nimport { PriorityList } from \"@juniper-lib/collections/dist/PriorityList\";\nimport { PriorityMap } from \"@juniper-lib/collections/dist/PriorityMap\";\nimport { Task } from \"@juniper-lib/events/dist/Task\";\nimport { withRetry } from \"@juniper-lib/events/dist/withRetry\";\nimport { identity } from \"@juniper-lib/tslib/dist/identity\";\nimport { IProgress } from \"@juniper-lib/progress/dist/IProgress\";\nimport { progressSplit } from \"@juniper-lib/progress/dist/progressSplit\";\nimport { assertNever, isArrayBuffer, isArrayBufferView, isDefined, isNullOrUndefined, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { using } from \"@juniper-lib/tslib/dist/using\";\nimport type { HTTPMethods } from \"./HTTPMethods\";\nimport type { IFetchingServiceImpl, XMLHttpRequestResponseTypeMap } from \"./IFetchingServiceImpl\";\nimport type { IRequest, IRequestWithBody } from \"./IRequest\";\nimport type { IResponse, ResponseCallback } from \"./IResponse\";\nimport { translateResponse } from \"./translateResponse\";\nimport { Text_Plain } from \"@juniper-lib/mediatypes\";\n\nexport function isXHRBodyInit(obj: any): obj is XMLHttpRequestBodyInit {\n    return isString(obj)\n        || isArrayBufferView(obj)\n        || obj instanceof Blob\n        || obj instanceof FormData\n        || isArrayBuffer(obj)\n        || \"Document\" in globalThis && obj instanceof Document;\n}\n\nfunction trackProgress(name: string, xhr: XMLHttpRequest, target: (XMLHttpRequest | XMLHttpRequestUpload), prog: IProgress, skipLoading: boolean, prevTask?: Promise<void>): Promise<void> {\n\n    let prevDone = !prevTask;\n    if (prevTask) {\n        prevTask.then(() => prevDone = true);\n    }\n\n    let done = false;\n    let loaded = skipLoading;\n\n    const requestComplete = new Task();\n\n    target.addEventListener(\"loadstart\", () => {\n        if (prevDone && !done && prog) {\n            prog.start(name);\n        }\n    });\n\n    target.addEventListener(\"progress\", (ev: Event) => {\n        if (prevDone && !done) {\n            const evt = ev as ProgressEvent<XMLHttpRequestEventTarget>;\n            if (prog) {\n                prog.report(evt.loaded, Math.max(evt.loaded, evt.total), name);\n            }\n            if (evt.loaded === evt.total) {\n                loaded = true;\n                if (done) {\n                    requestComplete.resolve();\n                }\n            }\n        }\n    });\n\n    target.addEventListener(\"load\", () => {\n        if (prevDone && !done) {\n            if (prog) {\n                prog.end(name);\n            }\n            done = true;\n            if (loaded) {\n                requestComplete.resolve();\n            }\n        }\n    });\n\n    const onError = (msg: string) => () => {\n        if (prevDone) {\n            requestComplete.reject(`${msg} (${xhr.status})`);\n        }\n    };\n\n    target.addEventListener(\"error\", onError(\"error\"));\n    target.addEventListener(\"abort\", onError(\"abort\"));\n    target.addEventListener(\"timeout\", onError(\"timeout\"));\n\n    return requestComplete;\n}\n\nfunction sendRequest(xhr: XMLHttpRequest, method: HTTPMethods, path: string, timeout: number, headers: Map<string, string>, body?: XMLHttpRequestBodyInit): void {\n    xhr.open(method, path);\n    xhr.responseType = \"blob\";\n    xhr.timeout = timeout;\n    if (headers) {\n        for (const [key, value] of headers) {\n            xhr.setRequestHeader(key, value);\n        }\n    }\n\n    if (isDefined(body)) {\n        xhr.send(body);\n    }\n    else {\n        xhr.send();\n    }\n}\n\nfunction readResponseHeader<T>(headers: Map<string, string>, key: string, translate: (value: string) => T): T {\n    if (!headers.has(key)) {\n        return null;\n    }\n\n    const value = headers.get(key);\n    try {\n        const translated = translate(value);\n        headers.delete(key);\n        return translated;\n    }\n    catch (exp) {\n        console.warn(key, exp);\n    }\n    return null;\n}\n\nconst FILE_NAME_PATTERN = /filename=\\\"(.+)\\\"(;|$)/;\nconst DB_NAME = \"Juniper:Fetcher:Cache\";\n\nexport class FetchingServiceImplXHR implements IFetchingServiceImpl {\n\n    private readonly cacheReady: Promise<void>;\n    private cache: IDexDB = null;\n    private store: IDexStore<IResponse<Blob>> = null;\n\n    constructor() {\n        this.cacheReady = this.openCache();\n    }\n\n    async drawImageToCanvas(request: IRequest, canvas: OffscreenCanvas, progress: IProgress): Promise<IResponse> {\n        const response = await this.sendNothingGetSomething(\"blob\", request, progress);\n        const blob = response.content;\n        return using(await createImageBitmap(blob, {\n            imageOrientation: \"from-image\"\n        }), (img) => {\n            canvas.width = img.width;\n            canvas.height = img.height;\n            const g = canvas.getContext(\"2d\");\n            g.drawImage(img, 0, 0);\n            return translateResponse(response);\n        });\n    }\n\n    private async openCache(): Promise<void> {\n        const options: IDexDBOptionsDef<IResponse> = {\n            keyPath: \"requestPath\"\n        };\n        this.cache = await IDexDB.open(DB_NAME, {\n            name: \"files\",\n            options\n        });\n\n        this.store = await this.cache.getStore(\"files\");\n    }\n\n    async clearCache(): Promise<void> {\n        await this.cacheReady;\n        await this.store.clear();\n    }\n\n    async evict(path: string): Promise<void> {\n        await this.cacheReady;\n        if (this.store.has(path)) {\n            await this.store.delete(path);\n        }\n    }\n\n    private async readResponseHeaders(requestPath: string, xhr: XMLHttpRequest): Promise<IResponse> {\n        const headerParts = xhr\n            .getAllResponseHeaders()\n            .split(/[\\r\\n]+/)\n            .map((v) => v.trim())\n            .filter((v) => v.length > 0)\n            .map<[string, string]>((line) => {\n                const parts = line.split(\": \");\n                const key = parts.shift().toLowerCase();\n                const value = parts.join(\": \");\n                return [key, value];\n            });\n\n        const pList = new PriorityList<string, string>(headerParts);\n        const normalizedHeaderParts = Array.from(pList.keys())\n            .map<[string, string]>((key) =>\n                [\n                    key,\n                    pList.get(key)\n                        .join(\", \")\n                ]);\n\n        const headers = new Map<string, string>(normalizedHeaderParts);\n        const contentType = readResponseHeader(headers, \"content-type\", identity);\n        const contentLength = readResponseHeader(headers, \"content-length\", parseFloat);\n        const date = readResponseHeader(headers, \"date\", (v) => new Date(v));\n        const fileName = readResponseHeader(headers, \"content-disposition\", (v) => {\n            if (isDefined(v)) {\n                const match = v.match(FILE_NAME_PATTERN);\n                if (isDefined(match)) {\n                    return match[1];\n                }\n            }\n\n            return null;\n        });\n\n        const response: IResponse = {\n            status: xhr.status,\n            requestPath,\n            responsePath: xhr.responseURL,\n            content: undefined,\n            contentType,\n            contentLength,\n            fileName,\n            date,\n            headers\n        };\n\n        return response;\n    }\n\n    private async readResponse(requestPath: string, xhr: XMLHttpRequest): Promise<IResponse<Blob>> {\n        const {\n            responsePath,\n            status,\n            contentType,\n            contentLength,\n            fileName,\n            date,\n            headers\n        } = await this.readResponseHeaders(requestPath, xhr);\n\n        const response: IResponse<Blob> = {\n            requestPath,\n            responsePath,\n            status,\n            contentType,\n            contentLength,\n            fileName,\n            date,\n            headers,\n            content: xhr.response as Blob\n        };\n\n        if (isDefined(response.content)) {\n            response.contentType = response.contentType || response.content.type;\n            response.contentLength = response.contentLength || response.content.size;\n        }\n\n        return response;\n    }\n\n    private async decodeContent<K extends keyof (XMLHttpRequestResponseTypeMap), T extends XMLHttpRequestResponseTypeMap[K]>(xhrType: K, response: IResponse<Blob>): Promise<IResponse<T>> {\n        return translateResponse<Blob, T>(response, async (contentBlob) => {\n            if (xhrType === \"\") {\n                return null;\n            }\n            else if (isNullOrUndefined(response.contentType)) {\n                const headerBlock = Array.from(response.headers.entries())\n                    .map((kv) => kv.join(\": \"))\n                    .join(\"\\n  \");\n                throw new Error(\"No content type found in headers: \\n  \" + headerBlock);\n            }\n            else if (xhrType === \"blob\") {\n                return contentBlob as any as T;\n            }\n            else if (xhrType === \"arraybuffer\") {\n                return (await contentBlob.arrayBuffer()) as any as T;\n            }\n            else if (xhrType === \"json\") {\n                const text = await contentBlob.text();\n                if (text.length > 0) {\n                    return JSON.parse(text) as T;\n                }\n                else {\n                    return null;\n                }\n            }\n            else if (xhrType === \"document\") {\n                const parser = new DOMParser();\n                if (response.contentType === \"application/xhtml+xml\"\n                    || response.contentType === \"text/html\"\n                    || response.contentType === \"application/xml\"\n                    || response.contentType === \"image/svg+xml\"\n                    || response.contentType === \"text/xml\") {\n                    return parser.parseFromString(await contentBlob.text(), response.contentType) as any as T;\n                }\n                else {\n                    throw new Error(\"Couldn't parse document\");\n                }\n            }\n            else if (xhrType === \"text\") {\n                return (await contentBlob.text()) as any as T;\n            }\n            else {\n                assertNever(xhrType);\n            }\n        });\n    }\n\n    private readonly tasks = new PriorityMap<HTTPMethods, string, Promise<any>>();\n\n    private async withCachedTask<T>(request: IRequest, action: ResponseCallback<T>): Promise<IResponse<T>> {\n        if (request.method !== \"GET\"\n            && request.method !== \"HEAD\"\n            && request.method !== \"OPTIONS\") {\n            return await action();\n        }\n\n        if (!this.tasks.has(request.method, request.path)) {\n            this.tasks.add(\n                request.method,\n                request.path,\n                action().finally(() =>\n                    this.tasks.delete(request.method, request.path)));\n        }\n\n        return this.tasks.get(request.method, request.path);\n    }\n\n    sendNothingGetNothing(request: IRequest): Promise<IResponse> {\n        return this.withCachedTask(request,\n            withRetry(request.retryCount, async () => {\n                const xhr = new XMLHttpRequest();\n                const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, null, true);\n\n                sendRequest(xhr, request.method, request.path, request.timeout, request.headers);\n\n                await download;\n\n                return await this.readResponseHeaders(request.path, xhr);\n            }));\n    }\n\n    sendNothingGetSomething<K extends keyof (XMLHttpRequestResponseTypeMap), T extends XMLHttpRequestResponseTypeMap[K]>(xhrType: K, request: IRequest, progress: IProgress): Promise<IResponse<T>> {\n        return this.withCachedTask(request,\n            withRetry(request.retryCount, async () => {\n                let response: IResponse<Blob> = null;\n\n                const useCache = request.useCache && request.method === \"GET\";\n\n                if (useCache) {\n                    if (isDefined(progress)) {\n                        progress.start();\n                    }\n                    await this.cacheReady;\n                    response = await this.store.get(request.path);\n                }\n\n                const noCachedResponse = isNullOrUndefined(response);\n\n                if (noCachedResponse) {\n                    const xhr = new XMLHttpRequest();\n                    const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, progress, true);\n\n                    sendRequest(xhr, request.method, request.path, request.timeout, request.headers);\n\n                    await download;\n\n                    response = await this.readResponse(request.path, xhr);\n\n                    if (useCache) {\n                        await this.store.add(response);\n                    }\n                }\n\n                const value = await this.decodeContent<K, T>(xhrType, response);\n\n                if (noCachedResponse && isDefined(progress)) {\n                    progress.end();\n                }\n\n                return value;\n            }));\n    }\n\n    sendSomethingGetSomething<K extends keyof (XMLHttpRequestResponseTypeMap), T extends XMLHttpRequestResponseTypeMap[K]>(xhrType: K, request: IRequestWithBody, defaultPostHeaders: Map<string, string>, progress: IProgress): Promise<IResponse<T>> {\n        let body: XMLHttpRequestBodyInit = null;\n\n        const headers = mapJoin(new Map<string, string>(), defaultPostHeaders, request.headers);\n\n        let contentType: string = null;\n\n        if (isDefined(headers)) {\n            const contentTypeHeaders = new Array<string>();\n            for (const key of headers.keys()) {\n                if (key.toLowerCase() === \"content-type\") {\n                    contentTypeHeaders.push(key);\n                }\n            }\n\n            if (contentTypeHeaders.length > 0) {\n                if (!(request.body instanceof FormData)) {\n                    contentType = headers.get(contentTypeHeaders[0]);\n                    // If there's more than one, keep just the first one\n                    contentTypeHeaders.shift();\n                }\n\n                // delete all the rest, or all if we're submitting a form\n                for (const key of contentTypeHeaders) {\n                    headers.delete(key);\n                }\n            }\n        }\n\n        if (isXHRBodyInit(request.body) && !isString(request.body)\n            || isString(request.body) && Text_Plain.matches(contentType)) {\n            body = request.body;\n        }\n        else if (isDefined(request.body)) {\n            body = JSON.stringify(request.body);\n        }\n\n        const hasBody = isDefined(body);\n        const progs = progressSplit(progress, hasBody ? 2 : 1);\n        const [progUpload, progDownload] = progs;\n        const query: ResponseCallback<T> = async () => {\n            const xhr = new XMLHttpRequest();\n            const upload = hasBody\n                ? trackProgress(\"uploading\", xhr, xhr.upload, progUpload, false)\n                : Promise.resolve();\n            const download = trackProgress(\"saving\", xhr, xhr, progDownload, true, upload);\n\n            sendRequest(xhr, request.method, request.path, request.timeout, headers, body);\n\n            await upload;\n            await download;\n\n            const response = await this.readResponse(request.path, xhr);\n            return await this.decodeContent(xhrType, response);\n        };\n\n        return withRetry(request.retryCount, query)();\n    }\n}\n", "export function isChrome() {\n    return \"chrome\" in globalThis && !navigator.userAgent.match(\"CriOS\");\n}\n\nexport function isFirefox() {\n    return \"InstallTrigger\" in globalThis;\n}\n\nexport function isSafari() {\n    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n}\n\nexport function isMacOS() {\n    return /^mac/i.test(navigator.platform);\n}\n\nexport function isIOS() {\n    return /iP(ad|hone|od)/.test(navigator.platform)\n        || /Macintosh(.*?) FxiOS(.*?)\\//.test(navigator.platform)\n        || isMacOS()\n            && \"maxTouchPoints\" in navigator\n            && (navigator as any).maxTouchPoints > 2;\n}\n\nexport function isApple() {\n    return isIOS()\n        || isMacOS();\n}\n\nexport function isMobileVR() {\n    return /Mobile VR/.test(navigator.userAgent)\n        || /Pico Neo 3 Link/.test(navigator.userAgent)\n        || isOculusBrowser;\n}\n\nexport function hasWebXR() {\n    return \"xr\" in navigator\n        && \"isSessionSupported\" in (navigator as any).xr;\n}\n\nexport function hasWebVR() {\n    return \"getVRDisplays\" in navigator;\n}\n\nexport function hasVR() {\n    return hasWebXR() || hasWebVR();\n}\n\nexport function isMobile() {\n    return /Android/.test(navigator.userAgent)\n        || /BlackBerry/.test(navigator.userAgent)\n        || /(UC Browser |UCWEB)/.test(navigator.userAgent)\n        || isIOS()\n        || isMobileVR();\n}\n\nexport function isDesktop() {\n    return !isMobile();\n}\n\nconst oculusBrowserPattern = /*@__PURE__*/ /OculusBrowser\\/(\\d+)\\.(\\d+)\\.(\\d+)/i;\nconst oculusMatch = /*@__PURE__*/ navigator.userAgent.match(oculusBrowserPattern);\nexport const isOculusBrowser = /*@__PURE__*/ !!oculusMatch;\nexport const oculusBrowserVersion: { major: number, minor: number, patch: number } = /*@__PURE__*/ isOculusBrowser && {\n    major: parseFloat(oculusMatch[1]),\n    minor: parseFloat(oculusMatch[2]),\n    patch: parseFloat(oculusMatch[3])\n};\n\nexport const isOculusGo = /*@__PURE__*/ isOculusBrowser && /pacific/i.test(navigator.userAgent);\nexport const isOculusQuest = /*@__PURE__*/ isOculusBrowser && /quest/i.test(navigator.userAgent);\nexport const isOculusQuest2 = /*@__PURE__*/ isOculusBrowser && /quest 2/i.test(navigator.userAgent);\nexport const isOculusQuest1 = /*@__PURE__*/ isOculusBrowser && !isOculusQuest2;\n\nexport const isWorkerSupported = /*@__PURE__*/ \"Worker\" in globalThis;", "import { TypedEventMap, TypedEventTarget } from \"@juniper-lib/events/dist/TypedEventTarget\";\nimport { BaseProgress } from \"@juniper-lib/progress/dist/BaseProgress\";\nimport { isArray, isDefined } from \"@juniper-lib/tslib/dist/typeChecks\";\nimport { WorkerClientMethodCallMessage, WorkerServerErrorMessage, WorkerServerEventMessage, WorkerServerMessages, WorkerServerProgressMessage, WorkerServerReturnMessage } from \"./WorkerMessages\";\n\ntype workerServerMethod = (taskID: number, ...params: any[]) => Promise<void>;\n\ntype createTransferableCallback<T> = (returnValue: T) => (Transferable | OffscreenCanvas)[];\n\ntype Executor<T> = (...params: any[]) => Promise<T>;\n\ntype VoidExecutor = (...params: any[]) => void;\n\nclass WorkerServerProgress extends BaseProgress {\n    constructor(private readonly server: WorkerServer<any>, private readonly taskID: number) {\n        super();\n    }\n\n\n    /**\n     * Report progress through long-running invocations. If your invocable\n     * functions don't report progress, this can be safely ignored.\n     * @param soFar - how much of the process we've gone through.\n     * @param total - the total amount we need to go through.\n     * @param msg - an optional message to include as part of the progress update.\n     * @param est - an optional estimate of how many milliseconds are left in the progress.\n     */\n    override report(soFar: number, total: number, msg?: string, est?: number): void {\n        const message: WorkerServerProgressMessage = {\n            type: \"progress\",\n            taskID: this.taskID,\n            soFar,\n            total,\n            msg,\n            est\n        };\n        this.server.postMessage(message);\n    }\n}\n\nexport class WorkerServer<EventMapT extends TypedEventMap<string>> {\n    private methods = new Map<string, workerServerMethod>();\n\n    /**\n     * Creates a new worker thread method call listener.\n     * @param self - the worker scope in which to listen.\n     */\n    constructor(private self: DedicatedWorkerGlobalScope) {\n        this.self.addEventListener(\"message\", (evt: MessageEvent<WorkerClientMethodCallMessage>): void => {\n            const data = evt.data;\n            this.callMethod(data);\n        });\n    }\n\n    postMessage(message: WorkerServerMessages<EventMapT>, transferables?: (Transferable | OffscreenCanvas)[]): void {\n        if (isDefined(transferables)) {\n            this.self.postMessage(message, transferables);\n        }\n        else {\n            this.self.postMessage(message);\n        }\n    }\n\n    private callMethod(data: WorkerClientMethodCallMessage) {\n        const method = this.methods.get(data.methodName);\n        if (method) {\n            try {\n                if (isArray(data.params)) {\n                    method(data.taskID, ...data.params);\n                }\n                else if (isDefined(data.params)) {\n                    method(data.taskID, data.params);\n                }\n                else {\n                    method(data.taskID);\n                }\n            }\n            catch (exp) {\n                this.onError(data.taskID, `method invocation error: ${data.methodName}(${exp.message || exp})`);\n            }\n        }\n        else {\n            this.onError(data.taskID, `method not found: ${data.methodName}`);\n        }\n    }\n\n    /**\n     * Report an error back to the calling thread.\n     * @param taskID - the invocation ID of the method that errored.\n     * @param errorMessage - what happened?\n     */\n    private onError(taskID: number, errorMessage: string): void {\n        const message: WorkerServerErrorMessage = {\n            type: \"error\",\n            taskID,\n            errorMessage\n        };\n        this.postMessage(message);\n    }\n\n    /**\n     * Return back to the client.\n     * @param taskID - the invocation ID of the method that is returning.\n     * @param returnValue - the (optional) value to return.\n     * @param transferReturnValue - a mapping function to extract any Transferable objects from the return value.\n     */\n    private onReturn<T>(taskID: number, returnValue: T, transferReturnValue: createTransferableCallback<T>): void {\n        let message: WorkerServerReturnMessage = null;\n        if (returnValue === undefined) {\n            message = {\n                type: \"return\",\n                taskID\n            };\n        }\n        else {\n            message = {\n                type: \"return\",\n                taskID,\n                returnValue\n            };\n        }\n\n        if (isDefined(transferReturnValue)) {\n            const transferables = transferReturnValue(returnValue);\n            this.postMessage(message, transferables);\n        }\n        else {\n            this.postMessage(message);\n        }\n    }\n\n    private addMethodInternal<T>(methodName: string, asyncFunc: Function, transferReturnValue?: createTransferableCallback<T>) {\n        if (this.methods.has(methodName)) {\n            throw new Error(`${methodName} method has already been mapped.`);\n        }\n\n        this.methods.set(methodName, async (taskID: number, ...params: any[]) => {\n            const prog = new WorkerServerProgress(this, taskID);\n\n            try {\n                // Even functions returning void and functions returning bare, unPromised values, can be awaited.\n                // This creates a convenient fallback where we don't have to consider the exact return type of the function.\n                const returnValue = await asyncFunc(...params, prog);\n                this.onReturn(taskID, returnValue, transferReturnValue);\n            }\n            catch (exp) {\n                console.error(exp);\n                this.onError(taskID, exp.message || exp);\n            }\n        });\n    }\n\n    /**\n     * Registers a function call for cross-thread invocation.\n     * @param methodName - the name of the function to use during invocations.\n     * @param asyncFunc - the function to execute when the method is invoked.\n     * @param transferReturnValue - an (optional) function that reports on which values in the `returnValue` should be transfered instead of copied.\n     */\n    addFunction<T>(methodName: string, asyncFunc: Executor<T>, transferReturnValue?: createTransferableCallback<T>) {\n        this.addMethodInternal<T>(methodName, asyncFunc, transferReturnValue);\n    }\n\n    /**\n     * Registers a function call for cross-thread invocation.\n     * @param methodName - the name of the function to use during invocations.\n     * @param asyncFunc - the function to execute when the method is invoked.\n     */\n    addVoidFunction(methodName: string, asyncFunc: VoidExecutor) {\n        this.addMethodInternal(methodName, asyncFunc);\n    }\n\n    /**\n     * Registers a class method call for cross-thread invocation.\n     * @param obj - the object on which to find the method.\n     * @param methodName - the name of the method to use during invocations.\n     * @param transferReturnValue - an (optional) function that reports on which values in the `returnValue` should be transfered instead of copied.\n     */\n    addMethod<\n        ClassT,\n        MethodNameT extends keyof ClassT & string,\n        MethodT extends ClassT[MethodNameT] & Executor<any>,\n        ReturnT extends (ReturnType<MethodT> extends Promise<infer T> ? T : ReturnT)\n    >(\n        obj: ClassT,\n        methodName: MethodNameT,\n        method: MethodT,\n        transferReturnValue?: createTransferableCallback<ReturnT>\n    ): void {\n        this.addFunction(methodName, method.bind(obj), transferReturnValue);\n    }\n\n\n    /**\n     * Registers a class method call for cross-thread invocation.\n     * @param methodName - the name of the method to use during invocations.\n     * @param obj - the object on which to find the method.\n     */\n    addVoidMethod<\n        ClassT,\n        MethodNameT extends keyof ClassT & string,\n        MethodT extends ClassT[MethodNameT] & VoidExecutor\n    >(\n        obj: ClassT,\n        methodName: MethodNameT,\n        method: MethodT\n    ): void {\n        this.addVoidFunction(methodName, method.bind(obj));\n    }\n\n\n    addEvent<EventNameT extends keyof EventMapT & string, TransferableT>(\n        object: TypedEventTarget<EventMapT>,\n        eventName: EventNameT,\n        makePayload?: (evt: EventMapT[EventNameT] & Event) => TransferableT,\n        transferReturnValue?: createTransferableCallback<TransferableT>\n    ): void {\n        object.addEventListener(eventName, (evt: EventMapT[EventNameT] & Event) => {\n            let message: WorkerServerEventMessage<EventMapT> = null;\n            if (isDefined(makePayload)) {\n                message = {\n                    type: \"event\",\n                    eventName,\n                    data: makePayload(evt)\n                };\n            }\n            else {\n                message = {\n                    type: \"event\",\n                    eventName\n                };\n            }\n\n            if (message.data !== undefined\n                && isDefined(transferReturnValue)) {\n                const transferables = transferReturnValue(message.data);\n                this.postMessage(message, transferables);\n            }\n            else {\n                this.postMessage(message);\n            }\n        });\n    }\n}", "import { IProgress } from \"@juniper-lib/progress/dist/IProgress\";\nimport { IFetchingService } from \"./IFetchingService\";\nimport { IFetchingServiceImpl } from \"./IFetchingServiceImpl\";\nimport { IRequest, IRequestWithBody } from \"./IRequest\";\nimport { IResponse } from \"./IResponse\";\nimport { translateResponse } from \"./translateResponse\";\n\n\nexport class FetchingService implements IFetchingService {\n\n    constructor(private readonly impl: IFetchingServiceImpl) {\n    }\n\n    protected readonly defaultPostHeaders = new Map<string, string>();\n\n    setRequestVerificationToken(value: string): void {\n        this.defaultPostHeaders.set(\"RequestVerificationToken\", value);\n    }\n\n    clearCache(): Promise<void> {\n        return this.impl.clearCache();\n    }\n\n    evict(path: string): Promise<void> {\n        return this.impl.evict(path);\n    }\n\n    sendNothingGetNothing(request: IRequest): Promise<IResponse> {\n        return this.impl.sendNothingGetNothing(request);\n    }\n\n    sendNothingGetBlob(request: IRequest, progress: IProgress): Promise<IResponse<Blob>> {\n        return this.impl.sendNothingGetSomething(\"blob\", request, progress);\n    }\n\n    sendObjectGetBlob(request: IRequestWithBody, progress: IProgress): Promise<IResponse<Blob>> {\n        return this.impl.sendSomethingGetSomething(\"blob\", request, this.defaultPostHeaders, progress);\n    }\n\n    sendNothingGetBuffer(request: IRequest, progress: IProgress): Promise<IResponse<ArrayBuffer>> {\n        return this.impl.sendNothingGetSomething(\"arraybuffer\", request, progress);\n    }\n\n    sendObjectGetBuffer(request: IRequestWithBody, progress: IProgress): Promise<IResponse<ArrayBuffer>> {\n        return this.impl.sendSomethingGetSomething(\"arraybuffer\", request, this.defaultPostHeaders, progress);\n    }\n\n    sendNothingGetText(request: IRequest, progress: IProgress): Promise<IResponse<string>> {\n        return this.impl.sendNothingGetSomething(\"text\", request, progress);\n    }\n\n    sendObjectGetText(request: IRequestWithBody, progress: IProgress): Promise<IResponse<string>> {\n        return this.impl.sendSomethingGetSomething(\"text\", request, this.defaultPostHeaders, progress);\n    }\n\n    sendNothingGetObject<T>(request: IRequest, progress: IProgress): Promise<IResponse<T>> {\n        return this.impl.sendNothingGetSomething<\"json\", T>(\"json\", request, progress);\n    }\n\n    sendObjectGetObject<T>(request: IRequestWithBody, progress: IProgress): Promise<IResponse<T>> {\n        return this.impl.sendSomethingGetSomething<\"json\", T>(\"json\", request, this.defaultPostHeaders, progress);\n    }\n\n    sendObjectGetNothing(request: IRequestWithBody, progress: IProgress): Promise<IResponse> {\n        return this.impl.sendSomethingGetSomething(\"\", request, this.defaultPostHeaders, progress);\n    }\n\n    drawImageToCanvas(request: IRequest, canvas: OffscreenCanvas, progress: IProgress): Promise<IResponse> {\n        return this.impl.drawImageToCanvas(request, canvas, progress);\n    }\n\n    async sendNothingGetFile(request: IRequest, progress: IProgress): Promise<IResponse<string>> {\n        return translateResponse(\n            await this.sendNothingGetBlob(request, progress),\n            URL.createObjectURL);\n    }\n\n    async sendObjectGetFile(request: IRequestWithBody, progress: IProgress): Promise<IResponse<string>> {\n        return translateResponse(\n            await this.sendObjectGetBlob(request, progress),\n            URL.createObjectURL);\n    }\n\n    async sendNothingGetXml(request: IRequest, progress: IProgress): Promise<IResponse<HTMLElement>> {\n        return translateResponse(\n            await this.impl.sendNothingGetSomething(\"document\", request, progress),\n            (doc) => doc.documentElement);\n    }\n\n    async sendObjectGetXml(request: IRequestWithBody, progress: IProgress): Promise<IResponse<HTMLElement>> {\n        return translateResponse(\n            await this.impl.sendSomethingGetSomething(\"document\", request, this.defaultPostHeaders, progress),\n            (doc) => doc.documentElement);\n    }\n\n    async sendNothingGetImageBitmap(request: IRequest, progress: IProgress): Promise<IResponse<ImageBitmap>> {\n        return translateResponse(\n            await this.sendNothingGetBlob(request, progress),\n            createImageBitmap);\n    }\n\n    async sendObjectGetImageBitmap(request: IRequestWithBody, progress: IProgress): Promise<IResponse<ImageBitmap>> {\n        return translateResponse(\n            await this.sendObjectGetBlob(request, progress),\n            createImageBitmap);\n    }\n}\n", "import { TypedEventMap } from \"@juniper-lib/events/dist/TypedEventTarget\";\nimport { WorkerServer } from \"@juniper-lib/workers\";\nimport { FetchingService } from \"./FetchingService\";\nimport { IFetchingService } from \"./IFetchingService\";\nimport { IFetchingServiceImpl } from \"./IFetchingServiceImpl\";\nimport { IResponse } from \"./IResponse\";\n\nexport class FetchingServiceServer extends WorkerServer<TypedEventMap<string>> {\n    constructor(self: DedicatedWorkerGlobalScope, impl: IFetchingServiceImpl) {\n        super(self);\n        const fetcher = new FetchingService(impl);\n        addFetcherMethods(this, fetcher);\n    }\n}\n\nfunction getContent<T extends Transferable | OffscreenCanvas>(response: IResponse<T>): Array<Transferable | OffscreenCanvas> {\n    return [response.content];\n}\n\nexport function addFetcherMethods(server: WorkerServer<TypedEventMap<string>>, fetcher: IFetchingService) {\n    server.addVoidMethod(fetcher, \"setRequestVerificationToken\", fetcher.setRequestVerificationToken);\n\n    server.addMethod(fetcher, \"clearCache\", fetcher.clearCache);\n    server.addMethod(fetcher, \"evict\", fetcher.evict);\n\n    server.addMethod(fetcher, \"sendNothingGetNothing\", fetcher.sendNothingGetNothing);\n\n    server.addMethod(fetcher, \"sendNothingGetBuffer\", fetcher.sendNothingGetBuffer, getContent);\n    server.addMethod(fetcher, \"sendNothingGetImageBitmap\", fetcher.sendNothingGetImageBitmap, getContent);\n    server.addMethod(fetcher, \"sendNothingGetObject\", fetcher.sendNothingGetObject);\n    server.addMethod(fetcher, \"sendNothingGetFile\", fetcher.sendNothingGetFile);\n    server.addMethod(fetcher, \"sendNothingGetText\", fetcher.sendNothingGetText);\n\n    server.addMethod(fetcher, \"sendObjectGetNothing\", fetcher.sendObjectGetNothing);\n\n    server.addMethod(fetcher, \"sendObjectGetImageBitmap\", fetcher.sendObjectGetImageBitmap, getContent);\n    server.addMethod(fetcher, \"sendObjectGetBuffer\", fetcher.sendObjectGetBuffer, getContent);\n    server.addMethod(fetcher, \"sendObjectGetObject\", fetcher.sendObjectGetObject);\n    server.addMethod(fetcher, \"sendObjectGetFile\", fetcher.sendObjectGetFile);\n    server.addMethod(fetcher, \"sendObjectGetText\", fetcher.sendObjectGetText);\n\n    server.addMethod(fetcher, \"drawImageToCanvas\", fetcher.drawImageToCanvas);\n}\n", "import { FetchingServiceImplXHR } from \"@juniper-lib/fetcher/dist/FetchingServiceImplXHR\";\nimport { FetchingServiceServer } from \"@juniper-lib/fetcher/dist/FetchingServiceServer\";\n\n(globalThis as any).server = new FetchingServiceServer(\n    (globalThis as any) as DedicatedWorkerGlobalScope,\n    new FetchingServiceImplXHR());"],
  "mappings": "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",
  "names": ["text"]
}
