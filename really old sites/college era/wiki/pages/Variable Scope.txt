[JavaScript tidbits]
!!Variable Scope
JavaScript has three levels of scope: block, function instance, and function prototype
!Block Scope
For users of the more traditional C-like languages (including C++, C#, Java, etc), block level scope is the most familiar and works in much the same way. Nested blocks can access variables from their parent blocks, but variables may not be accessed from outside of a block. Block level variables are declared either with the "var" keyword or by setting the variable name to a value.
{
//x is currently "undefined"
alert(x === undefined); //will alert "true"
var x = 24; //x is declared and its value is set
y = 13; //y is declared and its value is set
var z; //z is declared, but its value remains "null"
z = 10;
for(var index = 0; index < 10; ++index)??< //index has scope at the level of the for loop block
//x, y, and z are accessible from this block
??>
//index is no longer in scope
}

!Function Instance Scope
Function instance scope is most similar to the pubically accessible member variables of a class in most object oriented languages. Variables of function instance level scope may be declared at any time. Function instance level variables are tied to an instance of a function object ([JavaScript Is A Functional Language]), and will persist with that object until the member is deleted or the object is destroyed. Function scope variables are declared by setting their value using dot notation on an instance of a function object.
{
function AFunc()
??<
    this.msg = "Hello";
    alert(this.msg);
    alert(this.msg2);
??>
var a = new AFunc(); //will alert "Hello" follwed by an alert "undefined"
a.msg2 = "Good bye";
alert(a.msg);   //will alert "Hello"
alert(a.msg2);  //will alert "Good Bye"
AFunc();        //will alert "Hello" follwed by an alert "undefined"
delete a.msg;
alert(a.msg);   //will alert "undefined"
}

Setting function instance level scope variables in the function definition (essentially, the object constructor when used with the new keyword), will assign a new copy of that variable for each new instance of the function object.

Function instance level scope methods can access block level variables in the function block scope level.
{
function AFunc()
??<
    var x = 5;
    this.getX = function()??< return x; ??>;
??>
var a = new AFunc();
alert(a.x);      //will alert "undefined"
alert(a.getX()); //will alert "5"
}
In this way, we can create an analog to private member variables in more traditional object oriented languages.

!Function Prototype Scope
Function prototype level scope memebers are equivalent to public static members in languages like Java and C#. One copy of the member is hosted for all instances of the function object. Because of how JavaScript treats objects, one can think of the function prototype as a sort of template or pattern from which new instances of a function object are created.
{
function AFunc()
??<
    this.msg2 = "what?";
??>
AFunc.prototype.msg = "hello";
var a = new AFunc();
var b = new AFunc();
alert(a.msg); //will alert "hello"
alert(b.msg); //will alert "hello"
alert(a.msg2); //will alert "what?"
alert(b.msg2); //will alert "what?"
a.msg = "goodbye";
a.msg2 = "yo";
alert(a.msg); //will alert "goodbye"
alert(b.msg); //will alert "goodbye", changes from instance a affect instance b
alert(a.msg2); //will alert "yo"
alert(b.msg2); //will alert "what?"
// msg2 was an instance level copy, it remains unchanged in b
}
!Function Prototype Caveat
Do not forget the prototype keyword when assigning prototype level members. Because a function definition:
{
function a()??<??>;
}
is equivalent to a variable assignment of an anonymous function object:
{
var a = function()??<??>;
}
assigning members to the function handle without the prototype keyword only assigns a function instance-level member to a single instance of that function.