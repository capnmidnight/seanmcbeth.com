var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj2, key, value) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value }) : obj2[key] = value;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj2, key, value) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value);
};
var __privateSet = (obj2, member, value, setter) => {
  __accessCheck(obj2, member, "write to private field");
  setter ? setter.call(obj2, value) : member.set(obj2, value);
  return value;
};
var __privateWrapper = (obj2, member, setter, getter) => ({
  set _(value) {
    __privateSet(obj2, member, value, setter);
  },
  get _() {
    return __privateGet(obj2, member, getter);
  }
});
var __privateMethod = (obj2, member, method) => {
  __accessCheck(obj2, member, "access private method");
  return method;
};

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
  }
});

// (disabled):canvas
var require_canvas = __commonJS({
  "(disabled):canvas"() {
  }
});

// (disabled):zlib
var require_zlib = __commonJS({
  "(disabled):zlib"() {
  }
});

// (disabled):http
var require_http = __commonJS({
  "(disabled):http"() {
  }
});

// (disabled):https
var require_https = __commonJS({
  "(disabled):https"() {
  }
});

// (disabled):url
var require_url = __commonJS({
  "(disabled):url"() {
  }
});

// ../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.arrayByteLength = arrayByteLength;
              exports2.arraysToBytes = arraysToBytes;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createPromiseCapability = createPromiseCapability;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.escapeString = escapeString;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer2;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isAscii = isAscii;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF16BEString = stringToUTF16BEString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              __w_pdfjs_require__2(2);
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                FREETEXT_SIZE: 1,
                FREETEXT_COLOR: 2,
                FREETEXT_OPACITY: 3,
                INK_COLOR: 11,
                INK_THICKNESS: 12,
                INK_OPACITY: 13
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationStateModelType = {
                MARKED: "Marked",
                REVIEW: "Review"
              };
              exports2.AnnotationStateModelType = AnnotationStateModelType;
              const AnnotationMarkedState = {
                MARKED: "Marked",
                UNMARKED: "Unmarked"
              };
              exports2.AnnotationMarkedState = AnnotationMarkedState;
              const AnnotationReviewState = {
                ACCEPTED: "Accepted",
                REJECTED: "Rejected",
                CANCELLED: "Cancelled",
                COMPLETED: "Completed",
                NONE: "None"
              };
              exports2.AnnotationReviewState = AnnotationReviewState;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const StreamType = {
                UNKNOWN: "UNKNOWN",
                FLATE: "FLATE",
                LZW: "LZW",
                DCT: "DCT",
                JPX: "JPX",
                JBIG: "JBIG",
                A85: "A85",
                AHX: "AHX",
                CCF: "CCF",
                RLX: "RLX"
              };
              exports2.StreamType = StreamType;
              const FontType = {
                UNKNOWN: "UNKNOWN",
                TYPE1: "TYPE1",
                TYPE1STANDARD: "TYPE1STANDARD",
                TYPE1C: "TYPE1C",
                CIDFONTTYPE0: "CIDFONTTYPE0",
                CIDFONTTYPE0C: "CIDFONTTYPE0C",
                TRUETYPE: "TRUETYPE",
                CIDFONTTYPE2: "CIDFONTTYPE2",
                TYPE3: "TYPE3",
                OPENTYPE: "OPENTYPE",
                TYPE0: "TYPE0",
                MMTYPE1: "MMTYPE1"
              };
              exports2.FontType = FontType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1,
                STREAM: 2
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const UNSUPPORTED_FEATURES = {
                unknown: "unknown",
                forms: "forms",
                javaScript: "javaScript",
                signatures: "signatures",
                smask: "smask",
                shadingPattern: "shadingPattern",
                font: "font",
                errorTilingPattern: "errorTilingPattern",
                errorExtGState: "errorExtGState",
                errorXObject: "errorXObject",
                errorFontLoadType3: "errorFontLoadType3",
                errorFontState: "errorFontState",
                errorFontMissing: "errorFontMissing",
                errorFontTranslate: "errorFontTranslate",
                errorColorSpace: "errorColorSpace",
                errorOperatorList: "errorOperatorList",
                errorFontToUnicode: "errorFontToUnicode",
                errorFontLoadNative: "errorFontLoadNative",
                errorFontBuildPath: "errorFontBuildPath",
                errorFontGetPath: "errorFontGetPath",
                errorMarkedContent: "errorMarkedContent",
                errorContentSubStream: "errorContentSubStream"
              };
              exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url2) {
                if (!url2) {
                  return false;
                }
                switch (url2.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url2, baseUrl = null, options = null) {
                if (!url2) {
                  return null;
                }
                try {
                  if (options && typeof url2 === "string") {
                    if (options.addDefaultProtocol && url2.startsWith("www.")) {
                      const dots = url2.match(/\./g);
                      if (dots && dots.length >= 2) {
                        url2 = `http://${url2}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url2 = stringToUTF8String(url2);
                      } catch (ex) {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url2, baseUrl) : new URL(url2);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch (ex) {
                }
                return null;
              }
              function shadow(obj2, prop, value) {
                Object.defineProperty(obj2, prop, {
                  value,
                  enumerable: true,
                  configurable: true,
                  writable: false
                });
                return value;
              }
              const BaseException = function BaseExceptionClosure() {
                function BaseException2(message, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException;
              class UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException;
              class InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException;
              class MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException;
              class UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              class FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError;
              class AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || bytes === null || bytes.length === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length3 = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length3 < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length3; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length3);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str3) {
                if (typeof str3 !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length3 = str3.length;
                const bytes = new Uint8Array(length3);
                for (let i = 0; i < length3; ++i) {
                  bytes[i] = str3.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function arrayByteLength(arr) {
                if (arr.length !== void 0) {
                  return arr.length;
                }
                if (arr.byteLength !== void 0) {
                  return arr.byteLength;
                }
                unreachable("Invalid argument for arrayByteLength");
              }
              function arraysToBytes(arr) {
                const length3 = arr.length;
                if (length3 === 1 && arr[0] instanceof Uint8Array) {
                  return arr[0];
                }
                let resultLength = 0;
                for (let i = 0; i < length3; i++) {
                  resultLength += arrayByteLength(arr[i]);
                }
                let pos = 0;
                const data = new Uint8Array(resultLength);
                for (let i = 0; i < length3; i++) {
                  let item = arr[i];
                  if (!(item instanceof Uint8Array)) {
                    if (typeof item === "string") {
                      item = stringToBytes(item);
                    } else {
                      item = new Uint8Array(item);
                    }
                  }
                  const itemLength = item.byteLength;
                  data.set(item, pos);
                  pos += itemLength;
                }
                return data;
              }
              function string32(value) {
                return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
              }
              function objectSize(obj2) {
                return Object.keys(obj2).length;
              }
              function objectFromMap(map) {
                const obj2 = /* @__PURE__ */ Object.create(null);
                for (const [key, value] of map) {
                  obj2[key] = value;
                }
                return obj2;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch (e2) {
                  return false;
                }
              }
              class FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
              }
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n2) => n2.toString(16).padStart(2, "0"));
              class Util {
                static makeHexColor(r, g, b) {
                  return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r, m) {
                  const p1 = Util.applyTransform(r, m);
                  const p2 = Util.applyTransform(r.slice(2, 4), m);
                  const p3 = Util.applyTransform([r[0], r[3]], m);
                  const p4 = Util.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static apply3dTransform(m, v) {
                  return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t2, t1, t22, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t2 = -c / b;
                      if (0 < t2 && t2 < 1) {
                        tvalues.push(t2);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t22 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t22 && t22 < 1) {
                      tvalues.push(t22);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t2 = tvalues[j];
                    mt = 1 - t2;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t2 * x1 + 3 * mt * t2 * t2 * x2 + t2 * t2 * t2 * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t2 * y1 + 3 * mt * t2 * t2 * y2 + t2 * t2 * t2 * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str3) {
                if (str3[0] >= "\xEF") {
                  let encoding;
                  if (str3[0] === "\xFE" && str3[1] === "\xFF") {
                    encoding = "utf-16be";
                  } else if (str3[0] === "\xFF" && str3[1] === "\xFE") {
                    encoding = "utf-16le";
                  } else if (str3[0] === "\xEF" && str3[1] === "\xBB" && str3[2] === "\xBF") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str3);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str3.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str3.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str3.charAt(i));
                }
                return strBuf.join("");
              }
              function escapeString(str3) {
                return str3.replace(/([()\\\n\r])/g, (match) => {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return `\\${match}`;
                });
              }
              function isAscii(str3) {
                return /^[\x00-\x7F]*$/.test(str3);
              }
              function stringToUTF16BEString(str3) {
                const buf = ["\xFE\xFF"];
                for (let i = 0, ii = str3.length; i < ii; i++) {
                  const char = str3.charCodeAt(i);
                  buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                }
                return buf.join("");
              }
              function stringToUTF8String(str3) {
                return decodeURIComponent(escape(str3));
              }
              function utf8StringToString(str3) {
                return unescape(encodeURIComponent(str3));
              }
              function isArrayBuffer2(v) {
                return typeof v === "object" && v !== null && v.byteLength !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate(date = /* @__PURE__ */ new Date()) {
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              function createPromiseCapability() {
                const capability = /* @__PURE__ */ Object.create(null);
                let isSettled = false;
                Object.defineProperty(capability, "settled", {
                  get() {
                    return isSettled;
                  }
                });
                capability.promise = new Promise(function(resolve, reject) {
                  capability.resolve = function(data) {
                    isSettled = true;
                    resolve(data);
                  };
                  capability.reject = function(reason) {
                    isSettled = true;
                    reject(reason);
                  };
                });
                return capability;
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var _is_node2 = __w_pdfjs_require__2(3);
              ;
            },
            /* 3 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            /* 4 */
            /***/
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              var _docId, _workerPorts, _docStats, _pageCache, _pagePromises, _metadataPromise, _objs, _ensureObj, ensureObj_fn, _internalRenderTask, _canvasInUse;
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              exports.getDocument = getDocument;
              exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
              exports.version = void 0;
              var _util = __w_pdfjs_require__(1);
              var _annotation_storage = __w_pdfjs_require__(5);
              var _display_utils = __w_pdfjs_require__(8);
              var _font_loader = __w_pdfjs_require__(11);
              var _canvas = __w_pdfjs_require__(12);
              var _worker_options = __w_pdfjs_require__(15);
              var _is_node = __w_pdfjs_require__(3);
              var _message_handler = __w_pdfjs_require__(16);
              var _metadata = __w_pdfjs_require__(17);
              var _optional_content_config = __w_pdfjs_require__(18);
              var _transport_stream = __w_pdfjs_require__(19);
              var _xfa_text = __w_pdfjs_require__(20);
              const DEFAULT_RANGE_CHUNK_SIZE = 65536;
              const RENDERING_CANCELLED_TIMEOUT = 100;
              let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              if (_is_node.isNodeJS) {
                const {
                  NodeCanvasFactory,
                  NodeCMapReaderFactory,
                  NodeStandardFontDataFactory
                } = __w_pdfjs_require__(21);
                exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
              }
              let createPDFNetworkStream;
              function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                createPDFNetworkStream = pdfNetworkStreamFactory;
              }
              function getDocument(src2) {
                const task = new PDFDocumentLoadingTask();
                let source;
                if (typeof src2 === "string" || src2 instanceof URL) {
                  source = {
                    url: src2
                  };
                } else if ((0, _util.isArrayBuffer)(src2)) {
                  source = {
                    data: src2
                  };
                } else if (src2 instanceof PDFDataRangeTransport) {
                  source = {
                    range: src2
                  };
                } else {
                  if (typeof src2 !== "object") {
                    throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
                  }
                  if (!src2.url && !src2.data && !src2.range) {
                    throw new Error("Invalid parameter object: need either .data, .range or .url");
                  }
                  source = src2;
                }
                const params = /* @__PURE__ */ Object.create(null);
                let rangeTransport = null, worker2 = null;
                for (const key in source) {
                  const value = source[key];
                  switch (key) {
                    case "url":
                      if (typeof window !== "undefined") {
                        try {
                          params[key] = new URL(value, window.location).href;
                          continue;
                        } catch (ex) {
                          (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                        }
                      } else if (typeof value === "string" || value instanceof URL) {
                        params[key] = value.toString();
                        continue;
                      }
                      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                    case "range":
                      rangeTransport = value;
                      continue;
                    case "worker":
                      worker2 = value;
                      continue;
                    case "data":
                      if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                        params[key] = new Uint8Array(value);
                      } else if (value instanceof Uint8Array) {
                        break;
                      } else if (typeof value === "string") {
                        params[key] = (0, _util.stringToBytes)(value);
                      } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
                        params[key] = new Uint8Array(value);
                      } else if ((0, _util.isArrayBuffer)(value)) {
                        params[key] = new Uint8Array(value);
                      } else {
                        throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                      }
                      continue;
                  }
                  params[key] = value;
                }
                params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
                params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
                params.ignoreErrors = params.stopAtErrors !== true;
                params.fontExtraProperties = params.fontExtraProperties === true;
                params.pdfBug = params.pdfBug === true;
                params.enableXfa = params.enableXfa === true;
                if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
                  params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
                }
                if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                  params.docBaseUrl = null;
                }
                if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
                  params.maxImageSize = -1;
                }
                if (typeof params.cMapUrl !== "string") {
                  params.cMapUrl = null;
                }
                if (typeof params.standardFontDataUrl !== "string") {
                  params.standardFontDataUrl = null;
                }
                if (typeof params.useWorkerFetch !== "boolean") {
                  params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
                }
                if (typeof params.isEvalSupported !== "boolean") {
                  params.isEvalSupported = true;
                }
                if (typeof params.disableFontFace !== "boolean") {
                  params.disableFontFace = _is_node.isNodeJS;
                }
                if (typeof params.useSystemFonts !== "boolean") {
                  params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
                }
                if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
                  params.ownerDocument = globalThis.document;
                }
                if (typeof params.disableRange !== "boolean") {
                  params.disableRange = false;
                }
                if (typeof params.disableStream !== "boolean") {
                  params.disableStream = false;
                }
                if (typeof params.disableAutoFetch !== "boolean") {
                  params.disableAutoFetch = false;
                }
                (0, _util.setVerbosityLevel)(params.verbosity);
                if (!worker2) {
                  const workerParams = {
                    verbosity: params.verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                const docId = task.docId;
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                  const networkStreamPromise = new Promise(function(resolve) {
                    let networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length: params.length,
                        initialData: params.initialData,
                        progressiveDone: params.progressiveDone,
                        contentDispositionFilename: params.contentDispositionFilename,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      }, rangeTransport);
                    } else if (!params.data) {
                      networkStream = createPDFNetworkStream({
                        url: params.url,
                        length: params.length,
                        httpHeaders: params.httpHeaders,
                        withCredentials: params.withCredentials,
                        rangeChunkSize: params.rangeChunkSize,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                }).catch(task._capability.reject);
                return task;
              }
              async function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                if (pdfDataRangeTransport) {
                  source.length = pdfDataRangeTransport.length;
                  source.initialData = pdfDataRangeTransport.initialData;
                  source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                  source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                }
                const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", {
                  docId,
                  apiVersion: "2.16.105",
                  source: {
                    data: source.data,
                    url: source.url,
                    password: source.password,
                    disableAutoFetch: source.disableAutoFetch,
                    rangeChunkSize: source.rangeChunkSize,
                    length: source.length
                  },
                  maxImageSize: source.maxImageSize,
                  disableFontFace: source.disableFontFace,
                  docBaseUrl: source.docBaseUrl,
                  ignoreErrors: source.ignoreErrors,
                  isEvalSupported: source.isEvalSupported,
                  fontExtraProperties: source.fontExtraProperties,
                  enableXfa: source.enableXfa,
                  useSystemFonts: source.useSystemFonts,
                  cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                  standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                });
                if (source.data) {
                  source.data = null;
                }
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              }
              const _PDFDocumentLoadingTask = class {
                constructor() {
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                async destroy() {
                  this.destroyed = true;
                  await this._transport?.destroy();
                  this._transport = null;
                  if (this._worker) {
                    this._worker.destroy();
                    this._worker = null;
                  }
                }
              };
              let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
              _docId = new WeakMap();
              __privateAdd(PDFDocumentLoadingTask, _docId, 0);
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              class PDFDataRangeTransport {
                constructor(length3, initialData, progressiveDone = false, contentDispositionFilename = null) {
                  this.length = length3;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = (0, _util.createPromiseCapability)();
                }
                addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
                addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
                addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
                addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
                onDataRange(begin, chunk) {
                  for (const listener of this._rangeListeners) {
                    listener(begin, chunk);
                  }
                }
                onDataProgress(loaded, total) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressListeners) {
                      listener(loaded, total);
                    }
                  });
                }
                onDataProgressiveRead(chunk) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveReadListeners) {
                      listener(chunk);
                    }
                  });
                }
                onDataProgressiveDone() {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveDoneListeners) {
                      listener();
                    }
                  });
                }
                transportReady() {
                  this._readyCapability.resolve();
                }
                requestDataRange(begin, end2) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
                abort() {
                }
              }
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              class PDFDocumentProxy {
                constructor(pdfInfo, transport) {
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                  Object.defineProperty(this, "fingerprint", {
                    get() {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.");
                      return this.fingerprints[0];
                    }
                  });
                  Object.defineProperty(this, "getStats", {
                    value: async () => {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.");
                      return this.stats || {
                        streamTypes: {},
                        fontTypes: {}
                      };
                    }
                  });
                }
                get annotationStorage() {
                  return this._transport.annotationStorage;
                }
                get numPages() {
                  return this._pdfInfo.numPages;
                }
                get fingerprints() {
                  return this._pdfInfo.fingerprints;
                }
                get stats() {
                  return this._transport.stats;
                }
                get isPureXfa() {
                  return !!this._transport._htmlForXfa;
                }
                get allXfaHtml() {
                  return this._transport._htmlForXfa;
                }
                getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
                getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
                getDestinations() {
                  return this._transport.getDestinations();
                }
                getDestination(id) {
                  return this._transport.getDestination(id);
                }
                getPageLabels() {
                  return this._transport.getPageLabels();
                }
                getPageLayout() {
                  return this._transport.getPageLayout();
                }
                getPageMode() {
                  return this._transport.getPageMode();
                }
                getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
                getOpenAction() {
                  return this._transport.getOpenAction();
                }
                getAttachments() {
                  return this._transport.getAttachments();
                }
                getJavaScript() {
                  return this._transport.getJavaScript();
                }
                getJSActions() {
                  return this._transport.getDocJSActions();
                }
                getOutline() {
                  return this._transport.getOutline();
                }
                getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
                getPermissions() {
                  return this._transport.getPermissions();
                }
                getMetadata() {
                  return this._transport.getMetadata();
                }
                getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
                getData() {
                  return this._transport.getData();
                }
                getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
                cleanup(keepLoadedFonts = false) {
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
                destroy() {
                  return this.loadingTask.destroy();
                }
                get loadingParams() {
                  return this._transport.loadingParams;
                }
                get loadingTask() {
                  return this._transport.loadingTask;
                }
                saveDocument() {
                  if (this._transport.annotationStorage.size <= 0) {
                    (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                  }
                  return this._transport.saveDocument();
                }
                getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
                hasJSActions() {
                  return this._transport.hasJSActions();
                }
                getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }
              exports.PDFDocumentProxy = PDFDocumentProxy;
              class PDFPageProxy {
                constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._ownerDocument = ownerDocument;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._bitmaps = /* @__PURE__ */ new Set();
                  this.cleanupAfterRender = false;
                  this.pendingCleanup = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this._annotationPromises = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                get pageNumber() {
                  return this._pageIndex + 1;
                }
                get rotate() {
                  return this._pageInfo.rotate;
                }
                get ref() {
                  return this._pageInfo.ref;
                }
                get userUnit() {
                  return this._pageInfo.userUnit;
                }
                get view() {
                  return this._pageInfo.view;
                }
                getViewport({
                  scale: scale3,
                  rotation = this.rotate,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                } = {}) {
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale: scale3,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                getAnnotations({
                  intent = "display"
                } = {}) {
                  const intentArgs = this._transport.getRenderingIntent(intent);
                  let promise = this._annotationPromises.get(intentArgs.cacheKey);
                  if (!promise) {
                    promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                    this._annotationPromises.set(intentArgs.cacheKey, promise);
                    promise = promise.then((annotations) => {
                      for (const annotation of annotations) {
                        if (annotation.titleObj !== void 0) {
                          Object.defineProperty(annotation, "title", {
                            get() {
                              (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                              return annotation.titleObj.str;
                            }
                          });
                        }
                        if (annotation.contentsObj !== void 0) {
                          Object.defineProperty(annotation, "contents", {
                            get() {
                              (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                              return annotation.contentsObj.str;
                            }
                          });
                        }
                      }
                      return annotations;
                    });
                  }
                  return promise;
                }
                getJSActions() {
                  return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);
                }
                async getXfa() {
                  return this._transport._htmlForXfa?.children[this._pageIndex] || null;
                }
                render({
                  canvasContext,
                  viewport,
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  transform = null,
                  imageLayer = null,
                  canvasFactory = null,
                  background = null,
                  optionalContentConfigPromise = null,
                  annotationCanvasMap = null,
                  pageColors = null,
                  printAnnotationStorage = null
                }) {
                  if (arguments[0]?.renderInteractiveForms !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                    }
                  }
                  if (arguments[0]?.includeAnnotationStorage !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                    }
                  }
                  if (this._stats) {
                    this._stats.time("Overall");
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                  this.pendingCleanup = false;
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                    ownerDocument: this._ownerDocument
                  });
                  const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  const complete = (error) => {
                    intentState.renderTasks.delete(internalRenderTask);
                    if (this.cleanupAfterRender || intentPrint) {
                      this.pendingCleanup = true;
                    }
                    this._tryCleanup();
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      this._abortOperatorList({
                        intentState,
                        reason: error instanceof Error ? error : new Error(error)
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Rendering");
                      this._stats.timeEnd("Overall");
                    }
                  };
                  const internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform,
                      imageLayer,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    annotationCanvasMap,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: canvasFactoryInstance,
                    useRequestAnimationFrame: !intentPrint,
                    pdfBug: this._pdfBug,
                    pageColors
                  });
                  (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
                  const renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                    if (this.pendingCleanup) {
                      complete();
                      return;
                    }
                    if (this._stats) {
                      this._stats.time("Rendering");
                    }
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                }
                getOperatorList({
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  printAnnotationStorage = null
                } = {}) {
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks.delete(opListTask);
                    }
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  let opListTask;
                  if (!intentState.opListReadCapability) {
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                    (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  return intentState.opListReadCapability.promise;
                }
                streamTextContent({
                  disableCombineTextItems = false,
                  includeMarkedContent = false
                } = {}) {
                  const TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    combineTextItems: disableCombineTextItems !== true,
                    includeMarkedContent: includeMarkedContent === true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
                getTextContent(params = {}) {
                  if (this._transport._htmlForXfa) {
                    return this.getXfa().then((xfa) => {
                      return _xfa_text.XfaText.textContent(xfa);
                    });
                  }
                  const readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value.styles);
                        textContent.items.push(...value.items);
                        pump();
                      }, reject);
                    }
                    const reader = readableStream.getReader();
                    const textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
                getStructTree() {
                  return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);
                }
                _destroy() {
                  this.destroyed = true;
                  const waitOn = [];
                  for (const intentState of this._intentStates.values()) {
                    this._abortOperatorList({
                      intentState,
                      reason: new Error("Page was destroyed."),
                      force: true
                    });
                    if (intentState.opListReadCapability) {
                      continue;
                    }
                    for (const internalRenderTask of intentState.renderTasks) {
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  }
                  this.objs.clear();
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  this.pendingCleanup = false;
                  return Promise.all(waitOn);
                }
                cleanup(resetStats = false) {
                  this.pendingCleanup = true;
                  return this._tryCleanup(resetStats);
                }
                _tryCleanup(resetStats = false) {
                  if (!this.pendingCleanup) {
                    return false;
                  }
                  for (const {
                    renderTasks,
                    operatorList
                  } of this._intentStates.values()) {
                    if (renderTasks.size > 0 || !operatorList.lastChunk) {
                      return false;
                    }
                  }
                  this._intentStates.clear();
                  this.objs.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  if (resetStats && this._stats) {
                    this._stats = new _display_utils.StatTimer();
                  }
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this.pendingCleanup = false;
                  return true;
                }
                _startRenderPage(transparency, cacheKey) {
                  const intentState = this._intentStates.get(cacheKey);
                  if (!intentState) {
                    return;
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Page Request");
                  }
                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.resolve(transparency);
                  }
                }
                _renderPageChunk(operatorListChunk, intentState) {
                  for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    this._tryCleanup();
                  }
                }
                _pumpOperatorList({
                  renderingIntent,
                  cacheKey,
                  annotationStorageMap
                }) {
                  const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    cacheKey,
                    annotationStorage: annotationStorageMap
                  });
                  const reader = readableStream.getReader();
                  const intentState = this._intentStates.get(cacheKey);
                  intentState.streamReader = reader;
                  const pump = () => {
                    reader.read().then(({
                      value,
                      done
                    }) => {
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (this._transport.destroyed) {
                        return;
                      }
                      this._renderPageChunk(value, intentState);
                      pump();
                    }, (reason) => {
                      intentState.streamReader = null;
                      if (this._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        for (const internalRenderTask of intentState.renderTasks) {
                          internalRenderTask.operatorListChanged();
                        }
                        this._tryCleanup();
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
                _abortOperatorList({
                  intentState,
                  reason,
                  force = false
                }) {
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      intentState.streamReaderCancelTimeout = setTimeout(() => {
                        this._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                        intentState.streamReaderCancelTimeout = null;
                      }, RENDERING_CANCELLED_TIMEOUT);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                  });
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  for (const [curCacheKey, curIntentState] of this._intentStates) {
                    if (curIntentState === intentState) {
                      this._intentStates.delete(curCacheKey);
                      break;
                    }
                  }
                  this.cleanup();
                }
                get stats() {
                  return this._stats;
                }
              }
              exports.PDFPageProxy = PDFPageProxy;
              class LoopbackPort {
                constructor() {
                  this._listeners = [];
                  this._deferred = Promise.resolve();
                }
                postMessage(obj2, transfers) {
                  const event = {
                    data: structuredClone(obj2, transfers)
                  };
                  this._deferred.then(() => {
                    for (const listener of this._listeners) {
                      listener.call(this, event);
                    }
                  });
                }
                addEventListener(name, listener) {
                  this._listeners.push(listener);
                }
                removeEventListener(name, listener) {
                  const i = this._listeners.indexOf(listener);
                  this._listeners.splice(i, 1);
                }
                terminate() {
                  this._listeners.length = 0;
                }
              }
              exports.LoopbackPort = LoopbackPort;
              const PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_is_node.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if (typeof document === "object") {
                  const pdfjsFilePath = document?.currentScript?.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e2) {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url2) {
                  const wrapper = `importScripts("${url2}");`;
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              const _PDFWorker = class {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && __privateGet(_PDFWorker, _workerPorts).has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    __privateGet(_PDFWorker, _workerPorts).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                    let {
                      workerSrc
                    } = _PDFWorker;
                    try {
                      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e2) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array();
                        messageHandler.send("test", testObj, [testObj.buffer]);
                      };
                      sendTest();
                      return;
                    } catch (e2) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!PDFWorkerUtil.isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    PDFWorkerUtil.isWorkerDisabled = true;
                  }
                  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                    const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  __privateGet(_PDFWorker, _workerPorts).delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!params?.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (__privateGet(this, _workerPorts).has(params.port)) {
                    return __privateGet(this, _workerPorts).get(params.port);
                  }
                  return new _PDFWorker(params);
                }
                static get workerSrc() {
                  if (_worker_options.GlobalWorkerOptions.workerSrc) {
                    return _worker_options.GlobalWorkerOptions.workerSrc;
                  }
                  if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                    if (!_is_node.isNodeJS) {
                      (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                    }
                    return PDFWorkerUtil.fallbackWorkerSrc;
                  }
                  throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                }
                static get _mainThreadWorkerMessageHandler() {
                  try {
                    return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
                  } catch (ex) {
                    return null;
                  }
                }
                static get _setupFakeWorkerGlobal() {
                  const loader = async () => {
                    const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_is_node.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(this.workerSrc);
                      return worker.WorkerMessageHandler;
                    }
                    await (0, _display_utils.loadScript)(this.workerSrc);
                    return window.pdfjsWorker.WorkerMessageHandler;
                  };
                  return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                }
              };
              let PDFWorker = _PDFWorker;
              _workerPorts = new WeakMap();
              __privateAdd(PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
              exports.PDFWorker = PDFWorker;
              {
                PDFWorker.getWorkerSrc = function() {
                  (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
                  return this.workerSrc;
                };
              }
              class WorkerTransport {
                constructor(messageHandler, loadingTask, networkStream, params) {
                  __privateAdd(this, _docStats, null);
                  __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                  __privateAdd(this, _metadataPromise, null);
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    docId: loadingTask.docId,
                    onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  if (!params.useWorkerFetch) {
                    this.CMapReaderFactory = new params.CMapReaderFactory({
                      baseUrl: params.cMapUrl,
                      isCompressed: params.cMapPacked
                    });
                    this.StandardFontDataFactory = new params.StandardFontDataFactory({
                      baseUrl: params.standardFontDataUrl
                    });
                  }
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._passwordCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                  this.setupMessageHandler();
                }
                get annotationStorage() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
                get stats() {
                  return __privateGet(this, _docStats);
                }
                getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
                  let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                  let annotationMap = null;
                  switch (intent) {
                    case "any":
                      renderingIntent = _util.RenderingIntentFlag.ANY;
                      break;
                    case "display":
                      break;
                    case "print":
                      renderingIntent = _util.RenderingIntentFlag.PRINT;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                  }
                  switch (annotationMode) {
                    case _util.AnnotationMode.DISABLE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                      break;
                    case _util.AnnotationMode.ENABLE:
                      break;
                    case _util.AnnotationMode.ENABLE_FORMS:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                      break;
                    case _util.AnnotationMode.ENABLE_STORAGE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                      const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                      annotationMap = annotationStorage.serializable;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                  }
                  if (isOpList) {
                    renderingIntent += _util.RenderingIntentFlag.OPLIST;
                  }
                  return {
                    renderingIntent,
                    cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,
                    annotationStorageMap: annotationMap
                  };
                }
                destroy() {
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = (0, _util.createPromiseCapability)();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  const waitOn = [];
                  for (const page of __privateGet(this, _pageCache).values()) {
                    waitOn.push(page._destroy());
                  }
                  __privateGet(this, _pageCache).clear();
                  __privateGet(this, _pagePromises).clear();
                  if (this.hasOwnProperty("annotationStorage")) {
                    this.annotationStorage.resetModified();
                  }
                  const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(() => {
                    this.commonObjs.clear();
                    this.fontLoader.clear();
                    __privateSet(this, _metadataPromise, null);
                    this._getFieldObjectsPromise = null;
                    this._hasJSActionsPromise = null;
                    if (this._networkStream) {
                      this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    }
                    if (this.messageHandler) {
                      this.messageHandler.destroy();
                      this.messageHandler = null;
                    }
                    this.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
                setupMessageHandler() {
                  const {
                    messageHandler,
                    loadingTask
                  } = this;
                  messageHandler.on("GetReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = (evt) => {
                      this._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = () => {
                      this._fullReader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      this._fullReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", (data) => {
                    const headersCapability = (0, _util.createPromiseCapability)();
                    const fullReader = this._fullReader;
                    fullReader.headersReady.then(() => {
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (this._lastProgress) {
                          loadingTask.onProgress?.(this._lastProgress);
                        }
                        fullReader.onProgress = (evt) => {
                          loadingTask.onProgress?.({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = () => {
                      rangeReader.read().then(function({
                        value,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value), 1, [value]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      rangeReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", ({
                    pdfInfo
                  }) => {
                    this._numPages = pdfInfo.numPages;
                    this._htmlForXfa = pdfInfo.htmlForXfa;
                    delete pdfInfo.htmlForXfa;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                  });
                  messageHandler.on("DocException", function(ex) {
                    let reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                      default:
                        (0, _util.unreachable)("DocException - expected a valid Error.");
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", (exception) => {
                    this._passwordCapability = (0, _util.createPromiseCapability)();
                    if (loadingTask.onPassword) {
                      const updatePassword = (password) => {
                        if (password instanceof Error) {
                          this._passwordCapability.reject(password);
                        } else {
                          this._passwordCapability.resolve({
                            password
                          });
                        }
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        this._passwordCapability.reject(ex);
                      }
                    } else {
                      this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return this._passwordCapability.promise;
                  });
                  messageHandler.on("DataLoaded", (data) => {
                    loadingTask.onProgress?.({
                      loaded: data.length,
                      total: data.length
                    });
                    this.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    const page = __privateGet(this, _pageCache).get(data.pageIndex);
                    page._startRenderPage(data.transparency, data.cacheKey);
                  });
                  messageHandler.on("commonobj", ([id, type2, exportedData]) => {
                    if (this.destroyed) {
                      return;
                    }
                    if (this.commonObjs.has(id)) {
                      return;
                    }
                    switch (type2) {
                      case "Font":
                        const params = this._params;
                        if ("error" in exportedData) {
                          const exportedError = exportedData.error;
                          (0, _util.warn)(`Error during font loading: ${exportedError}`);
                          this.commonObjs.resolve(id, exportedError);
                          break;
                        }
                        let fontRegistry = null;
                        if (params.pdfBug && globalThis.FontInspector?.enabled) {
                          fontRegistry = {
                            registerFont(font2, url2) {
                              globalThis.FontInspector.fontAdded(font2, url2);
                            }
                          };
                        }
                        const font = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                          fontRegistry
                        });
                        this.fontLoader.bind(font).catch((reason) => {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id
                          });
                        }).finally(() => {
                          if (!params.fontExtraProperties && font.data) {
                            font.data = null;
                          }
                          this.commonObjs.resolve(id, font);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                        this.commonObjs.resolve(id, exportedData);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${type2}`);
                    }
                  });
                  messageHandler.on("obj", ([id, pageIndex, type2, imageData]) => {
                    if (this.destroyed) {
                      return;
                    }
                    const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                    if (pageProxy.objs.has(id)) {
                      return;
                    }
                    switch (type2) {
                      case "Image":
                        pageProxy.objs.resolve(id, imageData);
                        const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                        if (imageData) {
                          let length3;
                          if (imageData.bitmap) {
                            const {
                              bitmap,
                              width,
                              height
                            } = imageData;
                            length3 = width * height * 4;
                            pageProxy._bitmaps.add(bitmap);
                          } else {
                            length3 = imageData.data?.length || 0;
                          }
                          if (length3 > MAX_IMAGE_SIZE_TO_STORE) {
                            pageProxy.cleanupAfterRender = true;
                          }
                        }
                        break;
                      case "Pattern":
                        pageProxy.objs.resolve(id, imageData);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${type2}`);
                    }
                  });
                  messageHandler.on("DocProgress", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    loadingTask.onProgress?.({
                      loaded: data.loaded,
                      total: data.total
                    });
                  });
                  messageHandler.on("DocStats", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    __privateSet(this, _docStats, Object.freeze({
                      streamTypes: Object.freeze(data.streamTypes),
                      fontTypes: Object.freeze(data.fontTypes)
                    }));
                  });
                  messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                  messageHandler.on("FetchBuiltInCMap", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.CMapReaderFactory) {
                      return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.CMapReaderFactory.fetch(data);
                  });
                  messageHandler.on("FetchStandardFontData", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.StandardFontDataFactory) {
                      return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.StandardFontDataFactory.fetch(data);
                  });
                }
                _onUnsupportedFeature({
                  featureId
                }) {
                  if (this.destroyed) {
                    return;
                  }
                  this.loadingTask.onUnsupportedFeature?.(featureId);
                }
                getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
                getPage(pageNumber) {
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request."));
                  }
                  const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then((pageInfo) => {
                    if (this.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
                    __privateGet(this, _pageCache).set(pageIndex, page);
                    return page;
                  });
                  __privateGet(this, _pagePromises).set(pageIndex, promise);
                  return promise;
                }
                getPageIndex(ref) {
                  if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                    return Promise.reject(new Error("Invalid pageIndex request."));
                  }
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    num: ref.num,
                    gen: ref.gen
                  });
                }
                getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
                saveDocument() {
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    isPureXfa: !!this._htmlForXfa,
                    numPages: this._numPages,
                    annotationStorage: this.annotationStorage.serializable,
                    filename: this._fullReader?.filename ?? null
                  }).finally(() => {
                    this.annotationStorage.resetModified();
                  });
                }
                getFieldObjects() {
                  return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise("GetFieldObjects", null);
                }
                hasJSActions() {
                  return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise("HasJSActions", null);
                }
                getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
                getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
                getDestination(id) {
                  if (typeof id !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id
                  });
                }
                getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
                getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
                getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
                getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
                getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
                getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
                getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                }
                getDocJSActions() {
                  return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                }
                getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
                getStructTree(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetStructTree", {
                    pageIndex
                  });
                }
                getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
                getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
                getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
                getMetadata() {
                  return __privateGet(this, _metadataPromise) || __privateSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: this._fullReader?.filename ?? null,
                      contentLength: this._fullReader?.contentLength ?? null
                    };
                  }));
                }
                getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
                async startCleanup(keepLoadedFonts = false) {
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  if (this.destroyed) {
                    return;
                  }
                  for (const page of __privateGet(this, _pageCache).values()) {
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  __privateSet(this, _metadataPromise, null);
                  this._getFieldObjectsPromise = null;
                  this._hasJSActionsPromise = null;
                }
                get loadingParams() {
                  const params = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch: params.disableAutoFetch,
                    enableXfa: params.enableXfa
                  });
                }
              }
              _docStats = new WeakMap();
              _pageCache = new WeakMap();
              _pagePromises = new WeakMap();
              _metadataPromise = new WeakMap();
              class PDFObjects {
                constructor() {
                  __privateAdd(this, _ensureObj);
                  __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
                }
                get(objId, callback = null) {
                  if (callback) {
                    const obj3 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                    obj3.capability.promise.then(() => callback(obj3.data));
                    return null;
                  }
                  const obj2 = __privateGet(this, _objs)[objId];
                  if (!obj2?.capability.settled) {
                    throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                  }
                  return obj2.data;
                }
                has(objId) {
                  const obj2 = __privateGet(this, _objs)[objId];
                  return obj2?.capability.settled || false;
                }
                resolve(objId, data = null) {
                  const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                  obj2.data = data;
                  obj2.capability.resolve();
                }
                clear() {
                  __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
                }
              }
              _objs = new WeakMap();
              _ensureObj = new WeakSet();
              ensureObj_fn = function(objId) {
                const obj2 = __privateGet(this, _objs)[objId];
                if (obj2) {
                  return obj2;
                }
                return __privateGet(this, _objs)[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null
                };
              };
              class RenderTask {
                constructor(internalRenderTask) {
                  __privateAdd(this, _internalRenderTask, null);
                  __privateSet(this, _internalRenderTask, internalRenderTask);
                  this.onContinue = null;
                }
                get promise() {
                  return __privateGet(this, _internalRenderTask).capability.promise;
                }
                cancel() {
                  __privateGet(this, _internalRenderTask).cancel();
                }
                get separateAnnots() {
                  const {
                    separateAnnots
                  } = __privateGet(this, _internalRenderTask).operatorList;
                  if (!separateAnnots) {
                    return false;
                  }
                  const {
                    annotationCanvasMap
                  } = __privateGet(this, _internalRenderTask);
                  return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
                }
              }
              _internalRenderTask = new WeakMap();
              exports.RenderTask = RenderTask;
              const _InternalRenderTask = class {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  annotationCanvasMap,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  useRequestAnimationFrame = false,
                  pdfBug = false,
                  pageColors = null
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics({
                  transparency = false,
                  optionalContentConfig
                }) {
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                  }
                  if (this._pdfBug && globalThis.StepperManager?.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel(error = null) {
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              };
              let InternalRenderTask = _InternalRenderTask;
              _canvasInUse = new WeakMap();
              __privateAdd(InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
              const version = "2.16.105";
              exports.version = version;
              const build = "172ccdbe5";
              exports.build = build;
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _setModified, setModified_fn, _serializable;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(6);
              var _murmurhash = __w_pdfjs_require__2(10);
              class AnnotationStorage {
                constructor() {
                  __privateAdd(this, _setModified);
                  this._storage = /* @__PURE__ */ new Map();
                  this._modified = false;
                  this.onSetModified = null;
                  this.onResetModified = null;
                  this.onAnnotationEditor = null;
                }
                getValue(key, defaultValue) {
                  const value = this._storage.get(key);
                  if (value === void 0) {
                    return defaultValue;
                  }
                  return Object.assign(defaultValue, value);
                }
                getRawValue(key) {
                  return this._storage.get(key);
                }
                remove(key) {
                  this._storage.delete(key);
                  if (this._storage.size === 0) {
                    this.resetModified();
                  }
                  if (typeof this.onAnnotationEditor === "function") {
                    for (const value of this._storage.values()) {
                      if (value instanceof _editor.AnnotationEditor) {
                        return;
                      }
                    }
                    this.onAnnotationEditor(null);
                  }
                }
                setValue(key, value) {
                  const obj2 = this._storage.get(key);
                  let modified = false;
                  if (obj2 !== void 0) {
                    for (const [entry, val] of Object.entries(value)) {
                      if (obj2[entry] !== val) {
                        modified = true;
                        obj2[entry] = val;
                      }
                    }
                  } else {
                    modified = true;
                    this._storage.set(key, value);
                  }
                  if (modified) {
                    __privateMethod(this, _setModified, setModified_fn).call(this);
                  }
                  if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                    this.onAnnotationEditor(value.constructor._type);
                  }
                }
                has(key) {
                  return this._storage.has(key);
                }
                getAll() {
                  return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                }
                get size() {
                  return this._storage.size;
                }
                resetModified() {
                  if (this._modified) {
                    this._modified = false;
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
                get print() {
                  return new PrintAnnotationStorage(this);
                }
                get serializable() {
                  if (this._storage.size === 0) {
                    return null;
                  }
                  const clone3 = /* @__PURE__ */ new Map();
                  for (const [key, val] of this._storage) {
                    const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;
                    if (serialized) {
                      clone3.set(key, serialized);
                    }
                  }
                  return clone3;
                }
                static getHash(map) {
                  if (!map) {
                    return "";
                  }
                  const hash = new _murmurhash.MurmurHash3_64();
                  for (const [key, val] of map) {
                    hash.update(`${key}:${JSON.stringify(val)}`);
                  }
                  return hash.hexdigest();
                }
              }
              _setModified = new WeakSet();
              setModified_fn = function() {
                if (!this._modified) {
                  this._modified = true;
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              };
              exports2.AnnotationStorage = AnnotationStorage;
              class PrintAnnotationStorage extends AnnotationStorage {
                constructor(parent) {
                  super();
                  __privateAdd(this, _serializable, null);
                  __privateSet(this, _serializable, structuredClone(parent.serializable));
                }
                get print() {
                  (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
                }
                get serializable() {
                  return __privateGet(this, _serializable);
                }
              }
              _serializable = new WeakMap();
              exports2.PrintAnnotationStorage = PrintAnnotationStorage;
            },
            /* 6 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundFocusin, _boundFocusout, _hasBeenSelected, _isEditing, _isInEditMode, _zIndex;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditor = void 0;
              var _tools = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              const _AnnotationEditor = class {
                constructor(parameters) {
                  __privateAdd(this, _boundFocusin, this.focusin.bind(this));
                  __privateAdd(this, _boundFocusout, this.focusout.bind(this));
                  __privateAdd(this, _hasBeenSelected, false);
                  __privateAdd(this, _isEditing, false);
                  __privateAdd(this, _isInEditMode, false);
                  __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
                  if (this.constructor === _AnnotationEditor) {
                    (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                  }
                  this.parent = parameters.parent;
                  this.id = parameters.id;
                  this.width = this.height = null;
                  this.pageIndex = parameters.parent.pageIndex;
                  this.name = parameters.name;
                  this.div = null;
                  const [width, height] = this.parent.viewportBaseDimensions;
                  this.x = parameters.x / width;
                  this.y = parameters.y / height;
                  this.rotation = this.parent.viewport.rotation;
                  this.isAttachedToDOM = false;
                }
                static get _defaultLineColor() {
                  return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                }
                setInBackground() {
                  this.div.style.zIndex = 0;
                }
                setInForeground() {
                  this.div.style.zIndex = __privateGet(this, _zIndex);
                }
                focusin(event) {
                  if (!__privateGet(this, _hasBeenSelected)) {
                    this.parent.setSelected(this);
                  } else {
                    __privateSet(this, _hasBeenSelected, false);
                  }
                }
                focusout(event) {
                  if (!this.isAttachedToDOM) {
                    return;
                  }
                  const target = event.relatedTarget;
                  if (target?.closest(`#${this.id}`)) {
                    return;
                  }
                  event.preventDefault();
                  if (!this.parent.isMultipleSelection) {
                    this.commitOrRemove();
                  }
                }
                commitOrRemove() {
                  if (this.isEmpty()) {
                    this.remove();
                  } else {
                    this.commit();
                  }
                }
                commit() {
                  this.parent.addToAnnotationStorage(this);
                }
                dragstart(event) {
                  const rect = this.parent.div.getBoundingClientRect();
                  this.startX = event.clientX - rect.x;
                  this.startY = event.clientY - rect.y;
                  event.dataTransfer.setData("text/plain", this.id);
                  event.dataTransfer.effectAllowed = "move";
                }
                setAt(x, y, tx, ty) {
                  const [width, height] = this.parent.viewportBaseDimensions;
                  [tx, ty] = this.screenToPageTranslation(tx, ty);
                  this.x = (x + tx) / width;
                  this.y = (y + ty) / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                translate(x, y) {
                  const [width, height] = this.parent.viewportBaseDimensions;
                  [x, y] = this.screenToPageTranslation(x, y);
                  this.x += x / width;
                  this.y += y / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                screenToPageTranslation(x, y) {
                  const {
                    rotation
                  } = this.parent.viewport;
                  switch (rotation) {
                    case 90:
                      return [y, -x];
                    case 180:
                      return [-x, -y];
                    case 270:
                      return [-y, x];
                    default:
                      return [x, y];
                  }
                }
                setDims(width, height) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.div.style.width = `${100 * width / parentWidth}%`;
                  this.div.style.height = `${100 * height / parentHeight}%`;
                }
                getInitialTranslation() {
                  return [0, 0];
                }
                render() {
                  this.div = document.createElement("div");
                  this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                  this.div.className = this.name;
                  this.div.setAttribute("id", this.id);
                  this.div.setAttribute("tabIndex", 0);
                  this.setInForeground();
                  this.div.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.addEventListener("focusout", __privateGet(this, _boundFocusout));
                  const [tx, ty] = this.getInitialTranslation();
                  this.translate(tx, ty);
                  (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
                  return this.div;
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    event.preventDefault();
                    return;
                  }
                  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                    this.parent.toggleSelected(this);
                  } else {
                    this.parent.setSelected(this);
                  }
                  __privateSet(this, _hasBeenSelected, true);
                }
                getRect(tx, ty) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  const [pageWidth, pageHeight] = this.parent.pageDimensions;
                  const shiftX = pageWidth * tx / parentWidth;
                  const shiftY = pageHeight * ty / parentHeight;
                  const x = this.x * pageWidth;
                  const y = this.y * pageHeight;
                  const width = this.width * pageWidth;
                  const height = this.height * pageHeight;
                  switch (this.rotation) {
                    case 0:
                      return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY];
                    case 90:
                      return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width];
                    case 180:
                      return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];
                    case 270:
                      return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRectInCurrentCoords(rect, pageHeight) {
                  const [x1, y1, x2, y2] = rect;
                  const width = x2 - x1;
                  const height = y2 - y1;
                  switch (this.rotation) {
                    case 0:
                      return [x1, pageHeight - y2, width, height];
                    case 90:
                      return [x1, pageHeight - y1, height, width];
                    case 180:
                      return [x2, pageHeight - y1, width, height];
                    case 270:
                      return [x2, pageHeight - y2, height, width];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                onceAdded() {
                }
                isEmpty() {
                  return false;
                }
                enableEditMode() {
                  __privateSet(this, _isInEditMode, true);
                }
                disableEditMode() {
                  __privateSet(this, _isInEditMode, false);
                }
                isInEditMode() {
                  return __privateGet(this, _isInEditMode);
                }
                shouldGetKeyboardEvents() {
                  return false;
                }
                needsToBeRebuilt() {
                  return this.div && !this.isAttachedToDOM;
                }
                rebuild() {
                  this.div?.addEventListener("focusin", __privateGet(this, _boundFocusin));
                }
                serialize() {
                  (0, _util2.unreachable)("An editor must be serializable");
                }
                static deserialize(data, parent) {
                  const editor = new this.prototype.constructor({
                    parent,
                    id: parent.getNextId()
                  });
                  editor.rotation = data.rotation;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
                  editor.x = x / pageWidth;
                  editor.y = y / pageHeight;
                  editor.width = width / pageWidth;
                  editor.height = height / pageHeight;
                  return editor;
                }
                remove() {
                  this.div.removeEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.removeEventListener("focusout", __privateGet(this, _boundFocusout));
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.parent.remove(this);
                }
                select() {
                  this.div?.classList.add("selectedEditor");
                }
                unselect() {
                  this.div?.classList.remove("selectedEditor");
                }
                updateParams(type2, value) {
                }
                disableEditing() {
                }
                enableEditing() {
                }
                get propertiesToUpdate() {
                  return {};
                }
                get contentDiv() {
                  return this.div;
                }
                get isEditing() {
                  return __privateGet(this, _isEditing);
                }
                set isEditing(value) {
                  __privateSet(this, _isEditing, value);
                  if (value) {
                    this.parent.setSelected(this);
                    this.parent.setActiveEditor(this);
                  } else {
                    this.parent.setActiveEditor(null);
                  }
                }
              };
              let AnnotationEditor = _AnnotationEditor;
              _boundFocusin = new WeakMap();
              _boundFocusout = new WeakMap();
              _hasBeenSelected = new WeakMap();
              _isEditing = new WeakMap();
              _isInEditMode = new WeakMap();
              _zIndex = new WeakMap();
              __publicField(AnnotationEditor, "_colorManager", new _tools.ColorManager());
              __publicField(AnnotationEditor, "_zIndex", 1);
              exports2.AnnotationEditor = AnnotationEditor;
            },
            /* 7 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _id, _commands, _locked, _maxSize, _position, _serialize, serialize_fn, _elements, _activeEditor, _allEditors, _allLayers, _clipboardManager, _commandManager, _currentPageIndex, _editorTypes, _eventBus, _idManager, _isEnabled, _mode, _selectedEditors, _boundKeydown, _boundOnEditingAction, _boundOnPageChanging, _previousStates, _container, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
              exports2.bindEvents = bindEvents;
              exports2.opacityToHex = opacityToHex;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              function bindEvents(obj2, element, names) {
                for (const name of names) {
                  element.addEventListener(name, obj2[name].bind(obj2));
                }
              }
              function opacityToHex(opacity) {
                return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
              }
              class IdManager {
                constructor() {
                  __privateAdd(this, _id, 0);
                }
                getId() {
                  return `${_util2.AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
                }
              }
              _id = new WeakMap();
              class CommandManager {
                constructor(maxSize = 128) {
                  __privateAdd(this, _commands, []);
                  __privateAdd(this, _locked, false);
                  __privateAdd(this, _maxSize, void 0);
                  __privateAdd(this, _position, -1);
                  __privateSet(this, _maxSize, maxSize);
                }
                add({
                  cmd,
                  undo,
                  mustExec,
                  type: type2 = NaN,
                  overwriteIfSameType = false,
                  keepUndo = false
                }) {
                  if (mustExec) {
                    cmd();
                  }
                  if (__privateGet(this, _locked)) {
                    return;
                  }
                  const save = {
                    cmd,
                    undo,
                    type: type2
                  };
                  if (__privateGet(this, _position) === -1) {
                    if (__privateGet(this, _commands).length > 0) {
                      __privateGet(this, _commands).length = 0;
                    }
                    __privateSet(this, _position, 0);
                    __privateGet(this, _commands).push(save);
                    return;
                  }
                  if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type2) {
                    if (keepUndo) {
                      save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
                    }
                    __privateGet(this, _commands)[__privateGet(this, _position)] = save;
                    return;
                  }
                  const next = __privateGet(this, _position) + 1;
                  if (next === __privateGet(this, _maxSize)) {
                    __privateGet(this, _commands).splice(0, 1);
                  } else {
                    __privateSet(this, _position, next);
                    if (next < __privateGet(this, _commands).length) {
                      __privateGet(this, _commands).splice(next);
                    }
                  }
                  __privateGet(this, _commands).push(save);
                }
                undo() {
                  if (__privateGet(this, _position) === -1) {
                    return;
                  }
                  __privateSet(this, _locked, true);
                  __privateGet(this, _commands)[__privateGet(this, _position)].undo();
                  __privateSet(this, _locked, false);
                  __privateSet(this, _position, __privateGet(this, _position) - 1);
                }
                redo() {
                  if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
                    __privateSet(this, _position, __privateGet(this, _position) + 1);
                    __privateSet(this, _locked, true);
                    __privateGet(this, _commands)[__privateGet(this, _position)].cmd();
                    __privateSet(this, _locked, false);
                  }
                }
                hasSomethingToUndo() {
                  return __privateGet(this, _position) !== -1;
                }
                hasSomethingToRedo() {
                  return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
                }
                destroy() {
                  __privateSet(this, _commands, null);
                }
              }
              _commands = new WeakMap();
              _locked = new WeakMap();
              _maxSize = new WeakMap();
              _position = new WeakMap();
              exports2.CommandManager = CommandManager;
              const _KeyboardManager = class {
                constructor(callbacks) {
                  __privateAdd(this, _serialize);
                  this.buffer = [];
                  this.callbacks = /* @__PURE__ */ new Map();
                  this.allKeys = /* @__PURE__ */ new Set();
                  const isMac = _KeyboardManager.platform.isMac;
                  for (const [keys, callback] of callbacks) {
                    for (const key of keys) {
                      const isMacKey = key.startsWith("mac+");
                      if (isMac && isMacKey) {
                        this.callbacks.set(key.slice(4), callback);
                        this.allKeys.add(key.split("+").at(-1));
                      } else if (!isMac && !isMacKey) {
                        this.callbacks.set(key, callback);
                        this.allKeys.add(key.split("+").at(-1));
                      }
                    }
                  }
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
                exec(self, event) {
                  if (!this.allKeys.has(event.key)) {
                    return;
                  }
                  const callback = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
                  if (!callback) {
                    return;
                  }
                  callback.bind(self)();
                  event.stopPropagation();
                  event.preventDefault();
                }
              };
              let KeyboardManager = _KeyboardManager;
              _serialize = new WeakSet();
              serialize_fn = function(event) {
                if (event.altKey) {
                  this.buffer.push("alt");
                }
                if (event.ctrlKey) {
                  this.buffer.push("ctrl");
                }
                if (event.metaKey) {
                  this.buffer.push("meta");
                }
                if (event.shiftKey) {
                  this.buffer.push("shift");
                }
                this.buffer.push(event.key);
                const str3 = this.buffer.join("+");
                this.buffer.length = 0;
                return str3;
              };
              exports2.KeyboardManager = KeyboardManager;
              class ClipboardManager {
                constructor() {
                  __privateAdd(this, _elements, null);
                }
                copy(element) {
                  if (!element) {
                    return;
                  }
                  if (Array.isArray(element)) {
                    __privateSet(this, _elements, element.map((el) => el.serialize()));
                  } else {
                    __privateSet(this, _elements, [element.serialize()]);
                  }
                  __privateSet(this, _elements, __privateGet(this, _elements).filter((el) => !!el));
                  if (__privateGet(this, _elements).length === 0) {
                    __privateSet(this, _elements, null);
                  }
                }
                paste() {
                  return __privateGet(this, _elements);
                }
                isEmpty() {
                  return __privateGet(this, _elements) === null;
                }
                destroy() {
                  __privateSet(this, _elements, null);
                }
              }
              _elements = new WeakMap();
              const _ColorManager = class {
                get _colors() {
                  const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                  (0, _display_utils2.getColorValues)(colors);
                  return (0, _util2.shadow)(this, "_colors", colors);
                }
                convert(color) {
                  const rgb2 = (0, _display_utils2.getRGB)(color);
                  if (!window.matchMedia("(forced-colors: active)").matches) {
                    return rgb2;
                  }
                  for (const [name, RGB] of this._colors) {
                    if (RGB.every((x, i) => x === rgb2[i])) {
                      return _ColorManager._colorsMapping.get(name);
                    }
                  }
                  return rgb2;
                }
                getHexCode(name) {
                  const rgb2 = this._colors.get(name);
                  if (!rgb2) {
                    return name;
                  }
                  return _util2.Util.makeHexColor(...rgb2);
                }
              };
              let ColorManager = _ColorManager;
              __publicField(ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
              exports2.ColorManager = ColorManager;
              const _AnnotationEditorUIManager = class {
                constructor(container, eventBus) {
                  __privateAdd(this, _addKeyboardManager);
                  __privateAdd(this, _removeKeyboardManager);
                  __privateAdd(this, _dispatchUpdateStates);
                  __privateAdd(this, _dispatchUpdateUI);
                  __privateAdd(this, _enableAll);
                  __privateAdd(this, _disableAll);
                  __privateAdd(this, _addEditorToLayer);
                  __privateAdd(this, _isEmpty);
                  __privateAdd(this, _selectEditors);
                  __privateAdd(this, _activeEditor, null);
                  __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
                  __privateAdd(this, _clipboardManager, new ClipboardManager());
                  __privateAdd(this, _commandManager, new CommandManager());
                  __privateAdd(this, _currentPageIndex, 0);
                  __privateAdd(this, _editorTypes, null);
                  __privateAdd(this, _eventBus, null);
                  __privateAdd(this, _idManager, new IdManager());
                  __privateAdd(this, _isEnabled, false);
                  __privateAdd(this, _mode, _util2.AnnotationEditorType.NONE);
                  __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
                  __privateAdd(this, _boundKeydown, this.keydown.bind(this));
                  __privateAdd(this, _boundOnEditingAction, this.onEditingAction.bind(this));
                  __privateAdd(this, _boundOnPageChanging, this.onPageChanging.bind(this));
                  __privateAdd(this, _previousStates, {
                    isEditing: false,
                    isEmpty: true,
                    hasEmptyClipboard: true,
                    hasSomethingToUndo: false,
                    hasSomethingToRedo: false,
                    hasSelectedEditor: false
                  });
                  __privateAdd(this, _container, null);
                  __privateSet(this, _container, container);
                  __privateSet(this, _eventBus, eventBus);
                  __privateGet(this, _eventBus)._on("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._on("pagechanging", __privateGet(this, _boundOnPageChanging));
                }
                destroy() {
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateGet(this, _eventBus)._off("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._off("pagechanging", __privateGet(this, _boundOnPageChanging));
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.destroy();
                  }
                  __privateGet(this, _allLayers).clear();
                  __privateGet(this, _allEditors).clear();
                  __privateSet(this, _activeEditor, null);
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _clipboardManager).destroy();
                  __privateGet(this, _commandManager).destroy();
                }
                onPageChanging({
                  pageNumber
                }) {
                  __privateSet(this, _currentPageIndex, pageNumber - 1);
                }
                focusMainContainer() {
                  __privateGet(this, _container).focus();
                }
                keydown(event) {
                  if (!this.getActive()?.shouldGetKeyboardEvents()) {
                    _AnnotationEditorUIManager._keyboardManager.exec(this, event);
                  }
                }
                onEditingAction(details) {
                  if (["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(details.name)) {
                    this[details.name]();
                  }
                }
                setEditingState(isEditing) {
                  if (isEditing) {
                    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: __privateGet(this, _mode) !== _util2.AnnotationEditorType.NONE,
                      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
                      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                      hasSelectedEditor: false,
                      hasEmptyClipboard: __privateGet(this, _clipboardManager).isEmpty()
                    });
                  } else {
                    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: false
                    });
                  }
                }
                registerEditorTypes(types) {
                  __privateSet(this, _editorTypes, types);
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
                  }
                }
                getId() {
                  return __privateGet(this, _idManager).getId();
                }
                addLayer(layer) {
                  __privateGet(this, _allLayers).set(layer.pageIndex, layer);
                  if (__privateGet(this, _isEnabled)) {
                    layer.enable();
                  } else {
                    layer.disable();
                  }
                }
                removeLayer(layer) {
                  __privateGet(this, _allLayers).delete(layer.pageIndex);
                }
                updateMode(mode) {
                  __privateSet(this, _mode, mode);
                  if (mode === _util2.AnnotationEditorType.NONE) {
                    this.setEditingState(false);
                    __privateMethod(this, _disableAll, disableAll_fn).call(this);
                  } else {
                    this.setEditingState(true);
                    __privateMethod(this, _enableAll, enableAll_fn).call(this);
                    for (const layer of __privateGet(this, _allLayers).values()) {
                      layer.updateMode(mode);
                    }
                  }
                }
                updateToolbar(mode) {
                  if (mode === __privateGet(this, _mode)) {
                    return;
                  }
                  __privateGet(this, _eventBus).dispatch("switchannotationeditormode", {
                    source: this,
                    mode
                  });
                }
                updateParams(type2, value) {
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.updateParams(type2, value);
                  }
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    editorType.updateDefaultParams(type2, value);
                  }
                }
                getEditors(pageIndex) {
                  const editors = [];
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    if (editor.pageIndex === pageIndex) {
                      editors.push(editor);
                    }
                  }
                  return editors;
                }
                getEditor(id) {
                  return __privateGet(this, _allEditors).get(id);
                }
                addEditor(editor) {
                  __privateGet(this, _allEditors).set(editor.id, editor);
                }
                removeEditor(editor) {
                  __privateGet(this, _allEditors).delete(editor.id);
                  this.unselect(editor);
                }
                setActiveEditor(editor) {
                  if (__privateGet(this, _activeEditor) === editor) {
                    return;
                  }
                  __privateSet(this, _activeEditor, editor);
                  if (editor) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  }
                }
                toggleSelected(editor) {
                  if (__privateGet(this, _selectedEditors).has(editor)) {
                    __privateGet(this, _selectedEditors).delete(editor);
                    editor.unselect();
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasSelectedEditor: this.hasSelection
                    });
                    return;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                setSelected(editor) {
                  for (const ed of __privateGet(this, _selectedEditors)) {
                    if (ed !== editor) {
                      ed.unselect();
                    }
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                isSelected(editor) {
                  return __privateGet(this, _selectedEditors).has(editor);
                }
                unselect(editor) {
                  editor.unselect();
                  __privateGet(this, _selectedEditors).delete(editor);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                }
                get hasSelection() {
                  return __privateGet(this, _selectedEditors).size !== 0;
                }
                undo() {
                  __privateGet(this, _commandManager).undo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: true,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                redo() {
                  __privateGet(this, _commandManager).redo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                addCommands(params) {
                  __privateGet(this, _commandManager).add(params);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: false,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                delete() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [...__privateGet(this, _selectedEditors)];
                  const cmd = () => {
                    for (const editor of editors) {
                      editor.remove();
                    }
                  };
                  const undo = () => {
                    for (const editor of editors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                copy() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (this.hasSelection) {
                    const editors = [];
                    for (const editor of __privateGet(this, _selectedEditors)) {
                      if (!editor.isEmpty()) {
                        editors.push(editor);
                      }
                    }
                    if (editors.length === 0) {
                      return;
                    }
                    __privateGet(this, _clipboardManager).copy(editors);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasEmptyClipboard: false
                    });
                  }
                }
                cut() {
                  this.copy();
                  this.delete();
                }
                paste() {
                  if (__privateGet(this, _clipboardManager).isEmpty()) {
                    return;
                  }
                  this.unselectAll();
                  const layer = __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
                  const newEditors = __privateGet(this, _clipboardManager).paste().map((data) => layer.deserialize(data));
                  const cmd = () => {
                    for (const editor of newEditors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                    __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
                  };
                  const undo = () => {
                    for (const editor of newEditors) {
                      editor.remove();
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                selectAll() {
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.commit();
                  }
                  __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
                }
                unselectAll() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                    return;
                  }
                  if (__privateMethod(this, _selectEditors, selectEditors_fn).size === 0) {
                    return;
                  }
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.unselect();
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: false
                  });
                }
                isActive(editor) {
                  return __privateGet(this, _activeEditor) === editor;
                }
                getActive() {
                  return __privateGet(this, _activeEditor);
                }
                getMode() {
                  return __privateGet(this, _mode);
                }
              };
              let AnnotationEditorUIManager = _AnnotationEditorUIManager;
              _activeEditor = new WeakMap();
              _allEditors = new WeakMap();
              _allLayers = new WeakMap();
              _clipboardManager = new WeakMap();
              _commandManager = new WeakMap();
              _currentPageIndex = new WeakMap();
              _editorTypes = new WeakMap();
              _eventBus = new WeakMap();
              _idManager = new WeakMap();
              _isEnabled = new WeakMap();
              _mode = new WeakMap();
              _selectedEditors = new WeakMap();
              _boundKeydown = new WeakMap();
              _boundOnEditingAction = new WeakMap();
              _boundOnPageChanging = new WeakMap();
              _previousStates = new WeakMap();
              _container = new WeakMap();
              _addKeyboardManager = new WeakSet();
              addKeyboardManager_fn = function() {
                __privateGet(this, _container).addEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _removeKeyboardManager = new WeakSet();
              removeKeyboardManager_fn = function() {
                __privateGet(this, _container).removeEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _dispatchUpdateStates = new WeakSet();
              dispatchUpdateStates_fn = function(details) {
                const hasChanged = Object.entries(details).some(([key, value]) => __privateGet(this, _previousStates)[key] !== value);
                if (hasChanged) {
                  __privateGet(this, _eventBus).dispatch("annotationeditorstateschanged", {
                    source: this,
                    details: Object.assign(__privateGet(this, _previousStates), details)
                  });
                }
              };
              _dispatchUpdateUI = new WeakSet();
              dispatchUpdateUI_fn = function(details) {
                __privateGet(this, _eventBus).dispatch("annotationeditorparamschanged", {
                  source: this,
                  details
                });
              };
              _enableAll = new WeakSet();
              enableAll_fn = function() {
                if (!__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, true);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.enable();
                  }
                }
              };
              _disableAll = new WeakSet();
              disableAll_fn = function() {
                this.unselectAll();
                if (__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, false);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.disable();
                  }
                }
              };
              _addEditorToLayer = new WeakSet();
              addEditorToLayer_fn = function(editor) {
                const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
                if (layer) {
                  layer.addOrRebuild(editor);
                } else {
                  this.addEditor(editor);
                }
              };
              _isEmpty = new WeakSet();
              isEmpty_fn = function() {
                if (__privateGet(this, _allEditors).size === 0) {
                  return true;
                }
                if (__privateGet(this, _allEditors).size === 1) {
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    return editor.isEmpty();
                  }
                }
                return false;
              };
              _selectEditors = new WeakSet();
              selectEditors_fn = function(editors) {
                __privateGet(this, _selectedEditors).clear();
                for (const editor of editors) {
                  if (editor.isEmpty()) {
                    continue;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                }
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              };
              __publicField(AnnotationEditorUIManager, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], _AnnotationEditorUIManager.prototype.selectAll], [["ctrl+c", "mac+meta+c"], _AnnotationEditorUIManager.prototype.copy], [["ctrl+v", "mac+meta+v"], _AnnotationEditorUIManager.prototype.paste], [["ctrl+x", "mac+meta+x"], _AnnotationEditorUIManager.prototype.cut], [["ctrl+z", "mac+meta+z"], _AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], _AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], _AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], _AnnotationEditorUIManager.prototype.unselectAll]]));
              exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = exports2.AnnotationPrefix = void 0;
              exports2.deprecated = deprecated;
              exports2.getColorValues = getColorValues;
              exports2.getCurrentTransform = getCurrentTransform;
              exports2.getCurrentTransformInverse = getCurrentTransformInverse;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getRGB = getRGB;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              var _base_factory = __w_pdfjs_require__2(9);
              var _util2 = __w_pdfjs_require__2(1);
              const SVG_NS = "http://www.w3.org/2000/svg";
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
              const _PixelsPerInch = class {
              };
              let PixelsPerInch = _PixelsPerInch;
              __publicField(PixelsPerInch, "CSS", 96);
              __publicField(PixelsPerInch, "PDF", 72);
              __publicField(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
              exports2.PixelsPerInch = PixelsPerInch;
              class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                constructor({
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  this._document = ownerDocument;
                }
                _createCanvas(width, height) {
                  const canvas = this._document.createElement("canvas");
                  canvas.width = width;
                  canvas.height = height;
                  return canvas;
                }
              }
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              async function fetchData(url2, asTypedArray = false) {
                if (isValidFetchUrl(url2, document.baseURI)) {
                  const response = await fetch(url2);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url2, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
              class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url2, compressionType) {
                  return fetchData(url2, this.isCompressed).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url2) {
                  return fetchData(url2, true);
                }
              }
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                _createSVG(type2) {
                  return document.createElementNS(SVG_NS, type2);
                }
              }
              exports2.DOMSVGFactory = DOMSVGFactory;
              class PageViewport {
                constructor({
                  viewBox,
                  scale: scale3,
                  rotation,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                }) {
                  this.viewBox = viewBox;
                  this.scale = scale3;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  const centerX = (viewBox[2] + viewBox[0]) / 2;
                  const centerY = (viewBox[3] + viewBox[1]) / 2;
                  let rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  let offsetCanvasX, offsetCanvasY;
                  let width, height;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale3 + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale3 + offsetY;
                    width = Math.abs(viewBox[3] - viewBox[1]) * scale3;
                    height = Math.abs(viewBox[2] - viewBox[0]) * scale3;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale3 + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale3 + offsetY;
                    width = Math.abs(viewBox[2] - viewBox[0]) * scale3;
                    height = Math.abs(viewBox[3] - viewBox[1]) * scale3;
                  }
                  this.transform = [rotateA * scale3, rotateB * scale3, rotateC * scale3, rotateD * scale3, offsetCanvasX - rotateA * scale3 * centerX - rotateC * scale3 * centerY, offsetCanvasY - rotateB * scale3 * centerX - rotateD * scale3 * centerY];
                  this.width = width;
                  this.height = height;
                }
                clone({
                  scale: scale3 = this.scale,
                  rotation = this.rotation,
                  offsetX = this.offsetX,
                  offsetY = this.offsetY,
                  dontFlip = false
                } = {}) {
                  return new PageViewport({
                    viewBox: this.viewBox.slice(),
                    scale: scale3,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                convertToViewportPoint(x, y) {
                  return _util2.Util.applyTransform([x, y], this.transform);
                }
                convertToViewportRectangle(rect) {
                  const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
                convertToPdfPoint(x, y) {
                  return _util2.Util.applyInverseTransform([x, y], this.transform);
                }
              }
              exports2.PageViewport = PageViewport;
              class RenderingCancelledException extends _util2.BaseException {
                constructor(msg, type2) {
                  super(msg, "RenderingCancelledException");
                  this.type = type2;
                }
              }
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url2) {
                const ii = url2.length;
                let i = 0;
                while (i < ii && url2[i].trim() === "") {
                  i++;
                }
                return url2.substring(i, i + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url2) {
                const anchor = url2.indexOf("#");
                const query = url2.indexOf("?");
                const end2 = Math.min(anchor > 0 ? anchor : url2.length, query > 0 ? query : url2.length);
                return url2.substring(url2.lastIndexOf("/", end2) + 1, end2);
              }
              function getPdfFilenameFromUrl(url2, defaultFilename = "document.pdf") {
                if (typeof url2 !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url2)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                const splitURI = reURI.exec(url2);
                let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch (ex) {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              class StatTimer {
                constructor() {
                  this.started = /* @__PURE__ */ Object.create(null);
                  this.times = [];
                }
                time(name) {
                  if (name in this.started) {
                    (0, _util2.warn)(`Timer is already running for ${name}`);
                  }
                  this.started[name] = Date.now();
                }
                timeEnd(name) {
                  if (!(name in this.started)) {
                    (0, _util2.warn)(`Timer has not been started for ${name}`);
                  }
                  this.times.push({
                    name,
                    start: this.started[name],
                    end: Date.now()
                  });
                  delete this.started[name];
                }
                toString() {
                  const outBuf = [];
                  let longest = 0;
                  for (const time of this.times) {
                    const name = time.name;
                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                  for (const time of this.times) {
                    const duration = time.end - time.start;
                    outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                  }
                  return outBuf.join("");
                }
              }
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url2, baseUrl) {
                try {
                  const {
                    protocol
                  } = baseUrl ? new URL(url2, baseUrl) : new URL(url2);
                  return protocol === "http:" || protocol === "https:";
                } catch (ex) {
                  return false;
                }
              }
              function loadScript(src2, removeScriptElement = false) {
                return new Promise((resolve, reject) => {
                  const script = document.createElement("script");
                  script.src = src2;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error(`Cannot load script at: ${script.src}`));
                  };
                  (document.head || document.documentElement).append(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              let pdfDateStringRegex;
              class PDFDateString {
                static toDateObject(input) {
                  if (!input || typeof input !== "string") {
                    return null;
                  }
                  if (!pdfDateStringRegex) {
                    pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                  }
                  const matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  const year = parseInt(matches[1], 10);
                  let month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  let day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  let hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  let minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  let second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  const universalTimeRelation = matches[7] || "Z";
                  let offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  let offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, {
                scale: scale3 = 1,
                rotation = 0
              }) {
                const {
                  width,
                  height
                } = xfaPage.attributes.style;
                const viewBox = [0, 0, parseInt(width), parseInt(height)];
                return new PageViewport({
                  viewBox,
                  scale: scale3,
                  rotation
                });
              }
              function getRGB(color) {
                if (color.startsWith("#")) {
                  const colorRGB = parseInt(color.slice(1), 16);
                  return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
                }
                if (color.startsWith("rgb(")) {
                  return color.slice(4, -1).split(",").map((x) => parseInt(x));
                }
                if (color.startsWith("rgba(")) {
                  return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
                }
                (0, _util2.warn)(`Not a valid color format: "${color}"`);
                return [0, 0, 0];
              }
              function getColorValues(colors) {
                const span = document.createElement("span");
                span.style.visibility = "hidden";
                document.body.append(span);
                for (const name of colors.keys()) {
                  span.style.color = name;
                  const computedColor = window.getComputedStyle(span).color;
                  colors.set(name, getRGB(computedColor));
                }
                span.remove();
              }
              function getCurrentTransform(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e: e2,
                  f
                } = ctx.getTransform();
                return [a, b, c, d, e2, f];
              }
              function getCurrentTransformInverse(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e: e2,
                  f
                } = ctx.getTransform().invertSelf();
                return [a, b, c, d, e2, f];
              }
            },
            /* 9 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseCanvasFactory {
                constructor() {
                  if (this.constructor === BaseCanvasFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                create(width, height) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const canvas = this._createCanvas(width, height);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
                reset(canvasAndContext, width, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width;
                  canvasAndContext.canvas.height = height;
                }
                destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
                _createCanvas(width, height) {
                  (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                }
              }
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              class BaseCMapReaderFactory {
                constructor({
                  baseUrl = null,
                  isCompressed = false
                }) {
                  if (this.constructor === BaseCMapReaderFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                async fetch({
                  name
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url2 = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url2, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url2}`);
                  });
                }
                _fetchData(url2, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              class BaseStandardFontDataFactory {
                constructor({
                  baseUrl = null
                }) {
                  if (this.constructor === BaseStandardFontDataFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                async fetch({
                  filename
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                  }
                  if (!filename) {
                    throw new Error("Font filename must be specified.");
                  }
                  const url2 = `${this.baseUrl}${filename}`;
                  return this._fetchData(url2).catch((reason) => {
                    throw new Error(`Unable to load font data at: ${url2}`);
                  });
                }
                _fetchData(url2) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              class BaseSVGFactory {
                constructor() {
                  if (this.constructor === BaseSVGFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                create(width, height, skipDimensions = false) {
                  if (width <= 0 || height <= 0) {
                    throw new Error("Invalid SVG dimensions");
                  }
                  const svg = this._createSVG("svg:svg");
                  svg.setAttribute("version", "1.1");
                  if (!skipDimensions) {
                    svg.setAttribute("width", `${width}px`);
                    svg.setAttribute("height", `${height}px`);
                  }
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
                  return svg;
                }
                createElement(type2) {
                  if (typeof type2 !== "string") {
                    throw new Error("Invalid SVG element type");
                  }
                  return this._createSVG(type2);
                }
                _createSVG(type2) {
                  (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                }
              }
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            /* 10 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length3;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length3 = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length3++] = code;
                      } else {
                        data[length3++] = code >>> 8;
                        data[length3++] = code & 255;
                      }
                    }
                  } else if ((0, _util2.isArrayBuffer)(input)) {
                    data = input.slice();
                    length3 = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length3 >> 2;
                  const tailLength = length3 - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                  return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 11 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseFontLoader {
                constructor({
                  docId,
                  onUnsupportedFeature,
                  ownerDocument = globalThis.document,
                  styleElement = null
                }) {
                  if (this.constructor === BaseFontLoader) {
                    (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                  }
                  this.docId = docId;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this._document = ownerDocument;
                  this.nativeFontFaces = [];
                  this.styleElement = null;
                }
                addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.push(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
                insertRule(rule) {
                  let styleElement = this.styleElement;
                  if (!styleElement) {
                    styleElement = this.styleElement = this._document.createElement("style");
                    styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                    this._document.documentElement.getElementsByTagName("head")[0].append(styleElement);
                  }
                  const styleSheet = styleElement.sheet;
                  styleSheet.insertRule(rule, styleSheet.cssRules.length);
                }
                clear() {
                  for (const nativeFontFace of this.nativeFontFaces) {
                    this._document.fonts.delete(nativeFontFace);
                  }
                  this.nativeFontFaces.length = 0;
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
                async bind(font) {
                  if (font.attached || font.missingFile) {
                    return;
                  }
                  font.attached = true;
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        await nativeFontFace.loaded;
                      } catch (ex) {
                        this._onUnsupportedFeature({
                          featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                        });
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule = font.createFontFaceRule();
                  if (rule) {
                    this.insertRule(rule);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    await new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent([rule], [font], request);
                    });
                  }
                }
                _queueLoadingCallback(callback) {
                  (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                }
                get isFontLoadingAPISupported() {
                  const hasFonts = !!this._document?.fonts;
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                }
                get isSyncFontLoadingSupported() {
                  (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                }
                get _loadTestFont() {
                  (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                }
                _prepareFontLoadEvent(rules, fontsToLoad, request) {
                  (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                }
              }
              let FontLoader;
              exports2.FontLoader = FontLoader;
              {
                exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                  constructor(params) {
                    super(params);
                    this.loadingContext = {
                      requests: [],
                      nextRequestId: 0
                    };
                    this.loadTestFontId = 0;
                  }
                  get isSyncFontLoadingSupported() {
                    let supported = false;
                    if (typeof navigator === "undefined") {
                      supported = true;
                    } else {
                      const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                      if (m?.[1] >= 14) {
                        supported = true;
                      }
                    }
                    return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                  }
                  _queueLoadingCallback(callback) {
                    function completeRequest() {
                      (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                      request.done = true;
                      while (context.requests.length > 0 && context.requests[0].done) {
                        const otherRequest = context.requests.shift();
                        setTimeout(otherRequest.callback, 0);
                      }
                    }
                    const context = this.loadingContext;
                    const request = {
                      id: `pdfjs-font-loading-${context.nextRequestId++}`,
                      done: false,
                      complete: completeRequest,
                      callback
                    };
                    context.requests.push(request);
                    return request;
                  }
                  get _loadTestFont() {
                    const getLoadTestFont = function() {
                      return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                    };
                    return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                  }
                  _prepareFontLoadEvent(rules, fonts, request) {
                    function int32(data2, offset) {
                      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                    }
                    function spliceString(s, offset, remove, insert) {
                      const chunk1 = s.substring(0, offset);
                      const chunk2 = s.substring(offset + remove);
                      return chunk1 + insert + chunk2;
                    }
                    let i, ii;
                    const canvas = this._document.createElement("canvas");
                    canvas.width = 1;
                    canvas.height = 1;
                    const ctx = canvas.getContext("2d");
                    let called = 0;
                    function isFontReady(name, callback) {
                      called++;
                      if (called > 30) {
                        (0, _util2.warn)("Load test font never loaded.");
                        callback();
                        return;
                      }
                      ctx.font = "30px " + name;
                      ctx.fillText(".", 0, 20);
                      const imageData = ctx.getImageData(0, 0, 1, 1);
                      if (imageData.data[3] > 0) {
                        callback();
                        return;
                      }
                      setTimeout(isFontReady.bind(null, name, callback));
                    }
                    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                    let data = this._loadTestFont;
                    const COMMENT_OFFSET = 976;
                    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                    const CFF_CHECKSUM_OFFSET = 16;
                    const XXXX_VALUE = 1482184792;
                    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                    }
                    if (i < loadTestFontId.length) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                    }
                    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                    const url2 = `url(data:font/opentype;base64,${btoa(data)});`;
                    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url2}}`;
                    this.insertRule(rule);
                    const names = [];
                    for (const font of fonts) {
                      names.push(font.loadedName);
                    }
                    names.push(loadTestFontId);
                    const div3 = this._document.createElement("div");
                    div3.style.visibility = "hidden";
                    div3.style.width = div3.style.height = "10px";
                    div3.style.position = "absolute";
                    div3.style.top = div3.style.left = "0px";
                    for (const name of names) {
                      const span = this._document.createElement("span");
                      span.textContent = "Hi";
                      span.style.fontFamily = name;
                      div3.append(span);
                    }
                    this._document.body.append(div3);
                    isFontReady(loadTestFontId, () => {
                      div3.remove();
                      request.complete();
                    });
                  }
                };
              }
              class FontFaceObject {
                constructor(translatedData, {
                  isEvalSupported = true,
                  disableFontFace = false,
                  ignoreErrors = false,
                  onUnsupportedFeature,
                  fontRegistry = null
                }) {
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (const i in translatedData) {
                    this[i] = translatedData[i];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this.fontRegistry = fontRegistry;
                }
                createNativeFontFace() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  let nativeFontFace;
                  if (!this.cssFontInfo) {
                    nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  } else {
                    const css = {
                      weight: this.cssFontInfo.fontWeight
                    };
                    if (this.cssFontInfo.italicAngle) {
                      css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                    }
                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this);
                  }
                  return nativeFontFace;
                }
                createFontFaceRule() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  const data = (0, _util2.bytesToString)(this.data);
                  const url2 = `url(data:${this.mimetype};base64,${btoa(data)});`;
                  let rule;
                  if (!this.cssFontInfo) {
                    rule = `@font-face {font-family:"${this.loadedName}";src:${url2}}`;
                  } else {
                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                    if (this.cssFontInfo.italicAngle) {
                      css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                    }
                    rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url2}}`;
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this, url2);
                  }
                  return rule;
                }
                getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  let cmds;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                    });
                    (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                    return this.compiledGlyphs[character] = function(c, size2) {
                    };
                  }
                  if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                    const jsBuf = [];
                    for (const current of cmds) {
                      const args = current.args !== void 0 ? current.args.join(",") : "";
                      jsBuf.push("c.", current.cmd, "(", args, ");\n");
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                  }
                  return this.compiledGlyphs[character] = function(c, size2) {
                    for (const current of cmds) {
                      if (current.cmd === "scale") {
                        current.args = [size2, -size2];
                      }
                      c[current.cmd].apply(c, current.args);
                    }
                  };
                }
              }
              exports2.FontFaceObject = FontFaceObject;
            },
            /* 12 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _restoreInitialState, restoreInitialState_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _util2 = __w_pdfjs_require__2(1);
              var _pattern_helper = __w_pdfjs_require__2(13);
              var _image_utils = __w_pdfjs_require__2(14);
              var _is_node2 = __w_pdfjs_require__2(3);
              const MIN_FONT_SIZE = 16;
              const MAX_FONT_SIZE = 100;
              const MAX_GROUP_SIZE = 4096;
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              const MAX_SIZE_TO_COMPILE = _is_node2.isNodeJS && typeof Path2D === "undefined" ? -1 : 1e3;
              const FULL_CHUNK_HEIGHT = 16;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = () => {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x, y) {
                  destCtx.translate(x, y);
                  this.__originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  destCtx.scale(x, y);
                  this.__originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e2, f) {
                  destCtx.transform(a, b, c, d, e2, f);
                  this.__originalTransform(a, b, c, d, e2, f);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e2, f) {
                  destCtx.setTransform(a, b, c, d, e2, f);
                  this.__originalSetTransform(a, b, c, d, e2, f);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle3) {
                  destCtx.rotate(angle3);
                  this.__originalRotate(angle3);
                };
                ctx.clip = function ctxRotate(rule) {
                  destCtx.clip(rule);
                  this.__originalClip(rule);
                };
                ctx.moveTo = function(x, y) {
                  destCtx.moveTo(x, y);
                  this.__originalMoveTo(x, y);
                };
                ctx.lineTo = function(x, y) {
                  destCtx.lineTo(x, y);
                  this.__originalLineTo(x, y);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                };
                ctx.rect = function(x, y, width, height) {
                  destCtx.rect(x, y, width, height);
                  this.__originalRect(x, y, width, height);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              class CachedCanvases {
                constructor(canvasFactory) {
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                getCanvas(id, width, height) {
                  let canvasEntry;
                  if (this.cache[id] !== void 0) {
                    canvasEntry = this.cache[id];
                    this.canvasFactory.reset(canvasEntry, width, height);
                  } else {
                    canvasEntry = this.canvasFactory.create(width, height);
                    this.cache[id] = canvasEntry;
                  }
                  return canvasEntry;
                }
                delete(id) {
                  delete this.cache[id];
                }
                clear() {
                  for (const id in this.cache) {
                    const canvasEntry = this.cache[id];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id];
                  }
                }
              }
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                const [a, b, c, d, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
                if (b === 0 && c === 0) {
                  const tlX = destX * a + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destY * d + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destX + destW) * a + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destY + destH) * d + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a === 0 && d === 0) {
                  const tlX = destY * c + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destX * b + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destY + destH) * c + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destX + destW) * b + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rHeight, rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                const scaleX = Math.hypot(a, b);
                const scaleY = Math.hypot(c, d);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                const {
                  width,
                  height
                } = imgData;
                if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                const POINT_TO_PROCESS_LIMIT = 1e3;
                const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                const width1 = width + 1;
                let points = new Uint8Array(width1 * (height + 1));
                let i, j, j0;
                const lineSize = width + 7 & ~7;
                let data = new Uint8Array(lineSize * height), pos = 0;
                for (const elem of imgData.data) {
                  let mask = 128;
                  while (mask > 0) {
                    data[pos++] = elem & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                let count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j] = 2;
                  ++count;
                }
                for (i = 1; i < height; i++) {
                  pos = i * lineSize;
                  j0 = i * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j = 1; j < width; j++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j = 1; j < width; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                const path = new Path2D();
                for (i = 0; count && i <= height; i++) {
                  let p = i * width1;
                  const end2 = p + width;
                  while (p < end2 && !points[p]) {
                    p++;
                  }
                  if (p === end2) {
                    continue;
                  }
                  path.moveTo(p % width1, i);
                  const p0 = p;
                  let type2 = points[p];
                  do {
                    const step = steps[type2];
                    do {
                      p += step;
                    } while (!points[p]);
                    const pp = points[p];
                    if (pp !== 5 && pp !== 10) {
                      type2 = pp;
                      points[p] = 0;
                    } else {
                      type2 = pp & 51 * type2 >> 4;
                      points[p] &= type2 >> 2 | type2 << 2;
                    }
                    path.lineTo(p % width1, p / width1 | 0);
                    if (!points[p]) {
                      --count;
                    }
                  } while (p0 !== p);
                  --i;
                }
                data = null;
                points = null;
                const drawOutline = function(c) {
                  c.save();
                  c.scale(1 / width, -1 / height);
                  c.translate(0, -height);
                  c.fill(path);
                  c.beginPath();
                  c.restore();
                };
                return drawOutline;
              }
              class CanvasExtraState {
                constructor(width, height) {
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = null;
                  this.startNewPathAndClipBox([0, 0, width, height]);
                }
                clone() {
                  const clone3 = Object.create(this);
                  clone3.clipBox = this.clipBox.slice();
                  return clone3;
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
                updatePathMinMax(transform, x, y) {
                  [x, y] = _util2.Util.applyTransform([x, y], transform);
                  this.minX = Math.min(this.minX, x);
                  this.minY = Math.min(this.minY, y);
                  this.maxX = Math.max(this.maxX, x);
                  this.maxY = Math.max(this.maxY, y);
                }
                updateRectMinMax(transform, rect) {
                  const p1 = _util2.Util.applyTransform(rect, transform);
                  const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                  this.minX = Math.min(this.minX, p1[0], p2[0]);
                  this.minY = Math.min(this.minY, p1[1], p2[1]);
                  this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                  this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                }
                updateScalingPathMinMax(transform, minMax) {
                  _util2.Util.scaleMinMax(transform, minMax);
                  this.minX = Math.min(this.minX, minMax[0]);
                  this.maxX = Math.max(this.maxX, minMax[1]);
                  this.minY = Math.min(this.minY, minMax[2]);
                  this.maxY = Math.max(this.maxY, minMax[3]);
                }
                updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                  const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                  if (minMax) {
                    minMax[0] = Math.min(minMax[0], box[0], box[2]);
                    minMax[1] = Math.max(minMax[1], box[0], box[2]);
                    minMax[2] = Math.min(minMax[2], box[1], box[3]);
                    minMax[3] = Math.max(minMax[3], box[1], box[3]);
                    return;
                  }
                  this.updateRectMinMax(transform, box);
                }
                getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  const box = [this.minX, this.minY, this.maxX, this.maxY];
                  if (pathType === _pattern_helper.PathType.STROKE) {
                    if (!transform) {
                      (0, _util2.unreachable)("Stroke bounding box must include transform.");
                    }
                    const scale3 = _util2.Util.singularValueDecompose2dScale(transform);
                    const xStrokePad = scale3[0] * this.lineWidth / 2;
                    const yStrokePad = scale3[1] * this.lineWidth / 2;
                    box[0] -= xStrokePad;
                    box[1] -= yStrokePad;
                    box[2] += xStrokePad;
                    box[3] += yStrokePad;
                  }
                  return box;
                }
                updateClipFromPath() {
                  const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                  this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                }
                isEmptyClip() {
                  return this.minX === Infinity;
                }
                startNewPathAndClipBox(box) {
                  this.clipBox = box;
                  this.minX = Infinity;
                  this.minY = Infinity;
                  this.maxX = 0;
                  this.maxY = 0;
                }
                getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                }
              }
              function putBinaryImageData(ctx, imgData, transferMaps = null) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src2 = imgData.data;
                const dest = chunkImgData.data;
                let i, j, thisChunkHeight, elemsInThisChunk;
                let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src2.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width + 7 >> 3;
                  let white2 = 4294967295;
                  let black2 = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      [white2, black2] = [black2, white2];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      const srcDiff = srcLength - srcPos;
                      let k = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src2[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white2 : black2;
                        dest32[destPos++] = srcByte & 64 ? white2 : black2;
                        dest32[destPos++] = srcByte & 32 ? white2 : black2;
                        dest32[destPos++] = srcByte & 16 ? white2 : black2;
                        dest32[destPos++] = srcByte & 8 ? white2 : black2;
                        dest32[destPos++] = srcByte & 4 ? white2 : black2;
                        dest32[destPos++] = srcByte & 2 ? white2 : black2;
                        dest32[destPos++] = srcByte & 1 ? white2 : black2;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src2[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white2 : black2;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src2.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width * partialChunkHeight * 4;
                    dest.set(src2.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (hasTransferMaps) {
                      for (let k = 0; k < destPos; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                const height = imgData.height, width = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src2 = imgData.data;
                const dest = chunkImgData.data;
                for (let i = 0; i < totalChunks; i++) {
                  const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  ({
                    srcPos
                  } = (0, _image_utils.applyMaskImageData)({
                    src: src2,
                    srcPos,
                    dest,
                    width,
                    height: thisChunkHeight
                  }));
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (let i = 0, ii = properties.length; i < ii; i++) {
                  const property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx, foregroundColor) {
                ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length3 = bytes.length;
                for (let i = 3; i < length3; i += 4) {
                  const alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length3 = maskData.length;
                const scale3 = 1 / 255;
                for (let i = 3; i < length3; i += 4) {
                  const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale3 | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length3 = maskData.length;
                for (let i = 3; i < length3; i += 4) {
                  const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                let composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));
                for (let row = 0; row < height; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height - row);
                  const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
                  const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                const layerOffsetX = layerBox[0];
                const layerOffsetY = layerBox[1];
                const layerWidth = layerBox[2] - layerOffsetX;
                const layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform, interpolate) {
                const scale3 = _util2.Util.singularValueDecompose2dScale(transform);
                scale3[0] = Math.fround(scale3[0]);
                scale3[1] = Math.fround(scale3[1]);
                const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale3[0] <= actualScale || scale3[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              const _CanvasGraphics = class {
                constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
                  __privateAdd(this, _restoreInitialState);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.imageLayer = imageLayer;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.backgroundColor = pageColors?.background || null;
                  this.foregroundColor = pageColors?.foreground || null;
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  const width = this.ctx.canvas.width;
                  const height = this.ctx.canvas.height;
                  const defaultBackgroundColor = background || "#ffffff";
                  this.ctx.save();
                  if (this.foregroundColor && this.backgroundColor) {
                    this.ctx.fillStyle = this.foregroundColor;
                    const fg = this.foregroundColor = this.ctx.fillStyle;
                    this.ctx.fillStyle = this.backgroundColor;
                    const bg = this.backgroundColor = this.ctx.fillStyle;
                    let isValidDefaultBg = true;
                    let defaultBg = defaultBackgroundColor;
                    this.ctx.fillStyle = defaultBackgroundColor;
                    defaultBg = this.ctx.fillStyle;
                    isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
                    if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                      this.foregroundColor = this.backgroundColor = null;
                    } else {
                      const [rB, gB, bB] = (0, _display_utils2.getRGB)(defaultBg);
                      const newComp = (x) => {
                        x /= 255;
                        return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                      };
                      const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
                      this.selectColor = (r, g, b) => {
                        const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                        return Math.round(lumC) === lumB ? bg : fg;
                      };
                    }
                  }
                  this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
                  this.ctx.fillRect(0, 0, width, height);
                  this.ctx.restore();
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  if (transform) {
                    this.ctx.transform(...transform);
                    this.outputScaleX = transform[0];
                    this.outputScaleY = transform[0];
                  }
                  this.ctx.transform(...viewport.transform);
                  this.viewportScale = viewport.scale;
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (this.imageLayer) {
                    (0, _display_utils2.deprecated)("The `imageLayer` functionality will be removed in the future.");
                    this.imageLayer.beginLayout();
                  }
                }
                executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                }
                endDrawing() {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  this.cachedCanvases.clear();
                  this.cachedPatterns.clear();
                  for (const cache of this._cachedBitmapsMap.values()) {
                    for (const canvas of cache.values()) {
                      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                        canvas.width = canvas.height = 0;
                      }
                    }
                    cache.clear();
                  }
                  this._cachedBitmapsMap.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                }
                _scaleImage(img, inverseTransform) {
                  const width = img.width;
                  const height = img.height;
                  let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                  let paintWidth = width, paintHeight = height;
                  let tmpCanvasId = "prescale1";
                  let tmpCanvas, tmpCtx;
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    img = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  return {
                    img,
                    paintWidth,
                    paintHeight
                  };
                }
                _createMaskCanvas(img) {
                  const ctx = this.ctx;
                  const {
                    width,
                    height
                  } = img;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  let cache, cacheKey, scaled, maskCanvas;
                  if ((img.bitmap || img.data) && img.count > 1) {
                    const mainKey = img.bitmap || img.data.buffer;
                    const withoutTranslation = currentTransform.slice(0, 4);
                    cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
                    cache = this._cachedBitmapsMap.get(mainKey);
                    if (!cache) {
                      cache = /* @__PURE__ */ new Map();
                      this._cachedBitmapsMap.set(mainKey, cache);
                    }
                    const cachedImage = cache.get(cacheKey);
                    if (cachedImage && !isPatternFill) {
                      const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                      const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                      return {
                        canvas: cachedImage,
                        offsetX: offsetX2,
                        offsetY: offsetY2
                      };
                    }
                    scaled = cachedImage;
                  }
                  if (!scaled) {
                    maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    putBinaryImageMask(maskCanvas.context, img);
                  }
                  let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
                  maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                  const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                  const cord2 = _util2.Util.applyTransform([width, height], maskToCanvas);
                  const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                  const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                  const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                  const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                  const fillCtx = fillCanvas.context;
                  const offsetX = Math.min(cord1[0], cord2[0]);
                  const offsetY = Math.min(cord1[1], cord2[1]);
                  fillCtx.translate(-offsetX, -offsetY);
                  fillCtx.transform(...maskToCanvas);
                  if (!scaled) {
                    scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                    scaled = scaled.img;
                    if (cache && isPatternFill) {
                      cache.set(cacheKey, scaled);
                    }
                  }
                  fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                  drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
                  fillCtx.globalCompositeOperation = "source-in";
                  const inverse3 = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                  fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse3, _pattern_helper.PathType.FILL) : fillColor;
                  fillCtx.fillRect(0, 0, width, height);
                  if (cache && !isPatternFill) {
                    this.cachedCanvases.delete("fillCanvas");
                    cache.set(cacheKey, fillCanvas.canvas);
                  }
                  return {
                    canvas: fillCanvas.canvas,
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY)
                  };
                }
                setLineWidth(width) {
                  if (width !== this.current.lineWidth) {
                    this._cachedScaleForStroking = null;
                  }
                  this.current.lineWidth = width;
                  this.ctx.lineWidth = width;
                }
                setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                }
                setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (let i = 0, ii = states.length; i < ii; i++) {
                    const state = states[i];
                    const key = state[0];
                    const value = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;
                      case "LC":
                        this.setLineCap(value);
                        break;
                      case "LJ":
                        this.setLineJoin(value);
                        break;
                      case "ML":
                        this.setMiterLimit(value);
                        break;
                      case "D":
                        this.setDash(value[0], value[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value);
                        break;
                      case "FL":
                        this.setFlatness(value);
                        break;
                      case "Font":
                        this.setFont(value[0], value[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value;
                        break;
                      case "SMask":
                        this.current.activeSMask = value ? this.tempSMask : null;
                        this.tempSMask = null;
                        this.checkSMaskState();
                        break;
                      case "TR":
                        this.current.transferMaps = value;
                    }
                  }
                }
                get inSMaskMode() {
                  return !!this.suspendedCtx;
                }
                checkSMaskState() {
                  const inSMaskMode = this.inSMaskMode;
                  if (this.current.activeSMask && !inSMaskMode) {
                    this.beginSMaskMode();
                  } else if (!this.current.activeSMask && inSMaskMode) {
                    this.endSMaskMode();
                  }
                }
                beginSMaskMode() {
                  if (this.inSMaskMode) {
                    throw new Error("beginSMaskMode called while already in smask mode");
                  }
                  const drawnWidth = this.ctx.canvas.width;
                  const drawnHeight = this.ctx.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  this.suspendedCtx = this.ctx;
                  this.ctx = scratchCanvas.context;
                  const ctx = this.ctx;
                  ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                  copyCtxState(this.suspendedCtx, ctx);
                  mirrorContextOperations(ctx, this.suspendedCtx);
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                }
                endSMaskMode() {
                  if (!this.inSMaskMode) {
                    throw new Error("endSMaskMode called while not in smask mode");
                  }
                  this.ctx._removeMirroring();
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.ctx = this.suspendedCtx;
                  this.suspendedCtx = null;
                }
                compose(dirtyBox) {
                  if (!this.current.activeSMask) {
                    return;
                  }
                  if (!dirtyBox) {
                    dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                  } else {
                    dirtyBox[0] = Math.floor(dirtyBox[0]);
                    dirtyBox[1] = Math.floor(dirtyBox[1]);
                    dirtyBox[2] = Math.ceil(dirtyBox[2]);
                    dirtyBox[3] = Math.ceil(dirtyBox[3]);
                  }
                  const smask = this.current.activeSMask;
                  const suspendedCtx = this.suspendedCtx;
                  composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                  this.ctx.restore();
                }
                save() {
                  if (this.inSMaskMode) {
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.suspendedCtx.save();
                  } else {
                    this.ctx.save();
                  }
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  if (this.stateStack.length === 0 && this.inSMaskMode) {
                    this.endSMaskMode();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    if (this.inSMaskMode) {
                      this.suspendedCtx.restore();
                      copyCtxState(this.suspendedCtx, this.ctx);
                    } else {
                      this.ctx.restore();
                    }
                    this.checkSMaskState();
                    this.pendingClip = null;
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }
                transform(a, b, c, d, e2, f) {
                  this.ctx.transform(a, b, c, d, e2, f);
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                }
                constructPath(ops, args, minMax) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let startX, startY;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                  const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                  for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width = args[j++];
                        const height = args[j++];
                        const xw = x + width;
                        const yh = y + height;
                        ctx.moveTo(x, y);
                        if (width === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        if (!isScalingMatrix) {
                          current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.curveTo:
                        startX = x;
                        startY = y;
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        startX = x;
                        startY = y;
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        startX = x;
                        startY = y;
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  if (isScalingMatrix) {
                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                  }
                  current.setCurrentPoint(x, y);
                }
                closePath() {
                  this.ctx.closePath();
                }
                stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && strokeColor?.getPattern) {
                      ctx.save();
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                      this.rescaleAndStroke(false);
                      ctx.restore();
                    } else {
                      this.rescaleAndStroke(true);
                    }
                  }
                  if (consumePath) {
                    this.consumePath(this.current.getClippedPathBoundingBox());
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    needRestore = true;
                  }
                  const intersect = this.current.getClippedPathBoundingBox();
                  if (this.contentVisible && intersect !== null) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath(intersect);
                  }
                }
                eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                }
                fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                }
                eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                }
                endPath() {
                  this.consumePath();
                }
                clip() {
                  this.pendingClip = NORMAL_CLIP;
                }
                eoClip() {
                  this.pendingClip = EO_CLIP;
                }
                beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (const path of paths) {
                    ctx.setTransform(...path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                }
                setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                }
                setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                }
                setHScale(scale3) {
                  this.current.textHScale = scale3 / 100;
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setFont(fontRefName, size2) {
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size2 < 0) {
                    size2 = -size2;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size2;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  const typeface = `"${name}", ${fontObj.fallbackName}`;
                  let browserFontSize = size2;
                  if (size2 < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size2 > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size2 / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                }
                setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                }
                setTextRise(rise) {
                  this.current.textRise = rise;
                }
                moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                setTextMatrix(a, b, c, d, e2, f) {
                  this.current.textMatrix = [a, b, c, d, e2, f];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                paintChar(character, x, y, patternTransform) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font.missingFile;
                  let addToPath;
                  if (font.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font.getPathGenerator(this.commonObjs, character);
                  }
                  if (font.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform(...patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: (0, _display_utils2.getCurrentTransform)(ctx),
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                }
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                }
                showText(glyphs) {
                  const current = this.current;
                  const font = current.font;
                  if (font.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  let lineWidth = current.lineWidth;
                  const scale3 = current.textMatrixScale;
                  if (scale3 === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      lineWidth = this.getSinglePixelWidth();
                    }
                  } else {
                    lineWidth /= scale3;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  let x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    const glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font.remeasure && width > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width !== measuredWidth) {
                        scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font = current.font;
                  const fontSize = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i, glyph, width, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform(...fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width = transformed[0] * fontSize + spacing;
                    ctx.translate(width, 0);
                    current.x += width * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                }
                setCharWidth(xWidth, yWidth) {
                }
                setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.ctx.clip();
                  this.endPath();
                }
                getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color = IR[1];
                    const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = this._getPattern(IR[1], IR[2]);
                  }
                  return pattern;
                }
                setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                }
                setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                }
                setStrokeRGBColor(r, g, b) {
                  const color = this.selectColor?.(r, g, b) || _util2.Util.makeHexColor(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                }
                setFillRGBColor(r, g, b) {
                  const color = this.selectColor?.(r, g, b) || _util2.Util.makeHexColor(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                }
                _getPattern(objId, matrix = null) {
                  let pattern;
                  if (this.cachedPatterns.has(objId)) {
                    pattern = this.cachedPatterns.get(objId);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
                    this.cachedPatterns.set(objId, pattern);
                  }
                  if (matrix) {
                    pattern.matrix = matrix;
                  }
                  return pattern;
                }
                shadingFill(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = this._getPattern(objId);
                  ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                  const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                  if (inv) {
                    const canvas = ctx.canvas;
                    const width = canvas.width;
                    const height = canvas.height;
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width, 0], inv);
                    const ur = _util2.Util.applyTransform([width, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.compose(this.current.getClippedPathBoundingBox());
                  this.restore();
                }
                beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                }
                beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(...matrix);
                  }
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (bbox) {
                    const width = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width, height);
                    this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                    this.clip();
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                }
                beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  if (this.inSMaskMode) {
                    this.endSMaskMode();
                    this.current.activeSMask = null;
                  }
                  const currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                  if (group.matrix) {
                    currentCtx.transform(...group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform(...currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                    currentCtx.save();
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                }
                endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  const ctx = this.groupStack.pop();
                  this.ctx = ctx;
                  this.ctx.imageSmoothingEnabled = false;
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                    this.restore();
                  } else {
                    this.ctx.restore();
                    const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    this.restore();
                    this.ctx.save();
                    this.ctx.setTransform(...currentMtx);
                    const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    this.ctx.restore();
                    this.compose(dirtyBox);
                  }
                }
                beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  this.ctx.save();
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform(...this.baseTransform);
                  }
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width = rect[2] - rect[0];
                    const height = rect[3] - rect[1];
                    if (hasOwnCanvas && this.annotationCanvasMap) {
                      transform = transform.slice();
                      transform[4] -= rect[0];
                      transform[5] -= rect[1];
                      rect = rect.slice();
                      rect[0] = rect[1] = 0;
                      rect[2] = width;
                      rect[3] = height;
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                      const {
                        viewportScale
                      } = this;
                      const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                      const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                      this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                      const {
                        canvas,
                        context
                      } = this.annotationCanvas;
                      this.annotationCanvasMap.set(id, canvas);
                      this.annotationCanvas.savedCtx = this.ctx;
                      this.ctx = context;
                      this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                    } else {
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                      this.ctx.rect(rect[0], rect[1], width, height);
                      this.ctx.clip();
                      this.endPath();
                    }
                  }
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.transform(...transform);
                  this.transform(...matrix);
                }
                endAnnotation() {
                  if (this.annotationCanvas) {
                    this.ctx = this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas;
                  }
                }
                paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const count = img.count;
                  img = this.getObject(img.data, img);
                  img.count = count;
                  const ctx = this.ctx;
                  const glyph = this.processingType3;
                  if (glyph) {
                    if (glyph.compiled === void 0) {
                      glyph.compiled = compileType3Glyph(img);
                    }
                    if (glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                  }
                  const mask = this._createMaskCanvas(img);
                  const maskCanvas = mask.canvas;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  img = this.getObject(img.data, img);
                  const ctx = this.ctx;
                  ctx.save();
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                  const mask = this._createMaskCanvas(img);
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    const trans2 = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                    const [x, y] = _util2.Util.applyTransform([0, 0], trans2);
                    ctx.drawImage(mask.canvas, x, y);
                  }
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (const image2 of images) {
                    const {
                      data,
                      width,
                      height,
                      transform
                    } = image2;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    const img = this.getObject(data, image2);
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                    maskCtx.fillRect(0, 0, width, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform(...transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const map = [];
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                }
                paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width = imgData.width;
                  const height = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width, -1 / height);
                  let imgToPaint;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                  ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                  const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
                  if (this.imageLayer) {
                    const [left, top] = _util2.Util.applyTransform([0, -height], (0, _display_utils2.getCurrentTransform)(this.ctx));
                    this.imageLayer.appendImage({
                      imgData,
                      left,
                      top,
                      width: rWidth,
                      height: rHeight
                    });
                  }
                  this.compose();
                  this.restore();
                }
                paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const w = imgData.width;
                  const h = imgData.height;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                  for (const entry of map) {
                    ctx.save();
                    ctx.transform(...entry.transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      const [left, top] = _util2.Util.applyTransform([entry.x, entry.y], (0, _display_utils2.getCurrentTransform)(this.ctx));
                      this.imageLayer.appendImage({
                        imgData,
                        left,
                        top,
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                  this.compose();
                }
                paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                  this.compose();
                }
                markPoint(tag2) {
                }
                markPointProps(tag2, properties) {
                }
                beginMarkedContent(tag2) {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                beginMarkedContentProps(tag2, properties) {
                  if (tag2 === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                }
                endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                }
                beginCompat() {
                }
                endCompat() {
                }
                consumePath(clipBox) {
                  const isEmpty = this.current.isEmptyClip();
                  if (this.pendingClip) {
                    this.current.updateClipFromPath();
                  }
                  if (!this.pendingClip) {
                    this.compose(clipBox);
                  }
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (!isEmpty) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                    }
                    this.pendingClip = null;
                  }
                  this.current.startNewPathAndClipBox(this.current.clipBox);
                  ctx.beginPath();
                }
                getSinglePixelWidth() {
                  if (!this._cachedGetSinglePixelWidth) {
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    if (m[1] === 0 && m[2] === 0) {
                      this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[2]);
                      const normY = Math.hypot(m[1], m[3]);
                      this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                }
                getScaleForStroking() {
                  if (!this._cachedScaleForStroking) {
                    const {
                      lineWidth
                    } = this.current;
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    let scaleX, scaleY;
                    if (m[1] === 0 && m[2] === 0) {
                      const normX = Math.abs(m[0]);
                      const normY = Math.abs(m[3]);
                      if (lineWidth === 0) {
                        scaleX = 1 / normX;
                        scaleY = 1 / normY;
                      } else {
                        const scaledXLineWidth = normX * lineWidth;
                        const scaledYLineWidth = normY * lineWidth;
                        scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                        scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                      }
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[1]);
                      const normY = Math.hypot(m[2], m[3]);
                      if (lineWidth === 0) {
                        scaleX = normY / absDet;
                        scaleY = normX / absDet;
                      } else {
                        const baseArea = lineWidth * absDet;
                        scaleX = normY > baseArea ? normY / baseArea : 1;
                        scaleY = normX > baseArea ? normX / baseArea : 1;
                      }
                    }
                    this._cachedScaleForStroking = [scaleX, scaleY];
                  }
                  return this._cachedScaleForStroking;
                }
                rescaleAndStroke(saveRestore) {
                  const {
                    ctx
                  } = this;
                  const {
                    lineWidth
                  } = this.current;
                  const [scaleX, scaleY] = this.getScaleForStroking();
                  ctx.lineWidth = lineWidth || 1;
                  if (scaleX === 1 && scaleY === 1) {
                    ctx.stroke();
                    return;
                  }
                  let savedMatrix, savedDashes, savedDashOffset;
                  if (saveRestore) {
                    savedMatrix = (0, _display_utils2.getCurrentTransform)(ctx);
                    savedDashes = ctx.getLineDash().slice();
                    savedDashOffset = ctx.lineDashOffset;
                  }
                  ctx.scale(scaleX, scaleY);
                  const scale3 = Math.max(scaleX, scaleY);
                  ctx.setLineDash(ctx.getLineDash().map((x) => x / scale3));
                  ctx.lineDashOffset /= scale3;
                  ctx.stroke();
                  if (saveRestore) {
                    ctx.setTransform(...savedMatrix);
                    ctx.setLineDash(savedDashes);
                    ctx.lineDashOffset = savedDashOffset;
                  }
                }
                isContentVisible() {
                  for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              let CanvasGraphics = _CanvasGraphics;
              _restoreInitialState = new WeakSet();
              restoreInitialState_fn = function() {
                while (this.stateStack.length || this.inSMaskMode) {
                  this.restore();
                }
                this.ctx.restore();
                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }
              };
              exports2.CanvasGraphics = CanvasGraphics;
              for (const op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _is_node2 = __w_pdfjs_require__2(3);
              const PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox || _is_node2.isNodeJS) {
                  return;
                }
                const width = bbox[2] - bbox[0];
                const height = bbox[3] - bbox[1];
                const region = new Path2D();
                region.rect(bbox[0], bbox[1], width, height);
                ctx.clip(region);
              }
              class BaseShadingPattern {
                constructor() {
                  if (this.constructor === BaseShadingPattern) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                getPattern() {
                  (0, _util2.unreachable)("Abstract method `getPattern` called.");
                }
              }
              class RadialAxialShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._type = IR[1];
                  this._bbox = IR[2];
                  this._colorStops = IR[3];
                  this._p0 = IR[4];
                  this._p1 = IR[5];
                  this._r0 = IR[6];
                  this._r1 = IR[7];
                  this.matrix = null;
                }
                _createGradient(ctx) {
                  let grad;
                  if (this._type === "axial") {
                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                  } else if (this._type === "radial") {
                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                  }
                  for (const colorStop of this._colorStops) {
                    grad.addColorStop(colorStop[0], colorStop[1]);
                  }
                  return grad;
                }
                getPattern(ctx, owner, inverse3, pathType) {
                  let pattern;
                  if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                    const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                    const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
                    const tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.beginPath();
                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                    inverse3 = _util2.Util.transform(inverse3, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                    tmpCtx.transform(...owner.baseTransform);
                    if (this.matrix) {
                      tmpCtx.transform(...this.matrix);
                    }
                    applyBoundingBox(tmpCtx, this._bbox);
                    tmpCtx.fillStyle = this._createGradient(tmpCtx);
                    tmpCtx.fill();
                    pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                    const domMatrix = new DOMMatrix(inverse3);
                    try {
                      pattern.setTransform(domMatrix);
                    } catch (ex) {
                      (0, _util2.warn)(`RadialAxialShadingPattern.getPattern: "${ex?.message}".`);
                    }
                  } else {
                    applyBoundingBox(ctx, this._bbox);
                    pattern = this._createGradient(ctx);
                  }
                  return pattern;
                }
              }
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                const coords = context.coords, colors = context.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                const x2 = (coords[p2] + context.offsetX) * context.scaleX;
                const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  const x1_ = Math.round(Math.min(xa, xb));
                  const x2_ = Math.round(Math.max(xa, xb));
                  let j = rowSize * y + x1_ * 4;
                  for (let x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                const ps = figure.coords;
                const cs = figure.colors;
                let i, ii;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      let q = i * verticesPerRow;
                      for (let j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              class MeshShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._coords = IR[2];
                  this._colors = IR[3];
                  this._figures = IR[4];
                  this._bounds = IR[5];
                  this._bbox = IR[7];
                  this._background = IR[8];
                  this.matrix = null;
                }
                _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                  const EXPECTED_SCALE = 1.1;
                  const MAX_PATTERN_SIZE = 3e3;
                  const BORDER_SIZE = 2;
                  const offsetX = Math.floor(this._bounds[0]);
                  const offsetY = Math.floor(this._bounds[1]);
                  const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                  const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                  const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const scaleX = boundsWidth / width;
                  const scaleY = boundsHeight / height;
                  const context = {
                    coords: this._coords,
                    colors: this._colors,
                    offsetX: -offsetX,
                    offsetY: -offsetY,
                    scaleX: 1 / scaleX,
                    scaleY: 1 / scaleY
                  };
                  const paddedWidth = width + BORDER_SIZE * 2;
                  const paddedHeight = height + BORDER_SIZE * 2;
                  const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width, height);
                  if (backgroundColor) {
                    const bytes = data.data;
                    for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (const figure of this._figures) {
                    drawFigure(data, figure, context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  const canvas = tmpCanvas.canvas;
                  return {
                    canvas,
                    offsetX: offsetX - BORDER_SIZE * scaleX,
                    offsetY: offsetY - BORDER_SIZE * scaleY,
                    scaleX,
                    scaleY
                  };
                }
                getPattern(ctx, owner, inverse3, pathType) {
                  applyBoundingBox(ctx, this._bbox);
                  let scale3;
                  if (pathType === PathType.SHADING) {
                    scale3 = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                  } else {
                    scale3 = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                    if (this.matrix) {
                      const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                      scale3 = [scale3[0] * matrixScale[0], scale3[1] * matrixScale[1]];
                    }
                  }
                  const temporaryPatternCanvas = this._createMeshCanvas(scale3, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                  if (pathType !== PathType.SHADING) {
                    ctx.setTransform(...owner.baseTransform);
                    if (this.matrix) {
                      ctx.transform(...this.matrix);
                    }
                  }
                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              }
              class DummyShadingPattern extends BaseShadingPattern {
                getPattern() {
                  return "hotpink";
                }
              }
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error(`Unknown IR type: ${IR[0]}`);
              }
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              class TilingPattern {
                static get MAX_PATTERN_SIZE() {
                  return (0, _util2.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
                }
                constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  let adjustedX0 = x0;
                  let adjustedY0 = y0;
                  let adjustedX1 = x1;
                  let adjustedY1 = y1;
                  if (x0 < 0) {
                    adjustedX0 = 0;
                    adjustedX1 += Math.abs(x0);
                  }
                  if (y0 < 0) {
                    adjustedY0 = 0;
                    adjustedY1 += Math.abs(y0);
                  }
                  tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  tmpCtx.save();
                  this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                  graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                  graphics.executeOperatorList(operatorList);
                  graphics.endDrawing();
                  return {
                    canvas: tmpCanvas.canvas,
                    scaleX: dimx.scale,
                    scaleY: dimy.scale,
                    offsetX: adjustedX0,
                    offsetY: adjustedY0
                  };
                }
                getSizeAndScale(step, realOutputSize, scale3) {
                  step = Math.abs(step);
                  const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                  let size2 = Math.ceil(step * scale3);
                  if (size2 >= maxSize) {
                    size2 = maxSize;
                  } else {
                    scale3 = size2 / step;
                  }
                  return {
                    scale: scale3,
                    size: size2
                  };
                }
                clipBbox(graphics, x0, y0, x1, y1) {
                  const bboxWidth = x1 - x0;
                  const bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                  graphics.clip();
                  graphics.endPath();
                }
                setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                }
                getPattern(ctx, owner, inverse3, pathType) {
                  let matrix = inverse3;
                  if (pathType !== PathType.SHADING) {
                    matrix = _util2.Util.transform(matrix, owner.baseTransform);
                    if (this.matrix) {
                      matrix = _util2.Util.transform(matrix, this.matrix);
                    }
                  }
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  let domMatrix = new DOMMatrix(matrix);
                  domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                  const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                  try {
                    pattern.setTransform(domMatrix);
                  } catch (ex) {
                    (0, _util2.warn)(`TilingPattern.getPattern: "${ex?.message}".`);
                  }
                  return pattern;
                }
              }
              exports2.TilingPattern = TilingPattern;
            },
            /* 14 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.applyMaskImageData = applyMaskImageData;
              var _util2 = __w_pdfjs_require__2(1);
              function applyMaskImageData({
                src: src2,
                srcPos = 0,
                dest,
                destPos = 0,
                width,
                height,
                inverseDecode = false
              }) {
                const opaque = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
                const widthInSource = width >> 3;
                const widthRemainder = width & 7;
                const srcLength = src2.length;
                dest = new Uint32Array(dest.buffer);
                for (let i = 0; i < height; i++) {
                  for (const max3 = srcPos + widthInSource; srcPos < max3; srcPos++) {
                    const elem2 = srcPos < srcLength ? src2[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src2[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
            },
            /* 15 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions;
              GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
              GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
            },
            /* 16 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      this._processStreamMessage(data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      this._createStreamSink(data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = (0, _util2.createPromiseCapability)();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                _createStreamSink(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const self = this, action = this.actionHandler[data.action];
                  const streamSink = {
                    enqueue(chunk, size2 = 1, transfers) {
                      if (this.isCancelled) {
                        return;
                      }
                      const lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size2;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ENQUEUE,
                        streamId,
                        chunk
                      }, transfers);
                    },
                    close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CLOSE,
                        streamId
                      });
                      delete self.streamSinks[streamId];
                    },
                    error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ERROR,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    },
                    sinkCapability: (0, _util2.createPromiseCapability)(),
                    onPull: null,
                    onCancel: null,
                    isCancelled: false,
                    desiredSize: data.desiredSize,
                    ready: null
                  };
                  streamSink.sinkCapability.resolve();
                  streamSink.ready = streamSink.sinkCapability.promise;
                  this.streamSinks[streamId] = streamSink;
                  new Promise(function(resolve) {
                    resolve(action(data.data, streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                }
                _processStreamMessage(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                  switch (data.stream) {
                    case StreamKind.START_COMPLETE:
                      if (data.success) {
                        streamController.startCall.resolve();
                      } else {
                        streamController.startCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL_COMPLETE:
                      if (data.success) {
                        streamController.pullCall.resolve();
                      } else {
                        streamController.pullCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL:
                      if (!streamSink) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                        break;
                      }
                      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                        streamSink.sinkCapability.resolve();
                      }
                      streamSink.desiredSize = data.desiredSize;
                      new Promise(function(resolve) {
                        resolve(streamSink.onPull && streamSink.onPull());
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      break;
                    case StreamKind.ENQUEUE:
                      (0, _util2.assert)(streamController, "enqueue should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.controller.enqueue(data.chunk);
                      break;
                    case StreamKind.CLOSE:
                      (0, _util2.assert)(streamController, "close should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.isClosed = true;
                      streamController.controller.close();
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.ERROR:
                      (0, _util2.assert)(streamController, "error should have stream controller");
                      streamController.controller.error(wrapReason(data.reason));
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL_COMPLETE:
                      if (data.success) {
                        streamController.cancelCall.resolve();
                      } else {
                        streamController.cancelCall.reject(wrapReason(data.reason));
                      }
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL:
                      if (!streamSink) {
                        break;
                      }
                      new Promise(function(resolve) {
                        resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      streamSink.sinkCapability.reject(wrapReason(data.reason));
                      streamSink.isCancelled = true;
                      delete this.streamSinks[streamId];
                      break;
                    default:
                      throw new Error("Unexpected stream case");
                  }
                }
                async _deleteStreamController(streamController, streamId) {
                  await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                  delete this.streamControllers[streamId];
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              exports2.MessageHandler = MessageHandler;
            },
            /* 17 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _metadataMap, _data;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class Metadata {
                constructor({
                  parsedData,
                  rawData
                }) {
                  __privateAdd(this, _metadataMap, void 0);
                  __privateAdd(this, _data, void 0);
                  __privateSet(this, _metadataMap, parsedData);
                  __privateSet(this, _data, rawData);
                }
                getRaw() {
                  return __privateGet(this, _data);
                }
                get(name) {
                  return __privateGet(this, _metadataMap).get(name) ?? null;
                }
                getAll() {
                  return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
                }
                has(name) {
                  return __privateGet(this, _metadataMap).has(name);
                }
              }
              _metadataMap = new WeakMap();
              _data = new WeakMap();
              exports2.Metadata = Metadata;
            },
            /* 18 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _visible, _cachedHasInitialVisibility, _groups, _initialVisibility, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const INTERNAL = Symbol("INTERNAL");
              class OptionalContentGroup {
                constructor(name, intent) {
                  __privateAdd(this, _visible, true);
                  this.name = name;
                  this.intent = intent;
                }
                get visible() {
                  return __privateGet(this, _visible);
                }
                _setVisible(internal, visible) {
                  if (internal !== INTERNAL) {
                    (0, _util2.unreachable)("Internal method `_setVisible` called.");
                  }
                  __privateSet(this, _visible, visible);
                }
              }
              _visible = new WeakMap();
              class OptionalContentConfig {
                constructor(data) {
                  __privateAdd(this, _evaluateVisibilityExpression);
                  __privateAdd(this, _cachedHasInitialVisibility, true);
                  __privateAdd(this, _groups, /* @__PURE__ */ new Map());
                  __privateAdd(this, _initialVisibility, null);
                  __privateAdd(this, _order, null);
                  this.name = null;
                  this.creator = null;
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  __privateSet(this, _order, data.order);
                  for (const group of data.groups) {
                    __privateGet(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
                  }
                  if (data.baseState === "OFF") {
                    for (const group of __privateGet(this, _groups).values()) {
                      group._setVisible(INTERNAL, false);
                    }
                  }
                  for (const on of data.on) {
                    __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
                  }
                  for (const off of data.off) {
                    __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
                  }
                  __privateSet(this, _initialVisibility, /* @__PURE__ */ new Map());
                  for (const [id, group] of __privateGet(this, _groups)) {
                    __privateGet(this, _initialVisibility).set(id, group.visible);
                  }
                }
                isVisible(group) {
                  if (__privateGet(this, _groups).size === 0) {
                    return true;
                  }
                  if (!group) {
                    (0, _util2.warn)("Optional content group not defined.");
                    return true;
                  }
                  if (group.type === "OCG") {
                    if (!__privateGet(this, _groups).has(group.id)) {
                      (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                      return true;
                    }
                    return __privateGet(this, _groups).get(group.id).visible;
                  } else if (group.type === "OCMD") {
                    if (group.expression) {
                      return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
                    }
                    if (!group.policy || group.policy === "AnyOn") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOn") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    } else if (group.policy === "AnyOff") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOff") {
                      for (const id of group.ids) {
                        if (!__privateGet(this, _groups).has(id)) {
                          (0, _util2.warn)(`Optional content group not found: ${id}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id).visible) {
                          return false;
                        }
                      }
                      return true;
                    }
                    (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                    return true;
                  }
                  (0, _util2.warn)(`Unknown group type ${group.type}.`);
                  return true;
                }
                setVisibility(id, visible = true) {
                  if (!__privateGet(this, _groups).has(id)) {
                    (0, _util2.warn)(`Optional content group not found: ${id}`);
                    return;
                  }
                  __privateGet(this, _groups).get(id)._setVisible(INTERNAL, !!visible);
                  __privateSet(this, _cachedHasInitialVisibility, null);
                }
                get hasInitialVisibility() {
                  if (__privateGet(this, _cachedHasInitialVisibility) !== null) {
                    return __privateGet(this, _cachedHasInitialVisibility);
                  }
                  for (const [id, group] of __privateGet(this, _groups)) {
                    const visible = __privateGet(this, _initialVisibility).get(id);
                    if (group.visible !== visible) {
                      return __privateSet(this, _cachedHasInitialVisibility, false);
                    }
                  }
                  return __privateSet(this, _cachedHasInitialVisibility, true);
                }
                getOrder() {
                  if (!__privateGet(this, _groups).size) {
                    return null;
                  }
                  if (__privateGet(this, _order)) {
                    return __privateGet(this, _order).slice();
                  }
                  return [...__privateGet(this, _groups).keys()];
                }
                getGroups() {
                  return __privateGet(this, _groups).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _groups)) : null;
                }
                getGroup(id) {
                  return __privateGet(this, _groups).get(id) || null;
                }
              }
              _cachedHasInitialVisibility = new WeakMap();
              _groups = new WeakMap();
              _initialVisibility = new WeakMap();
              _order = new WeakMap();
              _evaluateVisibilityExpression = new WeakSet();
              evaluateVisibilityExpression_fn = function(array) {
                const length3 = array.length;
                if (length3 < 2) {
                  return true;
                }
                const operator = array[0];
                for (let i = 1; i < length3; i++) {
                  const element = array[i];
                  let state;
                  if (Array.isArray(element)) {
                    state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
                  } else if (__privateGet(this, _groups).has(element)) {
                    state = __privateGet(this, _groups).get(element).visible;
                  } else {
                    (0, _util2.warn)(`Optional content group not found: ${element}`);
                    return true;
                  }
                  switch (operator) {
                    case "And":
                      if (!state) {
                        return false;
                      }
                      break;
                    case "Or":
                      if (state) {
                        return true;
                      }
                      break;
                    case "Not":
                      return !state;
                    default:
                      return true;
                  }
                }
                return operator === "And";
              };
              exports2.OptionalContentConfig = OptionalContentConfig;
            },
            /* 19 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              class PDFDataTransportStream {
                constructor(params, pdfDataRangeTransport) {
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = params.progressiveDone || false;
                  this._contentDispositionFilename = params.contentDispositionFilename || null;
                  const initialData = params.initialData;
                  if (initialData?.length > 0) {
                    const buffer = new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !params.disableStream;
                  this._isRangeSupported = !params.disableRange;
                  this._contentLength = params.length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                    this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                    this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                    this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                    this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _onReceiveData(args) {
                  const buffer = new Uint8Array(args.chunk).buffer;
                  if (args.begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    const found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== args.begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                _onProgress(evt) {
                  if (evt.total === void 0) {
                    const firstReader = this._rangeReaders[0];
                    if (firstReader?.onProgress) {
                      firstReader.onProgress({
                        loaded: evt.loaded
                      });
                    }
                  } else {
                    const fullReader = this._fullRequestReader;
                    if (fullReader?.onProgress) {
                      fullReader.onProgress({
                        loaded: evt.loaded,
                        total: evt.total
                      });
                    }
                  }
                }
                _onProgressiveDone() {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.progressiveDone();
                  }
                  this._progressiveDone = true;
                }
                _removeRangeReader(reader) {
                  const i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  const queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
                getRangeReader(begin, end2) {
                  if (end2 <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFDataTransportStreamRangeReader(this, begin, end2);
                  this._pdfDataRangeTransport.requestDataRange(begin, end2);
                  this._rangeReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                  this._pdfDataRangeTransport.abort();
                }
              }
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              class PDFDataTransportStreamReader {
                constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  for (const chunk of this._queuedChunks) {
                    this._loaded += chunk.byteLength;
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
                get headersReady() {
                  return this._headersReady;
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                }
                get contentLength() {
                  return this._stream._contentLength;
                }
                async read() {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }
              class PDFDataTransportStreamRangeReader {
                constructor(stream, begin, end2) {
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end2;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    const requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._stream._removeRangeReader(this);
                }
              }
            },
            /* 20 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              class XfaText {
                static textContent(xfa) {
                  const items = [];
                  const output = {
                    items,
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  function walk(node) {
                    if (!node) {
                      return;
                    }
                    let str3 = null;
                    const name = node.name;
                    if (name === "#text") {
                      str3 = node.value;
                    } else if (!XfaText.shouldBuildText(name)) {
                      return;
                    } else if (node?.attributes?.textContent) {
                      str3 = node.attributes.textContent;
                    } else if (node.value) {
                      str3 = node.value;
                    }
                    if (str3 !== null) {
                      items.push({
                        str: str3
                      });
                    }
                    if (!node.children) {
                      return;
                    }
                    for (const child of node.children) {
                      walk(child);
                    }
                  }
                  walk(xfa);
                  return output;
                }
                static shouldBuildText(name) {
                  return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                }
              }
              exports2.XfaText = XfaText;
            },
            /* 21 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(9);
              ;
              const fetchData = function(url2) {
                return new Promise((resolve, reject) => {
                  const fs = require_fs();
                  fs.readFile(url2, (error, data) => {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                _createCanvas(width, height) {
                  const Canvas2 = require_canvas();
                  return Canvas2.createCanvas(width, height);
                }
              }
              exports2.NodeCanvasFactory = NodeCanvasFactory;
              class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url2, compressionType) {
                  return fetchData(url2).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
              class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url2) {
                  return fetchData(url2);
                }
              }
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
            },
            /* 22 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _accessibilityManager, _allowClick, _boundPointerup, _boundPointerdown, _editors, _hadPointerDown, _isCleaningUp, _uiManager, _changeParent, changeParent_fn, _createNewEditor, createNewEditor_fn, _createAndAddNewEditor, createAndAddNewEditor_fn, _cleanup, cleanup_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayer = void 0;
              var _tools = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              var _freetext = __w_pdfjs_require__2(23);
              var _ink = __w_pdfjs_require__2(24);
              const _AnnotationEditorLayer = class {
                constructor(options) {
                  __privateAdd(this, _changeParent);
                  __privateAdd(this, _createNewEditor);
                  __privateAdd(this, _createAndAddNewEditor);
                  __privateAdd(this, _cleanup);
                  __privateAdd(this, _accessibilityManager, void 0);
                  __privateAdd(this, _allowClick, false);
                  __privateAdd(this, _boundPointerup, this.pointerup.bind(this));
                  __privateAdd(this, _boundPointerdown, this.pointerdown.bind(this));
                  __privateAdd(this, _editors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _hadPointerDown, false);
                  __privateAdd(this, _isCleaningUp, false);
                  __privateAdd(this, _uiManager, void 0);
                  if (!_AnnotationEditorLayer._initialized) {
                    _AnnotationEditorLayer._initialized = true;
                    _freetext.FreeTextEditor.initialize(options.l10n);
                    _ink.InkEditor.initialize(options.l10n);
                    options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
                  }
                  __privateSet(this, _uiManager, options.uiManager);
                  this.annotationStorage = options.annotationStorage;
                  this.pageIndex = options.pageIndex;
                  this.div = options.div;
                  __privateSet(this, _accessibilityManager, options.accessibilityManager);
                  __privateGet(this, _uiManager).addLayer(this);
                }
                updateToolbar(mode) {
                  __privateGet(this, _uiManager).updateToolbar(mode);
                }
                updateMode(mode = __privateGet(this, _uiManager).getMode()) {
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (mode === _util2.AnnotationEditorType.INK) {
                    this.addInkEditorIfNeeded(false);
                    this.disableClick();
                  } else {
                    this.enableClick();
                  }
                  __privateGet(this, _uiManager).unselectAll();
                }
                addInkEditorIfNeeded(isCommitting) {
                  if (!isCommitting && __privateGet(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                    return;
                  }
                  if (!isCommitting) {
                    for (const editor2 of __privateGet(this, _editors).values()) {
                      if (editor2.isEmpty()) {
                        editor2.setInBackground();
                        return;
                      }
                    }
                  }
                  const editor = __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, {
                    offsetX: 0,
                    offsetY: 0
                  });
                  editor.setInBackground();
                }
                setEditingState(isEditing) {
                  __privateGet(this, _uiManager).setEditingState(isEditing);
                }
                addCommands(params) {
                  __privateGet(this, _uiManager).addCommands(params);
                }
                enable() {
                  this.div.style.pointerEvents = "auto";
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.enableEditing();
                  }
                }
                disable() {
                  this.div.style.pointerEvents = "none";
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.disableEditing();
                  }
                }
                setActiveEditor(editor) {
                  const currentActive = __privateGet(this, _uiManager).getActive();
                  if (currentActive === editor) {
                    return;
                  }
                  __privateGet(this, _uiManager).setActiveEditor(editor);
                }
                enableClick() {
                  this.div.addEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.addEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                disableClick() {
                  this.div.removeEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.removeEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                attach(editor) {
                  __privateGet(this, _editors).set(editor.id, editor);
                }
                detach(editor) {
                  __privateGet(this, _editors).delete(editor.id);
                  __privateGet(this, _accessibilityManager)?.removePointerInTextLayer(editor.contentDiv);
                }
                remove(editor) {
                  __privateGet(this, _uiManager).removeEditor(editor);
                  this.detach(editor);
                  this.annotationStorage.remove(editor.id);
                  editor.div.style.display = "none";
                  setTimeout(() => {
                    editor.div.style.display = "";
                    editor.div.remove();
                    editor.isAttachedToDOM = false;
                    if (document.activeElement === document.body) {
                      __privateGet(this, _uiManager).focusMainContainer();
                    }
                  }, 0);
                  if (!__privateGet(this, _isCleaningUp)) {
                    this.addInkEditorIfNeeded(false);
                  }
                }
                add(editor) {
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor);
                  __privateGet(this, _uiManager).addEditor(editor);
                  this.attach(editor);
                  if (!editor.isAttachedToDOM) {
                    const div3 = editor.render();
                    this.div.append(div3);
                    editor.isAttachedToDOM = true;
                  }
                  this.moveEditorInDOM(editor);
                  editor.onceAdded();
                  this.addToAnnotationStorage(editor);
                }
                moveEditorInDOM(editor) {
                  __privateGet(this, _accessibilityManager)?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
                }
                addToAnnotationStorage(editor) {
                  if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {
                    this.annotationStorage.setValue(editor.id, editor);
                  }
                }
                addOrRebuild(editor) {
                  if (editor.needsToBeRebuilt()) {
                    editor.rebuild();
                  } else {
                    this.add(editor);
                  }
                }
                addANewEditor(editor) {
                  const cmd = () => {
                    this.addOrRebuild(editor);
                  };
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                addUndoableEditor(editor) {
                  const cmd = () => {
                    this.addOrRebuild(editor);
                  };
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: false
                  });
                }
                getNextId() {
                  return __privateGet(this, _uiManager).getId();
                }
                deserialize(data) {
                  switch (data.annotationType) {
                    case _util2.AnnotationEditorType.FREETEXT:
                      return _freetext.FreeTextEditor.deserialize(data, this);
                    case _util2.AnnotationEditorType.INK:
                      return _ink.InkEditor.deserialize(data, this);
                  }
                  return null;
                }
                setSelected(editor) {
                  __privateGet(this, _uiManager).setSelected(editor);
                }
                toggleSelected(editor) {
                  __privateGet(this, _uiManager).toggleSelected(editor);
                }
                isSelected(editor) {
                  return __privateGet(this, _uiManager).isSelected(editor);
                }
                unselect(editor) {
                  __privateGet(this, _uiManager).unselect(editor);
                }
                pointerup(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  if (!__privateGet(this, _hadPointerDown)) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, false);
                  if (!__privateGet(this, _allowClick)) {
                    __privateSet(this, _allowClick, true);
                    return;
                  }
                  __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, event);
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, true);
                  const editor = __privateGet(this, _uiManager).getActive();
                  __privateSet(this, _allowClick, !editor || editor.isEmpty());
                }
                drop(event) {
                  const id = event.dataTransfer.getData("text/plain");
                  const editor = __privateGet(this, _uiManager).getEditor(id);
                  if (!editor) {
                    return;
                  }
                  event.preventDefault();
                  event.dataTransfer.dropEffect = "move";
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor);
                  const rect = this.div.getBoundingClientRect();
                  const endX = event.clientX - rect.x;
                  const endY = event.clientY - rect.y;
                  editor.translate(endX - editor.startX, endY - editor.startY);
                  this.moveEditorInDOM(editor);
                  editor.div.focus();
                }
                dragover(event) {
                  event.preventDefault();
                }
                destroy() {
                  if (__privateGet(this, _uiManager).getActive()?.parent === this) {
                    __privateGet(this, _uiManager).setActiveEditor(null);
                  }
                  for (const editor of __privateGet(this, _editors).values()) {
                    __privateGet(this, _accessibilityManager)?.removePointerInTextLayer(editor.contentDiv);
                    editor.isAttachedToDOM = false;
                    editor.div.remove();
                    editor.parent = null;
                  }
                  this.div = null;
                  __privateGet(this, _editors).clear();
                  __privateGet(this, _uiManager).removeLayer(this);
                }
                render(parameters) {
                  this.viewport = parameters.viewport;
                  (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
                  this.setDimensions();
                  for (const editor of __privateGet(this, _uiManager).getEditors(this.pageIndex)) {
                    this.add(editor);
                  }
                  this.updateMode();
                }
                update(parameters) {
                  this.viewport = parameters.viewport;
                  this.setDimensions();
                  this.updateMode();
                }
                get scaleFactor() {
                  return this.viewport.scale;
                }
                get pageDimensions() {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const width = pageURx - pageLLx;
                  const height = pageURy - pageLLy;
                  return [width, height];
                }
                get viewportBaseDimensions() {
                  const {
                    width,
                    height,
                    rotation
                  } = this.viewport;
                  return rotation % 180 === 0 ? [width, height] : [height, width];
                }
                setDimensions() {
                  const {
                    width,
                    height,
                    rotation
                  } = this.viewport;
                  const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width) + "px", heightStr = Math.floor(height) + "px";
                  this.div.style.width = flipOrientation ? heightStr : widthStr;
                  this.div.style.height = flipOrientation ? widthStr : heightStr;
                  this.div.setAttribute("data-main-rotation", rotation);
                }
              };
              let AnnotationEditorLayer = _AnnotationEditorLayer;
              _accessibilityManager = new WeakMap();
              _allowClick = new WeakMap();
              _boundPointerup = new WeakMap();
              _boundPointerdown = new WeakMap();
              _editors = new WeakMap();
              _hadPointerDown = new WeakMap();
              _isCleaningUp = new WeakMap();
              _uiManager = new WeakMap();
              _changeParent = new WeakSet();
              changeParent_fn = function(editor) {
                if (editor.parent === this) {
                  return;
                }
                this.attach(editor);
                editor.pageIndex = this.pageIndex;
                editor.parent?.detach(editor);
                editor.parent = this;
                if (editor.div && editor.isAttachedToDOM) {
                  editor.div.remove();
                  this.div.append(editor.div);
                }
              };
              _createNewEditor = new WeakSet();
              createNewEditor_fn = function(params) {
                switch (__privateGet(this, _uiManager).getMode()) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return new _freetext.FreeTextEditor(params);
                  case _util2.AnnotationEditorType.INK:
                    return new _ink.InkEditor(params);
                }
                return null;
              };
              _createAndAddNewEditor = new WeakSet();
              createAndAddNewEditor_fn = function(event) {
                const id = this.getNextId();
                const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                  parent: this,
                  id,
                  x: event.offsetX,
                  y: event.offsetY
                });
                if (editor) {
                  this.add(editor);
                }
                return editor;
              };
              _cleanup = new WeakSet();
              cleanup_fn = function() {
                __privateSet(this, _isCleaningUp, true);
                for (const editor of __privateGet(this, _editors).values()) {
                  if (editor.isEmpty()) {
                    editor.remove();
                  }
                }
                __privateSet(this, _isCleaningUp, false);
              };
              __publicField(AnnotationEditorLayer, "_initialized", false);
              exports2.AnnotationEditorLayer = AnnotationEditorLayer;
            },
            /* 23 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundEditorDivBlur, _boundEditorDivFocus, _boundEditorDivKeydown, _color, _content, _hasAlreadyBeenCommitted, _fontSize, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FreeTextEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _tools = __w_pdfjs_require__2(7);
              var _editor = __w_pdfjs_require__2(6);
              const _FreeTextEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "freeTextEditor"
                  });
                  __privateAdd(this, _updateFontSize);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _extractText);
                  __privateAdd(this, _setEditorDimensions);
                  __privateAdd(this, _boundEditorDivBlur, this.editorDivBlur.bind(this));
                  __privateAdd(this, _boundEditorDivFocus, this.editorDivFocus.bind(this));
                  __privateAdd(this, _boundEditorDivKeydown, this.editorDivKeydown.bind(this));
                  __privateAdd(this, _color, void 0);
                  __privateAdd(this, _content, "");
                  __privateAdd(this, _hasAlreadyBeenCommitted, false);
                  __privateAdd(this, _fontSize, void 0);
                  __privateSet(this, _color, params.color || _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  __privateSet(this, _fontSize, params.fontSize || _FreeTextEditor._defaultFontSize);
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((str3) => [str3, l10n.get(str3)]));
                  const style = getComputedStyle(document.documentElement);
                  this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
                }
                static updateDefaultParams(type2, value) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      _FreeTextEditor._defaultFontSize = value;
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      _FreeTextEditor._defaultColor = value;
                      break;
                  }
                }
                updateParams(type2, value) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color)]];
                }
                getInitialTranslation() {
                  return [-_FreeTextEditor._internalPadding * this.parent.scaleFactor, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize)) * this.parent.scaleFactor];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                enableEditMode() {
                  if (this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(false);
                  this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                  super.enableEditMode();
                  this.enableEditing();
                  this.overlayDiv.classList.remove("enabled");
                  this.editorDiv.contentEditable = true;
                  this.div.draggable = false;
                  this.editorDiv.addEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.addEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.addEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                }
                disableEditMode() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(true);
                  super.disableEditMode();
                  this.disableEditing();
                  this.overlayDiv.classList.add("enabled");
                  this.editorDiv.contentEditable = false;
                  this.div.draggable = true;
                  this.editorDiv.removeEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.removeEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.removeEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.div.focus();
                  this.isEditing = false;
                }
                focusin(event) {
                  super.focusin(event);
                  if (event.target !== this.editorDiv) {
                    this.editorDiv.focus();
                  }
                }
                onceAdded() {
                  if (this.width) {
                    return;
                  }
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                isEmpty() {
                  return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                }
                remove() {
                  this.isEditing = false;
                  this.parent.setEditingState(true);
                  super.remove();
                }
                commit() {
                  super.commit();
                  if (!__privateGet(this, _hasAlreadyBeenCommitted)) {
                    __privateSet(this, _hasAlreadyBeenCommitted, true);
                    this.parent.addUndoableEditor(this);
                  }
                  this.disableEditMode();
                  __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                }
                shouldGetKeyboardEvents() {
                  return this.isInEditMode();
                }
                dblclick(event) {
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                keydown(event) {
                  if (event.target === this.div && event.key === "Enter") {
                    this.enableEditMode();
                    this.editorDiv.focus();
                  }
                }
                editorDivKeydown(event) {
                  _FreeTextEditor._keyboardManager.exec(this, event);
                }
                editorDivFocus(event) {
                  this.isEditing = true;
                }
                editorDivBlur(event) {
                  this.isEditing = false;
                }
                disableEditing() {
                  this.editorDiv.setAttribute("role", "comment");
                  this.editorDiv.removeAttribute("aria-multiline");
                }
                enableEditing() {
                  this.editorDiv.setAttribute("role", "textbox");
                  this.editorDiv.setAttribute("aria-multiline", true);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.editorDiv = document.createElement("div");
                  this.editorDiv.className = "internal";
                  this.editorDiv.setAttribute("id", `${this.id}-editor`);
                  this.enableEditing();
                  _FreeTextEditor._l10nPromise.get("editor_free_text_aria_label").then((msg) => this.editorDiv?.setAttribute("aria-label", msg));
                  _FreeTextEditor._l10nPromise.get("free_text_default_content").then((msg) => this.editorDiv?.setAttribute("default-content", msg));
                  this.editorDiv.contentEditable = true;
                  const {
                    style
                  } = this.editorDiv;
                  style.fontSize = `calc(${__privateGet(this, _fontSize)}px * var(--scale-factor))`;
                  style.color = __privateGet(this, _color);
                  this.div.append(this.editorDiv);
                  this.overlayDiv = document.createElement("div");
                  this.overlayDiv.classList.add("overlay", "enabled");
                  this.div.append(this.overlayDiv);
                  (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    for (const line of __privateGet(this, _content).split("\n")) {
                      const div3 = document.createElement("div");
                      div3.append(line ? document.createTextNode(line) : document.createElement("br"));
                      this.editorDiv.append(div3);
                    }
                    this.div.draggable = true;
                    this.editorDiv.contentEditable = false;
                  } else {
                    this.div.draggable = false;
                    this.editorDiv.contentEditable = true;
                  }
                  return this.div;
                }
                get contentDiv() {
                  return this.editorDiv;
                }
                static deserialize(data, parent) {
                  const editor = super.deserialize(data, parent);
                  __privateSet(editor, _fontSize, data.fontSize);
                  __privateSet(editor, _color, _util2.Util.makeHexColor(...data.color));
                  __privateSet(editor, _content, data.value);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const padding = _FreeTextEditor._internalPadding * this.parent.scaleFactor;
                  const rect = this.getRect(padding, padding);
                  const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
                  return {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color,
                    fontSize: __privateGet(this, _fontSize),
                    value: __privateGet(this, _content),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let FreeTextEditor = _FreeTextEditor;
              _boundEditorDivBlur = new WeakMap();
              _boundEditorDivFocus = new WeakMap();
              _boundEditorDivKeydown = new WeakMap();
              _color = new WeakMap();
              _content = new WeakMap();
              _hasAlreadyBeenCommitted = new WeakMap();
              _fontSize = new WeakMap();
              _updateFontSize = new WeakSet();
              updateFontSize_fn = function(fontSize) {
                const setFontsize = (size2) => {
                  this.editorDiv.style.fontSize = `calc(${size2}px * var(--scale-factor))`;
                  this.translate(0, -(size2 - __privateGet(this, _fontSize)) * this.parent.scaleFactor);
                  __privateSet(this, _fontSize, size2);
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                };
                const savedFontsize = __privateGet(this, _fontSize);
                this.parent.addCommands({
                  cmd: () => {
                    setFontsize(fontSize);
                  },
                  undo: () => {
                    setFontsize(savedFontsize);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = __privateGet(this, _color);
                this.parent.addCommands({
                  cmd: () => {
                    __privateSet(this, _color, color);
                    this.editorDiv.style.color = color;
                  },
                  undo: () => {
                    __privateSet(this, _color, savedColor);
                    this.editorDiv.style.color = savedColor;
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _extractText = new WeakSet();
              extractText_fn = function() {
                const divs = this.editorDiv.getElementsByTagName("div");
                if (divs.length === 0) {
                  return this.editorDiv.innerText;
                }
                const buffer = [];
                for (let i = 0, ii = divs.length; i < ii; i++) {
                  const div3 = divs[i];
                  const first = div3.firstChild;
                  if (first?.nodeName === "#text") {
                    buffer.push(first.data);
                  } else {
                    buffer.push("");
                  }
                }
                return buffer.join("\n");
              };
              _setEditorDimensions = new WeakSet();
              setEditorDimensions_fn = function() {
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                const rect = this.div.getBoundingClientRect();
                this.width = rect.width / parentWidth;
                this.height = rect.height / parentHeight;
              };
              __publicField(FreeTextEditor, "_freeTextDefaultContent", "");
              __publicField(FreeTextEditor, "_l10nPromise");
              __publicField(FreeTextEditor, "_internalPadding", 0);
              __publicField(FreeTextEditor, "_defaultColor", null);
              __publicField(FreeTextEditor, "_defaultFontSize", 10);
              __publicField(FreeTextEditor, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], _FreeTextEditor.prototype.commitOrRemove]]));
              __publicField(FreeTextEditor, "_type", "freetext");
              exports2.FreeTextEditor = FreeTextEditor;
            },
            /* 24 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _aspectRatio, _baseHeight, _baseWidth, _boundCanvasPointermove, _boundCanvasPointerleave, _boundCanvasPointerup, _boundCanvasPointerdown, _disableEditing, _isCanvasInitialized, _lastPoint, _observer, _realWidth, _realHeight, _requestFrameCallback, _updateThickness, updateThickness_fn, _updateColor, updateColor_fn, _updateOpacity, updateOpacity_fn, _getInitialBBox, getInitialBBox_fn, _setStroke, setStroke_fn, _startDrawing, startDrawing_fn, _draw, draw_fn, _stopDrawing, stopDrawing_fn, _redraw, redraw_fn, _endDrawing, endDrawing_fn, _createCanvas, createCanvas_fn, _createObserver, createObserver_fn, _setCanvasDims, setCanvasDims_fn, _setScaleFactor, setScaleFactor_fn, _updateTransform, updateTransform_fn, _buildPath2D, buildPath2D_fn, _serializePaths, serializePaths_fn, _extractPointsOnBezier, extractPointsOnBezier_fn, _isAlmostFlat, isAlmostFlat_fn, _getBbox, getBbox_fn, _getPadding, getPadding_fn, _fitToContent, fitToContent_fn, _setMinDims, setMinDims_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkEditor = void 0;
              Object.defineProperty(exports2, "fitCurve", {
                enumerable: true,
                get: function() {
                  return _pdfjsFitCurve.fitCurve;
                }
              });
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(6);
              var _pdfjsFitCurve = __w_pdfjs_require__2(25);
              var _tools = __w_pdfjs_require__2(7);
              const RESIZER_SIZE = 16;
              const _InkEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "inkEditor"
                  });
                  __privateAdd(this, _updateThickness);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _updateOpacity);
                  __privateAdd(this, _getInitialBBox);
                  __privateAdd(this, _setStroke);
                  __privateAdd(this, _startDrawing);
                  __privateAdd(this, _draw);
                  __privateAdd(this, _stopDrawing);
                  __privateAdd(this, _redraw);
                  __privateAdd(this, _endDrawing);
                  __privateAdd(this, _createCanvas);
                  __privateAdd(this, _createObserver);
                  __privateAdd(this, _setCanvasDims);
                  __privateAdd(this, _setScaleFactor);
                  __privateAdd(this, _updateTransform);
                  __privateAdd(this, _serializePaths);
                  __privateAdd(this, _extractPointsOnBezier);
                  __privateAdd(this, _isAlmostFlat);
                  __privateAdd(this, _getBbox);
                  __privateAdd(this, _getPadding);
                  __privateAdd(this, _fitToContent);
                  __privateAdd(this, _setMinDims);
                  __privateAdd(this, _aspectRatio, 0);
                  __privateAdd(this, _baseHeight, 0);
                  __privateAdd(this, _baseWidth, 0);
                  __privateAdd(this, _boundCanvasPointermove, this.canvasPointermove.bind(this));
                  __privateAdd(this, _boundCanvasPointerleave, this.canvasPointerleave.bind(this));
                  __privateAdd(this, _boundCanvasPointerup, this.canvasPointerup.bind(this));
                  __privateAdd(this, _boundCanvasPointerdown, this.canvasPointerdown.bind(this));
                  __privateAdd(this, _disableEditing, false);
                  __privateAdd(this, _isCanvasInitialized, false);
                  __privateAdd(this, _lastPoint, null);
                  __privateAdd(this, _observer, null);
                  __privateAdd(this, _realWidth, 0);
                  __privateAdd(this, _realHeight, 0);
                  __privateAdd(this, _requestFrameCallback, null);
                  this.color = params.color || null;
                  this.thickness = params.thickness || null;
                  this.opacity = params.opacity || null;
                  this.paths = [];
                  this.bezierPath2D = [];
                  this.currentPath = [];
                  this.scaleFactor = 1;
                  this.translationX = this.translationY = 0;
                  this.x = 0;
                  this.y = 0;
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((str3) => [str3, l10n.get(str3)]));
                }
                static updateDefaultParams(type2, value) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      _InkEditor._defaultThickness = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      _InkEditor._defaultColor = value;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      _InkEditor._defaultOpacity = value / 100;
                      break;
                  }
                }
                updateParams(type2, value) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      __privateMethod(this, _updateOpacity, updateOpacity_fn).call(this, value);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(_InkEditor._defaultOpacity * 100)]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.canvas) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                    __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  }
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                }
                remove() {
                  if (this.canvas === null) {
                    return;
                  }
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.canvas.width = this.canvas.height = 0;
                  this.canvas.remove();
                  this.canvas = null;
                  __privateGet(this, _observer).disconnect();
                  __privateSet(this, _observer, null);
                  super.remove();
                }
                enableEditMode() {
                  if (__privateGet(this, _disableEditing) || this.canvas === null) {
                    return;
                  }
                  super.enableEditMode();
                  this.div.draggable = false;
                  this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                  this.canvas.addEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                }
                disableEditMode() {
                  if (!this.isInEditMode() || this.canvas === null) {
                    return;
                  }
                  super.disableEditMode();
                  this.div.draggable = !this.isEmpty();
                  this.div.classList.remove("editing");
                  this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                  this.canvas.removeEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                }
                onceAdded() {
                  this.div.draggable = !this.isEmpty();
                }
                isEmpty() {
                  return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                }
                commit() {
                  if (__privateGet(this, _disableEditing)) {
                    return;
                  }
                  super.commit();
                  this.isEditing = false;
                  this.disableEditMode();
                  this.setInForeground();
                  __privateSet(this, _disableEditing, true);
                  this.div.classList.add("disabled");
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this, true);
                  this.parent.addInkEditorIfNeeded(true);
                  this.parent.moveEditorInDOM(this);
                  this.div.focus();
                }
                focusin(event) {
                  super.focusin(event);
                  this.enableEditMode();
                }
                canvasPointerdown(event) {
                  if (event.button !== 0 || !this.isInEditMode() || __privateGet(this, _disableEditing)) {
                    return;
                  }
                  this.setInForeground();
                  if (event.type !== "mouse") {
                    this.div.focus();
                  }
                  event.stopPropagation();
                  this.canvas.addEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                  this.canvas.addEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                  __privateMethod(this, _startDrawing, startDrawing_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointermove(event) {
                  event.stopPropagation();
                  __privateMethod(this, _draw, draw_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointerup(event) {
                  if (event.button !== 0) {
                    return;
                  }
                  if (this.isInEditMode() && this.currentPath.length !== 0) {
                    event.stopPropagation();
                    __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                    this.setInBackground();
                  }
                }
                canvasPointerleave(event) {
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                  this.setInBackground();
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  _InkEditor._l10nPromise.get("editor_ink_aria_label").then((msg) => this.div?.setAttribute("aria-label", msg));
                  const [x, y, w, h] = __privateMethod(this, _getInitialBBox, getInitialBBox_fn).call(this);
                  this.setAt(x, y, 0, 0);
                  this.setDims(w, h);
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    __privateSet(this, _isCanvasInitialized, true);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                    this.setDims(this.width * parentWidth, this.height * parentHeight);
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                    __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                    this.div.classList.add("disabled");
                  } else {
                    this.div.classList.add("editing");
                    this.enableEditMode();
                  }
                  __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  return this.div;
                }
                setDimensions(width, height) {
                  const roundedWidth = Math.round(width);
                  const roundedHeight = Math.round(height);
                  if (__privateGet(this, _realWidth) === roundedWidth && __privateGet(this, _realHeight) === roundedHeight) {
                    return;
                  }
                  __privateSet(this, _realWidth, roundedWidth);
                  __privateSet(this, _realHeight, roundedHeight);
                  this.canvas.style.visibility = "hidden";
                  if (__privateGet(this, _aspectRatio) && Math.abs(__privateGet(this, _aspectRatio) - width / height) > 0.01) {
                    height = Math.ceil(width / __privateGet(this, _aspectRatio));
                    this.setDims(width, height);
                  }
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.width = width / parentWidth;
                  this.height = height / parentHeight;
                  if (__privateGet(this, _disableEditing)) {
                    __privateMethod(this, _setScaleFactor, setScaleFactor_fn).call(this, width, height);
                  }
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  this.canvas.style.visibility = "visible";
                }
                static deserialize(data, parent) {
                  var _a, _b;
                  const editor = super.deserialize(data, parent);
                  editor.thickness = data.thickness;
                  editor.color = _util2.Util.makeHexColor(...data.color);
                  editor.opacity = data.opacity;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const width = editor.width * pageWidth;
                  const height = editor.height * pageHeight;
                  const scaleFactor = parent.scaleFactor;
                  const padding = data.thickness / 2;
                  __privateSet(editor, _aspectRatio, width / height);
                  __privateSet(editor, _disableEditing, true);
                  __privateSet(editor, _realWidth, Math.round(width));
                  __privateSet(editor, _realHeight, Math.round(height));
                  for (const {
                    bezier: bezier2
                  } of data.paths) {
                    const path = [];
                    editor.paths.push(path);
                    let p0 = scaleFactor * (bezier2[0] - padding);
                    let p1 = scaleFactor * (height - bezier2[1] - padding);
                    for (let i = 2, ii = bezier2.length; i < ii; i += 6) {
                      const p10 = scaleFactor * (bezier2[i] - padding);
                      const p11 = scaleFactor * (height - bezier2[i + 1] - padding);
                      const p20 = scaleFactor * (bezier2[i + 2] - padding);
                      const p21 = scaleFactor * (height - bezier2[i + 3] - padding);
                      const p30 = scaleFactor * (bezier2[i + 4] - padding);
                      const p31 = scaleFactor * (height - bezier2[i + 5] - padding);
                      path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                      p0 = p30;
                      p1 = p31;
                    }
                    const path2D = __privateMethod(this, _buildPath2D, buildPath2D_fn).call(this, path);
                    editor.bezierPath2D.push(path2D);
                  }
                  const bbox = __privateMethod(_a = editor, _getBbox, getBbox_fn).call(_a);
                  __privateSet(editor, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                  __privateSet(editor, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                  __privateMethod(_b = editor, _setScaleFactor, setScaleFactor_fn).call(_b, width, height);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const rect = this.getRect(0, 0);
                  const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];
                  const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                  return {
                    annotationType: _util2.AnnotationEditorType.INK,
                    color,
                    thickness: this.thickness,
                    opacity: this.opacity,
                    paths: __privateMethod(this, _serializePaths, serializePaths_fn).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let InkEditor = _InkEditor;
              _aspectRatio = new WeakMap();
              _baseHeight = new WeakMap();
              _baseWidth = new WeakMap();
              _boundCanvasPointermove = new WeakMap();
              _boundCanvasPointerleave = new WeakMap();
              _boundCanvasPointerup = new WeakMap();
              _boundCanvasPointerdown = new WeakMap();
              _disableEditing = new WeakMap();
              _isCanvasInitialized = new WeakMap();
              _lastPoint = new WeakMap();
              _observer = new WeakMap();
              _realWidth = new WeakMap();
              _realHeight = new WeakMap();
              _requestFrameCallback = new WeakMap();
              _updateThickness = new WeakSet();
              updateThickness_fn = function(thickness) {
                const savedThickness = this.thickness;
                this.parent.addCommands({
                  cmd: () => {
                    this.thickness = thickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  undo: () => {
                    this.thickness = savedThickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = this.color;
                this.parent.addCommands({
                  cmd: () => {
                    this.color = color;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.color = savedColor;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateOpacity = new WeakSet();
              updateOpacity_fn = function(opacity) {
                opacity /= 100;
                const savedOpacity = this.opacity;
                this.parent.addCommands({
                  cmd: () => {
                    this.opacity = opacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.opacity = savedOpacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _getInitialBBox = new WeakSet();
              getInitialBBox_fn = function() {
                const {
                  width,
                  height,
                  rotation
                } = this.parent.viewport;
                switch (rotation) {
                  case 90:
                    return [0, width, width, height];
                  case 180:
                    return [width, height, width, height];
                  case 270:
                    return [height, 0, width, height];
                  default:
                    return [0, 0, width, height];
                }
              };
              _setStroke = new WeakSet();
              setStroke_fn = function() {
                this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;
                this.ctx.lineCap = "round";
                this.ctx.lineJoin = "round";
                this.ctx.miterLimit = 10;
                this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;
              };
              _startDrawing = new WeakSet();
              startDrawing_fn = function(x, y) {
                this.isEditing = true;
                if (!__privateGet(this, _isCanvasInitialized)) {
                  __privateSet(this, _isCanvasInitialized, true);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  this.thickness ||= _InkEditor._defaultThickness;
                  this.color ||= _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
                  this.opacity ??= _InkEditor._defaultOpacity;
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _lastPoint, null);
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                __privateSet(this, _requestFrameCallback, () => {
                  if (!__privateGet(this, _requestFrameCallback)) {
                    return;
                  }
                  if (__privateGet(this, _lastPoint)) {
                    if (this.isEmpty()) {
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } else {
                      __privateMethod(this, _redraw, redraw_fn).call(this);
                    }
                    this.ctx.lineTo(...__privateGet(this, _lastPoint));
                    __privateSet(this, _lastPoint, null);
                    this.ctx.stroke();
                  }
                  window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
                });
                window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
              };
              _draw = new WeakSet();
              draw_fn = function(x, y) {
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x === lastX && y === lastY) {
                  return;
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _lastPoint, [x, y]);
              };
              _stopDrawing = new WeakSet();
              stopDrawing_fn = function(x, y) {
                var _a;
                this.ctx.closePath();
                __privateSet(this, _requestFrameCallback, null);
                x = Math.min(Math.max(x, 0), this.canvas.width);
                y = Math.min(Math.max(y, 0), this.canvas.height);
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x !== lastX || y !== lastY) {
                  this.currentPath.push([x, y]);
                }
                let bezier2;
                if (this.currentPath.length !== 1) {
                  bezier2 = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);
                } else {
                  const xy = [x, y];
                  bezier2 = [[xy, xy.slice(), xy.slice(), xy]];
                }
                const path2D = __privateMethod(_a = _InkEditor, _buildPath2D, buildPath2D_fn).call(_a, bezier2);
                this.currentPath.length = 0;
                const cmd = () => {
                  this.paths.push(bezier2);
                  this.bezierPath2D.push(path2D);
                  this.rebuild();
                };
                const undo = () => {
                  this.paths.pop();
                  this.bezierPath2D.pop();
                  if (this.paths.length === 0) {
                    this.remove();
                  } else {
                    if (!this.canvas) {
                      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                      __privateMethod(this, _createObserver, createObserver_fn).call(this);
                    }
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  }
                };
                this.parent.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              };
              _redraw = new WeakSet();
              redraw_fn = function() {
                if (this.isEmpty()) {
                  __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                  return;
                }
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                const {
                  canvas,
                  ctx
                } = this;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
              };
              _endDrawing = new WeakSet();
              endDrawing_fn = function(event) {
                __privateMethod(this, _stopDrawing, stopDrawing_fn).call(this, event.offsetX, event.offsetY);
                this.canvas.removeEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.removeEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.parent.addToAnnotationStorage(this);
              };
              _createCanvas = new WeakSet();
              createCanvas_fn = function() {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.canvas.height = 0;
                this.canvas.className = "inkEditorCanvas";
                _InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => this.canvas?.setAttribute("aria-label", msg));
                this.div.append(this.canvas);
                this.ctx = this.canvas.getContext("2d");
              };
              _createObserver = new WeakSet();
              createObserver_fn = function() {
                __privateSet(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    this.setDimensions(rect.width, rect.height);
                  }
                }));
                __privateGet(this, _observer).observe(this.div);
              };
              _setCanvasDims = new WeakSet();
              setCanvasDims_fn = function() {
                if (!__privateGet(this, _isCanvasInitialized)) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.canvas.width = Math.ceil(this.width * parentWidth);
                this.canvas.height = Math.ceil(this.height * parentHeight);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
              };
              _setScaleFactor = new WeakSet();
              setScaleFactor_fn = function(width, height) {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                const scaleFactorW = (width - padding) / __privateGet(this, _baseWidth);
                const scaleFactorH = (height - padding) / __privateGet(this, _baseHeight);
                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
              };
              _updateTransform = new WeakSet();
              updateTransform_fn = function() {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this) / 2;
                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
              };
              _buildPath2D = new WeakSet();
              buildPath2D_fn = function(bezier2) {
                const path2D = new Path2D();
                for (let i = 0, ii = bezier2.length; i < ii; i++) {
                  const [first, control1, control2, second] = bezier2[i];
                  if (i === 0) {
                    path2D.moveTo(...first);
                  }
                  path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
                }
                return path2D;
              };
              _serializePaths = new WeakSet();
              serializePaths_fn = function(s, tx, ty, h) {
                const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;
                const paths = [];
                const padding = this.thickness / 2;
                let buffer, points;
                for (const bezier2 of this.paths) {
                  buffer = [];
                  points = [];
                  for (let i = 0, ii = bezier2.length; i < ii; i++) {
                    const [first, control1, control2, second] = bezier2[i];
                    const p10 = s * (first[0] + tx) + padding;
                    const p11 = h - s * (first[1] + ty) - padding;
                    const p20 = s * (control1[0] + tx) + padding;
                    const p21 = h - s * (control1[1] + ty) - padding;
                    const p30 = s * (control2[0] + tx) + padding;
                    const p31 = h - s * (control2[1] + ty) - padding;
                    const p40 = s * (second[0] + tx) + padding;
                    const p41 = h - s * (second[1] + ty) - padding;
                    if (i === 0) {
                      buffer.push(p10, p11);
                      points.push(p10, p11);
                    }
                    buffer.push(p20, p21, p30, p31, p40, p41);
                    __privateMethod(this, _extractPointsOnBezier, extractPointsOnBezier_fn).call(this, p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);
                  }
                  paths.push({
                    bezier: buffer,
                    points
                  });
                }
                return paths;
              };
              _extractPointsOnBezier = new WeakSet();
              extractPointsOnBezier_fn = function(p10, p11, p20, p21, p30, p31, p40, p41, n2, points) {
                if (__privateMethod(this, _isAlmostFlat, isAlmostFlat_fn).call(this, p10, p11, p20, p21, p30, p31, p40, p41)) {
                  points.push(p40, p41);
                  return;
                }
                for (let i = 1; i < n2 - 1; i++) {
                  const t2 = i / n2;
                  const mt = 1 - t2;
                  let q10 = t2 * p10 + mt * p20;
                  let q11 = t2 * p11 + mt * p21;
                  let q20 = t2 * p20 + mt * p30;
                  let q21 = t2 * p21 + mt * p31;
                  const q30 = t2 * p30 + mt * p40;
                  const q31 = t2 * p31 + mt * p41;
                  q10 = t2 * q10 + mt * q20;
                  q11 = t2 * q11 + mt * q21;
                  q20 = t2 * q20 + mt * q30;
                  q21 = t2 * q21 + mt * q31;
                  q10 = t2 * q10 + mt * q20;
                  q11 = t2 * q11 + mt * q21;
                  points.push(q10, q11);
                }
                points.push(p40, p41);
              };
              _isAlmostFlat = new WeakSet();
              isAlmostFlat_fn = function(p10, p11, p20, p21, p30, p31, p40, p41) {
                const tol = 10;
                const ax = (3 * p20 - 2 * p10 - p40) ** 2;
                const ay = (3 * p21 - 2 * p11 - p41) ** 2;
                const bx = (3 * p30 - p10 - 2 * p40) ** 2;
                const by = (3 * p31 - p11 - 2 * p41) ** 2;
                return Math.max(ax, bx) + Math.max(ay, by) <= tol;
              };
              _getBbox = new WeakSet();
              getBbox_fn = function() {
                let xMin = Infinity;
                let xMax = -Infinity;
                let yMin = Infinity;
                let yMax = -Infinity;
                for (const path of this.paths) {
                  for (const [first, control1, control2, second] of path) {
                    const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                    xMin = Math.min(xMin, bbox[0]);
                    yMin = Math.min(yMin, bbox[1]);
                    xMax = Math.max(xMax, bbox[2]);
                    yMax = Math.max(yMax, bbox[3]);
                  }
                }
                return [xMin, yMin, xMax, yMax];
              };
              _getPadding = new WeakSet();
              getPadding_fn = function() {
                return __privateGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
              };
              _fitToContent = new WeakSet();
              fitToContent_fn = function(firstTime = false) {
                if (this.isEmpty()) {
                  return;
                }
                if (!__privateGet(this, _disableEditing)) {
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  return;
                }
                const bbox = __privateMethod(this, _getBbox, getBbox_fn).call(this);
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                __privateSet(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                __privateSet(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                const width = Math.ceil(padding + __privateGet(this, _baseWidth) * this.scaleFactor);
                const height = Math.ceil(padding + __privateGet(this, _baseHeight) * this.scaleFactor);
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.width = width / parentWidth;
                this.height = height / parentHeight;
                __privateSet(this, _aspectRatio, width / height);
                __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                const prevTranslationX = this.translationX;
                const prevTranslationY = this.translationY;
                this.translationX = -bbox[0];
                this.translationY = -bbox[1];
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                __privateMethod(this, _redraw, redraw_fn).call(this);
                __privateSet(this, _realWidth, width);
                __privateSet(this, _realHeight, height);
                this.setDims(width, height);
                const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
              };
              _setMinDims = new WeakSet();
              setMinDims_fn = function() {
                const {
                  style
                } = this.div;
                if (__privateGet(this, _aspectRatio) >= 1) {
                  style.minHeight = `${RESIZER_SIZE}px`;
                  style.minWidth = `${Math.round(__privateGet(this, _aspectRatio) * RESIZER_SIZE)}px`;
                } else {
                  style.minWidth = `${RESIZER_SIZE}px`;
                  style.minHeight = `${Math.round(RESIZER_SIZE / __privateGet(this, _aspectRatio))}px`;
                }
              };
              __privateAdd(InkEditor, _buildPath2D);
              __publicField(InkEditor, "_defaultColor", null);
              __publicField(InkEditor, "_defaultOpacity", 1);
              __publicField(InkEditor, "_defaultThickness", 1);
              __publicField(InkEditor, "_l10nPromise");
              __publicField(InkEditor, "_type", "ink");
              exports2.InkEditor = InkEditor;
            },
            /* 25 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.fitCurve = void 0;
              const fitCurve = __w_pdfjs_require__2(26);
              exports2.fitCurve = fitCurve;
            },
            /* 26 */
            /***/
            (module2) => {
              function fitCurve(points, maxError, progressCallback) {
                if (!Array.isArray(points)) {
                  throw new TypeError("First argument should be an array");
                }
                points.forEach((point) => {
                  if (!Array.isArray(point) || point.some((item) => typeof item !== "number") || point.length !== points[0].length) {
                    throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
                  }
                });
                points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));
                if (points.length < 2) {
                  return [];
                }
                const len3 = points.length;
                const leftTangent = createTangent(points[1], points[0]);
                const rightTangent = createTangent(points[len3 - 2], points[len3 - 1]);
                return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
              }
              function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
                const MaxIterations = 20;
                var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist3, i;
                if (points.length === 2) {
                  dist3 = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
                  bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist3)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist3)), points[1]];
                  return [bezCurve];
                }
                u = chordLengthParameterize(points);
                [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);
                if (maxError === 0 || maxError < error) {
                  return [bezCurve];
                }
                if (maxError < error * error) {
                  uPrime = u;
                  prevErr = maxError;
                  prevSplit = splitPoint;
                  for (i = 0; i < MaxIterations; i++) {
                    uPrime = reparameterize(bezCurve, points, uPrime);
                    [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);
                    if (maxError < error) {
                      return [bezCurve];
                    } else if (splitPoint === prevSplit) {
                      let errChange = maxError / prevErr;
                      if (errChange > 0.9999 && errChange < 1.0001) {
                        break;
                      }
                    }
                    prevErr = maxError;
                    prevSplit = splitPoint;
                  }
                }
                beziers = [];
                centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
                if (centerVector.every((val) => val === 0)) {
                  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
                  [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
                }
                toCenterTangent = maths.normalize(centerVector);
                fromCenterTangent = maths.mulItems(toCenterTangent, -1);
                beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
                beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
                return beziers;
              }
              ;
              function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
                var bezCurve, maxError, splitPoint;
                bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
                [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);
                if (progressCallback) {
                  progressCallback({
                    bez: bezCurve,
                    points,
                    params: paramsOrig,
                    maxErr: maxError,
                    maxPoint: splitPoint
                  });
                }
                return [bezCurve, maxError, splitPoint];
              }
              function generateBezier(points, parameters, leftTangent, rightTangent) {
                var bezCurve, A2, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len3, tmp, u, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
                bezCurve = [firstPoint, null, null, lastPoint];
                A2 = maths.zeros_Xx2x2(parameters.length);
                for (i = 0, len3 = parameters.length; i < len3; i++) {
                  u = parameters[i];
                  ux = 1 - u;
                  a = A2[i];
                  a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
                  a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
                }
                C = [[0, 0], [0, 0]];
                X = [0, 0];
                for (i = 0, len3 = points.length; i < len3; i++) {
                  u = parameters[i];
                  a = A2[i];
                  C[0][0] += maths.dot(a[0], a[0]);
                  C[0][1] += maths.dot(a[0], a[1]);
                  C[1][0] += maths.dot(a[0], a[1]);
                  C[1][1] += maths.dot(a[1], a[1]);
                  tmp = maths.subtract(points[i], bezier2.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
                  X[0] += maths.dot(a[0], tmp);
                  X[1] += maths.dot(a[1], tmp);
                }
                det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
                det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
                det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
                alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
                alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
                segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
                epsilon = 1e-6 * segLength;
                if (alpha_l < epsilon || alpha_r < epsilon) {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
                } else {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
                }
                return bezCurve;
              }
              ;
              function reparameterize(bezier3, points, parameters) {
                return parameters.map((p, i) => newtonRaphsonRootFind(bezier3, points[i], p));
              }
              ;
              function newtonRaphsonRootFind(bez, point, u) {
                var d = maths.subtract(bezier2.q(bez, u), point), qprime = bezier2.qprime(bez, u), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier2.qprimeprime(bez, u));
                if (denominator === 0) {
                  return u;
                } else {
                  return u - numerator / denominator;
                }
              }
              ;
              function chordLengthParameterize(points) {
                var u = [], currU, prevU, prevP;
                points.forEach((p, i) => {
                  currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
                  u.push(currU);
                  prevU = currU;
                  prevP = p;
                });
                u = u.map((x) => x / prevU);
                return u;
              }
              ;
              function computeMaxError(points, bez, parameters) {
                var dist3, maxDist, splitPoint, v, i, count, point, t2;
                maxDist = 0;
                splitPoint = Math.floor(points.length / 2);
                const t_distMap = mapTtoRelativeDistances(bez, 10);
                for (i = 0, count = points.length; i < count; i++) {
                  point = points[i];
                  t2 = find_t(bez, parameters[i], t_distMap, 10);
                  v = maths.subtract(bezier2.q(bez, t2), point);
                  dist3 = v[0] * v[0] + v[1] * v[1];
                  if (dist3 > maxDist) {
                    maxDist = dist3;
                    splitPoint = i;
                  }
                }
                return [maxDist, splitPoint];
              }
              ;
              var mapTtoRelativeDistances = function(bez, B_parts) {
                var B_t_curr;
                var B_t_dist = [0];
                var B_t_prev = bez[0];
                var sumLen = 0;
                for (var i = 1; i <= B_parts; i++) {
                  B_t_curr = bezier2.q(bez, i / B_parts);
                  sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
                  B_t_dist.push(sumLen);
                  B_t_prev = B_t_curr;
                }
                B_t_dist = B_t_dist.map((x) => x / sumLen);
                return B_t_dist;
              };
              function find_t(bez, param, t_distMap, B_parts) {
                if (param < 0) {
                  return 0;
                }
                if (param > 1) {
                  return 1;
                }
                var lenMax, lenMin, tMax, tMin, t2;
                for (var i = 1; i <= B_parts; i++) {
                  if (param <= t_distMap[i]) {
                    tMin = (i - 1) / B_parts;
                    tMax = i / B_parts;
                    lenMin = t_distMap[i - 1];
                    lenMax = t_distMap[i];
                    t2 = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
                    break;
                  }
                }
                return t2;
              }
              function createTangent(pointA, pointB) {
                return maths.normalize(maths.subtract(pointA, pointB));
              }
              class maths {
                static zeros_Xx2x2(x) {
                  var zs = [];
                  while (x--) {
                    zs.push([0, 0]);
                  }
                  return zs;
                }
                static mulItems(items, multiplier) {
                  return items.map((x) => x * multiplier);
                }
                static mulMatrix(m1, m2) {
                  return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);
                }
                static subtract(arr1, arr2) {
                  return arr1.map((x1, i) => x1 - arr2[i]);
                }
                static addArrays(arr1, arr2) {
                  return arr1.map((x1, i) => x1 + arr2[i]);
                }
                static addItems(items, addition) {
                  return items.map((x) => x + addition);
                }
                static sum(items) {
                  return items.reduce((sum, x) => sum + x);
                }
                static dot(m1, m2) {
                  return maths.mulMatrix(m1, m2);
                }
                static vectorLen(v) {
                  return Math.hypot(...v);
                }
                static divItems(items, divisor) {
                  return items.map((x) => x / divisor);
                }
                static squareItems(items) {
                  return items.map((x) => x * x);
                }
                static normalize(v) {
                  return this.divItems(v, this.vectorLen(v));
                }
              }
              class bezier2 {
                static q(ctrlPoly, t2) {
                  var tx = 1 - t2;
                  var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t2), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t2 * t2), pD = maths.mulItems(ctrlPoly[3], t2 * t2 * t2);
                  return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
                }
                static qprime(ctrlPoly, t2) {
                  var tx = 1 - t2;
                  var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t2), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t2 * t2);
                  return maths.addArrays(maths.addArrays(pA, pB), pC);
                }
                static qprimeprime(ctrlPoly, t2) {
                  return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t2)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t2));
                }
              }
              module2.exports = fitCurve;
              module2.exports.fitCubic = fitCubic;
              module2.exports.createTangent = createTangent;
            },
            /* 27 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _appendElement, appendElement_fn, _setDimensions, setDimensions_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _annotation_storage2 = __w_pdfjs_require__2(5);
              var _scripting_utils = __w_pdfjs_require__2(28);
              var _xfa_layer = __w_pdfjs_require__2(29);
              const DEFAULT_TAB_INDEX = 1e3;
              const DEFAULT_FONT_SIZE = 9;
              const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              class AnnotationElementFactory {
                static create(parameters) {
                  const subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      const fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }
              class AnnotationElement {
                constructor(parameters, {
                  isRenderable = false,
                  ignoreBorder = false,
                  createQuadrilaterals = false
                } = {}) {
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.page = parameters.page;
                  this.viewport = parameters.viewport;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this._mouseState = parameters.mouseState;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                  }
                }
                _createContainer(ignoreBorder = false) {
                  const data = this.data, page = this.page, viewport = this.viewport;
                  const container = document.createElement("section");
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  container.setAttribute("data-annotation-id", data.id);
                  const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = `${data.borderStyle.width}px`;
                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    const verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                      const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    const borderColor = data.borderColor || null;
                    if (borderColor) {
                      container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;
                  container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;
                  const {
                    rotation
                  } = data;
                  if (data.hasOwnCanvas || rotation === 0) {
                    container.style.width = `${100 * width / pageWidth}%`;
                    container.style.height = `${100 * height / pageHeight}%`;
                  } else {
                    this.setRotation(rotation, container);
                  }
                  return container;
                }
                setRotation(angle3, container = this.container) {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  const {
                    width,
                    height
                  } = getRectDims(this.data.rect);
                  let elementWidth, elementHeight;
                  if (angle3 % 180 === 0) {
                    elementWidth = 100 * width / pageWidth;
                    elementHeight = 100 * height / pageHeight;
                  } else {
                    elementWidth = 100 * height / pageWidth;
                    elementHeight = 100 * width / pageHeight;
                  }
                  container.style.width = `${elementWidth}%`;
                  container.style.height = `${elementHeight}%`;
                  container.setAttribute("data-main-rotation", (360 - angle3) % 360);
                }
                get _commonActions() {
                  const setColor = (jsName, styleName, event) => {
                    const color = event.detail[jsName];
                    event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
                  };
                  return (0, _util2.shadow)(this, "_commonActions", {
                    display: (event) => {
                      const hidden = event.detail.display % 2 === 1;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden,
                        print: event.detail.display === 0 || event.detail.display === 3
                      });
                    },
                    print: (event) => {
                      this.annotationStorage.setValue(this.data.id, {
                        print: event.detail.print
                      });
                    },
                    hidden: (event) => {
                      this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden: event.detail.hidden
                      });
                    },
                    focus: (event) => {
                      setTimeout(() => event.target.focus({
                        preventScroll: false
                      }), 0);
                    },
                    userName: (event) => {
                      event.target.title = event.detail.userName;
                    },
                    readonly: (event) => {
                      if (event.detail.readonly) {
                        event.target.setAttribute("readonly", "");
                      } else {
                        event.target.removeAttribute("readonly");
                      }
                    },
                    required: (event) => {
                      this._setRequired(event.target, event.detail.required);
                    },
                    bgColor: (event) => {
                      setColor("bgColor", "backgroundColor", event);
                    },
                    fillColor: (event) => {
                      setColor("fillColor", "backgroundColor", event);
                    },
                    fgColor: (event) => {
                      setColor("fgColor", "color", event);
                    },
                    textColor: (event) => {
                      setColor("textColor", "color", event);
                    },
                    borderColor: (event) => {
                      setColor("borderColor", "borderColor", event);
                    },
                    strokeColor: (event) => {
                      setColor("strokeColor", "borderColor", event);
                    },
                    rotation: (event) => {
                      const angle3 = event.detail.rotation;
                      this.setRotation(angle3);
                      this.annotationStorage.setValue(this.data.id, {
                        rotation: angle3
                      });
                    }
                  });
                }
                _dispatchEventFromSandbox(actions, jsEvent) {
                  const commonActions = this._commonActions;
                  for (const name of Object.keys(jsEvent.detail)) {
                    const action = actions[name] || commonActions[name];
                    if (action) {
                      action(jsEvent);
                    }
                  }
                }
                _setDefaultPropertiesFromJS(element) {
                  if (!this.enableScripting) {
                    return;
                  }
                  const storedData = this.annotationStorage.getRawValue(this.data.id);
                  if (!storedData) {
                    return;
                  }
                  const commonActions = this._commonActions;
                  for (const [actionName, detail] of Object.entries(storedData)) {
                    const action = commonActions[actionName];
                    if (action) {
                      const eventProxy = {
                        detail: {
                          [actionName]: detail
                        },
                        target: element
                      };
                      action(eventProxy);
                      delete storedData[actionName];
                    }
                  }
                }
                _createQuadrilaterals(ignoreBorder = false) {
                  if (!this.data.quadPoints) {
                    return null;
                  }
                  const quadrilaterals = [];
                  const savedRect = this.data.rect;
                  for (const quadPoint of this.data.quadPoints) {
                    this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                    quadrilaterals.push(this._createContainer(ignoreBorder));
                  }
                  this.data.rect = savedRect;
                  return quadrilaterals;
                }
                _createPopup(trigger, data) {
                  let container = this.container;
                  if (this.quadrilaterals) {
                    trigger = trigger || this.quadrilaterals;
                    container = this.quadrilaterals[0];
                  }
                  if (!trigger) {
                    trigger = document.createElement("div");
                    trigger.className = "popupTriggerArea";
                    container.append(trigger);
                  }
                  const popupElement = new PopupElement({
                    container,
                    trigger,
                    color: data.color,
                    titleObj: data.titleObj,
                    modificationDate: data.modificationDate,
                    contentsObj: data.contentsObj,
                    richText: data.richText,
                    hideWrapper: true
                  });
                  const popup = popupElement.render();
                  popup.style.left = "100%";
                  container.append(popup);
                }
                _renderQuadrilaterals(className2) {
                  for (const quadrilateral of this.quadrilaterals) {
                    quadrilateral.className = className2;
                  }
                  return this.quadrilaterals;
                }
                render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
                _getElementsByName(name, skipId = null) {
                  const fields = [];
                  if (this._fieldObjects) {
                    const fieldObj = this._fieldObjects[name];
                    if (fieldObj) {
                      for (const {
                        page,
                        id,
                        exportValues
                      } of fieldObj) {
                        if (page === -1) {
                          continue;
                        }
                        if (id === skipId) {
                          continue;
                        }
                        const exportValue = typeof exportValues === "string" ? exportValues : null;
                        const domElement = document.querySelector(`[data-element-id="${id}"]`);
                        if (domElement && !GetElementsByNameSet.has(domElement)) {
                          (0, _util2.warn)(`_getElementsByName - element not allowed: ${id}`);
                          continue;
                        }
                        fields.push({
                          id,
                          exportValue,
                          domElement
                        });
                      }
                    }
                    return fields;
                  }
                  for (const domElement of document.getElementsByName(name)) {
                    const {
                      id,
                      exportValue
                    } = domElement;
                    if (id === skipId) {
                      continue;
                    }
                    if (!GetElementsByNameSet.has(domElement)) {
                      continue;
                    }
                    fields.push({
                      id,
                      exportValue,
                      domElement
                    });
                  }
                  return fields;
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
              }
              class LinkAnnotationElement extends AnnotationElement {
                constructor(parameters, options = null) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: !!options?.ignoreBorder,
                    createQuadrilaterals: true
                  });
                  this.isTooltipOnly = parameters.data.isTooltipOnly;
                }
                render() {
                  const {
                    data,
                    linkService
                  } = this;
                  const link = document.createElement("a");
                  link.setAttribute("data-element-id", data.id);
                  let isBound = false;
                  if (data.url) {
                    linkService.addLinkAttributes(link, data.url, data.newWindow);
                    isBound = true;
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                    isBound = true;
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                    isBound = true;
                  } else {
                    if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                      this._bindJSAction(link, data);
                      isBound = true;
                    }
                    if (data.resetForm) {
                      this._bindResetFormAction(link, data.resetForm);
                      isBound = true;
                    } else if (this.isTooltipOnly && !isBound) {
                      this._bindLink(link, "");
                      isBound = true;
                    }
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                      const linkElement = index === 0 ? link : link.cloneNode();
                      quadrilateral.append(linkElement);
                      return quadrilateral;
                    });
                  }
                  this.container.className = "linkAnnotation";
                  if (isBound) {
                    this.container.append(link);
                  }
                  return this.container;
                }
                _bindLink(link, destination) {
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = () => {
                    if (destination) {
                      this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    link.className = "internalLink";
                  }
                }
                _bindNamedAction(link, action) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    this.linkService.executeNamedAction(action);
                    return false;
                  };
                  link.className = "internalLink";
                }
                _bindJSAction(link, data) {
                  link.href = this.linkService.getAnchorUrl("");
                  const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  for (const name of Object.keys(data.actions)) {
                    const jsName = map.get(name);
                    if (!jsName) {
                      continue;
                    }
                    link[jsName] = () => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: data.id,
                          name
                        }
                      });
                      return false;
                    };
                  }
                  if (!link.onclick) {
                    link.onclick = () => false;
                  }
                  link.className = "internalLink";
                }
                _bindResetFormAction(link, resetForm) {
                  const otherClickAction = link.onclick;
                  if (!otherClickAction) {
                    link.href = this.linkService.getAnchorUrl("");
                  }
                  link.className = "internalLink";
                  if (!this._fieldObjects) {
                    (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                    if (!otherClickAction) {
                      link.onclick = () => false;
                    }
                    return;
                  }
                  link.onclick = () => {
                    if (otherClickAction) {
                      otherClickAction();
                    }
                    const {
                      fields: resetFormFields,
                      refs: resetFormRefs,
                      include
                    } = resetForm;
                    const allFields = [];
                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                      const fieldIds = new Set(resetFormRefs);
                      for (const fieldName of resetFormFields) {
                        const fields = this._fieldObjects[fieldName] || [];
                        for (const {
                          id
                        } of fields) {
                          fieldIds.add(id);
                        }
                      }
                      for (const fields of Object.values(this._fieldObjects)) {
                        for (const field of fields) {
                          if (fieldIds.has(field.id) === include) {
                            allFields.push(field);
                          }
                        }
                      }
                    } else {
                      for (const fields of Object.values(this._fieldObjects)) {
                        allFields.push(...fields);
                      }
                    }
                    const storage = this.annotationStorage;
                    const allIds = [];
                    for (const field of allFields) {
                      const {
                        id
                      } = field;
                      allIds.push(id);
                      switch (field.type) {
                        case "text": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "checkbox":
                        case "radiobutton": {
                          const value = field.defaultValue === field.exportValues;
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        case "combobox":
                        case "listbox": {
                          const value = field.defaultValue || "";
                          storage.setValue(id, {
                            value
                          });
                          break;
                        }
                        default:
                          continue;
                      }
                      const domElement = document.querySelector(`[data-element-id="${id}"]`);
                      if (!domElement) {
                        continue;
                      } else if (!GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id}`);
                        continue;
                      }
                      domElement.dispatchEvent(new Event("resetform"));
                    }
                    if (this.enableScripting) {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: "app",
                          ids: allIds,
                          name: "ResetForm"
                        }
                      });
                    }
                    return false;
                  };
                }
              }
              class TextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  this.container.className = "textAnnotation";
                  const image2 = document.createElement("img");
                  image2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image2.alt = "[{{type}} Annotation]";
                  image2.dataset.l10nId = "text_annotation_type";
                  image2.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.hasPopup) {
                    this._createPopup(image2, this.data);
                  }
                  this.container.append(image2);
                  return this.container;
                }
              }
              class WidgetAnnotationElement extends AnnotationElement {
                render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
                _getKeyModifier(event) {
                  const {
                    isWin,
                    isMac
                  } = AnnotationElement.platform;
                  return isWin && event.ctrlKey || isMac && event.metaKey;
                }
                _setEventListener(element, baseName, eventName, valueGetter) {
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, (event) => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: this._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, (event) => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event)
                        }
                      });
                    });
                  }
                }
                _setEventListeners(element, names, getter) {
                  for (const [baseName, eventName] of names) {
                    if (eventName === "Action" || this.data.actions?.[eventName]) {
                      this._setEventListener(element, baseName, eventName, getter);
                    }
                  }
                }
                _setBackgroundColor(element) {
                  const color = this.data.backgroundColor || null;
                  element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                }
                _setTextStyle(element) {
                  const TEXT_ALIGNMENT = ["left", "center", "right"];
                  const {
                    fontColor
                  } = this.data.defaultAppearanceData;
                  const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                  const style = element.style;
                  let computedFontSize;
                  if (this.data.multiLine) {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    const numberOfLines = Math.round(height / (_util2.LINE_FACTOR * fontSize)) || 1;
                    const lineHeight = height / numberOfLines;
                    computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util2.LINE_FACTOR));
                  } else {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    computedFontSize = Math.min(fontSize, Math.round(height / _util2.LINE_FACTOR));
                  }
                  style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
                _setRequired(element, isRequired) {
                  if (isRequired) {
                    element.setAttribute("required", true);
                  } else {
                    element.removeAttribute("required");
                  }
                  element.setAttribute("aria-required", isRequired);
                }
              }
              class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  super(parameters, {
                    isRenderable
                  });
                }
                setPropertyOnSiblings(base, key, value, keyInStorage) {
                  const storage = this.annotationStorage;
                  for (const element of this._getElementsByName(base.name, base.id)) {
                    if (element.domElement) {
                      element.domElement[key] = value;
                    }
                    storage.setValue(element.id, {
                      [keyInStorage]: value
                    });
                  }
                }
                render() {
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  this.container.className = "textWidgetAnnotation";
                  let element = null;
                  if (this.renderForms) {
                    const storedData = storage.getValue(id, {
                      value: this.data.fieldValue
                    });
                    let textContent = storedData.formattedValue || storedData.value || "";
                    const maxLen = storage.getValue(id, {
                      charLimit: this.data.maxLen
                    }).charLimit;
                    if (maxLen && textContent.length > maxLen) {
                      textContent = textContent.slice(0, maxLen);
                    }
                    const elementData = {
                      userValue: textContent,
                      formattedValue: null,
                      valueOnFocus: ""
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = textContent;
                      if (this.data.doNotScroll) {
                        element.style.overflowY = "hidden";
                      }
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", textContent);
                      if (this.data.doNotScroll) {
                        element.style.overflowX = "hidden";
                      }
                    }
                    GetElementsByNameSet.add(element);
                    element.setAttribute("data-element-id", id);
                    element.disabled = this.data.readOnly;
                    element.name = this.data.fieldName;
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    this._setRequired(element, this.data.required);
                    if (maxLen) {
                      element.maxLength = maxLen;
                    }
                    element.addEventListener("input", (event) => {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                      this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = this.data.defaultFieldValue ?? "";
                      element.value = elementData.userValue = defaultValue;
                      elementData.formattedValue = null;
                    });
                    let blurListener = (event) => {
                      const {
                        formattedValue
                      } = elementData;
                      if (formattedValue !== null && formattedValue !== void 0) {
                        event.target.value = formattedValue;
                      }
                      event.target.scrollLeft = 0;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("focus", (event) => {
                        if (elementData.userValue) {
                          event.target.value = elementData.userValue;
                        }
                        elementData.valueOnFocus = event.target.value;
                      });
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value(event) {
                            elementData.userValue = event.detail.value ?? "";
                            storage.setValue(id, {
                              value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                          },
                          formattedValue(event) {
                            const {
                              formattedValue
                            } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                              event.target.value = formattedValue;
                            }
                            storage.setValue(id, {
                              formattedValue
                            });
                          },
                          selRange(event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                          },
                          charLimit: (event) => {
                            const {
                              charLimit
                            } = event.detail;
                            const {
                              target
                            } = event;
                            if (charLimit === 0) {
                              target.removeAttribute("maxLength");
                              return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value = elementData.userValue;
                            if (!value || value.length <= charLimit) {
                              return;
                            }
                            value = value.slice(0, charLimit);
                            target.value = elementData.userValue = value;
                            storage.setValue(id, {
                              value
                            });
                            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id,
                                name: "Keystroke",
                                value,
                                willCommit: true,
                                commitKey: 1,
                                selStart: target.selectionStart,
                                selEnd: target.selectionEnd
                              }
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      element.addEventListener("keydown", (event) => {
                        let commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter") {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        const {
                          value
                        } = event.target;
                        if (elementData.valueOnFocus === value) {
                          return;
                        }
                        elementData.userValue = value;
                        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id,
                            name: "Keystroke",
                            value,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      const _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", (event) => {
                        const {
                          value
                        } = event.target;
                        elementData.userValue = value;
                        if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
                          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              willCommit: true,
                              commitKey: 1,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      if (this.data.actions?.Keystroke) {
                        element.addEventListener("beforeinput", (event) => {
                          const {
                            data,
                            target
                          } = event;
                          const {
                            value,
                            selectionStart,
                            selectionEnd
                          } = target;
                          let selStart = selectionStart, selEnd = selectionEnd;
                          switch (event.inputType) {
                            case "deleteWordBackward": {
                              const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                              if (match) {
                                selStart -= match[0].length;
                              }
                              break;
                            }
                            case "deleteWordForward": {
                              const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                              if (match) {
                                selEnd += match[0].length;
                              }
                              break;
                            }
                            case "deleteContentBackward":
                              if (selectionStart === selectionEnd) {
                                selStart -= 1;
                              }
                              break;
                            case "deleteContentForward":
                              if (selectionStart === selectionEnd) {
                                selEnd += 1;
                              }
                              break;
                          }
                          event.preventDefault();
                          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id,
                              name: "Keystroke",
                              value,
                              change: data || "",
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    if (this.data.comb) {
                      const fieldWidth = this.data.rect[2] - this.data.rect[0];
                      const combWidth = fieldWidth / maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.exportValue === data.fieldValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== "Off";
                    storage.setValue(id, {
                      value
                    });
                  }
                  this.container.className = "buttonWidgetAnnotation checkBox";
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "checkbox";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("exportValue", data.exportValue);
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const checkbox of this._getElementsByName(name, id)) {
                      const curChecked = checked && checkbox.exportValue === data.exportValue;
                      if (checkbox.domElement) {
                        checkbox.domElement.checked = curChecked;
                      }
                      storage.setValue(checkbox.id, {
                        value: curChecked
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue || "Off";
                    event.target.checked = defaultValue === data.exportValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          event.target.checked = event.detail.value !== "Off";
                          storage.setValue(id, {
                            value: event.target.checked
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "buttonWidgetAnnotation radioButton";
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id = data.id;
                  let value = storage.getValue(id, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  if (typeof value === "string") {
                    value = value !== data.buttonValue;
                    storage.setValue(id, {
                      value
                    });
                  }
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "radio";
                  element.name = data.fieldName;
                  if (value) {
                    element.setAttribute("checked", true);
                  }
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const radio of this._getElementsByName(name, id)) {
                      storage.setValue(radio.id, {
                        value: false
                      });
                    }
                    storage.setValue(id, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue;
                    event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    const pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value: (event) => {
                          const checked = pdfButtonValue === event.detail.value;
                          for (const radio of this._getElementsByName(event.target.name)) {
                            const curChecked = checked && radio.id === id;
                            if (radio.domElement) {
                              radio.domElement.checked = curChecked;
                            }
                            storage.setValue(radio.id, {
                              value: curChecked
                            });
                          }
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                render() {
                  const container = super.render();
                  container.className = "buttonWidgetAnnotation pushButton";
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  const linkElement = container.lastChild;
                  if (this.enableScripting && this.hasJSActions && linkElement) {
                    this._setDefaultPropertiesFromJS(linkElement);
                    linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      this._dispatchEventFromSandbox({}, jsEvent);
                    });
                  }
                  return container;
                }
              }
              class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "choiceWidgetAnnotation";
                  const storage = this.annotationStorage;
                  const id = this.data.id;
                  const storedData = storage.getValue(id, {
                    value: this.data.fieldValue
                  });
                  const selectElement = document.createElement("select");
                  GetElementsByNameSet.add(selectElement);
                  selectElement.setAttribute("data-element-id", id);
                  selectElement.disabled = this.data.readOnly;
                  this._setRequired(selectElement, this.data.required);
                  selectElement.name = this.data.fieldName;
                  selectElement.tabIndex = DEFAULT_TAB_INDEX;
                  let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  selectElement.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue;
                    for (const option of selectElement.options) {
                      option.selected = option.value === defaultValue;
                    }
                  });
                  for (const option of this.data.options) {
                    const optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (storedData.value.includes(option.exportValue)) {
                      optionElement.setAttribute("selected", true);
                      addAnEmptyEntry = false;
                    }
                    selectElement.append(optionElement);
                  }
                  let removeEmptyEntry = null;
                  if (addAnEmptyEntry) {
                    const noneOptionElement = document.createElement("option");
                    noneOptionElement.value = " ";
                    noneOptionElement.setAttribute("hidden", true);
                    noneOptionElement.setAttribute("selected", true);
                    selectElement.prepend(noneOptionElement);
                    removeEmptyEntry = () => {
                      noneOptionElement.remove();
                      selectElement.removeEventListener("input", removeEmptyEntry);
                      removeEmptyEntry = null;
                    };
                    selectElement.addEventListener("input", removeEmptyEntry);
                  }
                  const getValue = (event, isExport) => {
                    const name = isExport ? "value" : "textContent";
                    const options = event.target.options;
                    if (!event.target.multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                    }
                    return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                  };
                  const getItems = (event) => {
                    const options = event.target.options;
                    return Array.prototype.map.call(options, (option) => {
                      return {
                        displayValue: option.textContent,
                        exportValue: option.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          removeEmptyEntry?.();
                          const value = event.detail.value;
                          const values = new Set(Array.isArray(value) ? value : [value]);
                          for (const option of selectElement.options) {
                            option.selected = values.has(option.value);
                          }
                          storage.setValue(id, {
                            value: getValue(event, true)
                          });
                        },
                        multipleSelection(event) {
                          selectElement.multiple = true;
                        },
                        remove(event) {
                          const options = selectElement.options;
                          const index = event.detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                            if (i === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        clear(event) {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id, {
                            value: null,
                            items: []
                          });
                        },
                        insert(event) {
                          const {
                            index,
                            displayValue,
                            exportValue
                          } = event.detail.insert;
                          const selectChild = selectElement.children[index];
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          if (selectChild) {
                            selectChild.before(optionElement);
                          } else {
                            selectElement.append(optionElement);
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        items(event) {
                          const {
                            items
                          } = event.detail;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          for (const item of items) {
                            const {
                              displayValue,
                              exportValue
                            } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        indices(event) {
                          const indices = new Set(event.detail.indices);
                          for (const option of event.target.options) {
                            option.selected = indices.has(option.index);
                          }
                          storage.setValue(id, {
                            value: getValue(event, true)
                          });
                        },
                        editable(event) {
                          event.target.disabled = !event.detail.editable;
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    selectElement.addEventListener("input", (event) => {
                      const exportValue = getValue(event, true);
                      const value = getValue(event, false);
                      storage.setValue(id, {
                        value: exportValue
                      });
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value,
                          changeEx: exportValue,
                          willCommit: true,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (event) => event.target.checked);
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id, {
                        value: getValue(event, true)
                      });
                    });
                  }
                  if (this.data.combo) {
                    this._setTextStyle(selectElement);
                  } else {
                  }
                  this._setBackgroundColor(selectElement);
                  this._setDefaultPropertiesFromJS(selectElement);
                  this.container.append(selectElement);
                  return this.container;
                }
              }
              class PopupAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                  this.container.className = "popupAnnotation";
                  if (IGNORE_TYPES.includes(this.data.parentType)) {
                    return this.container;
                  }
                  const selector = `[data-annotation-id="${this.data.parentId}"]`;
                  const parentElements = this.layer.querySelectorAll(selector);
                  if (parentElements.length === 0) {
                    return this.container;
                  }
                  const popup = new PopupElement({
                    container: this.container,
                    trigger: Array.from(parentElements),
                    color: this.data.color,
                    titleObj: this.data.titleObj,
                    modificationDate: this.data.modificationDate,
                    contentsObj: this.data.contentsObj,
                    richText: this.data.richText
                  });
                  const page = this.page;
                  const rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                  const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                  const popupTop = rect[1];
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;
                  this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;
                  this.container.append(popup.render());
                  return this.container;
                }
              }
              class PopupElement {
                constructor(parameters) {
                  this.container = parameters.container;
                  this.trigger = parameters.trigger;
                  this.color = parameters.color;
                  this.titleObj = parameters.titleObj;
                  this.modificationDate = parameters.modificationDate;
                  this.contentsObj = parameters.contentsObj;
                  this.richText = parameters.richText;
                  this.hideWrapper = parameters.hideWrapper || false;
                  this.pinned = false;
                }
                render() {
                  const BACKGROUND_ENLIGHT = 0.7;
                  const wrapper = document.createElement("div");
                  wrapper.className = "popupWrapper";
                  this.hideElement = this.hideWrapper ? wrapper : this.container;
                  this.hideElement.hidden = true;
                  const popup = document.createElement("div");
                  popup.className = "popup";
                  const color = this.color;
                  if (color) {
                    const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                    const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                    const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                    popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                  }
                  const title = document.createElement("h1");
                  title.dir = this.titleObj.dir;
                  title.textContent = this.titleObj.str;
                  popup.append(title);
                  const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                  if (dateObject) {
                    const modificationDate = document.createElement("span");
                    modificationDate.className = "popupDate";
                    modificationDate.textContent = "{{date}}, {{time}}";
                    modificationDate.dataset.l10nId = "annotation_date_string";
                    modificationDate.dataset.l10nArgs = JSON.stringify({
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    });
                    popup.append(modificationDate);
                  }
                  if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {
                    _xfa_layer.XfaLayer.render({
                      xfaHtml: this.richText.html,
                      intent: "richText",
                      div: popup
                    });
                    popup.lastChild.className = "richText popupContent";
                  } else {
                    const contents = this._formatContents(this.contentsObj);
                    popup.append(contents);
                  }
                  if (!Array.isArray(this.trigger)) {
                    this.trigger = [this.trigger];
                  }
                  for (const element of this.trigger) {
                    element.addEventListener("click", this._toggle.bind(this));
                    element.addEventListener("mouseover", this._show.bind(this, false));
                    element.addEventListener("mouseout", this._hide.bind(this, false));
                  }
                  popup.addEventListener("click", this._hide.bind(this, true));
                  wrapper.append(popup);
                  return wrapper;
                }
                _formatContents({
                  str: str3,
                  dir
                }) {
                  const p = document.createElement("p");
                  p.className = "popupContent";
                  p.dir = dir;
                  const lines = str3.split(/(?:\r\n?|\n)/);
                  for (let i = 0, ii = lines.length; i < ii; ++i) {
                    const line = lines[i];
                    p.append(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.append(document.createElement("br"));
                    }
                  }
                  return p;
                }
                _toggle() {
                  if (this.pinned) {
                    this._hide(true);
                  } else {
                    this._show(true);
                  }
                }
                _show(pin = false) {
                  if (pin) {
                    this.pinned = true;
                  }
                  if (this.hideElement.hidden) {
                    this.hideElement.hidden = false;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3;
                  }
                }
                _hide(unpin = true) {
                  if (unpin) {
                    this.pinned = false;
                  }
                  if (!this.hideElement.hidden && !this.pinned) {
                    this.hideElement.hidden = true;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3;
                  }
                }
              }
              class FreeTextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.textContent = parameters.data.textContent;
                }
                render() {
                  this.container.className = "freeTextAnnotation";
                  if (this.textContent) {
                    const content = document.createElement("div");
                    content.className = "annotationTextContent";
                    content.setAttribute("role", "comment");
                    for (const line of this.textContent) {
                      const lineSpan = document.createElement("span");
                      lineSpan.textContent = line;
                      content.append(lineSpan);
                    }
                    this.container.append(content);
                  }
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class LineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "lineAnnotation";
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const line = this.svgFactory.createElement("svg:line");
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  line.setAttribute("fill", "transparent");
                  svg.append(line);
                  this.container.append(svg);
                  this._createPopup(line, data);
                  return this.container;
                }
              }
              class SquareAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "squareAnnotation";
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const square = this.svgFactory.createElement("svg:rect");
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "transparent");
                  svg.append(square);
                  this.container.append(svg);
                  this._createPopup(square, data);
                  return this.container;
                }
              }
              class CircleAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "circleAnnotation";
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  const borderWidth = data.borderStyle.width;
                  const circle = this.svgFactory.createElement("svg:ellipse");
                  circle.setAttribute("cx", width / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "transparent");
                  svg.append(circle);
                  this.container.append(svg);
                  this._createPopup(circle, data);
                  return this.container;
                }
              }
              class PolylineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "polylineAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  let points = [];
                  for (const coordinate of data.vertices) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(x + "," + y);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  svg.append(polyline);
                  this.container.append(svg);
                  this._createPopup(polyline, data);
                  return this.container;
                }
              }
              class PolygonAnnotationElement extends PolylineAnnotationElement {
                constructor(parameters) {
                  super(parameters);
                  this.containerClassName = "polygonAnnotation";
                  this.svgElementName = "svg:polygon";
                }
              }
              class CaretAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "caretAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class InkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "inkAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width, height, true);
                  for (const inkList of data.inkLists) {
                    let points = [];
                    for (const coordinate of inkList) {
                      const x = coordinate.x - data.rect[0];
                      const y = data.rect[3] - coordinate.y;
                      points.push(`${x},${y}`);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    this._createPopup(polyline, data);
                    svg.append(polyline);
                  }
                  this.container.append(svg);
                  return this.container;
                }
              }
              class HighlightAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("highlightAnnotation");
                  }
                  this.container.className = "highlightAnnotation";
                  return this.container;
                }
              }
              class UnderlineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("underlineAnnotation");
                  }
                  this.container.className = "underlineAnnotation";
                  return this.container;
                }
              }
              class SquigglyAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("squigglyAnnotation");
                  }
                  this.container.className = "squigglyAnnotation";
                  return this.container;
                }
              }
              class StrikeOutAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("strikeoutAnnotation");
                  }
                  this.container.className = "strikeoutAnnotation";
                  return this.container;
                }
              }
              class StampAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "stampAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class FileAttachmentAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true
                  });
                  const {
                    filename,
                    content
                  } = this.data.file;
                  this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                  this.content = content;
                  this.linkService.eventBus?.dispatch("fileattachmentannotation", {
                    source: this,
                    filename,
                    content
                  });
                }
                render() {
                  this.container.className = "fileAttachmentAnnotation";
                  const trigger = document.createElement("div");
                  trigger.className = "popupTriggerArea";
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {
                    this._createPopup(trigger, this.data);
                  }
                  this.container.append(trigger);
                  return this.container;
                }
                _download() {
                  this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
                }
              }
              const _AnnotationLayer = class {
                static render(parameters) {
                  var _a, _b;
                  const {
                    annotations,
                    div: div3,
                    viewport,
                    accessibilityManager
                  } = parameters;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, div3, viewport);
                  let zIndex = 0;
                  for (const data of annotations) {
                    if (data.annotationType !== _util2.AnnotationType.POPUP) {
                      const {
                        width,
                        height
                      } = getRectDims(data.rect);
                      if (width <= 0 || height <= 0) {
                        continue;
                      }
                    }
                    const element = AnnotationElementFactory.create({
                      data,
                      layer: div3,
                      page: parameters.page,
                      viewport,
                      linkService: parameters.linkService,
                      downloadManager: parameters.downloadManager,
                      imageResourcesPath: parameters.imageResourcesPath || "",
                      renderForms: parameters.renderForms !== false,
                      svgFactory: new _display_utils2.DOMSVGFactory(),
                      annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                      enableScripting: parameters.enableScripting,
                      hasJSActions: parameters.hasJSActions,
                      fieldObjects: parameters.fieldObjects,
                      mouseState: parameters.mouseState || {
                        isDown: false
                      }
                    });
                    if (element.isRenderable) {
                      const rendered = element.render();
                      if (data.hidden) {
                        rendered.style.visibility = "hidden";
                      }
                      if (Array.isArray(rendered)) {
                        for (const renderedElement of rendered) {
                          renderedElement.style.zIndex = zIndex++;
                          __privateMethod(_a = _AnnotationLayer, _appendElement, appendElement_fn).call(_a, renderedElement, data.id, div3, accessibilityManager);
                        }
                      } else {
                        rendered.style.zIndex = zIndex++;
                        if (element instanceof PopupAnnotationElement) {
                          div3.prepend(rendered);
                        } else {
                          __privateMethod(_b = _AnnotationLayer, _appendElement, appendElement_fn).call(_b, rendered, data.id, div3, accessibilityManager);
                        }
                      }
                    }
                  }
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div3, parameters.annotationCanvasMap);
                }
                static update(parameters) {
                  const {
                    annotationCanvasMap,
                    div: div3,
                    viewport
                  } = parameters;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, div3, viewport);
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div3, annotationCanvasMap);
                  div3.hidden = false;
                }
              };
              let AnnotationLayer = _AnnotationLayer;
              _appendElement = new WeakSet();
              appendElement_fn = function(element, id, div3, accessibilityManager) {
                const contentElement = element.firstChild || element;
                contentElement.id = `${_display_utils2.AnnotationPrefix}${id}`;
                div3.append(element);
                accessibilityManager?.moveElementInDOM(div3, element, contentElement, false);
              };
              _setDimensions = new WeakSet();
              setDimensions_fn = function(div3, {
                width,
                height,
                rotation
              }) {
                const {
                  style
                } = div3;
                const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width) + "px", heightStr = Math.floor(height) + "px";
                style.width = flipOrientation ? heightStr : widthStr;
                style.height = flipOrientation ? widthStr : heightStr;
                div3.setAttribute("data-main-rotation", rotation);
              };
              _setAnnotationCanvasMap = new WeakSet();
              setAnnotationCanvasMap_fn = function(div3, annotationCanvasMap) {
                if (!annotationCanvasMap) {
                  return;
                }
                for (const [id, canvas] of annotationCanvasMap) {
                  const element = div3.querySelector(`[data-annotation-id="${id}"]`);
                  if (!element) {
                    continue;
                  }
                  const {
                    firstChild
                  } = element;
                  if (!firstChild) {
                    element.append(canvas);
                  } else if (firstChild.nodeName === "CANVAS") {
                    firstChild.replaceWith(canvas);
                  } else {
                    firstChild.before(canvas);
                  }
                }
                annotationCanvasMap.clear();
              };
              __privateAdd(AnnotationLayer, _appendElement);
              __privateAdd(AnnotationLayer, _setDimensions);
              __privateAdd(AnnotationLayer, _setAnnotationCanvasMap);
              exports2.AnnotationLayer = AnnotationLayer;
            },
            /* 28 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function makeColorComp(n2) {
                return Math.floor(Math.max(0, Math.min(1, n2)) * 255).toString(16).padStart(2, "0");
              }
              class ColorConverters {
                static CMYK_G([c, y, m, k]) {
                  return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                }
                static G_CMYK([g]) {
                  return ["CMYK", 0, 0, 0, 1 - g];
                }
                static G_RGB([g]) {
                  return ["RGB", g, g, g];
                }
                static G_HTML([g]) {
                  const G = makeColorComp(g);
                  return `#${G}${G}${G}`;
                }
                static RGB_G([r, g, b]) {
                  return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                }
                static RGB_HTML([r, g, b]) {
                  const R = makeColorComp(r);
                  const G = makeColorComp(g);
                  const B = makeColorComp(b);
                  return `#${R}${G}${B}`;
                }
                static T_HTML() {
                  return "#00000000";
                }
                static CMYK_RGB([c, y, m, k]) {
                  return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                }
                static CMYK_HTML(components) {
                  const rgb2 = this.CMYK_RGB(components).slice(1);
                  return this.RGB_HTML(rgb2);
                }
                static RGB_CMYK([r, g, b]) {
                  const c = 1 - r;
                  const m = 1 - g;
                  const y = 1 - b;
                  const k = Math.min(c, m, y);
                  return ["CMYK", c, m, y, k];
                }
              }
              exports2.ColorConverters = ColorConverters;
            },
            /* 29 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(20);
              class XfaLayer {
                static setupStorage(html, id, element, storage, intent) {
                  const storedData = storage.getValue(id, {
                    value: null
                  });
                  switch (element.name) {
                    case "textarea":
                      if (storedData.value !== null) {
                        html.textContent = storedData.value;
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id, {
                          value: event.target.value
                        });
                      });
                      break;
                    case "input":
                      if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                        if (storedData.value === element.attributes.xfaOn) {
                          html.setAttribute("checked", true);
                        } else if (storedData.value === element.attributes.xfaOff) {
                          html.removeAttribute("checked");
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("change", (event) => {
                          storage.setValue(id, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                          });
                        });
                      } else {
                        if (storedData.value !== null) {
                          html.setAttribute("value", storedData.value);
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id, {
                            value: event.target.value
                          });
                        });
                      }
                      break;
                    case "select":
                      if (storedData.value !== null) {
                        for (const option of element.children) {
                          if (option.attributes.value === storedData.value) {
                            option.attributes.selected = true;
                          }
                        }
                      }
                      html.addEventListener("input", (event) => {
                        const options = event.target.options;
                        const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                        storage.setValue(id, {
                          value
                        });
                      });
                      break;
                  }
                }
                static setAttributes({
                  html,
                  element,
                  storage = null,
                  intent,
                  linkService
                }) {
                  const {
                    attributes
                  } = element;
                  const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                  if (attributes.type === "radio") {
                    attributes.name = `${attributes.name}-${intent}`;
                  }
                  for (const [key, value] of Object.entries(attributes)) {
                    if (value === null || value === void 0) {
                      continue;
                    }
                    switch (key) {
                      case "class":
                        if (value.length) {
                          html.setAttribute(key, value.join(" "));
                        }
                        break;
                      case "dataId":
                        break;
                      case "id":
                        html.setAttribute("data-element-id", value);
                        break;
                      case "style":
                        Object.assign(html.style, value);
                        break;
                      case "textContent":
                        html.textContent = value;
                        break;
                      default:
                        if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                          html.setAttribute(key, value);
                        }
                    }
                  }
                  if (isHTMLAnchorElement) {
                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                  }
                  if (storage && attributes.dataId) {
                    this.setupStorage(html, attributes.dataId, element, storage);
                  }
                }
                static render(parameters) {
                  const storage = parameters.annotationStorage;
                  const linkService = parameters.linkService;
                  const root = parameters.xfaHtml;
                  const intent = parameters.intent || "display";
                  const rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    this.setAttributes({
                      html: rootHtml,
                      element: root,
                      intent,
                      linkService
                    });
                  }
                  const stack = [[root, -1, rootHtml]];
                  const rootDiv = parameters.div;
                  rootDiv.append(rootHtml);
                  if (parameters.viewport) {
                    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                    rootDiv.style.transform = transform;
                  }
                  if (intent !== "richText") {
                    rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  }
                  const textDivs = [];
                  while (stack.length > 0) {
                    const [parent, i, html] = stack.at(-1);
                    if (i + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = parent.children[++stack.at(-1)[1]];
                    if (child === null) {
                      continue;
                    }
                    const {
                      name
                    } = child;
                    if (name === "#text") {
                      const node = document.createTextNode(child.value);
                      textDivs.push(node);
                      html.append(node);
                      continue;
                    }
                    let childHtml;
                    if (child?.attributes?.xmlns) {
                      childHtml = document.createElementNS(child.attributes.xmlns, name);
                    } else {
                      childHtml = document.createElement(name);
                    }
                    html.append(childHtml);
                    if (child.attributes) {
                      this.setAttributes({
                        html: childHtml,
                        element: child,
                        storage,
                        intent,
                        linkService
                      });
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      const node = document.createTextNode(child.value);
                      if (_xfa_text2.XfaText.shouldBuildText(name)) {
                        textDivs.push(node);
                      }
                      childHtml.append(node);
                    }
                  }
                  for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                    el.setAttribute("readOnly", true);
                  }
                  return {
                    textDivs
                  };
                }
                static update(parameters) {
                  const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  parameters.div.style.transform = transform;
                  parameters.div.hidden = false;
                }
              }
              exports2.XfaLayer = XfaLayer;
            },
            /* 30 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerRenderTask = void 0;
              exports2.renderTextLayer = renderTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              const AllWhitespaceRegexp = /^\s+$/g;
              function getAscent(fontFamily, ctx) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                  if (pixels[i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles, ctx) {
                const textDiv = document.createElement("span");
                const textDivProperties = task._enhanceTextSelection ? {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1,
                  fontSize: 0
                } : {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  fontSize: 0
                };
                task._textDivs.push(textDiv);
                const tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                let angle3 = Math.atan2(tx[1], tx[0]);
                const style = styles[geom.fontName];
                if (style.vertical) {
                  angle3 += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                let left, top;
                if (angle3 === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle3);
                  top = tx[5] - fontAscent * Math.cos(angle3);
                }
                textDiv.style.left = `${left}px`;
                textDiv.style.top = `${top}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDivProperties.fontSize = fontHeight;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle3 !== 0) {
                  textDivProperties.angle = angle3 * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
                  shouldScaleText = true;
                } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                  const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection && textDivProperties.hasText) {
                  let angleCos = 1, angleSin = 0;
                  if (angle3 !== 0) {
                    angleCos = Math.cos(angle3);
                    angleSin = Math.sin(angle3);
                  }
                  const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  const divHeight = fontHeight;
                  let m, b;
                  if (angle3 !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (let i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                let result = 0;
                for (let i = 0; i < count; i++) {
                  const t2 = ts[offset++];
                  if (t2 > 0) {
                    result = result ? Math.min(t2, result) : t2;
                  }
                }
                return result;
              }
              function expand(task) {
                const bounds = task._bounds;
                const viewport = task._viewport;
                const expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (let i = 0; i < expanded.length; i++) {
                  const div3 = bounds[i].div;
                  const divProperties = task._textDivProperties.get(div3);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div3, divProperties);
                    continue;
                  }
                  const e2 = expanded[i], b = bounds[i];
                  const m = b.m, c = m[0], s = m[1];
                  const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  const ts = new Float64Array(64);
                  for (let j = 0, jj = points.length; j < jj; j++) {
                    const t2 = _util2.Util.applyTransform(points[j], m);
                    ts[j + 0] = c && (e2.left - t2[0]) / c;
                    ts[j + 4] = s && (e2.top - t2[1]) / s;
                    ts[j + 8] = c && (e2.right - t2[0]) / c;
                    ts[j + 12] = s && (e2.bottom - t2[1]) / s;
                    ts[j + 16] = s && (e2.left - t2[0]) / -s;
                    ts[j + 20] = c && (e2.top - t2[1]) / c;
                    ts[j + 24] = s && (e2.right - t2[0]) / -s;
                    ts[j + 28] = c && (e2.bottom - t2[1]) / c;
                    ts[j + 32] = c && (e2.left - t2[0]) / -c;
                    ts[j + 36] = s && (e2.top - t2[1]) / -s;
                    ts[j + 40] = c && (e2.right - t2[0]) / -c;
                    ts[j + 44] = s && (e2.bottom - t2[1]) / -s;
                    ts[j + 48] = s && (e2.left - t2[0]) / s;
                    ts[j + 52] = c && (e2.top - t2[1]) / -c;
                    ts[j + 56] = s && (e2.right - t2[0]) / s;
                    ts[j + 60] = c && (e2.bottom - t2[1]) / -c;
                  }
                  const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div3, divProperties);
                }
              }
              function expandBounds(width, height, boxes) {
                const bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width, bounds);
                const expanded = new Array(boxes.length);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                }
                boxes.map(function(box, i) {
                  const e2 = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width - e2.right;
                  b.x2 = box.bottom;
                  b.y2 = width - e2.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                }
                return expanded;
              }
              function expandBoundsLTR(width, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                const fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                const horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                for (const boundary of bounds) {
                  let i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  let j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  let horizonPart, affectedBoundary;
                  let q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    let xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  const changedHorizon = [];
                  let lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon.at(-1).end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon.at(-1).end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    let used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);
                }
                for (const horizonPart of horizon) {
                  const affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
                  }
                }
              }
              class TextLayerRenderTask {
                constructor({
                  textContent,
                  textContentStream,
                  container,
                  viewport,
                  textDivs,
                  textContentItemsStr,
                  enhanceTextSelection
                }) {
                  if (enhanceTextSelection) {
                    (0, _display_utils2.deprecated)("The `enhanceTextSelection` functionality will be removed in the future.");
                  }
                  this._textContent = textContent;
                  this._textContentStream = textContentStream;
                  this._container = container;
                  this._document = container.ownerDocument;
                  this._viewport = viewport;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._enhanceTextSelection = !!enhanceTextSelection;
                  this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
                  this._reader = null;
                  this._layoutTextLastFontSize = null;
                  this._layoutTextLastFontFamily = null;
                  this._layoutTextCtx = null;
                  this._textDivProperties = /* @__PURE__ */ new WeakMap();
                  this._renderingDone = false;
                  this._canceled = false;
                  this._capability = (0, _util2.createPromiseCapability)();
                  this._renderTimer = null;
                  this._bounds = [];
                  this._devicePixelRatio = globalThis.devicePixelRatio || 1;
                  this._capability.promise.finally(() => {
                    if (!this._enhanceTextSelection) {
                      this._textDivProperties = null;
                    }
                    if (this._layoutTextCtx) {
                      this._layoutTextCtx.canvas.width = 0;
                      this._layoutTextCtx.canvas.height = 0;
                      this._layoutTextCtx = null;
                    }
                  }).catch(() => {
                  });
                }
                get promise() {
                  return this._capability.promise;
                }
                cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                    });
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                }
                _processItems(items, styleCache) {
                  for (let i = 0, len3 = items.length; i < len3; i++) {
                    if (items[i].str === void 0) {
                      if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                        const parent = this._container;
                        this._container = document.createElement("span");
                        this._container.classList.add("markedContent");
                        if (items[i].id !== null) {
                          this._container.setAttribute("id", `${items[i].id}`);
                        }
                        parent.append(this._container);
                      } else if (items[i].type === "endMarkedContent") {
                        this._container = this._container.parentNode;
                      }
                      continue;
                    }
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache, this._layoutTextCtx);
                  }
                }
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  let transform = "";
                  if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                    const {
                      fontFamily
                    } = textDiv.style;
                    const {
                      fontSize
                    } = textDivProperties;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width > 0) {
                      const scale3 = this._devicePixelRatio * textDivProperties.canvasWidth / width;
                      if (this._enhanceTextSelection) {
                        textDivProperties.scale = scale3;
                      }
                      transform = `scaleX(${scale3})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  if (textDivProperties.hasText) {
                    this._container.append(textDiv);
                  }
                  if (textDivProperties.hasEOL) {
                    const br = document.createElement("br");
                    br.setAttribute("role", "presentation");
                    this._container.append(br);
                  }
                }
                _render(timeout = 0) {
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = this._document.createElement("canvas");
                  canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value.styles);
                        this._processItems(value.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                }
                expandTextDivs(expandDivs = false) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
                    const div3 = this._textDivs[i];
                    const divProps = this._textDivProperties.get(div3);
                    if (!divProps.hasText) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div3.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div3.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div3.style.padding = null;
                      div3.style.transform = divProps.originalTransform;
                    }
                  }
                }
              }
              exports2.TextLayerRenderTask = TextLayerRenderTask;
              function renderTextLayer(renderParameters) {
                const task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
            },
            /* 31 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(3);
              let SVGGraphics = class {
                constructor() {
                  (0, _util2.unreachable)("Not implemented: SVGGraphics");
                }
              };
              exports2.SVGGraphics = SVGGraphics;
              {
                let opListToTree = function(opList) {
                  let opTree = [];
                  const tmp = [];
                  for (const opListElement of opList) {
                    if (opListElement.fn === "save") {
                      opTree.push({
                        fnId: 92,
                        fn: "group",
                        items: []
                      });
                      tmp.push(opTree);
                      opTree = opTree.at(-1).items;
                      continue;
                    }
                    if (opListElement.fn === "restore") {
                      opTree = tmp.pop();
                    } else {
                      opTree.push(opListElement);
                    }
                  }
                  return opTree;
                }, pf = function(value) {
                  if (Number.isInteger(value)) {
                    return value.toString();
                  }
                  const s = value.toFixed(10);
                  let i = s.length - 1;
                  if (s[i] !== "0") {
                    return s;
                  }
                  do {
                    i--;
                  } while (s[i] === "0");
                  return s.substring(0, s[i] === "." ? i : i + 1);
                }, pm = function(m) {
                  if (m[4] === 0 && m[5] === 0) {
                    if (m[1] === 0 && m[2] === 0) {
                      if (m[0] === 1 && m[3] === 1) {
                        return "";
                      }
                      return `scale(${pf(m[0])} ${pf(m[3])})`;
                    }
                    if (m[0] === m[3] && m[1] === -m[2]) {
                      const a = Math.acos(m[0]) * 180 / Math.PI;
                      return `rotate(${pf(a)})`;
                    }
                  } else {
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                      return `translate(${pf(m[4])} ${pf(m[5])})`;
                    }
                  }
                  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
                };
                const SVG_DEFAULTS = {
                  fontStyle: "normal",
                  fontWeight: "normal",
                  fillColor: "#000000"
                };
                const XML_NS = "http://www.w3.org/XML/1998/namespace";
                const XLINK_NS = "http://www.w3.org/1999/xlink";
                const LINE_CAP_STYLES = ["butt", "round", "square"];
                const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                const createObjectURL = function(data, contentType = "", forceDataSchema = false) {
                  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                    return URL.createObjectURL(new Blob([data], {
                      type: contentType
                    }));
                  }
                  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  let buffer = `data:${contentType};base64,`;
                  for (let i = 0, ii = data.length; i < ii; i += 3) {
                    const b1 = data[i] & 255;
                    const b2 = data[i + 1] & 255;
                    const b3 = data[i + 2] & 255;
                    const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                    const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                    const d4 = i + 2 < ii ? b3 & 63 : 64;
                    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                  }
                  return buffer;
                };
                const convertImgDataToPng = function() {
                  const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                  const CHUNK_WRAPPER_SIZE = 12;
                  const crcTable = new Int32Array(256);
                  for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let h = 0; h < 8; h++) {
                      if (c & 1) {
                        c = 3988292384 ^ c >> 1 & 2147483647;
                      } else {
                        c = c >> 1 & 2147483647;
                      }
                    }
                    crcTable[i] = c;
                  }
                  function crc32(data, start2, end2) {
                    let crc = -1;
                    for (let i = start2; i < end2; i++) {
                      const a = (crc ^ data[i]) & 255;
                      const b = crcTable[a];
                      crc = crc >>> 8 ^ b;
                    }
                    return crc ^ -1;
                  }
                  function writePngChunk(type2, body, data, offset) {
                    let p = offset;
                    const len3 = body.length;
                    data[p] = len3 >> 24 & 255;
                    data[p + 1] = len3 >> 16 & 255;
                    data[p + 2] = len3 >> 8 & 255;
                    data[p + 3] = len3 & 255;
                    p += 4;
                    data[p] = type2.charCodeAt(0) & 255;
                    data[p + 1] = type2.charCodeAt(1) & 255;
                    data[p + 2] = type2.charCodeAt(2) & 255;
                    data[p + 3] = type2.charCodeAt(3) & 255;
                    p += 4;
                    data.set(body, p);
                    p += body.length;
                    const crc = crc32(data, offset + 4, p);
                    data[p] = crc >> 24 & 255;
                    data[p + 1] = crc >> 16 & 255;
                    data[p + 2] = crc >> 8 & 255;
                    data[p + 3] = crc & 255;
                  }
                  function adler32(data, start2, end2) {
                    let a = 1;
                    let b = 0;
                    for (let i = start2; i < end2; ++i) {
                      a = (a + (data[i] & 255)) % 65521;
                      b = (b + a) % 65521;
                    }
                    return b << 16 | a;
                  }
                  function deflateSync(literals) {
                    if (!_is_node2.isNodeJS) {
                      return deflateSyncUncompressed(literals);
                    }
                    try {
                      let input;
                      if (parseInt(process.versions.node) >= 8) {
                        input = literals;
                      } else {
                        input = Buffer.from(literals);
                      }
                      const output = require_zlib().deflateSync(input, {
                        level: 9
                      });
                      return output instanceof Uint8Array ? output : new Uint8Array(output);
                    } catch (e2) {
                      (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e2);
                    }
                    return deflateSyncUncompressed(literals);
                  }
                  function deflateSyncUncompressed(literals) {
                    let len3 = literals.length;
                    const maxBlockLength = 65535;
                    const deflateBlocks = Math.ceil(len3 / maxBlockLength);
                    const idat = new Uint8Array(2 + len3 + deflateBlocks * 5 + 4);
                    let pi = 0;
                    idat[pi++] = 120;
                    idat[pi++] = 156;
                    let pos = 0;
                    while (len3 > maxBlockLength) {
                      idat[pi++] = 0;
                      idat[pi++] = 255;
                      idat[pi++] = 255;
                      idat[pi++] = 0;
                      idat[pi++] = 0;
                      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                      pi += maxBlockLength;
                      pos += maxBlockLength;
                      len3 -= maxBlockLength;
                    }
                    idat[pi++] = 1;
                    idat[pi++] = len3 & 255;
                    idat[pi++] = len3 >> 8 & 255;
                    idat[pi++] = ~len3 & 65535 & 255;
                    idat[pi++] = (~len3 & 65535) >> 8 & 255;
                    idat.set(literals.subarray(pos), pi);
                    pi += literals.length - pos;
                    const adler = adler32(literals, 0, literals.length);
                    idat[pi++] = adler >> 24 & 255;
                    idat[pi++] = adler >> 16 & 255;
                    idat[pi++] = adler >> 8 & 255;
                    idat[pi++] = adler & 255;
                    return idat;
                  }
                  function encode(imgData, kind, forceDataSchema, isMask) {
                    const width = imgData.width;
                    const height = imgData.height;
                    let bitDepth, colorType, lineSize;
                    const bytes = imgData.data;
                    switch (kind) {
                      case _util2.ImageKind.GRAYSCALE_1BPP:
                        colorType = 0;
                        bitDepth = 1;
                        lineSize = width + 7 >> 3;
                        break;
                      case _util2.ImageKind.RGB_24BPP:
                        colorType = 2;
                        bitDepth = 8;
                        lineSize = width * 3;
                        break;
                      case _util2.ImageKind.RGBA_32BPP:
                        colorType = 6;
                        bitDepth = 8;
                        lineSize = width * 4;
                        break;
                      default:
                        throw new Error("invalid format");
                    }
                    const literals = new Uint8Array((1 + lineSize) * height);
                    let offsetLiterals = 0, offsetBytes = 0;
                    for (let y = 0; y < height; ++y) {
                      literals[offsetLiterals++] = 0;
                      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                      offsetBytes += lineSize;
                      offsetLiterals += lineSize;
                    }
                    if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                      offsetLiterals = 0;
                      for (let y = 0; y < height; y++) {
                        offsetLiterals++;
                        for (let i = 0; i < lineSize; i++) {
                          literals[offsetLiterals++] ^= 255;
                        }
                      }
                    }
                    const ihdr = new Uint8Array([width >> 24 & 255, width >> 16 & 255, width >> 8 & 255, width & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                    const idat = deflateSync(literals);
                    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                    const data = new Uint8Array(pngLength);
                    let offset = 0;
                    data.set(PNG_HEADER, offset);
                    offset += PNG_HEADER.length;
                    writePngChunk("IHDR", ihdr, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                    writePngChunk("IDATA", idat, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + idat.length;
                    writePngChunk("IEND", new Uint8Array(0), data, offset);
                    return createObjectURL(data, "image/png", forceDataSchema);
                  }
                  return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                    const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                    return encode(imgData, kind, forceDataSchema, isMask);
                  };
                }();
                class SVGExtraState {
                  constructor() {
                    this.fontSizeScale = 1;
                    this.fontWeight = SVG_DEFAULTS.fontWeight;
                    this.fontSize = 0;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textMatrixScale = 1;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                    this.fillColor = SVG_DEFAULTS.fillColor;
                    this.strokeColor = "#000000";
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.lineJoin = "";
                    this.lineCap = "";
                    this.miterLimit = 0;
                    this.dashArray = [];
                    this.dashPhase = 0;
                    this.dependencies = [];
                    this.activeClipUrl = null;
                    this.clipGroup = null;
                    this.maskId = "";
                  }
                  clone() {
                    return Object.create(this);
                  }
                  setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                }
                let clipCount = 0;
                let maskCount = 0;
                let shadingCount = 0;
                exports2.SVGGraphics = SVGGraphics = class {
                  constructor(commonObjs, objs, forceDataSchema = false) {
                    (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                    this.svgFactory = new _display_utils2.DOMSVGFactory();
                    this.current = new SVGExtraState();
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.transformStack = [];
                    this.extraStack = [];
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.embedFonts = false;
                    this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                    this.cssStyle = null;
                    this.forceDataSchema = !!forceDataSchema;
                    this._operatorIdMapping = [];
                    for (const op in _util2.OPS) {
                      this._operatorIdMapping[_util2.OPS[op]] = op;
                    }
                  }
                  save() {
                    this.transformStack.push(this.transformMatrix);
                    const old = this.current;
                    this.extraStack.push(old);
                    this.current = old.clone();
                  }
                  restore() {
                    this.transformMatrix = this.transformStack.pop();
                    this.current = this.extraStack.pop();
                    this.pendingClip = null;
                    this.tgrp = null;
                  }
                  group(items) {
                    this.save();
                    this.executeOpTree(items);
                    this.restore();
                  }
                  loadDependencies(operatorList) {
                    const fnArray = operatorList.fnArray;
                    const argsArray = operatorList.argsArray;
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      if (fnArray[i] !== _util2.OPS.dependency) {
                        continue;
                      }
                      for (const obj2 of argsArray[i]) {
                        const objsPool = obj2.startsWith("g_") ? this.commonObjs : this.objs;
                        const promise = new Promise((resolve) => {
                          objsPool.get(obj2, resolve);
                        });
                        this.current.dependencies.push(promise);
                      }
                    }
                    return Promise.all(this.current.dependencies);
                  }
                  transform(a, b, c, d, e2, f) {
                    const transformMatrix = [a, b, c, d, e2, f];
                    this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                    this.tgrp = null;
                  }
                  getSVG(operatorList, viewport) {
                    this.viewport = viewport;
                    const svgElement = this._initialize(viewport);
                    return this.loadDependencies(operatorList).then(() => {
                      this.transformMatrix = _util2.IDENTITY_MATRIX;
                      this.executeOpTree(this.convertOpList(operatorList));
                      return svgElement;
                    });
                  }
                  convertOpList(operatorList) {
                    const operatorIdMapping = this._operatorIdMapping;
                    const argsArray = operatorList.argsArray;
                    const fnArray = operatorList.fnArray;
                    const opList = [];
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      const fnId = fnArray[i];
                      opList.push({
                        fnId,
                        fn: operatorIdMapping[fnId],
                        args: argsArray[i]
                      });
                    }
                    return opListToTree(opList);
                  }
                  executeOpTree(opTree) {
                    for (const opTreeElement of opTree) {
                      const fn = opTreeElement.fn;
                      const fnId = opTreeElement.fnId;
                      const args = opTreeElement.args;
                      switch (fnId | 0) {
                        case _util2.OPS.beginText:
                          this.beginText();
                          break;
                        case _util2.OPS.dependency:
                          break;
                        case _util2.OPS.setLeading:
                          this.setLeading(args);
                          break;
                        case _util2.OPS.setLeadingMoveText:
                          this.setLeadingMoveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setFont:
                          this.setFont(args);
                          break;
                        case _util2.OPS.showText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.showSpacedText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.endText:
                          this.endText();
                          break;
                        case _util2.OPS.moveText:
                          this.moveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setCharSpacing:
                          this.setCharSpacing(args[0]);
                          break;
                        case _util2.OPS.setWordSpacing:
                          this.setWordSpacing(args[0]);
                          break;
                        case _util2.OPS.setHScale:
                          this.setHScale(args[0]);
                          break;
                        case _util2.OPS.setTextMatrix:
                          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.setTextRise:
                          this.setTextRise(args[0]);
                          break;
                        case _util2.OPS.setTextRenderingMode:
                          this.setTextRenderingMode(args[0]);
                          break;
                        case _util2.OPS.setLineWidth:
                          this.setLineWidth(args[0]);
                          break;
                        case _util2.OPS.setLineJoin:
                          this.setLineJoin(args[0]);
                          break;
                        case _util2.OPS.setLineCap:
                          this.setLineCap(args[0]);
                          break;
                        case _util2.OPS.setMiterLimit:
                          this.setMiterLimit(args[0]);
                          break;
                        case _util2.OPS.setFillRGBColor:
                          this.setFillRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeRGBColor:
                          this.setStrokeRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeColorN:
                          this.setStrokeColorN(args);
                          break;
                        case _util2.OPS.setFillColorN:
                          this.setFillColorN(args);
                          break;
                        case _util2.OPS.shadingFill:
                          this.shadingFill(args[0]);
                          break;
                        case _util2.OPS.setDash:
                          this.setDash(args[0], args[1]);
                          break;
                        case _util2.OPS.setRenderingIntent:
                          this.setRenderingIntent(args[0]);
                          break;
                        case _util2.OPS.setFlatness:
                          this.setFlatness(args[0]);
                          break;
                        case _util2.OPS.setGState:
                          this.setGState(args[0]);
                          break;
                        case _util2.OPS.fill:
                          this.fill();
                          break;
                        case _util2.OPS.eoFill:
                          this.eoFill();
                          break;
                        case _util2.OPS.stroke:
                          this.stroke();
                          break;
                        case _util2.OPS.fillStroke:
                          this.fillStroke();
                          break;
                        case _util2.OPS.eoFillStroke:
                          this.eoFillStroke();
                          break;
                        case _util2.OPS.clip:
                          this.clip("nonzero");
                          break;
                        case _util2.OPS.eoClip:
                          this.clip("evenodd");
                          break;
                        case _util2.OPS.paintSolidColorImageMask:
                          this.paintSolidColorImageMask();
                          break;
                        case _util2.OPS.paintImageXObject:
                          this.paintImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintInlineImageXObject:
                          this.paintInlineImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintImageMaskXObject:
                          this.paintImageMaskXObject(args[0]);
                          break;
                        case _util2.OPS.paintFormXObjectBegin:
                          this.paintFormXObjectBegin(args[0], args[1]);
                          break;
                        case _util2.OPS.paintFormXObjectEnd:
                          this.paintFormXObjectEnd();
                          break;
                        case _util2.OPS.closePath:
                          this.closePath();
                          break;
                        case _util2.OPS.closeStroke:
                          this.closeStroke();
                          break;
                        case _util2.OPS.closeFillStroke:
                          this.closeFillStroke();
                          break;
                        case _util2.OPS.closeEOFillStroke:
                          this.closeEOFillStroke();
                          break;
                        case _util2.OPS.nextLine:
                          this.nextLine();
                          break;
                        case _util2.OPS.transform:
                          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.constructPath:
                          this.constructPath(args[0], args[1]);
                          break;
                        case _util2.OPS.endPath:
                          this.endPath();
                          break;
                        case 92:
                          this.group(opTreeElement.items);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented operator ${fn}`);
                          break;
                      }
                    }
                  }
                  setWordSpacing(wordSpacing) {
                    this.current.wordSpacing = wordSpacing;
                  }
                  setCharSpacing(charSpacing) {
                    this.current.charSpacing = charSpacing;
                  }
                  nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                  setTextMatrix(a, b, c, d, e2, f) {
                    const current = this.current;
                    current.textMatrix = current.lineMatrix = [a, b, c, d, e2, f];
                    current.textMatrixScale = Math.hypot(a, b);
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtElement.append(current.tspan);
                  }
                  beginText() {
                    const current = this.current;
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.textMatrix = _util2.IDENTITY_MATRIX;
                    current.lineMatrix = _util2.IDENTITY_MATRIX;
                    current.textMatrixScale = 1;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtgrp = this.svgFactory.createElement("svg:g");
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  moveText(x, y) {
                    const current = this.current;
                    current.x = current.lineX += x;
                    current.y = current.lineY += y;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  showText(glyphs) {
                    const current = this.current;
                    const font = current.font;
                    const fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return;
                    }
                    const fontSizeScale = current.fontSizeScale;
                    const charSpacing = current.charSpacing;
                    const wordSpacing = current.wordSpacing;
                    const fontDirection = current.fontDirection;
                    const textHScale = current.textHScale * fontDirection;
                    const vertical = font.vertical;
                    const spacingDir = vertical ? 1 : -1;
                    const defaultVMetrics = font.defaultVMetrics;
                    const widthAdvanceScale = fontSize * current.fontMatrix[0];
                    let x = 0;
                    for (const glyph of glyphs) {
                      if (glyph === null) {
                        x += fontDirection * wordSpacing;
                        continue;
                      } else if (typeof glyph === "number") {
                        x += spacingDir * glyph * fontSize / 1e3;
                        continue;
                      }
                      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      const character = glyph.fontChar;
                      let scaledX, scaledY;
                      let width = glyph.width;
                      if (vertical) {
                        let vx;
                        const vmetric = glyph.vmetric || defaultVMetrics;
                        vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                        vx = -vx * widthAdvanceScale;
                        const vy = vmetric[2] * widthAdvanceScale;
                        width = vmetric ? -vmetric[0] : width;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (glyph.isInFont || font.missingFile) {
                        current.xcoords.push(current.x + scaledX);
                        if (vertical) {
                          current.ycoords.push(-current.y + scaledY);
                        }
                        current.tspan.textContent += character;
                      } else {
                      }
                      let charWidth;
                      if (vertical) {
                        charWidth = width * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                    }
                    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                    if (vertical) {
                      current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                    } else {
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                    }
                    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                    }
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                        current.tspan.setAttributeNS(null, "fill", current.fillColor);
                      }
                      if (current.fillAlpha < 1) {
                        current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      }
                    } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                      current.tspan.setAttributeNS(null, "fill", "transparent");
                    } else {
                      current.tspan.setAttributeNS(null, "fill", "none");
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      const lineWidthScale = 1 / (current.textMatrixScale || 1);
                      this._setStrokeAttributes(current.tspan, lineWidthScale);
                    }
                    let textMatrix = current.textMatrix;
                    if (current.textRise !== 0) {
                      textMatrix = textMatrix.slice();
                      textMatrix[5] += current.textRise;
                    }
                    current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                    current.txtElement.append(current.tspan);
                    current.txtgrp.append(current.txtElement);
                    this._ensureTransformGroup().append(current.txtElement);
                  }
                  setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                  addFontStyle(fontObj) {
                    if (!fontObj.data) {
                      throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                    }
                    if (!this.cssStyle) {
                      this.cssStyle = this.svgFactory.createElement("svg:style");
                      this.cssStyle.setAttributeNS(null, "type", "text/css");
                      this.defs.append(this.cssStyle);
                    }
                    const url2 = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                    this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url2}); }
`;
                  }
                  setFont(details) {
                    const current = this.current;
                    const fontObj = this.commonObjs.get(details[0]);
                    let size2 = details[1];
                    current.font = fontObj;
                    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                      this.addFontStyle(fontObj);
                      this.embeddedFonts[fontObj.loadedName] = fontObj;
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    let bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    const italic = fontObj.italic ? "italic" : "normal";
                    if (size2 < 0) {
                      size2 = -size2;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    current.fontSize = size2;
                    current.fontFamily = fontObj.loadedName;
                    current.fontWeight = bold;
                    current.fontStyle = italic;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  endText() {
                    const current = this.current;
                    if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
                      current.element = current.txtElement;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  setLineWidth(width) {
                    if (width > 0) {
                      this.current.lineWidth = width;
                    }
                  }
                  setLineCap(style) {
                    this.current.lineCap = LINE_CAP_STYLES[style];
                  }
                  setLineJoin(style) {
                    this.current.lineJoin = LINE_JOIN_STYLES[style];
                  }
                  setMiterLimit(limit) {
                    this.current.miterLimit = limit;
                  }
                  setStrokeAlpha(strokeAlpha) {
                    this.current.strokeAlpha = strokeAlpha;
                  }
                  setStrokeRGBColor(r, g, b) {
                    this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                  }
                  setFillAlpha(fillAlpha) {
                    this.current.fillAlpha = fillAlpha;
                  }
                  setFillRGBColor(r, g, b) {
                    this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.xcoords = [];
                    this.current.ycoords = [];
                  }
                  setStrokeColorN(args) {
                    this.current.strokeColor = this._makeColorN_Pattern(args);
                  }
                  setFillColorN(args) {
                    this.current.fillColor = this._makeColorN_Pattern(args);
                  }
                  shadingFill(args) {
                    const width = this.viewport.width;
                    const height = this.viewport.height;
                    const inv = _util2.Util.inverseTransform(this.transformMatrix);
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width, 0], inv);
                    const ur = _util2.Util.applyTransform([width, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", x0);
                    rect.setAttributeNS(null, "y", y0);
                    rect.setAttributeNS(null, "width", x1 - x0);
                    rect.setAttributeNS(null, "height", y1 - y0);
                    rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                    if (this.current.fillAlpha < 1) {
                      rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                    }
                    this._ensureTransformGroup().append(rect);
                  }
                  _makeColorN_Pattern(args) {
                    if (args[0] === "TilingPattern") {
                      return this._makeTilingPattern(args);
                    }
                    return this._makeShadingPattern(args);
                  }
                  _makeTilingPattern(args) {
                    const color = args[1];
                    const operatorList = args[2];
                    const matrix = args[3] || _util2.IDENTITY_MATRIX;
                    const [x0, y0, x1, y1] = args[4];
                    const xstep = args[5];
                    const ystep = args[6];
                    const paintType = args[7];
                    const tilingId = `shading${shadingCount++}`;
                    const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                    const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                    const txstep = xstep * xscale;
                    const tystep = ystep * yscale;
                    const tiling = this.svgFactory.createElement("svg:pattern");
                    tiling.setAttributeNS(null, "id", tilingId);
                    tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                    tiling.setAttributeNS(null, "width", txstep);
                    tiling.setAttributeNS(null, "height", tystep);
                    tiling.setAttributeNS(null, "x", `${tx0}`);
                    tiling.setAttributeNS(null, "y", `${ty0}`);
                    const svg = this.svg;
                    const transformMatrix = this.transformMatrix;
                    const fillColor = this.current.fillColor;
                    const strokeColor = this.current.strokeColor;
                    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                    this.svg = bbox;
                    this.transformMatrix = matrix;
                    if (paintType === 2) {
                      const cssColor = _util2.Util.makeHexColor(...color);
                      this.current.fillColor = cssColor;
                      this.current.strokeColor = cssColor;
                    }
                    this.executeOpTree(this.convertOpList(operatorList));
                    this.svg = svg;
                    this.transformMatrix = transformMatrix;
                    this.current.fillColor = fillColor;
                    this.current.strokeColor = strokeColor;
                    tiling.append(bbox.childNodes[0]);
                    this.defs.append(tiling);
                    return `url(#${tilingId})`;
                  }
                  _makeShadingPattern(args) {
                    if (typeof args === "string") {
                      args = this.objs.get(args);
                    }
                    switch (args[0]) {
                      case "RadialAxial":
                        const shadingId = `shading${shadingCount++}`;
                        const colorStops = args[3];
                        let gradient;
                        switch (args[1]) {
                          case "axial":
                            const point0 = args[4];
                            const point1 = args[5];
                            gradient = this.svgFactory.createElement("svg:linearGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "x1", point0[0]);
                            gradient.setAttributeNS(null, "y1", point0[1]);
                            gradient.setAttributeNS(null, "x2", point1[0]);
                            gradient.setAttributeNS(null, "y2", point1[1]);
                            break;
                          case "radial":
                            const focalPoint = args[4];
                            const circlePoint = args[5];
                            const focalRadius = args[6];
                            const circleRadius = args[7];
                            gradient = this.svgFactory.createElement("svg:radialGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "cx", circlePoint[0]);
                            gradient.setAttributeNS(null, "cy", circlePoint[1]);
                            gradient.setAttributeNS(null, "r", circleRadius);
                            gradient.setAttributeNS(null, "fx", focalPoint[0]);
                            gradient.setAttributeNS(null, "fy", focalPoint[1]);
                            gradient.setAttributeNS(null, "fr", focalRadius);
                            break;
                          default:
                            throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                        }
                        for (const colorStop of colorStops) {
                          const stop = this.svgFactory.createElement("svg:stop");
                          stop.setAttributeNS(null, "offset", colorStop[0]);
                          stop.setAttributeNS(null, "stop-color", colorStop[1]);
                          gradient.append(stop);
                        }
                        this.defs.append(gradient);
                        return `url(#${shadingId})`;
                      case "Mesh":
                        (0, _util2.warn)("Unimplemented pattern Mesh");
                        return null;
                      case "Dummy":
                        return "hotpink";
                      default:
                        throw new Error(`Unknown IR type: ${args[0]}`);
                    }
                  }
                  setDash(dashArray, dashPhase) {
                    this.current.dashArray = dashArray;
                    this.current.dashPhase = dashPhase;
                  }
                  constructPath(ops, args) {
                    const current = this.current;
                    let x = current.x, y = current.y;
                    let d = [];
                    let j = 0;
                    for (const op of ops) {
                      switch (op | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          const width = args[j++];
                          const height = args[j++];
                          const xw = x + width;
                          const yh = y + height;
                          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("M", pf(x), pf(y));
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("L", pf(x), pf(y));
                          break;
                        case _util2.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          d.push("Z");
                          break;
                      }
                    }
                    d = d.join(" ");
                    if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                      d = current.path.getAttributeNS(null, "d") + d;
                    } else {
                      current.path = this.svgFactory.createElement("svg:path");
                      this._ensureTransformGroup().append(current.path);
                    }
                    current.path.setAttributeNS(null, "d", d);
                    current.path.setAttributeNS(null, "fill", "none");
                    current.element = current.path;
                    current.setCurrentPoint(x, y);
                  }
                  endPath() {
                    const current = this.current;
                    current.path = null;
                    if (!this.pendingClip) {
                      return;
                    }
                    if (!current.element) {
                      this.pendingClip = null;
                      return;
                    }
                    const clipId = `clippath${clipCount++}`;
                    const clipPath = this.svgFactory.createElement("svg:clipPath");
                    clipPath.setAttributeNS(null, "id", clipId);
                    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    const clipElement = current.element.cloneNode(true);
                    if (this.pendingClip === "evenodd") {
                      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                    } else {
                      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                    }
                    this.pendingClip = null;
                    clipPath.append(clipElement);
                    this.defs.append(clipPath);
                    if (current.activeClipUrl) {
                      current.clipGroup = null;
                      for (const prev of this.extraStack) {
                        prev.clipGroup = null;
                      }
                      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                    }
                    current.activeClipUrl = `url(#${clipId})`;
                    this.tgrp = null;
                  }
                  clip(type2) {
                    this.pendingClip = type2;
                  }
                  closePath() {
                    const current = this.current;
                    if (current.path) {
                      const d = `${current.path.getAttributeNS(null, "d")}Z`;
                      current.path.setAttributeNS(null, "d", d);
                    }
                  }
                  setLeading(leading) {
                    this.current.leading = -leading;
                  }
                  setTextRise(textRise) {
                    this.current.textRise = textRise;
                  }
                  setTextRenderingMode(textRenderingMode) {
                    this.current.textRenderingMode = textRenderingMode;
                  }
                  setHScale(scale3) {
                    this.current.textHScale = scale3 / 100;
                  }
                  setRenderingIntent(intent) {
                  }
                  setFlatness(flatness) {
                  }
                  setGState(states) {
                    for (const [key, value] of states) {
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value);
                          break;
                        case "LC":
                          this.setLineCap(value);
                          break;
                        case "LJ":
                          this.setLineJoin(value);
                          break;
                        case "ML":
                          this.setMiterLimit(value);
                          break;
                        case "D":
                          this.setDash(value[0], value[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value);
                          break;
                        case "FL":
                          this.setFlatness(value);
                          break;
                        case "Font":
                          this.setFont(value);
                          break;
                        case "CA":
                          this.setStrokeAlpha(value);
                          break;
                        case "ca":
                          this.setFillAlpha(value);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                          break;
                      }
                    }
                  }
                  fill() {
                    const current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "fill", current.fillColor);
                      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      this.endPath();
                    }
                  }
                  stroke() {
                    const current = this.current;
                    if (current.element) {
                      this._setStrokeAttributes(current.element);
                      current.element.setAttributeNS(null, "fill", "none");
                      this.endPath();
                    }
                  }
                  _setStrokeAttributes(element, lineWidthScale = 1) {
                    const current = this.current;
                    let dashArray = current.dashArray;
                    if (lineWidthScale !== 1 && dashArray.length > 0) {
                      dashArray = dashArray.map(function(value) {
                        return lineWidthScale * value;
                      });
                    }
                    element.setAttributeNS(null, "stroke", current.strokeColor);
                    element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                    element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                    element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                    element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                    element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                    element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                    element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                  }
                  eoFill() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fill();
                  }
                  fillStroke() {
                    this.stroke();
                    this.fill();
                  }
                  eoFillStroke() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fillStroke();
                  }
                  closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                  closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                  closeEOFillStroke() {
                    this.closePath();
                    this.eoFillStroke();
                  }
                  paintSolidColorImageMask() {
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", "1px");
                    rect.setAttributeNS(null, "height", "1px");
                    rect.setAttributeNS(null, "fill", this.current.fillColor);
                    this._ensureTransformGroup().append(rect);
                  }
                  paintImageXObject(objId) {
                    const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                  paintInlineImageXObject(imgData, mask) {
                    const width = imgData.width;
                    const height = imgData.height;
                    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", "0");
                    cliprect.setAttributeNS(null, "y", "0");
                    cliprect.setAttributeNS(null, "width", pf(width));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    const imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-height));
                    imgEl.setAttributeNS(null, "width", pf(width) + "px");
                    imgEl.setAttributeNS(null, "height", pf(height) + "px");
                    imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);
                    if (mask) {
                      mask.append(imgEl);
                    } else {
                      this._ensureTransformGroup().append(imgEl);
                    }
                  }
                  paintImageMaskXObject(imgData) {
                    const current = this.current;
                    const width = imgData.width;
                    const height = imgData.height;
                    const fillColor = current.fillColor;
                    current.maskId = `mask${maskCount++}`;
                    const mask = this.svgFactory.createElement("svg:mask");
                    mask.setAttributeNS(null, "id", current.maskId);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", pf(width));
                    rect.setAttributeNS(null, "height", pf(height));
                    rect.setAttributeNS(null, "fill", fillColor);
                    rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                    this.defs.append(mask);
                    this._ensureTransformGroup().append(rect);
                    this.paintInlineImageXObject(imgData, mask);
                  }
                  paintFormXObjectBegin(matrix, bbox) {
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                    }
                    if (bbox) {
                      const width = bbox[2] - bbox[0];
                      const height = bbox[3] - bbox[1];
                      const cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", bbox[0]);
                      cliprect.setAttributeNS(null, "y", bbox[1]);
                      cliprect.setAttributeNS(null, "width", pf(width));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  paintFormXObjectEnd() {
                  }
                  _initialize(viewport) {
                    const svg = this.svgFactory.create(viewport.width, viewport.height);
                    const definitions = this.svgFactory.createElement("svg:defs");
                    svg.append(definitions);
                    this.defs = definitions;
                    const rootGroup = this.svgFactory.createElement("svg:g");
                    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                    svg.append(rootGroup);
                    this.svg = rootGroup;
                    return svg;
                  }
                  _ensureClipGroup() {
                    if (!this.current.clipGroup) {
                      const clipGroup = this.svgFactory.createElement("svg:g");
                      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                      this.svg.append(clipGroup);
                      this.current.clipGroup = clipGroup;
                    }
                    return this.current.clipGroup;
                  }
                  _ensureTransformGroup() {
                    if (!this.tgrp) {
                      this.tgrp = this.svgFactory.createElement("svg:g");
                      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      if (this.current.activeClipUrl) {
                        this._ensureClipGroup().append(this.tgrp);
                      } else {
                        this.svg.append(this.tgrp);
                      }
                    }
                    return this.tgrp;
                  }
                };
              }
            },
            /* 32 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              const fs = require_fs();
              const http = require_http();
              const https = require_https();
              const url2 = require_url();
              const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                const parsedUrl = url2.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url2.parse(`file:///${sourceUrl}`);
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              class PDFNodeStream {
                constructor(source) {
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(start2, end2) {
                  if (end2 <= this._progressiveDataLength) {
                    return null;
                  }
                  const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start2, end2) : new PDFNodeStreamRangeReader(this, start2, end2);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNodeStream = PDFNodeStream;
              class BaseFullReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  const source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              class BaseRangeReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  const source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              class PDFNodeStreamFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._headersCapability.resolve();
                    this._setReadableStream(response);
                    const getResponseHeader = (name) => {
                      return this._readableStream.headers[name.toLowerCase()];
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                    this._headersCapability.reject(reason);
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamRangeReader extends BaseRangeReader {
                constructor(stream, start2, end2) {
                  super(stream);
                  this._httpHeaders = {};
                  for (const property in stream.httpHeaders) {
                    const value = stream.httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    this._httpHeaders[property] = value;
                  }
                  this._httpHeaders.Range = `bytes=${start2}-${end2 - 1}`;
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      return;
                    }
                    this._setReadableStream(response);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamFsFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  fs.lstat(path, (error, stat) => {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                      }
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._contentLength = stat.size;
                    this._setReadableStream(fs.createReadStream(path));
                    this._headersCapability.resolve();
                  });
                }
              }
              class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                constructor(stream, start2, end2) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  this._setReadableStream(fs.createReadStream(path, {
                    start: start2,
                    end: end2 - 1
                  }));
                }
              }
            },
            /* 33 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(34);
              var _display_utils2 = __w_pdfjs_require__2(8);
              function validateRangeRequestCapabilities({
                getResponseHeader,
                isHttp,
                rangeChunkSize,
                disableRange
              }) {
                const returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                const length3 = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length3)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length3;
                if (length3 <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                const contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch (ex) {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url2) {
                if (status === 404 || status === 0 && url2.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url2 + '".');
                }
                return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url2}".`, status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            /* 34 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                let needsEncodingFixup = true;
                let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  const filename = rfc2047decode(tmp);
                  return fixupEncoding(filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value)) {
                      return value;
                    }
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = (0, _util2.stringToBytes)(value);
                      value = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch (e2) {
                    }
                  }
                  return value;
                }
                function fixupEncoding(value) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
                    value = textdecode("utf-8", value);
                    if (needsEncodingFixup) {
                      value = textdecode("iso-8859-1", value);
                    }
                  }
                  return value;
                }
                function rfc2231getparam(contentDispositionStr) {
                  const matches = [];
                  let match;
                  const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    let [, n2, quot, part] = match;
                    n2 = parseInt(n2, 10);
                    if (n2 in matches) {
                      if (n2 === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n2] = [quot, part];
                  }
                  const parts = [];
                  for (let n2 = 0; n2 < matches.length; ++n2) {
                    if (!(n2 in matches)) {
                      break;
                    }
                    let [quot, part] = matches[n2];
                    part = rfc2616unquote(part);
                    if (quot) {
                      part = unescape(part);
                      if (n2 === 0) {
                        part = rfc5987decode(part);
                      }
                    }
                    parts.push(part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value) {
                  if (value.startsWith('"')) {
                    const parts = value.slice(1).split('\\"');
                    for (let i = 0; i < parts.length; ++i) {
                      const quotindex = parts[i].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i] = parts[i].slice(0, quotindex);
                        parts.length = i + 1;
                      }
                      parts[i] = parts[i].replace(/\\(.)/g, "$1");
                    }
                    value = parts.join('"');
                  }
                  return value;
                }
                function rfc5987decode(extvalue) {
                  const encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  const encoding = extvalue.slice(0, encodingend);
                  const langvalue = extvalue.slice(encodingend + 1);
                  const value = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value);
                }
                function rfc2047decode(value) {
                  if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
                    return value;
                  }
                  return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text2) {
                    if (encoding === "q" || encoding === "Q") {
                      text2 = text2.replace(/_/g, " ");
                      text2 = text2.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text2);
                    }
                    try {
                      text2 = atob(text2);
                    } catch (e2) {
                    }
                    return textdecode(charset, text2);
                  });
                }
                return "";
              }
            },
            /* 35 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              const OK_RESPONSE = 200;
              const PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                const data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                const array = (0, _util2.stringToBytes)(data);
                return array.buffer;
              }
              class NetworkManager {
                constructor(url2, args = {}) {
                  this.url = url2;
                  this.isHttp = /^https?:/i.test(url2);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                    return new XMLHttpRequest();
                  };
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                requestRange(begin, end2, listeners) {
                  const args = {
                    begin,
                    end: end2
                  };
                  for (const prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
                requestFull(listeners) {
                  return this.request(listeners);
                }
                request(args) {
                  const xhr = this.getXhr();
                  const xhrId = this.currXhrId++;
                  const pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (const property in this.httpHeaders) {
                    const value = this.httpHeaders[property];
                    if (typeof value === "undefined") {
                      continue;
                    }
                    xhr.setRequestHeader(property, value);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
                onProgress(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  pendingRequest.onProgress?.(evt);
                }
                onStateChange(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  const xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    pendingRequest.onError?.(xhr.status);
                    return;
                  }
                  const xhrStatus = xhr.status || OK_RESPONSE;
                  const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    pendingRequest.onError?.(xhr.status);
                    return;
                  }
                  const chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    const rangeHeader = xhr.getResponseHeader("Content-Range");
                    const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else {
                    pendingRequest.onError?.(xhr.status);
                  }
                }
                getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
                isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
                abortRequest(xhrId) {
                  const xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }
              class PDFNetworkStream {
                constructor(source) {
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _onRangeRequestReaderClosed(reader) {
                  const i = this._rangeRequestReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeRequestReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end2) {
                  const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end2);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  this._fullRequestReader?.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNetworkStream = PDFNetworkStream;
              class PDFNetworkStreamFullRequestReader {
                constructor(manager, source) {
                  this._manager = manager;
                  const args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _onHeadersReceived() {
                  const fullRequestXhrId = this._fullRequestId;
                  const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  const getResponseHeader = (name) => {
                    return fullRequestXhr.getResponseHeader(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
                _onDone(data) {
                  if (data) {
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: data.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(data.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  this._headersReceivedCapability.reject(this._storedError);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._cachedChunks.length = 0;
                }
                _onProgress(evt) {
                  this.onProgress?.({
                    loaded: evt.loaded,
                    total: evt.lengthComputable ? evt.total : this._contentLength
                  });
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get headersReady() {
                  return this._headersReceivedCapability.promise;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }
              class PDFNetworkStreamRangeRequestReader {
                constructor(manager, begin, end2) {
                  this._manager = manager;
                  const args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end2, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _close() {
                  this.onClosed?.(this);
                }
                _onDone(data) {
                  const chunk = data.chunk;
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._close();
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._queuedChunk = null;
                }
                _onProgress(evt) {
                  if (!this.isStreamingSupported) {
                    this.onProgress?.({
                      loaded: evt.loaded
                    });
                  }
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }
            },
            /* 36 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                const headers = new Headers();
                for (const property in httpHeaders) {
                  const value = httpHeaders[property];
                  if (typeof value === "undefined") {
                    continue;
                  }
                  headers.append(property, value);
                }
                return headers;
              }
              class PDFFetchStream {
                constructor(source) {
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end2) {
                  if (end2 <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFFetchStreamRangeReader(this, begin, end2);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFFetchStream = PDFFetchStream;
              class PDFFetchStreamReader {
                constructor(stream) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._abortController = new AbortController();
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  const url2 = source.url;
                  fetch(url2, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url2);
                    }
                    this._reader = response.body.getReader();
                    this._headersCapability.resolve();
                    const getResponseHeader = (name) => {
                      return response.headers.get(name);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  }).catch(this._headersCapability.reject);
                  this.onProgress = null;
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._headersCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(value).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
              class PDFFetchStreamRangeReader {
                constructor(stream, begin, end2) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._isStreamingSupported = !source.disableStream;
                  this._abortController = new AbortController();
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", `bytes=${begin}-${end2 - 1}`);
                  const url2 = source.url;
                  fetch(url2, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url2);
                    }
                    this._readCapability.resolve();
                    this._reader = response.body.getReader();
                  }).catch(this._readCapability.reject);
                  this.onProgress = null;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  const {
                    value,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value,
                      done
                    };
                  }
                  this._loaded += value.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(value).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AnnotationEditorLayer", {
              enumerable: true,
              get: function() {
                return _annotation_editor_layer.AnnotationEditorLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorParamsType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorParamsType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorUIManager", {
              enumerable: true,
              get: function() {
                return _tools.AnnotationEditorUIManager;
              }
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "LoopbackPort", {
              enumerable: true,
              get: function() {
                return _api.LoopbackPort;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            Object.defineProperty(exports2, "SVGGraphics", {
              enumerable: true,
              get: function() {
                return _svg.SVGGraphics;
              }
            });
            Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
              enumerable: true,
              get: function() {
                return _util2.UNSUPPORTED_FEATURES;
              }
            });
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createPromiseCapability", {
              enumerable: true,
              get: function() {
                return _util2.createPromiseCapability;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(4);
            var _display_utils2 = __w_pdfjs_require__(8);
            var _annotation_editor_layer = __w_pdfjs_require__(22);
            var _tools = __w_pdfjs_require__(7);
            var _annotation_layer = __w_pdfjs_require__(27);
            var _worker_options2 = __w_pdfjs_require__(15);
            var _is_node2 = __w_pdfjs_require__(3);
            var _text_layer = __w_pdfjs_require__(30);
            var _svg = __w_pdfjs_require__(31);
            var _xfa_layer = __w_pdfjs_require__(29);
            const pdfjsVersion = "2.16.105";
            const pdfjsBuild = "172ccdbe5";
            {
              if (_is_node2.isNodeJS) {
                const {
                  PDFNodeStream
                } = __w_pdfjs_require__(32);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  return new PDFNodeStream(params);
                });
              } else {
                const {
                  PDFNetworkStream
                } = __w_pdfjs_require__(35);
                const {
                  PDFFetchStream
                } = __w_pdfjs_require__(36);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  if ((0, _display_utils2.isValidFetchUrl)(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/typeChecks.ts
function t(o, s, c) {
  return typeof o === s || o instanceof c;
}
function isFunction(obj2) {
  return t(obj2, "function", Function);
}
function isString(obj2) {
  return t(obj2, "string", String);
}
function isBoolean(obj2) {
  return t(obj2, "boolean", Boolean);
}
function isNumber(obj2) {
  return t(obj2, "number", Number);
}
function isObject(obj2) {
  return isDefined(obj2) && t(obj2, "object", Object);
}
function isArray(obj2) {
  return obj2 instanceof Array;
}
function assertNever(x, msg) {
  throw new Error((msg || "Unexpected object: ") + x);
}
function isNullOrUndefined(obj2) {
  return obj2 === null || obj2 === void 0;
}
function isDefined(obj2) {
  return !isNullOrUndefined(obj2);
}
function isArrayBufferView(obj2) {
  return obj2 instanceof Uint8Array || obj2 instanceof Uint8ClampedArray || obj2 instanceof Int8Array || obj2 instanceof Uint16Array || obj2 instanceof Int16Array || obj2 instanceof Uint32Array || obj2 instanceof Int32Array || obj2 instanceof Float32Array || obj2 instanceof Float64Array || "BigUint64Array" in globalThis && obj2 instanceof globalThis["BigUint64Array"] || "BigInt64Array" in globalThis && obj2 instanceof globalThis["BigInt64Array"];
}
function isArrayBuffer(val) {
  return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
  val.constructor && val.constructor.name === "ArrayBuffer");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/arrays.ts
function arrayClear(arr) {
  return arr.splice(0);
}
function arrayCompare(arr1, arr2) {
  for (let i = 0; i < arr1.length; ++i) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return -1;
}
function arrayRemove(arr, value) {
  const idx = arr.indexOf(value);
  if (idx > -1) {
    arrayRemoveAt(arr, idx);
    return true;
  }
  return false;
}
function arrayRemoveAt(arr, idx) {
  return arr.splice(idx, 1)[0];
}
function _arrayScan(forward, arr, tests) {
  const start2 = forward ? 0 : arr.length - 1;
  const end2 = forward ? arr.length : -1;
  const inc = forward ? 1 : -1;
  for (const test of tests) {
    for (let i = start2; i != end2; i += inc) {
      const item = arr[i];
      if (test(item)) {
        return item;
      }
    }
  }
  return null;
}
function arrayScan(arr, ...tests) {
  return _arrayScan(true, arr, tests);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/EventBase.ts
var EventBase = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.listenerOptions = /* @__PURE__ */ new Map();
  }
  addEventListener(type2, callback, options) {
    if (isFunction(callback)) {
      let listeners = this.listeners.get(type2);
      if (!listeners) {
        listeners = new Array();
        this.listeners.set(type2, listeners);
      }
      if (!listeners.find((c) => c === callback)) {
        listeners.push(callback);
        if (options) {
          this.listenerOptions.set(callback, options);
        }
      }
    }
  }
  removeEventListener(type2, callback) {
    if (isFunction(callback)) {
      const listeners = this.listeners.get(type2);
      if (listeners) {
        this.removeListener(listeners, callback);
      }
    }
  }
  clearEventListeners(type2) {
    for (const [evtName, handlers] of this.listeners) {
      if (isNullOrUndefined(type2) || type2 === evtName) {
        for (const handler of handlers) {
          this.removeEventListener(type2, handler);
        }
        arrayClear(handlers);
        this.listeners.delete(evtName);
      }
    }
  }
  removeListener(listeners, callback) {
    const idx = listeners.findIndex((c) => c === callback);
    if (idx >= 0) {
      arrayRemoveAt(listeners, idx);
      if (this.listenerOptions.has(callback)) {
        this.listenerOptions.delete(callback);
      }
    }
  }
  dispatchEvent(evt) {
    const listeners = this.listeners.get(evt.type);
    if (listeners) {
      for (const callback of listeners) {
        const options = this.listenerOptions.get(callback);
        if (isDefined(options) && !isBoolean(options) && options.once) {
          this.removeListener(listeners, callback);
        }
        callback.call(this, evt);
      }
    }
    return !evt.defaultPrevented;
  }
};
var TypedEvent = class extends Event {
  get type() {
    return super.type;
  }
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
  }
};
var TypedEventBase = class extends EventBase {
  constructor() {
    super(...arguments);
    this.bubblers = /* @__PURE__ */ new Set();
    this.scopes = /* @__PURE__ */ new WeakMap();
  }
  addBubbler(bubbler) {
    this.bubblers.add(bubbler);
  }
  removeBubbler(bubbler) {
    this.bubblers.delete(bubbler);
  }
  addEventListener(type2, callback, options) {
    super.addEventListener(type2, callback, options);
  }
  removeEventListener(type2, callback) {
    super.removeEventListener(type2, callback);
  }
  clearEventListeners(type2) {
    return super.clearEventListeners(type2);
  }
  addScopedEventListener(scope, type2, callback, options) {
    if (!this.scopes.has(scope)) {
      this.scopes.set(scope, []);
    }
    this.scopes.get(scope).push([type2, callback]);
    this.addEventListener(type2, callback, options);
  }
  removeScope(scope) {
    const listeners = this.scopes.get(scope);
    if (listeners) {
      this.scopes.delete(scope);
      for (const [type2, listener] of listeners) {
        this.removeEventListener(type2, listener);
      }
    }
  }
  dispatchEvent(evt) {
    if (!super.dispatchEvent(evt)) {
      return false;
    }
    if (!evt.cancelBubble) {
      for (const bubbler of this.bubblers) {
        if (!bubbler.dispatchEvent(evt)) {
          return false;
        }
      }
    }
    return true;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/environment/Application.ts
var ApplicationEvent = class extends TypedEvent {
  constructor(type2, app) {
    super(type2);
    this.app = app;
  }
};
var ApplicationJoinRoomEvent = class extends ApplicationEvent {
  constructor(app, roomName) {
    super("joinroom", app);
    this.roomName = roomName;
  }
};
var ApplicationQuitEvent = class extends ApplicationEvent {
  constructor(app) {
    super("quit", app);
  }
};
var ApplicationShownEvent = class extends ApplicationEvent {
  constructor(app) {
    super("shown", app);
  }
};
var ApplicationHiddenEvent = class extends ApplicationEvent {
  constructor(app) {
    super("hidden", app);
  }
};
var Application = class extends TypedEventBase {
  constructor(env) {
    super();
    this.env = env;
    this.dataLogger = null;
  }
  quit() {
    this.dispatchEvent(new ApplicationQuitEvent(this));
  }
  join(roomName) {
    this.dispatchEvent(new ApplicationJoinRoomEvent(this, roomName));
    this.env.avatar.reset();
  }
  async show(prog) {
    await this.showing(prog);
    this.dispatchEvent(new ApplicationShownEvent(this));
  }
  hide() {
    this.hiding();
    this.dispatchEvent(new ApplicationHiddenEvent(this));
  }
  init(params) {
    this.dataLogger = params.get("dataLogger");
    return Promise.resolve();
  }
  log(key, value) {
    if (isDefined(this.dataLogger)) {
      this.dataLogger.log(key, value);
    }
  }
  error(page, operation, exception) {
    if (isDefined(this.dataLogger)) {
      this.dataLogger.error(page, operation, exception);
    }
  }
  onError(page, operation) {
    return this.error.bind(this, page, operation);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/Exception.ts
var Exception = class extends Error {
  constructor(message, innerError = null) {
    super(message);
    this.innerError = innerError;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/util.ts
var typePattern = /([^\/]+)\/(.+)/;
var subTypePattern = /(?:([^\.]+)\.)?([^\+;]+)(?:\+([^;]+))?((?:; *([^=]+)=([^;]+))*)/;
var MediaType = class {
  constructor(_type, _fullSubType, extensions) {
    this._type = _type;
    this._fullSubType = _fullSubType;
    this._primaryExtension = null;
    this.depMessage = null;
    const parameters = /* @__PURE__ */ new Map();
    this._parameters = parameters;
    const subTypeParts = this._fullSubType.match(subTypePattern);
    this._tree = subTypeParts[1];
    this._subType = subTypeParts[2];
    this._suffix = subTypeParts[3];
    const paramStr = subTypeParts[4];
    this._value = this._fullValue = this._type + "/";
    if (isDefined(this._tree)) {
      this._value = this._fullValue += this._tree + ".";
    }
    this._value = this._fullValue += this._subType;
    if (isDefined(this._suffix)) {
      this._value = this._fullValue += "+" + this._suffix;
    }
    if (isDefined(paramStr)) {
      const pairs = paramStr.split(";").map((p) => p.trim()).filter((p) => p.length > 0).map((p) => p.split("="));
      for (const [key, ...values] of pairs) {
        const value = values.join("=");
        parameters.set(key, value);
        const slug = `; ${key}=${value}`;
        this._fullValue += slug;
        if (key !== "q") {
          this._value += slug;
        }
      }
    }
    this._extensions = extensions || [];
    this._primaryExtension = this._extensions[0] || null;
  }
  static parse(value) {
    if (!value) {
      return null;
    }
    const match = value.match(typePattern);
    if (!match) {
      return null;
    }
    const type2 = match[1];
    const subType = match[2];
    return new MediaType(type2, subType);
  }
  deprecate(message) {
    this.depMessage = message;
    return this;
  }
  check() {
    if (isDefined(this.depMessage)) {
      console.warn(`${this._value} is deprecated ${this.depMessage}`);
    }
  }
  matches(value) {
    if (isNullOrUndefined(value)) {
      return false;
    }
    if (this.typeName === "*" && this.subTypeName === "*") {
      return true;
    }
    let typeName = null;
    let subTypeName = null;
    if (isString(value)) {
      const match = value.match(typePattern);
      if (!match) {
        return false;
      }
      typeName = match[1];
      subTypeName = match[2];
    } else {
      typeName = value.typeName;
      subTypeName = value._fullSubType;
    }
    return this.typeName === typeName && (this._fullSubType === "*" || this._fullSubType === subTypeName);
  }
  withParameter(key, value) {
    const newSubType = `${this._fullSubType}; ${key}=${value}`;
    return new MediaType(this.typeName, newSubType, this.extensions);
  }
  get typeName() {
    this.check();
    return this._type;
  }
  get tree() {
    this.check();
    return this._tree;
  }
  get suffix() {
    return this._suffix;
  }
  get subTypeName() {
    this.check();
    return this._subType;
  }
  get value() {
    this.check();
    return this._value;
  }
  __getValueUnsafe() {
    return this._value;
  }
  get fullValue() {
    this.check();
    return this._fullValue;
  }
  get parameters() {
    this.check();
    return this._parameters;
  }
  get extensions() {
    this.check();
    return this._extensions;
  }
  __getExtensionsUnsafe() {
    return this._extensions;
  }
  get primaryExtension() {
    this.check();
    return this._primaryExtension;
  }
  toString() {
    if (this.parameters.get("q") === "1") {
      return this.value;
    } else {
      return this.fullValue;
    }
  }
  addExtension(fileName) {
    if (!fileName) {
      throw new Error("File name is not defined");
    }
    if (this.primaryExtension) {
      const idx = fileName.lastIndexOf(".");
      if (idx > -1) {
        const currentExtension = fileName.substring(idx + 1);
        ;
        if (this.extensions.indexOf(currentExtension) > -1) {
          fileName = fileName.substring(0, idx);
        }
      }
      fileName = `${fileName}.${this.primaryExtension}`;
    }
    return fileName;
  }
};
function create(group, value, ...extensions) {
  return new MediaType(group, value, extensions);
}
function specialize(group) {
  return create.bind(null, group);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/application.ts
var application = /* @__PURE__ */ specialize("application");
var Application_Javascript = /* @__PURE__ */ application("javascript", "js");
var Application_Json = /* @__PURE__ */ application("json", "json");
var Application_JsonUTF8 = /* @__PURE__ */ application("json; charset=UTF-8", "json");
var Application_Pdf = /* @__PURE__ */ application("pdf", "pdf");
var Application_Wasm = /* @__PURE__ */ application("wasm", "wasm");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/image.ts
var image = /* @__PURE__ */ specialize("image");
var Image_Jpeg = /* @__PURE__ */ image("jpeg", "jpeg", "jpg", "jpe");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/model.ts
var model = /* @__PURE__ */ specialize("model");
var Model_Gltf_Binary = /* @__PURE__ */ model("gltf-binary", "glb");
var Model_Gltf_Json = /* @__PURE__ */ model("gltf+json", "gltf");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/text.ts
var text = /* @__PURE__ */ specialize("text");
var Text_Css = /* @__PURE__ */ text("css", "css");
var Text_Plain = /* @__PURE__ */ text("plain", "txt", "text", "conf", "def", "list", "log", "in");
var Text_Xml = /* @__PURE__ */ text("xml");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/assertSuccess.ts
function assertSuccess(response) {
  if (response.status >= 400) {
    throw new Error("Resource could not be retrieved: " + response.requestPath);
  }
  return response;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/unwrapResponse.ts
function unwrapResponse(response) {
  const { content } = assertSuccess(response);
  return content;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/Asset.ts
function isAsset(obj2) {
  return isDefined(obj2) && isFunction(obj2.then) && isFunction(obj2.catch) && isFunction(obj2.finally) && isFunction(obj2.fetch) && isFunction(obj2.getSize);
}
var BaseAsset = class {
  constructor(path, type2) {
    this.path = path;
    this.type = type2;
    this._result = null;
    this._error = null;
    this._started = false;
    this._finished = false;
    this.resolve = null;
    this.reject = null;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value) => {
        this._result = value;
        this._finished = true;
        resolve(value);
      };
      this.reject = (reason) => {
        this._error = reason;
        this._finished = true;
        reject(reason);
      };
    });
  }
  get result() {
    if (isDefined(this.error)) {
      throw this.error;
    }
    return this._result;
  }
  get error() {
    return this._error;
  }
  get started() {
    return this._started;
  }
  get finished() {
    return this._finished;
  }
  async getSize(fetcher) {
    try {
      const { contentLength } = await fetcher.head(this.path).accept(this.type).exec();
      return [this, contentLength || 1];
    } catch (exp) {
      console.warn(exp);
      return [this, 1];
    }
    ;
  }
  async fetch(fetcher, prog) {
    try {
      const result = await this.getResult(fetcher, prog);
      this.resolve(result);
    } catch (err) {
      this.reject(err);
    }
  }
  get [Symbol.toStringTag]() {
    return this.promise.toString();
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.promise.catch(onrejected);
  }
  finally(onfinally) {
    return this.promise.finally(onfinally);
  }
};
var BaseFetchedAsset = class extends BaseAsset {
  constructor(path, typeOrUseCache, useCache) {
    let type2;
    if (isBoolean(typeOrUseCache)) {
      useCache = typeOrUseCache;
    } else {
      type2 = typeOrUseCache;
    }
    super(path, type2);
    this.useCache = !!useCache;
  }
  getResult(fetcher, prog) {
    return this.getRequest(fetcher, prog).then(unwrapResponse);
  }
  getRequest(fetcher, prog) {
    const request = fetcher.get(this.path).useCache(this.useCache).progress(prog);
    return this.getResponse(request);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/BaseProgress.ts
var BaseProgress = class extends TypedEventBase {
  constructor() {
    super(...arguments);
    this.attached = new Array();
    this.soFar = null;
    this.total = null;
    this.msg = null;
    this.est = null;
  }
  get p() {
    return this.total > 0 ? this.soFar / this.total : 0;
  }
  report(soFar, total, msg, est) {
    this.soFar = soFar;
    this.total = total;
    this.msg = msg;
    this.est = est;
    for (const attach of this.attached) {
      attach.report(soFar, total, msg, est);
    }
  }
  attach(prog) {
    this.attached.push(prog);
    prog.report(this.soFar, this.total, this.msg, this.est);
  }
  clear() {
    this.report(0, 0);
    this._clear();
  }
  start(msg) {
    this.report(0, 1, msg || "starting");
  }
  end(msg) {
    this.report(1, 1, msg || "done");
    this._clear();
  }
  _clear() {
    this.soFar = null;
    this.total = null;
    this.msg = null;
    this.est = null;
    arrayClear(this.attached);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/ChildProgressCallback.ts
var ChildProgressCallback = class extends BaseProgress {
  constructor(i, prog) {
    super();
    this.i = i;
    this.prog = prog;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    this.prog.update(this.i, soFar, total, msg);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/BaseParentProgressCallback.ts
var BaseParentProgressCallback = class {
  constructor(prog) {
    this.prog = prog;
    this.weightTotal = 0;
    this.subProgressCallbacks = new Array();
    this.subProgressWeights = new Array();
    this.subProgressValues = new Array();
    this.start = performance.now();
    for (let i = 0; i < this.subProgressWeights.length; ++i) {
      this.subProgressValues[i] = 0;
      this.subProgressCallbacks[i] = new ChildProgressCallback(i, this);
    }
  }
  addSubProgress(weight) {
    weight = weight || 1;
    this.weightTotal += weight;
    this.subProgressWeights.push(weight);
    this.subProgressValues.push(0);
    const child = new ChildProgressCallback(this.subProgressCallbacks.length, this);
    this.subProgressCallbacks.push(child);
    return child;
  }
  update(i, subSoFar, subTotal, msg) {
    if (this.prog) {
      this.subProgressValues[i] = subSoFar / subTotal;
      let soFar = 0;
      for (let j = 0; j < this.subProgressWeights.length; ++j) {
        soFar += this.subProgressValues[j] * this.subProgressWeights[j];
      }
      const end2 = performance.now();
      const delta2 = end2 - this.start;
      const est = this.start - end2 + delta2 * this.weightTotal / soFar;
      this.prog.report(soFar, this.weightTotal, msg, est);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressSplit.ts
function progressSplitWeighted(prog, subProgressWeights) {
  const subProg = new WeightedParentProgressCallback(subProgressWeights, prog);
  return subProg.subProgressCallbacks;
}
function progressSplit(prog, taskCount) {
  const subProgressWeights = new Array(taskCount);
  for (let i = 0; i < taskCount; ++i) {
    subProgressWeights[i] = 1;
  }
  return progressSplitWeighted(prog, subProgressWeights);
}
var WeightedParentProgressCallback = class extends BaseParentProgressCallback {
  constructor(subProgressWeights, prog) {
    super(prog);
    for (const weight of subProgressWeights) {
      this.addSubProgress(weight);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/identity.ts
function identity(item) {
  return item;
}
function alwaysTrue() {
  return true;
}
function alwaysFalse() {
  return false;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/Task.ts
var Task = class {
  /**
   * Create a new Task
   *
   * @param autoStart - set to false to require manually starting the Task. Useful
   * for reusable tasks that run on timers.
   */
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.onThens = new Array();
    this.onCatches = new Array();
    this._result = void 0;
    this._error = void 0;
    this._executionState = "waiting";
    this._resultState = "none";
    this.resolve = (value) => {
      if (this.running) {
        this._result = value;
        this._resultState = "resolved";
        for (const thenner of this.onThens) {
          thenner(value);
        }
        this.clear();
        this._executionState = "finished";
      }
    };
    this.reject = (reason) => {
      if (this.running) {
        this._error = reason;
        this._resultState = "errored";
        for (const catcher of this.onCatches) {
          catcher(reason);
        }
        this.clear();
        this._executionState = "finished";
      }
    };
    if (this.autoStart) {
      this.start();
    }
  }
  clear() {
    arrayClear(this.onThens);
    arrayClear(this.onCatches);
  }
  /**
   * If the task was not auto-started, signal that the task is now ready to recieve
   * resolutions or rejections.
   **/
  start() {
    this._executionState = "running";
  }
  /**
   * Creates a resolving callback for a static value.
   * @param value
   */
  resolver(value) {
    return () => this.resolve(value);
  }
  resolveOn(target, resolveEvt, value) {
    const resolver = this.resolver(value);
    target.addEventListener(resolveEvt, resolver);
    this.finally(() => target.removeEventListener(resolveEvt, resolver));
  }
  /**
   * Get the last result that the task had resolved to, if any is available.
   *
   * If the Task had been rejected, attempting to get the result will rethrow
   * the error that had rejected the task.
   **/
  get result() {
    if (isDefined(this.error)) {
      throw this.error;
    }
    return this._result;
  }
  /**
   * Get the last error that the task had been rejected by, if any.
   **/
  get error() {
    return this._error;
  }
  /**
   * Get the current state of the task.
   **/
  get executionState() {
    return this._executionState;
  }
  /**
   * Returns true when the Task is hasn't started yet.
   **/
  get waiting() {
    return this.executionState === "waiting";
  }
  /**
   * Returns true when the Task is waiting to be resolved or rejected.
   **/
  get started() {
    return this.executionState !== "waiting";
  }
  /**
   * Returns true after the Task has started, but before it has finished.
   **/
  get running() {
    return this.executionState === "running";
  }
  /**
   * Returns true when the Task has been resolved or rejected.
   **/
  get finished() {
    return this.executionState === "finished";
  }
  get resultState() {
    return this._resultState;
  }
  /**
   * Returns true if the Task had been resolved successfully.
   **/
  get resolved() {
    return this.resultState === "resolved";
  }
  /**
   * Returns true if the Task had been rejected, regardless of any
   * reason being given.
   **/
  get errored() {
    return this.resultState === "errored";
  }
  get [Symbol.toStringTag]() {
    return this.toString();
  }
  /**
   * Calling Task.then(), Task.catch(), or Task.finally() creates a new Promise.
   * This method creates that promise and links it with the task.
   **/
  project() {
    return new Promise((resolve, reject) => {
      if (!this.finished) {
        this.onThens.push(resolve);
        this.onCatches.push(reject);
      } else if (this.errored) {
        reject(this.error);
      } else {
        resolve(this.result);
      }
    });
  }
  /**
   * Attach a handler to the task that fires when the task is resolved.
   * 
   * @param onfulfilled
   * @param onrejected
   */
  then(onfulfilled, onrejected) {
    return this.project().then(onfulfilled, onrejected);
  }
  /**
   * Attach a handler that fires when the Task is rejected.
   * 
   * @param onrejected
   */
  catch(onrejected) {
    return this.project().catch(onrejected);
  }
  /**
   * Attach a handler that fires regardless of whether the Task is resolved
   * or rejected.
   * 
   * @param onfinally
   */
  finally(onfinally) {
    return this.project().finally(onfinally);
  }
  /**
   * Resets the Task to an unsignalled state, which is useful for
   * reducing GC pressure when working with lots of tasks.
   **/
  reset() {
    this._reset(this.autoStart);
  }
  restart() {
    this._reset(true);
  }
  _reset(start2) {
    if (this.running) {
      this.reject("Resetting previous invocation");
    }
    this.clear();
    this._result = void 0;
    this._error = void 0;
    this._executionState = "waiting";
    this._resultState = "none";
    if (start2) {
      this.start();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/once.ts
function targetValidateEvent(target, type2) {
  return "on" + type2 in target;
}
function once(target, resolveEvt, rejectEvtOrTimeout, ...rejectEvts) {
  if (isNullOrUndefined(rejectEvts)) {
    rejectEvts = [];
  }
  let timeout = void 0;
  if (isString(rejectEvtOrTimeout)) {
    rejectEvts.unshift(rejectEvtOrTimeout);
  } else if (isNumber(rejectEvtOrTimeout)) {
    timeout = rejectEvtOrTimeout;
  }
  if (!(target instanceof EventBase)) {
    if (!targetValidateEvent(target, resolveEvt)) {
      throw new Exception(`Target does not have a ${resolveEvt} rejection event`);
    }
    for (const evt of rejectEvts) {
      if (!targetValidateEvent(target, evt)) {
        throw new Exception(`Target does not have a ${evt} rejection event`);
      }
    }
  }
  const task = new Task();
  if (isNumber(timeout)) {
    const timeoutHandle = setTimeout(task.reject, timeout, `'${resolveEvt}' has timed out.`);
    task.finally(clearTimeout.bind(globalThis, timeoutHandle));
  }
  const register = (evt, callback) => {
    target.addEventListener(evt, callback);
    task.finally(() => target.removeEventListener(evt, callback));
  };
  register(resolveEvt, (evt) => task.resolve(evt));
  const onReject = (evt) => task.reject(evt);
  for (const rejectEvt of rejectEvts) {
    register(rejectEvt, onReject);
  }
  return task;
}
function success(task) {
  return task.then(alwaysTrue).catch(alwaysFalse);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/attrs.ts
var Attr = class {
  /**
   * Creates a new setter functor for HTML Attributes
   * @param key - the attribute name.
   * @param value - the value to set for the attribute.
   * @param tags - the HTML tags that support this attribute.
   */
  constructor(key, value, bySetAttribute, ...tags) {
    this.key = key;
    this.value = value;
    this.bySetAttribute = bySetAttribute;
    this.tags = tags.map((t2) => t2.toLocaleUpperCase());
    Object.freeze(this);
  }
  /**
   * Set the attribute value on an HTMLElement
   * @param elem - the element on which to set the attribute.
   */
  applyToElement(elem) {
    const isDataSet = this.key.startsWith("data-");
    const isValid = this.tags.length === 0 || this.tags.indexOf(elem.tagName) > -1 || isDataSet;
    if (!isValid) {
      console.warn(`Element ${elem.tagName} does not support Attribute ${this.key}`);
    } else if (isDataSet) {
      const subkey = this.key.substring(5);
      elem.dataset[subkey] = this.value;
    } else if (this.key === "style") {
      Object.assign(elem.style, this.value);
    } else if (this.key === "classList") {
      const arr = this.value.filter(identity);
      if (arr.length > 0) {
        arr.forEach((v) => elem.classList.add(v));
      }
    } else if (this.bySetAttribute) {
      elem.setAttribute(this.key, this.value);
    } else if (this.key in elem) {
      elem[this.key] = this.value;
    } else if (this.value === false) {
      elem.removeAttribute(this.key);
    } else if (this.value === true) {
      elem.setAttribute(this.key, "");
    } else {
      elem.setAttribute(this.key, this.value);
    }
  }
};
function htmlHeight(value) {
  return new Attr("height", value, false, "canvas", "embed", "iframe", "img", "input", "object", "video");
}
function rel(value) {
  return new Attr("rel", value, false, "a", "area", "link");
}
function unpackURL(value) {
  if (value instanceof URL) {
    value = value.href;
  }
  return value;
}
function src(value) {
  return new Attr("src", unpackURL(value), false, "audio", "embed", "iframe", "img", "input", "script", "source", "track", "video");
}
function type(value) {
  if (!isString(value)) {
    value = value.value;
  }
  return new Attr("type", value, false, "button", "input", "command", "embed", "link", "object", "script", "source", "style", "menu");
}
function htmlWidth(value) {
  return new Attr("width", value, false, "canvas", "embed", "iframe", "img", "input", "object", "video");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/css.ts
function px(value) {
  return `${value}px`;
}
function rgb(...v) {
  return `rgb(${v.join(", ")})`;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/tags.ts
function isErsatzElement(obj2) {
  if (!isObject(obj2)) {
    return false;
  }
  const elem = obj2;
  return elem.element instanceof Element;
}
function resolveElement(elem) {
  if (isErsatzElement(elem)) {
    return elem.element;
  } else if (isString(elem)) {
    return getElement(elem);
  }
  return elem;
}
function isIElementAppliable(obj2) {
  return isObject(obj2) && "applyToElement" in obj2 && isFunction(obj2.applyToElement);
}
function elementSetDisplay(elem, visible, visibleDisplayType = "") {
  elem = resolveElement(elem);
  elem.style.display = visible ? visibleDisplayType : "none";
}
function elementIsDisplayed(elem) {
  elem = resolveElement(elem);
  return elem.style.display !== "none";
}
function elementApply(elem, ...children) {
  elem = resolveElement(elem);
  for (const child of children) {
    if (isDefined(child)) {
      if (child instanceof Node) {
        elem.append(child);
      } else if (isErsatzElement(child)) {
        elem.append(resolveElement(child));
      } else if (isIElementAppliable(child)) {
        child.applyToElement(elem);
      } else {
        elem.append(document.createTextNode(child.toLocaleString()));
      }
    }
  }
  return elem;
}
function getElement(selector) {
  return document.querySelector(selector);
}
function getInput(selector) {
  return getElement(selector);
}
function tag(name, ...rest) {
  let elem = null;
  for (const attr of rest) {
    if (attr instanceof Attr && attr.key === "id") {
      elem = document.getElementById(attr.value);
      break;
    }
  }
  if (elem == null) {
    elem = document.createElement(name);
  }
  elementApply(elem, ...rest);
  return elem;
}
function Canvas(...rest) {
  return tag("canvas", ...rest);
}
function Img(...rest) {
  return tag("img", ...rest);
}
function Link(...rest) {
  return tag("link", ...rest);
}
function Script(...rest) {
  return tag("script", ...rest);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/using.ts
function interfaceSigCheck(obj2, ...funcNames) {
  if (!isObject(obj2)) {
    return false;
  }
  obj2 = obj2;
  for (const funcName of funcNames) {
    if (!(funcName in obj2)) {
      return false;
    }
    const func = obj2[funcName];
    if (!isFunction(func)) {
      return false;
    }
  }
  return true;
}
function isDisposable(obj2) {
  return interfaceSigCheck(obj2, "dispose");
}
function isDestroyable(obj2) {
  return interfaceSigCheck(obj2, "destroy");
}
function isClosable(obj2) {
  return interfaceSigCheck(obj2, "close");
}
function dispose(val) {
  if (isDisposable(val)) {
    val.dispose();
  }
  if (isClosable(val)) {
    val.close();
  }
  if (isDestroyable(val)) {
    val.destroy();
  }
}
function using(val, thunk) {
  try {
    return thunk(val);
  } finally {
    dispose(val);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/canvas.ts
var hasHTMLCanvas = "HTMLCanvasElement" in globalThis;
var hasHTMLImage = "HTMLImageElement" in globalThis;
var disableAdvancedSettings = false;
var hasOffscreenCanvas = !disableAdvancedSettings && "OffscreenCanvas" in globalThis;
var hasImageBitmap = !disableAdvancedSettings && "createImageBitmap" in globalThis;
function isHTMLCanvas(obj2) {
  return hasHTMLCanvas && obj2 instanceof HTMLCanvasElement;
}
function isOffscreenCanvas(obj2) {
  return hasOffscreenCanvas && obj2 instanceof OffscreenCanvas;
}
function isImageBitmap(img) {
  return hasImageBitmap && img instanceof ImageBitmap;
}
function isImageData(img) {
  return img instanceof ImageData;
}
function isCanvas(obj2) {
  return isHTMLCanvas(obj2) || isOffscreenCanvas(obj2);
}
function drawImageBitmapToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.drawImage(img, 0, 0);
}
function drawImageDataToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.putImageData(img, 0, 0);
}
function testOffscreen2D() {
  try {
    const canv = new OffscreenCanvas(1, 1);
    const g = canv.getContext("2d");
    return g != null;
  } catch (exp) {
    return false;
  }
}
var hasOffscreenCanvasRenderingContext2D = hasOffscreenCanvas && testOffscreen2D();
var createUtilityCanvas = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvas || hasHTMLCanvas && createCanvas || null;
var createUICanvas = hasHTMLCanvas ? createCanvas : createUtilityCanvas;
function testOffscreen3D() {
  try {
    const canv = new OffscreenCanvas(1, 1);
    const g = canv.getContext("webgl2");
    return g != null;
  } catch (exp) {
    return false;
  }
}
var hasOffscreenCanvasRenderingContext3D = hasOffscreenCanvas && testOffscreen3D();
function createOffscreenCanvas(width, height) {
  return new OffscreenCanvas(width, height);
}
function createCanvas(w, h) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  return Canvas(htmlWidth(w), htmlHeight(h));
}
function createOffscreenCanvasFromImageBitmap(img) {
  const canv = createOffscreenCanvas(img.width, img.height);
  drawImageBitmapToCanvas(canv, img);
  return canv;
}
function createCanvasFromImageBitmap(img) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  const canv = createCanvas(img.width, img.height);
  drawImageBitmapToCanvas(canv, img);
  return canv;
}
var createUtilityCanvasFromImageBitmap = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvasFromImageBitmap || hasHTMLCanvas && createCanvasFromImageBitmap || null;
function createOffscreenCanvasFromImageData(img) {
  const canv = createOffscreenCanvas(img.width, img.height);
  drawImageDataToCanvas(canv, img);
  return canv;
}
function createCanvasFromImageData(img) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  const canv = createCanvas(img.width, img.height);
  drawImageDataToCanvas(canv, img);
  return canv;
}
var createUtilityCanvasFromImageData = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvasFromImageData || hasHTMLCanvas && createCanvasFromImageData || null;
function drawImageToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.drawImage(img, 0, 0);
}
function createCanvasFromImage(img) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  const canv = createCanvas(img.width, img.height);
  drawImageToCanvas(canv, img);
  return canv;
}
async function createImageFromFile(file) {
  if (false) {
    throw new Error("HTML Image is not supported in workers");
  }
  const img = Img(src(file));
  await once(img, "load", "error");
  return img;
}
function setCanvasSize(canv, w, h, superscale = 1) {
  w = Math.floor(w * superscale);
  h = Math.floor(h * superscale);
  if (canv.width != w || canv.height != h) {
    canv.width = w;
    canv.height = h;
    return true;
  }
  return false;
}
function is2DRenderingContext(ctx) {
  return isDefined(ctx.textBaseline);
}
function setCanvas2DContextSize(ctx, w, h, superscale = 1) {
  const oldImageSmoothingEnabled = ctx.imageSmoothingEnabled, oldTextBaseline = ctx.textBaseline, oldTextAlign = ctx.textAlign, oldFont = ctx.font, resized = setCanvasSize(
    ctx.canvas,
    w,
    h,
    superscale
  );
  if (resized) {
    ctx.imageSmoothingEnabled = oldImageSmoothingEnabled;
    ctx.textBaseline = oldTextBaseline;
    ctx.textAlign = oldTextAlign;
    ctx.font = oldFont;
  }
  return resized;
}
function setContextSize(ctx, w, h, superscale = 1) {
  if (is2DRenderingContext(ctx)) {
    return setCanvas2DContextSize(ctx, w, h, superscale);
  } else {
    return setCanvasSize(
      ctx.canvas,
      w,
      h,
      superscale
    );
  }
}
function canvasToBlob(canvas, type2, quality) {
  if (type2 instanceof MediaType) {
    type2 = type2.value;
  }
  if (isOffscreenCanvas(canvas)) {
    return canvas.convertToBlob({ type: type2, quality });
  } else if (isHTMLCanvas(canvas)) {
    const blobCreated = new Task();
    canvas.toBlob(blobCreated.resolve, type2, quality);
    return blobCreated;
  } else {
    throw new Error("Cannot save image from canvas");
  }
}
function dispose2(val) {
  if (isCanvas(val)) {
    val.width = val.height = 0;
  } else {
    dispose(val);
  }
}

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create2,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create2() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale3) {
  out[0] = a[0] + b[0] * scale3;
  out[1] = a[1] + b[1] * scale3;
  out[2] = a[2] + b[2] * scale3;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len3 = x * x + y * y + z * z;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  out[2] = a[2] * len3;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t2) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t2) {
  var factorTimes2 = t2 * t2;
  var factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  var factor2 = factorTimes2 * (t2 - 2) + t2;
  var factor3 = factorTimes2 * (t2 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t2) {
  var inverseFactor = 1 - t2;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t2 * t2;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t2 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t2;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale3) {
  scale3 = scale3 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale3;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale3;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create2();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add2,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create3,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues2,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul2,
  multiply: () => multiply2,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  rotate: () => rotate,
  round: () => round2,
  scale: () => scale2,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set2,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create3() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues2(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set2(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply2(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale3) {
  out[0] = a[0] + b[0] * scale3;
  out[1] = a[1] + b[1] * scale3;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length2(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength2(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize2(out, a) {
  var x = a[0], y = a[1];
  var len3 = x * x + y * y;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross2(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp2(out, a, b, t2) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  return out;
}
function random2(out, scale3) {
  scale3 = scale3 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale3;
  out[1] = Math.sin(r) * scale3;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str2(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len2 = length2;
var sub2 = subtract2;
var mul2 = multiply2;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/math.ts
var Pi = Math.PI;
var HalfPi = 0.5 * Pi;
var Tau = 2 * Pi;
var TIME_MAX = 864e13;
var TIME_MIN = -TIME_MAX;
function clamp(v, min3, max3) {
  return Math.min(max3, Math.max(min3, v));
}
function deg2rad(degrees) {
  return degrees * Tau / 360;
}
function rad2deg(radians) {
  return radians * 360 / Tau;
}
function project(v, min3, max3) {
  const delta2 = max3 - min3;
  if (delta2 === 0) {
    return 0;
  } else {
    return (v - min3) / delta2;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/singleton.ts
function singleton(name, create4) {
  const box = globalThis;
  let value = box[name];
  if (isNullOrUndefined(value)) {
    if (isNullOrUndefined(create4)) {
      throw new Error(`No value ${name} found`);
    }
    value = create4();
    box[name] = value;
  }
  return value;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/URLBuilder.ts
function parsePort(portString) {
  if (isDefined(portString) && portString.length > 0) {
    return parseFloat(portString);
  }
  return null;
}
var URLBuilder = class {
  constructor(url2, base) {
    this._url = null;
    this._base = void 0;
    this._protocol = null;
    this._host = null;
    this._hostName = null;
    this._userName = null;
    this._password = null;
    this._port = null;
    this._pathName = null;
    this._hash = null;
    this._query = /* @__PURE__ */ new Map();
    if (url2 !== void 0) {
      this._url = new URL(url2, base);
      this.rehydrate();
    }
  }
  rehydrate() {
    if (isDefined(this._protocol) && this._protocol !== this._url.protocol) {
      this._url.protocol = this._protocol;
    }
    if (isDefined(this._host) && this._host !== this._url.host) {
      this._url.host = this._host;
    }
    if (isDefined(this._hostName) && this._hostName !== this._url.hostname) {
      this._url.hostname = this._hostName;
    }
    if (isDefined(this._userName) && this._userName !== this._url.username) {
      this._url.username = this._userName;
    }
    if (isDefined(this._password) && this._password !== this._url.password) {
      this._url.password = this._password;
    }
    if (isDefined(this._port) && this._port.toFixed(0) !== this._url.port) {
      this._url.port = this._port.toFixed(0);
    }
    if (isDefined(this._pathName) && this._pathName !== this._url.pathname) {
      this._url.pathname = this._pathName;
    }
    if (isDefined(this._hash) && this._hash !== this._url.hash) {
      this._url.hash = this._hash;
    }
    for (const [k, v] of this._query) {
      this._url.searchParams.set(k, v);
    }
    this._protocol = this._url.protocol;
    this._host = this._url.host;
    this._hostName = this._url.hostname;
    this._userName = this._url.username;
    this._password = this._url.password;
    this._port = parsePort(this._url.port);
    this._pathName = this._url.pathname;
    this._hash = this._url.hash;
    this._url.searchParams.forEach((v, k) => this._query.set(k, v));
  }
  refresh() {
    if (this._url === null) {
      if (isDefined(this._protocol) && (isDefined(this._host) || isDefined(this._hostName))) {
        if (isDefined(this._host)) {
          this._url = new URL(`${this._protocol}//${this._host}`, this._base);
          this._port = parsePort(this._url.port);
          this.rehydrate();
          return false;
        } else if (isDefined(this._hostName)) {
          this._url = new URL(`${this._protocol}//${this._hostName}`, this._base);
          this.rehydrate();
          return false;
        }
      } else if (isDefined(this._pathName) && isDefined(this._base)) {
        this._url = new URL(this._pathName, this._base);
        this.rehydrate();
        return false;
      }
    }
    return isDefined(this._url);
  }
  base(base) {
    if (this._url !== null) {
      throw new Error("Cannot redefine base after defining the protocol and domain");
    }
    this._base = base;
    this.refresh();
    return this;
  }
  protocol(protocol) {
    this._protocol = protocol;
    if (this.refresh()) {
      this._url.protocol = protocol;
    }
    return this;
  }
  host(host) {
    this._host = host;
    if (this.refresh()) {
      this._url.host = host;
      this._hostName = this._url.hostname;
      this._port = parsePort(this._url.port);
    }
    return this;
  }
  hostName(hostName) {
    this._hostName = hostName;
    if (this.refresh()) {
      this._url.hostname = hostName;
      this._host = `${this._url.hostname}:${this._url.port}`;
    }
    return this;
  }
  port(port) {
    this._port = port;
    if (this.refresh()) {
      this._url.port = port.toFixed(0);
      this._host = `${this._url.hostname}:${this._url.port}`;
    }
    return this;
  }
  userName(userName) {
    this._userName = userName;
    if (this.refresh()) {
      this._url.username = userName;
    }
    return this;
  }
  password(password) {
    this._password = password;
    if (this.refresh()) {
      this._url.password = password;
    }
    return this;
  }
  path(path) {
    this._pathName = path;
    if (this.refresh()) {
      this._url.pathname = path;
    }
    return this;
  }
  pathPop(pattern) {
    pattern = pattern || /\/[^/]+\/?$/;
    return this.path(this._pathName.replace(pattern, ""));
  }
  pathPush(part) {
    let path = this._pathName;
    if (!path.endsWith("/")) {
      path += "/";
    }
    path += part;
    return this.path(path);
  }
  query(name, value) {
    this._query.set(name, value);
    if (this.refresh()) {
      this._url.searchParams.set(name, value);
    }
    return this;
  }
  hash(hash) {
    this._hash = hash;
    if (this.refresh()) {
      this._url.hash = hash;
    }
    return this;
  }
  toURL() {
    return this._url;
  }
  toString() {
    return this._url.href;
  }
  [Symbol.toStringTag]() {
    return this.toString();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/PDFImage.ts
var import_pdfjs_dist = __toESM(require_pdf(), 1);

// ../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/package.json
var version2 = "2.16.105";

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/CanvasImage.ts
var CanvasImage = class extends TypedEventBase {
  constructor(width, height, options) {
    super();
    this._scale = 250;
    this._visible = true;
    this.wasVisible = null;
    this.redrawnEvt = new TypedEvent("redrawn");
    this.element = null;
    if (isDefined(options)) {
      if (isDefined(options.scale)) {
        this._scale = options.scale;
      }
    }
    this._canvas = createUICanvas(width, height);
    this._g = this.canvas.getContext("2d");
    if (isHTMLCanvas(this._canvas)) {
      this.element = this._canvas;
    }
  }
  fillRect(color, x, y, width, height, margin2) {
    this.g.fillStyle = color;
    this.g.fillRect(x + margin2, y + margin2, width - 2 * margin2, height - 2 * margin2);
  }
  drawText(text2, x, y, align) {
    this.g.textAlign = align;
    this.g.strokeText(text2, x, y);
    this.g.fillText(text2, x, y);
  }
  redraw() {
    if ((this.visible || this.wasVisible) && this.onRedraw()) {
      this.wasVisible = this.visible;
      this.dispatchEvent(this.redrawnEvt);
    }
  }
  onClear() {
    this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  clear() {
    this.onClear();
    this.dispatchEvent(this.redrawnEvt);
  }
  get canvas() {
    return this._canvas;
  }
  get g() {
    return this._g;
  }
  get imageWidth() {
    return this.canvas.width;
  }
  get imageHeight() {
    return this.canvas.height;
  }
  get aspectRatio() {
    return this.imageWidth / this.imageHeight;
  }
  get width() {
    return this.imageWidth / this.scale;
  }
  get height() {
    return this.imageHeight / this.scale;
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    if (this.scale !== v) {
      this._scale = v;
      this.redraw();
    }
  }
  get visible() {
    return this._visible;
  }
  set visible(v) {
    if (this.visible !== v) {
      this.wasVisible = this._visible;
      this._visible = v;
      this.redraw();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/CancelToken.ts
var CancelSignalException = class extends Exception {
  constructor() {
    super("Cancellation!");
  }
};
var CancelToken = class {
  constructor() {
    this._cancelled = false;
  }
  get cancelled() {
    return this._cancelled;
  }
  check() {
    if (this.cancelled) {
      throw new CancelSignalException();
    }
  }
  cancel() {
    this._cancelled = true;
  }
  dispose() {
    throw new Error("Method not implemented.");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/PDFImage.ts
var pdfReady = singleton("Juniper:PdfReady", () => new Task(false));
var PDFImage = class extends CanvasImage {
  constructor(filePath, viewportParams) {
    super(1, 1);
    this.viewportParams = viewportParams;
    this.pdf = null;
    this._curPageIndex = null;
    this.ready = this.load(filePath);
  }
  static async prepare(workerPath, fetcher, debug, tokenOrProg, prog) {
    let token = null;
    if (tokenOrProg instanceof CancelToken) {
      token = tokenOrProg;
    } else {
      prog = tokenOrProg;
    }
    token = token || new CancelToken();
    if (!pdfReady.started) {
      pdfReady.start();
      console.info(`PDF.js v${version2}`);
      const uri = new URLBuilder(workerPath, location.href);
      uri.query("v", version2);
      workerPath = uri.toString();
      import_pdfjs_dist.default.GlobalWorkerOptions.workerSrc = await fetcher.get(workerPath).useCache(!debug).progress(prog).file().then(unwrapResponse);
      token.check();
      pdfReady.resolve();
    }
    await pdfReady;
    token.check();
  }
  get curPageIndex() {
    return this._curPageIndex;
  }
  get curPageNumber() {
    return this.curPageIndex + 1;
  }
  get canGoBack() {
    return this._curPageIndex > 0;
  }
  get canGoForward() {
    return this._curPageIndex < this.numPages - 1;
  }
  async load(filePath) {
    await pdfReady;
    const pdfTask = import_pdfjs_dist.default.getDocument(filePath);
    this.pdf = await pdfTask.promise;
    if (this.pdf.numPages === 0) {
      throw new Error("No pages found in PDF");
    }
  }
  async getPage(pageIndex) {
    await this.ready;
    pageIndex = clamp(pageIndex, 0, this.pdf.numPages - 1);
    if (pageIndex !== this._curPageIndex) {
      this._curPageIndex = pageIndex;
      const page = await this.pdf.getPage(pageIndex + 1);
      const viewport = page.getViewport(this.viewportParams);
      setContextSize(this.g, viewport.width, viewport.height);
      const renderTask = page.render({
        canvasContext: this.g,
        viewport,
        intent: "print"
      });
      await renderTask.promise;
      this.dispatchEvent(this.redrawnEvt);
    }
  }
  get numPages() {
    if (this.pdf) {
      return this.pdf.numPages;
    }
    return null;
  }
  onRedraw() {
    return false;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/animation/tween.ts
function bump(t2, k) {
  const a = t2 * Pi;
  return 0.5 * (1 - Math.cos(a)) - k * Math.sin(2 * a);
}

// global-externals:three
var { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio: Audio2, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleBufferGeometry, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderBufferGeometry, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DisplayP3ColorSpace, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, Float64BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, Scene, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, TwoPassDoubleSide, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL1Renderer, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGLRenderer, WebGLUtils, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, _SRGBAFormat, sRGBEncoding } = THREE;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/typeChecks.ts
function isMesh(obj2) {
  return isDefined(obj2) && obj2.isMesh;
}
function isMaterial(obj2) {
  return isDefined(obj2) && obj2.isMaterial;
}
function isNamedMaterial(name, obj2) {
  return isMaterial(obj2) && obj2.type === name;
}
function isMeshBasicMaterial(obj2) {
  return isNamedMaterial("MeshBasicMaterial", obj2);
}
function isObject3D(obj2) {
  return isDefined(obj2) && obj2.isObject3D;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/objects.ts
function isErsatzObject(obj2) {
  return isDefined(obj2) && isObject3D(obj2.object);
}
function objectResolve(obj2) {
  if (isErsatzObject(obj2)) {
    return obj2.object;
  }
  return obj2;
}
function objectSetVisible(obj2, visible) {
  obj2 = objectResolve(obj2);
  obj2.visible = visible;
  return visible;
}
function objectIsFullyVisible(obj2) {
  if (!obj2) {
    return false;
  }
  obj2 = objectResolve(obj2);
  while (obj2) {
    if (!obj2.visible) {
      return false;
    }
    obj2 = obj2.parent;
  }
  return true;
}
function objGraph(obj2, ...children) {
  const toAdd = children.filter(isDefined).map(objectResolve);
  if (toAdd.length > 0) {
    objectResolve(obj2).add(...toAdd);
  }
  return obj2;
}
function obj(name, ...rest) {
  const obj2 = new Object3D();
  obj2.name = name;
  objGraph(obj2, ...rest);
  return obj2;
}
function mesh(name, geom, mat) {
  const mesh2 = new Mesh(geom, mat);
  mesh2.name = name;
  return mesh2;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/animation/scaleOnHover.ts
var scaledItems = singleton("Juniper:ScaledItems", () => /* @__PURE__ */ new Map());
var start = 1;
var end = 1.1;
var ScaleState = class {
  constructor(target) {
    this.target = target;
    this.obj = objectResolve(this.target);
    this.base = this.obj.scale.clone();
    this.p = 0;
    this.dir = 0;
    this.running = false;
    this.wasDisabled = this.disabled;
    this.target.addScopedEventListener(this, "enter", (evt) => {
      if (evt.pointer.type !== "nose") {
        this.run(1);
      }
    });
    this.target.addScopedEventListener(this, "exit", (evt) => {
      if (evt.pointer.type !== "nose") {
        this.run(-1);
      }
    });
    this.obj.traverse((child) => {
      if (isMesh(child)) {
        this.target.addMesh(child);
      }
    });
  }
  get disabled() {
    return this.target.disabled;
  }
  run(d) {
    if (!this.disabled || (d === -1 || this.p > 0)) {
      this.dir = d;
      this.running = true;
    }
  }
  updateScaling(dt) {
    if (this.disabled !== this.wasDisabled) {
      this.wasDisabled = this.disabled;
      if (this.disabled) {
        this.run(-1);
      }
    }
    if (this.running) {
      this.p += this.dir * dt;
      if (this.dir > 0 && this.p >= 1 || this.dir < 0 && this.p < 0) {
        this.p = Math.max(0, Math.min(1, this.p));
        this.running = false;
      }
      const q = bump(this.p, 1.1);
      this.obj.scale.copy(this.base).multiplyScalar(q * (end - start) + start);
    }
  }
  dispose() {
    this.target.removeScope(this);
  }
};
function removeScaledObj(obj2) {
  const state = scaledItems.get(obj2);
  if (state) {
    scaledItems.delete(obj2);
    dispose(state);
  }
}
function scaleOnHover(target, enabled) {
  const has = scaledItems.has(target);
  if (enabled != has) {
    if (enabled) {
      scaledItems.set(target, new ScaleState(target));
      ;
    } else {
      const scaler = scaledItems.get(target);
      dispose(scaler);
      scaledItems.delete(target);
    }
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/cleanup.ts
function cleanup(obj2) {
  const cleanupQ = new Array();
  const cleanupSeen = /* @__PURE__ */ new Set();
  cleanupQ.push(obj2);
  while (cleanupQ.length > 0) {
    const here = cleanupQ.shift();
    if (here && !cleanupSeen.has(here)) {
      cleanupSeen.add(here);
      if (here.isMesh) {
        cleanupQ.push(
          here.material,
          here.geometry
        );
      }
      if (here.isMaterial) {
        cleanupQ.push(...Object.values(here));
      }
      if (here.isObject3D) {
        cleanupQ.push(...here.children);
        here.clear();
        removeScaledObj(here);
      }
      if (isArray(here)) {
        cleanupQ.push(...here);
      }
      dispose2(here);
    }
  }
  cleanupSeen.clear();
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/LRUCache.ts
var LRUCacheItemEvicted = class extends TypedEvent {
  constructor(key, value) {
    super("itemevicted");
    this.key = key;
    this.value = value;
  }
};
var LRUCache = class extends TypedEventBase {
  constructor(size2) {
    super();
    this.size = size2;
    this.map = /* @__PURE__ */ new Map();
    this.usage = new Array();
    this.removed = /* @__PURE__ */ new Map();
  }
  set(key, value) {
    this.usage.push(key);
    while (this.usage.length > this.size) {
      const toDelete = this.usage.shift();
      if (isDefined(toDelete)) {
        this.removed.set(toDelete, this.map.get(toDelete));
        this.map.delete(toDelete);
      }
    }
    this.removed.delete(key);
    for (const [key2, value2] of this.removed) {
      this.dispatchEvent(new LRUCacheItemEvicted(key2, value2));
    }
    this.removed.clear();
    return this.map.set(key, value);
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    return this.map.get(key);
  }
  delete(key) {
    if (!this.map.has(key)) {
      return false;
    }
    arrayRemove(this.usage, key);
    return this.map.delete(key);
  }
  clear() {
    arrayClear(this.usage);
    this.map.clear();
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressOfArray.ts
function progressOfArray(prog, items, callback) {
  const weights = items.map(() => 1);
  const progs = progressSplitWeighted(prog, weights);
  return Promise.all(items.map(async (item, i) => {
    const prog2 = progs[i];
    prog2.start();
    const value = await callback(item, prog2, i);
    prog2.end();
    return value;
  }));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Skybox.ts
var U = new Vector3(0, 1, 0);
var FACE_SIZE = 2048;
var FACE_SIZE_HALF = FACE_SIZE / 2;
var CUBEMAP_PATTERN = {
  rows: 3,
  columns: 4,
  indices: [
    [-1 /* None */, 2 /* Up */, -1 /* None */, -1 /* None */],
    [0 /* Left */, 5 /* Front */, 1 /* Right */, 4 /* Back */],
    [-1 /* None */, 3 /* Down */, -1 /* None */, -1 /* None */]
  ],
  rotations: [
    [0, Pi, 0, 0],
    [0, 0, 0, 0],
    [0, Pi, 0, 0]
  ]
};
var black = new Color(0);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/PhotosphereRig.ts
var QUAD_SIZE = 2;
var FACE_SIZE2 = 1 << 11;
var E = new Euler();
var FOVOffsetsDegrees = /* @__PURE__ */ new Map([
  [90 /* Low */, 4],
  [60 /* Medium */, 8],
  [45 /* High */, 3],
  [30 /* Fine */, 2]
]);
var captureParamsRadians = [
  [HalfPi, 0, 0, 1],
  [-HalfPi, 0, 2, 1],
  [0, HalfPi, 1, 0],
  [0, -HalfPi, 1, 2],
  [Pi, 0, 3, 1],
  [0, 0, 1, 1]
];
var PhotosphereRig = class {
  constructor(fetcher, fixWatermarks) {
    this.fetcher = fetcher;
    this.fixWatermarks = fixWatermarks;
    this.baseURL = null;
    this.isDebug = false;
    this.disposed = false;
    this.canvas = createUtilityCanvas(FACE_SIZE2, FACE_SIZE2);
    this.renderer = new WebGLRenderer({
      canvas: this.canvas,
      alpha: false,
      antialias: false,
      depth: true,
      logarithmicDepthBuffer: false,
      powerPreference: "low-power",
      precision: "lowp",
      stencil: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false
    });
    this.camera = new PerspectiveCamera(90);
    this.photosphere = new Group();
    this.scene = objGraph(
      new Scene(),
      new AmbientLight(16777215, 1),
      this.camera,
      this.photosphere
    );
    this.geometry = new PlaneGeometry(1, 1, 1, 1);
  }
  init(baseURL, isDebug2) {
    this.baseURL = baseURL;
    this.isDebug = isDebug2;
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.onDisposing();
    }
  }
  onDisposing() {
    for (const child of this.scene.children) {
      cleanup(child);
    }
    dispose(this.renderer);
  }
  async renderFaces(getImagePath, level, progress) {
    this.clear();
    await this.loadFrames(level, progress, getImagePath);
    const files = await Promise.all(captureParamsRadians.map(async ([headingRadians, pitchRadians, dx, dy]) => {
      const rollRadians = CUBEMAP_PATTERN.rotations[dy][dx];
      E.set(pitchRadians, headingRadians, rollRadians, "YXZ");
      this.camera.setRotationFromEuler(E);
      this.renderer.render(this.scene, this.camera);
      const blob = await canvasToBlob(this.renderer.domElement, Image_Jpeg.value, 1);
      return URL.createObjectURL(blob);
    }));
    this.clear();
    return files;
  }
  async renderCubeMap(getImagePath, level, progress) {
    this.clear();
    const canv = createUtilityCanvas(FACE_SIZE2 * 4, FACE_SIZE2 * 3);
    const g = canv.getContext("2d", { alpha: false });
    await this.loadFrames(level, progress, getImagePath);
    for (const [headingRadians, pitchRadians, dx, dy] of captureParamsRadians) {
      E.set(pitchRadians, headingRadians, 0, "YXZ");
      this.camera.setRotationFromEuler(E);
      this.renderer.render(this.scene, this.camera);
      g.drawImage(this.renderer.domElement, dx * FACE_SIZE2, dy * FACE_SIZE2);
    }
    const blob = await canvasToBlob(canv, Image_Jpeg.value, 1);
    const file = URL.createObjectURL(blob);
    ;
    this.clear();
    return file;
  }
  getImageAngles(level) {
    const anglesDegrees = new Array();
    const FOVDegrees = level;
    const dFOVDegrees = this.fixWatermarks ? FOVOffsetsDegrees.get(FOVDegrees) : 0;
    for (let pitchDegrees = -90 + FOVDegrees; pitchDegrees < 90; pitchDegrees += FOVDegrees) {
      for (let headingDegrees = -180; headingDegrees < 180; headingDegrees += FOVDegrees) {
        anglesDegrees.push([headingDegrees, pitchDegrees, FOVDegrees + dFOVDegrees, QUAD_SIZE]);
      }
    }
    anglesDegrees.push([0, -90, FOVDegrees + dFOVDegrees, QUAD_SIZE]);
    anglesDegrees.push([0, 90, FOVDegrees + dFOVDegrees, QUAD_SIZE]);
    if (this.fixWatermarks) {
      anglesDegrees.push([0, -90, FOVDegrees, 0.5 * QUAD_SIZE]);
      anglesDegrees.push([0, 90, FOVDegrees, 0.5 * QUAD_SIZE]);
    }
    return anglesDegrees;
  }
  async loadFrames(level, progress, getImagePath) {
    const angles = this.getImageAngles(level);
    await progressOfArray(progress, angles, (set3, prog) => this.loadFrame(getImagePath, ...set3, prog));
  }
  async loadFrame(getImagePath, headingDegrees, pitchDegrees, fovDegrees, size2, prog) {
    const halfFOV = 0.5 * deg2rad(fovDegrees);
    const k = Math.tan(halfFOV);
    const dist3 = 0.5 * size2 / k;
    const path = getImagePath(fovDegrees, headingDegrees, pitchDegrees);
    const canvas = await this.fetcher.get(path, this.baseURL).progress(prog).useCache(!this.isDebug).canvas().then(unwrapResponse);
    const texture = new Texture(canvas);
    const material = new MeshBasicMaterial({
      map: texture,
      side: DoubleSide
    });
    const frame = mesh(`frame-${fovDegrees}-${headingDegrees}-${pitchDegrees}`, this.geometry, material);
    texture.needsUpdate = true;
    material.needsUpdate = true;
    E.set(deg2rad(pitchDegrees), -deg2rad(headingDegrees), 0, "YXZ");
    frame.scale.setScalar(size2);
    frame.quaternion.setFromEuler(E);
    frame.position.set(0, 0, -dist3).applyQuaternion(frame.quaternion);
    objGraph(this.photosphere, frame);
  }
  clear() {
    for (const child of this.photosphere.children) {
      cleanup(child);
    }
    this.photosphere.clear();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/PriorityList.ts
var PriorityList = class {
  constructor(init) {
    this.items = /* @__PURE__ */ new Map();
    this.defaultItems = new Array();
    if (isDefined(init)) {
      for (const [key, value] of init) {
        this.add(key, value);
      }
    }
  }
  add(key, ...values) {
    for (const value of values) {
      if (isNullOrUndefined(key)) {
        this.defaultItems.push(value);
      } else {
        let list = this.items.get(key);
        if (isNullOrUndefined(list)) {
          this.items.set(key, list = []);
        }
        list.push(value);
      }
    }
    return this;
  }
  entries() {
    return this.items.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  keys() {
    return this.items.keys();
  }
  *values() {
    for (const item of this.defaultItems) {
      yield item;
    }
    for (const list of this.items.values()) {
      for (const item of list) {
        yield item;
      }
    }
  }
  has(key) {
    if (isDefined(key)) {
      return this.items.has(key);
    } else {
      return this.defaultItems.length > 0;
    }
  }
  get(key) {
    if (isNullOrUndefined(key)) {
      return this.defaultItems;
    }
    return this.items.get(key) || [];
  }
  count(key) {
    if (isNullOrUndefined(key)) {
      return this.defaultItems.length;
    }
    const list = this.get(key);
    if (isDefined(list)) {
      return list.length;
    }
    return 0;
  }
  get size() {
    let size2 = this.defaultItems.length;
    for (const list of this.items.values()) {
      size2 += list.length;
    }
    return size2;
  }
  delete(key) {
    if (isNullOrUndefined(key)) {
      return arrayClear(this.defaultItems).length > 0;
    } else {
      return this.items.delete(key);
    }
  }
  remove(key, value) {
    if (isNullOrUndefined(key)) {
      arrayRemove(this.defaultItems, value);
    } else {
      const list = this.items.get(key);
      if (isDefined(list)) {
        arrayRemove(list, value);
        if (list.length === 0) {
          this.items.delete(key);
        }
      }
    }
  }
  clear() {
    this.items.clear();
    arrayClear(this.defaultItems);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/PriorityMap.ts
var PriorityMap = class {
  constructor(init) {
    this.items = /* @__PURE__ */ new Map();
    if (isDefined(init)) {
      for (const [key1, key2, value] of init) {
        this.add(key1, key2, value);
      }
    }
  }
  add(key1, key2, value) {
    let level1 = this.items.get(key1);
    if (isNullOrUndefined(level1)) {
      this.items.set(key1, level1 = /* @__PURE__ */ new Map());
    }
    level1.set(key2, value);
    return this;
  }
  *entries() {
    for (const [key1, level1] of this.items) {
      for (const [key2, value] of level1) {
        yield [key1, key2, value];
      }
    }
  }
  keys(key1) {
    if (isNullOrUndefined(key1)) {
      return this.items.keys();
    } else {
      return this.items.get(key1).keys();
    }
  }
  *values() {
    for (const level1 of this.items.values()) {
      for (const value of level1.values()) {
        yield value;
      }
    }
  }
  has(key1, key2) {
    return this.items.has(key1) && (isNullOrUndefined(key2) || this.items.get(key1).has(key2));
  }
  get(key1, key2) {
    if (isNullOrUndefined(key2)) {
      return this.items.get(key1);
    } else if (this.items.has(key1)) {
      return this.items.get(key1).get(key2);
    } else {
      return null;
    }
  }
  count(key1) {
    if (this.items.has(key1)) {
      return this.items.get(key1).size;
    }
    return null;
  }
  get size() {
    let size2 = 0;
    for (const list of this.items.values()) {
      size2 += list.size;
    }
    return size2;
  }
  delete(key1, key2) {
    if (isNullOrUndefined(key2)) {
      return this.items.delete(key1);
    } else if (this.items.has(key1)) {
      const items = this.items.get(key1);
      const deleted = items.delete(key2);
      if (items.size === 0) {
        this.items.delete(key1);
      }
      return deleted;
    } else {
      return false;
    }
  }
  clear() {
    this.items.clear();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/all.ts
function all(...tasks) {
  return Promise.all(tasks);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/WindowQuitEventer.ts
var WindowQuitEventer = class extends TypedEventBase {
  constructor() {
    super();
    this.event = new TypedEvent("quitting");
    const onWindowClosed = () => this.dispatchEvent(this.event);
    window.addEventListener("beforeunload", onWindowClosed);
    window.addEventListener("unload", onWindowClosed);
    window.addEventListener("pagehide", onWindowClosed);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/gis/Datum.ts
var FalseNorthing = 1e7;
var invF = 298.257223563;
var equatorialRadius = 6378137;
var pointScaleFactor = 0.9996;
var E0 = 5e5;
var flattening = 1 / invF;
var flatteningComp = 1 - flattening;
var n = flattening / (2 - flattening);
var A = equatorialRadius / (1 + n) * (1 + n * n / 4 + n * n * n * n / 64);
var e = Math.sqrt(1 - flatteningComp * flatteningComp);
var esq = 1 - flatteningComp * flatteningComp;
var e0sq = e * e / (1 - e * e);
var alpha1 = 1 - esq * (0.25 + esq * (3 / 64 + 5 * esq / 256));
var alpha2 = esq * (3 / 8 + esq * (3 / 32 + 45 * esq / 1024));
var alpha3 = esq * esq * (15 / 256 + esq * 45 / 1024);
var alpha4 = esq * esq * esq * (35 / 3072);
var beta = [
  n / 2 - 2 * n * n / 3 + 37 * n * n * n / 96,
  n * n / 48 + n * n * n / 15,
  17 * n * n * n / 480
];
var delta = [
  2 * n - 2 * n * n / 3,
  7 * n * n / 3 - 8 * n * n * n / 5,
  56 * n * n * n / 15
];
var DatumWGS_84 = {
  FalseNorthing,
  equatorialRadius,
  pointScaleFactor,
  E0,
  A,
  flattening,
  e,
  esq,
  e0sq,
  alpha1,
  alpha2,
  alpha3,
  alpha4,
  beta,
  delta
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/gis/UTMPoint.ts
var UTMPoint = class {
  static centroid(points) {
    const zoneCounts = /* @__PURE__ */ new Map();
    points.forEach((p) => zoneCounts.set(p.zone, (zoneCounts.get(p.zone) || 0) + 1));
    let maxZone = 0;
    let maxZoneCount = 0;
    for (const [zone, count] of zoneCounts) {
      if (count > maxZoneCount) {
        maxZone = zone;
        maxZoneCount = count;
      }
    }
    const scale3 = 1 / points.length;
    const vec = points.map((p) => p.rezone(maxZone).toVec3()).reduce((a, b) => vec3_exports.scaleAndAdd(a, a, b, scale3), vec3_exports.create());
    return new UTMPoint().fromVec3(vec, maxZone).toLatLng().toUTM();
  }
  /**
   * The east/west component of the coordinate.
   **/
  get easting() {
    return this._easting;
  }
  /**
   * The north/south component of the coordinate.
   **/
  get northing() {
    return this._northing;
  }
  /**
   * An altitude component.
   **/
  get altitude() {
    return this._altitude;
  }
  /**
   * The UTM Zone for which this coordinate represents.
   **/
  get zone() {
    return this._zone;
  }
  /**
   * The hemisphere in which the UTM point sits.
   **/
  get hemisphere() {
    return this.northing >= 0 ? "northern" : "southern";
  }
  constructor(eastingOrCopy, northing, altitude, zone) {
    if (isObject(eastingOrCopy)) {
      this._easting = eastingOrCopy.easting;
      this._northing = eastingOrCopy.northing;
      this._altitude = eastingOrCopy.altitude;
      this._zone = eastingOrCopy.zone;
    } else {
      this._easting = eastingOrCopy || 0;
      this._northing = northing || 0;
      this._altitude = altitude || 0;
      this._zone = zone || 0;
    }
  }
  toJSON() {
    return JSON.stringify({
      easting: this.easting,
      northing: this.northing,
      altitude: this.altitude,
      zone: this.zone,
      hemisphere: this.hemisphere
    });
  }
  toString() {
    return `(${this.easting}, ${this.northing}, ${this.altitude}) zone ${this.zone}`;
  }
  equals(other) {
    return isDefined(other) && this.hemisphere == other.hemisphere && this.easting == other.easting && this.northing == other.northing && this.altitude == other.altitude && this.zone == other.zone;
  }
  static A(cosPhi, lng, utmz) {
    const zcm = 3 + 6 * (utmz - 1) - 180;
    return deg2rad(lng - zcm) * cosPhi;
  }
  static getZoneWidthAtLatitude(lat) {
    const phi = deg2rad(lat);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    const tanPhi = sinPhi / cosPhi;
    const ePhi = DatumWGS_84.e * sinPhi;
    const N = DatumWGS_84.equatorialRadius / Math.sqrt(1 - ePhi * ePhi);
    const T = tanPhi * tanPhi;
    const C = DatumWGS_84.e0sq * cosPhi * cosPhi;
    const Tsqr = T * T;
    const A2 = deg2rad(3) * cosPhi;
    const Asqr = A2 * A2;
    const x0 = 1 - T + C;
    const x1 = 5 - 18 * T + Tsqr + 72 * C - 58 * DatumWGS_84.e0sq;
    const x2 = x0 / 6 + Asqr * x1 / 120;
    const x3 = 1 + Asqr * x2;
    const width = 2 * DatumWGS_84.pointScaleFactor * N * A2 * x3;
    return width;
  }
  /**
   * Converts this UTMPoint to a Latitude/Longitude point using the WGS-84 datum. The
   * coordinate pair's units will be in meters, and should be usable to make distance
   * calculations over short distances.
   * reference: http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  fromLatLng(latLng) {
    const phi = deg2rad(latLng.lat);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    const cosPhi2 = 2 * cosPhi;
    const sin2Phi = cosPhi2 * sinPhi;
    const cos2Phi = cosPhi2 * cosPhi - 1;
    const cos2Phi2 = 2 * cos2Phi;
    const sin4Phi = cos2Phi2 * sin2Phi;
    const cos4Phi = cos2Phi2 * cos2Phi - 1;
    const sin6Phi = sin4Phi * cos2Phi + cos4Phi * sin2Phi;
    const tanPhi = sinPhi / cosPhi;
    const ePhi = DatumWGS_84.e * sinPhi;
    const N = DatumWGS_84.equatorialRadius / Math.sqrt(1 - ePhi * ePhi);
    const M2 = DatumWGS_84.equatorialRadius * (phi * DatumWGS_84.alpha1 - sin2Phi * DatumWGS_84.alpha2 + sin4Phi * DatumWGS_84.alpha3 - sin6Phi * DatumWGS_84.alpha4);
    const utmz = 1 + (latLng.lng + 180) / 6 | 0;
    const A2 = UTMPoint.A(cosPhi, latLng.lng, utmz);
    const Asqr = A2 * A2;
    const T = tanPhi * tanPhi;
    const C = DatumWGS_84.e0sq * cosPhi * cosPhi;
    const Tsqr = T * T;
    const x0 = 1 - T + C;
    const x1 = 5 - 18 * T + Tsqr + 72 * C - 58 * DatumWGS_84.e0sq;
    const x2 = Asqr * x1 / 120;
    const x3 = x0 / 6 + x2;
    const x4 = 1 + Asqr * x3;
    const easting = DatumWGS_84.pointScaleFactor * N * A2 * x4 + DatumWGS_84.E0;
    const y0 = 5 - T + 9 * C + 4 * C * C;
    const y1 = 61 - 58 * T + Tsqr + 600 * C - 330 * DatumWGS_84.e0sq;
    const y2 = y0 / 24 + Asqr * y1 / 720;
    const y3 = 0.5 + Asqr * y2;
    const y4 = M2 + N * tanPhi * Asqr * y3;
    const northing = DatumWGS_84.pointScaleFactor * y4;
    this._easting = easting;
    this._northing = northing;
    this._altitude = latLng.alt;
    this._zone = utmz;
    return this;
  }
  rezone(newZone) {
    if (!(1 <= newZone && newZone <= 60)) {
      throw new Error(`Zones must be on the range [1, 60]. Given: ${newZone}`);
    }
    if (newZone !== this.zone) {
      const deltaZone = newZone - this.zone;
      const ll = this.toLatLng();
      const width = UTMPoint.getZoneWidthAtLatitude(ll.lat);
      return new UTMPoint(
        this.easting - width * deltaZone,
        this.northing,
        this.altitude,
        newZone
      );
    } else {
      return this;
    }
  }
  /**
   * Converts this UTMPoint to a Latitude/Longitude point using the WGS-84 datum. The
   * coordinate pair's units will be in meters, and should be usable to make distance
   * calculations over short distances.
   * reference: http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  toLatLng() {
    return new LatLngPoint().fromUTM(this);
  }
  toVec2() {
    const v = vec2_exports.create();
    vec2_exports.set(v, this.easting, -this.northing);
    return v;
  }
  fromVec2(arr, zone) {
    this._easting = arr[0];
    this._northing = -arr[1];
    this._altitude = 0;
    this._zone = zone;
    return this;
  }
  toVec3() {
    const v = vec3_exports.create();
    vec3_exports.set(v, this.easting, this.altitude, -this.northing);
    return v;
  }
  fromVec3(arr, zone) {
    this._easting = arr[0];
    this._altitude = arr[1];
    this._northing = -arr[2];
    this._zone = zone;
    return this;
  }
  copy(other) {
    this._easting = other.easting;
    this._northing = other.northing;
    this._altitude = other.altitude;
    this._zone = other.zone;
    return this;
  }
  clone() {
    return new UTMPoint(this);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/gis/LatLngPoint.ts
var LatLngPoint = class {
  static centroid(points) {
    const scale3 = 1 / points.length;
    const vec = points.map((p) => p.toVec3()).reduce((a, b) => vec3_exports.scaleAndAdd(a, a, b, scale3), vec3_exports.create());
    return new LatLngPoint().fromVec3(vec);
  }
  /**
   * An altitude value thrown in just for kicks. It makes some calculations and conversions
   * easier if we keep the Altitude value.
   **/
  get alt() {
    return this._alt;
  }
  /**
   * Lines of latitude run east/west around the globe, parallel to the equator, never
   * intersecting. They measure angular distance north/south.
   **/
  get lat() {
    return this._lat;
  }
  /**
   * Lines of longitude run north/south around the globe, intersecting at the poles. They
   * measure angular distance east/west.
   **/
  get lng() {
    return this._lng;
  }
  constructor(lat, lng, alt) {
    if (isObject(lat)) {
      this._lat = lat.lat;
      this._lng = lat.lng;
      this._alt = lat.alt;
    } else {
      this._lat = lat || 0;
      this._lng = lng || 0;
      this._alt = alt;
    }
  }
  toJSON() {
    return JSON.stringify({
      lat: this.lat,
      lng: this.lng,
      alt: this.alt
    });
  }
  static parseDMS(value) {
    const parts = value.split(" ");
    if (parts.length == 3) {
      const hemisphere = parts[0];
      const degrees = parseInt(parts[1], 10);
      const minutes = parseFloat(parts[2]);
      if ((hemisphere == "N" || hemisphere == "S" || hemisphere == "E" || hemisphere == "W") && Number.isInteger(degrees) && Number.isFinite(minutes)) {
        let dec = degrees + minutes / 60;
        if (hemisphere == "S" || hemisphere == "W") {
          dec *= -1;
        }
        return dec;
      }
    }
    return Number.NaN;
  }
  static parseDMSPair(value) {
    const parts = value.split(",");
    if (parts.length == 2) {
      const lat = LatLngPoint.parseDMS(parts[0]);
      const lng = LatLngPoint.parseDMS(parts[1]);
      if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
        return new LatLngPoint(lat, lng);
      }
    }
    return null;
  }
  static parseDecimal(value) {
    const parts = value.split(",");
    if (parts.length == 2) {
      const lat = parseFloat(parts[0].trim());
      const lng = parseFloat(parts[1].trim());
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        return new LatLngPoint(lat, lng);
      }
    }
    return null;
  }
  /**
   * Try to parse a string as a Latitude/Longitude.
   **/
  static parse(value) {
    const asDecimal = LatLngPoint.parseDecimal(value);
    const asDMS = LatLngPoint.parseDMSPair(value);
    return asDecimal || asDMS;
  }
  /**
   * Pretty-print the Degrees/Minutes/Second version of the Latitude/Longitude angles.
   * @param sigfigs
   */
  toDMS(sigfigs, withAltitude = true) {
    const latStr = LatLngPoint.toDMS(this.lat, "S", "N", sigfigs);
    const lngStr = LatLngPoint.toDMS(this.lng, "W", "E", sigfigs);
    if (this.alt && withAltitude) {
      const altStr = `${this.alt.toFixed(sigfigs)}m`;
      return `<${latStr}, ${lngStr}> alt ${altStr}`;
    } else {
      return `<${latStr}, ${lngStr}>`;
    }
  }
  toDMSArray(sigfigs, withAltitude = false) {
    const parts = [
      LatLngPoint.toDMS(this.lat, "S", "N", sigfigs),
      LatLngPoint.toDMS(this.lng, "W", "E", sigfigs)
    ];
    if (this.alt && withAltitude) {
      parts.push(`${this.alt.toFixed(sigfigs)}m`);
    }
    return parts;
  }
  /**
   * Pretty-print the Degrees/Minutes/Second version of the Latitude/Longitude angles.
   * @param value The decimal degree value to format
   * @param negative The string prefix to use when the value is negative
   * @param positive The string prefix to use when the value is positive
   * @param sigfigs The number of significant figures to which to print the value
   */
  static toDMS(value, negative, positive, sigfigs) {
    const hemisphere = value < 0 ? negative : positive;
    value = Math.abs(value);
    const degrees = Math.floor(value);
    const minutes = (value - degrees) * 60;
    const intMinutes = Math.floor(minutes);
    const seconds = (minutes - intMinutes) * 60;
    let secondsStr = seconds.toFixed(sigfigs);
    while (secondsStr.indexOf(".") <= 1) {
      secondsStr = `0${secondsStr}`;
    }
    return `${hemisphere} ${degrees.toFixed(0)}\xB0 ${intMinutes.toFixed(0)}' ${secondsStr}"`;
  }
  /**
   * Pretty-print the LatLngPoint for easier debugging.
   * @param sigfigs
   */
  toString(sigfigs) {
    sigfigs = sigfigs || 6;
    return `(${this.lat.toFixed(sigfigs)}\xB0, ${this.lng.toFixed(sigfigs)}\xB0)`;
  }
  /**
   * Check two LatLngPoints to see if they overlap.
   * @param other
   */
  equals(other) {
    return isObject(other) && this.lat == other.lat && this.lng == other.lng && this.alt == other.alt;
  }
  compareTo(other) {
    if (isNullOrUndefined(other)) {
      return -1;
    } else {
      const byLat = this.lat - other.lat;
      const byLng = this.lng - other.lng;
      const byAlt = (this.alt || 0) - (other.alt || 0);
      if (byLat == 0 && byLng == 0) {
        return byAlt;
      } else if (byLat == 0) {
        return byLng;
      } else {
        return byLat;
      }
    }
  }
  /**
   * Calculate a rough distance, in meters, between two LatLngPoints.
   * @param other
   */
  distance(other) {
    const a = this.toUTM();
    const b = other.toUTM().rezone(a.zone);
    const dx = b.easting - a.easting;
    const dy = b.northing - a.northing;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Converts this UTMPoint to a Latitude/Longitude point using the WGS-84 datum. The
   * coordinate pair's units will be in meters, and should be usable to make distance
   * calculations over short distances.
   * reference: http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  fromUTM(utm) {
    const N0 = utm.hemisphere === "southern" && utm.northing >= 0 ? DatumWGS_84.FalseNorthing : 0;
    const xi = (utm.northing - N0) / (DatumWGS_84.pointScaleFactor * DatumWGS_84.A);
    const eta = (utm.easting - DatumWGS_84.E0) / (DatumWGS_84.pointScaleFactor * DatumWGS_84.A);
    let xiPrime = xi;
    let etaPrime = eta;
    for (let j = 1; j <= 3; ++j) {
      const beta2 = DatumWGS_84.beta[j - 1];
      const je2 = 2 * j * xi;
      const jn2 = 2 * j * eta;
      const sinje2 = Math.sin(je2);
      const coshjn2 = Math.cosh(jn2);
      const cosje2 = Math.cos(je2);
      const sinhjn2 = Math.sinh(jn2);
      xiPrime -= beta2 * sinje2 * coshjn2;
      etaPrime -= beta2 * cosje2 * sinhjn2;
    }
    const chi = Math.asin(Math.sin(xiPrime) / Math.cosh(etaPrime));
    let lat = chi;
    for (let j = 1; j <= 3; ++j) {
      lat += DatumWGS_84.delta[j - 1] * Math.sin(2 * j * chi);
    }
    const long0 = utm.zone * 6 - 183;
    const lng = Math.atan(Math.sinh(etaPrime) / Math.cos(xiPrime));
    this._lat = rad2deg(lat);
    this._lng = long0 + rad2deg(lng);
    while (this._lng < -180) {
      this._lng += 360;
    }
    while (this._lng > 180) {
      this._lng -= 360;
    }
    this._alt = utm.altitude;
    return this;
  }
  /**
   * Converts this LatLngPoint to a Universal Transverse Mercator point using the WGS-84
   * datum. The coordinate pair's units will be in meters, and should be usable to make
   * distance calculations over short distances.
   *
   * @see http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  toUTM() {
    return new UTMPoint().fromLatLng(this);
  }
  toVec2() {
    const v = vec2_exports.create();
    vec2_exports.set(v, this.lng, this.lat);
    return v;
  }
  fromVec2(v) {
    this._lng = v[0];
    this._lat = v[1];
    this._alt = void 0;
    return this;
  }
  toVec3() {
    const v = vec3_exports.create();
    vec3_exports.set(v, this.lng, this.alt, this.lat);
    return v;
  }
  fromVec3(v) {
    this._lng = v[0];
    this._alt = v[1];
    this._lat = v[2];
    return this;
  }
  toArray() {
    return [this._lng, this._alt, this._lat];
  }
  fromArray(arr) {
    return this.fromVec3(arr);
  }
  copy(other) {
    this._lat = other.lat;
    this._lng = other.lng;
    this._alt = other.alt;
    return this;
  }
  clone() {
    return new LatLngPoint(this);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressTasks.ts
async function progressTasksWeighted(prog, taskDefs) {
  const weights = new Array(taskDefs.length);
  const callbacks = new Array(taskDefs.length);
  for (let i = 0; i < taskDefs.length; ++i) {
    const taskDef = taskDefs[i];
    weights[i] = taskDef[0];
    callbacks[i] = taskDef[1];
  }
  const progs = progressSplitWeighted(prog, weights);
  const tasks = new Array(taskDefs.length);
  for (let i = 0; i < taskDefs.length; ++i) {
    tasks[i] = callbacks[i](progs[i]);
  }
  return await Promise.all(tasks);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/YouTubeProxy.ts
function isYouTube(url2) {
  return url2.hostname === "www.youtube.com" || url2.hostname === "youtube.com" || url2.hostname === "youtu.be";
}
var codecReplaces = /* @__PURE__ */ new Map([
  ["vp9", "vp09.00.10.08"]
]);
function classifyFormat(f) {
  if (isNullOrUndefined(f.vcodec) || f.vcodec === "none") {
    return "audio";
  }
  return "video";
}
function combineContentTypeAndCodec(content_type, codec) {
  const parts = [content_type];
  if (isDefined(codec) && codec.length > 0 && codec !== "none") {
    codec = codecReplaces.get(codec) || codec;
  }
  if (isDefined(codec) && codec.length > 0 && codec !== "none") {
    const asterisk2 = encodeURI(codec) !== codec ? "*" : "";
    parts.push(`codecs${asterisk2}="${codec}"`);
  }
  return parts.join(";");
}
var YouTubeProxy = class {
  constructor(fetcher, makeProxyURL2) {
    this.fetcher = fetcher;
    this.makeProxyURL = makeProxyURL2;
  }
  makeVideoRecord(f) {
    const { content_type, acodec, vcodec } = f;
    const fullContentType = combineContentTypeAndCodec(content_type, vcodec);
    return {
      contentType: fullContentType,
      url: this.makeProxyURL(f.url).href,
      acodec,
      abr: f.abr * 1024,
      asr: f.asr,
      vcodec,
      vbr: f.vbr * 1024,
      fps: f.fps,
      width: f.width,
      height: f.height,
      resolution: f.width * f.height
    };
  }
  makeAudioRecord(f) {
    const { content_type, acodec } = f;
    const fullContentType = combineContentTypeAndCodec(content_type, acodec);
    return {
      contentType: fullContentType,
      url: this.makeProxyURL(f.url).href,
      acodec,
      abr: f.abr * 1024,
      asr: f.asr,
      resolution: f.abr
    };
  }
  makeImageRecord(f) {
    const { content_type, url: url2, width, height } = f;
    return {
      contentType: content_type,
      url: this.makeProxyURL(url2).href,
      width,
      height,
      resolution: width * height
    };
  }
  async loadData(pageURLOrMetadata, prog) {
    if (isNullOrUndefined(pageURLOrMetadata)) {
      throw new Error("must provide a YouTube URL or a YTMetadata object");
    }
    if (isDefined(prog)) {
      prog.start();
    }
    let metadata = null;
    if (isString(pageURLOrMetadata)) {
      metadata = await this.fetcher.get(pageURLOrMetadata).progress(prog).object().then(unwrapResponse);
    } else {
      if (isDefined(prog)) {
        prog.end(pageURLOrMetadata.title);
      }
      metadata = pageURLOrMetadata;
    }
    let startTime = 0;
    if (isDefined(metadata.original_url)) {
      const url2 = new URL(metadata.original_url);
      if (isYouTube(url2) && url2.searchParams.has("t")) {
        startTime = parseFloat(url2.searchParams.get("t"));
      }
    }
    const formats = new PriorityList((await Promise.all(metadata.formats)).map((f) => [classifyFormat(f), f]));
    const title = metadata.title;
    const thumbnails = metadata.thumbnails || [];
    const thumbnail = metadata.thumbnail && this.makeImageRecord(arrayScan(thumbnails, (t2) => t2.url === metadata.thumbnail));
    const videos = formats.get("video").map((f) => this.makeVideoRecord(f));
    const audios = formats.get("audio").map((f) => this.makeAudioRecord(f));
    const data = {
      title,
      thumbnail,
      videos,
      audios,
      startTime
    };
    return data;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/fonts.ts
var loadedFonts = singleton("juniper::loadedFonts", () => []);
function makeFont(style) {
  const fontParts = [];
  if (style.fontStyle && style.fontStyle !== "normal") {
    fontParts.push(style.fontStyle);
  }
  if (style.fontVariant && style.fontVariant !== "normal") {
    fontParts.push(style.fontVariant);
  }
  if (style.fontWeight && style.fontWeight !== "normal") {
    fontParts.push(style.fontWeight);
  }
  fontParts.push(px(style.fontSize));
  fontParts.push(style.fontFamily);
  return fontParts.join(" ");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/strings/stringRandom.ts
var DEFAULT_CHAR_SET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZ";
function stringRandom(length3, charSet) {
  if (length3 < 0) {
    throw new Error("Length must be greater than 0");
  }
  if (isNullOrUndefined(charSet)) {
    charSet = DEFAULT_CHAR_SET;
  }
  let str3 = "";
  for (let i = 0; i < length3; ++i) {
    const idx = Math.floor(Math.random() * charSet.length);
    str3 += charSet[idx];
  }
  return str3;
}

// package.json
var version3 = "3.7.24";

// src/isDebug.ts
var url = /* @__PURE__ */ new URL(globalThis.location.href);
var isDebug = !url.searchParams.has("RELEASE");

// src/settings.ts
var version4 = isDebug ? stringRandom(10) : version3;
var DEMO_PPI = 50;
var DEMO_DIM = 12;
var DEMO_PX = DEMO_PPI * DEMO_DIM;
var defaultFont = {
  fontFamily: "Lato",
  fontSize: 20
};
var DLSBlue = rgb(30, 67, 136);
var BasicLabelColor = rgb(78, 77, 77);
var baseTextStyle = {
  fontFamily: defaultFont.fontFamily,
  fontSize: defaultFont.fontSize,
  textFillColor: "white"
};
var textButtonStyle = Object.assign({}, baseTextStyle, {
  bgFillColor: rgb(0, 120, 215),
  bgStrokeColor: "black",
  bgStrokeSize: 0.02,
  padding: {
    top: 0.025,
    left: 0.05,
    bottom: 0.025,
    right: 0.05
  },
  minHeight: 0.2,
  maxHeight: 0.2,
  scale: 300
});
var textLabelStyle = Object.assign({}, baseTextStyle, {
  textStrokeColor: "black",
  textStrokeSize: 0.01,
  minHeight: 0.25,
  maxHeight: 0.25
});
var JS_EXT = isDebug ? ".js" : ".min.js";
function getAppUrl(ext, name) {
  return `/js/${name}/index${ext}?v=${version4}`;
}
function getScriptUrl(name) {
  return getAppUrl(JS_EXT, name);
}
function getWorkerUrl(name) {
  return getScriptUrl("workers/" + name);
}
function getLibScriptUrl(name) {
  return getScriptUrl("libs/" + name);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/Emoji.ts
var Emoji = class {
  /**
   * Creates a new Unicode-standardized pictograms.
   * @param value - a Unicode sequence.
   * @param desc - an English text description of the pictogram.
   * @param props - an optional set of properties to store with the emoji.
   */
  constructor(value, desc, props = null) {
    this.value = value;
    this.desc = desc;
    this.value = value;
    this.desc = desc;
    this.props = props || {};
  }
  /**
   * Determines of the provided Emoji or EmojiGroup is a subset of
   * this emoji.
   */
  contains(e2) {
    if (e2 instanceof Emoji) {
      return this.contains(e2.value);
    } else {
      return this.value.indexOf(e2) >= 0;
    }
  }
  changeStyle(expected, wanted) {
    let value = this.value;
    if (value.endsWith(expected)) {
      value = value.substring(0, value.length - expected.length);
    }
    value += wanted;
    return value;
  }
  get textStyle() {
    return this.changeStyle("\uFE0F", "\uFE0E");
  }
  get emojiStyle() {
    return this.changeStyle("\uFE0E", "\uFE0F");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/EmojiGroup.ts
var EmojiGroup = class extends Emoji {
  /**
   * Groupings of Unicode-standardized pictograms.
   * @param value - a Unicode sequence.
   * @param desc - an English text description of the pictogram.
   * @param ...rest - Emojis in this group.
   */
  constructor(value, desc, ...alts) {
    super(value, desc);
    this.width = null;
    this.alts = alts;
  }
  /**
   * Selects a random emoji out of the collection.
   **/
  random() {
    const idx = Math.floor(Math.random() * this.alts.length);
    if (idx < 0) {
      return null;
    }
    const selection = this.alts[idx];
    if (selection instanceof EmojiGroup) {
      return selection.random();
    } else {
      return selection;
    }
  }
  contains(e2) {
    if (super.contains(e2)) {
      return true;
    } else {
      for (const alt of this.alts) {
        if (alt.contains(e2)) {
          return true;
        }
      }
      return false;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/index.ts
var upArrowText = /* @__PURE__ */ new Emoji("\u2B06\uFE0E", "Up Arrow: Text");
var keycapDigitZero = /* @__PURE__ */ new Emoji("0\uFE0F\u20E3", "Keycap Digit Zero");
var keycapDigitOne = /* @__PURE__ */ new Emoji("1\uFE0F\u20E3", "Keycap Digit One");
var keycapDigitTwo = /* @__PURE__ */ new Emoji("2\uFE0F\u20E3", "Keycap Digit Two");
var keycapDigitThree = /* @__PURE__ */ new Emoji("3\uFE0F\u20E3", "Keycap Digit Three");
var keycapDigitFour = /* @__PURE__ */ new Emoji("4\uFE0F\u20E3", "Keycap Digit Four");
var keycapDigitFive = /* @__PURE__ */ new Emoji("5\uFE0F\u20E3", "Keycap Digit Five");
var keycapDigitSix = /* @__PURE__ */ new Emoji("6\uFE0F\u20E3", "Keycap Digit Six");
var keycapDigitSeven = /* @__PURE__ */ new Emoji("7\uFE0F\u20E3", "Keycap Digit Seven");
var keycapDigitEight = /* @__PURE__ */ new Emoji("8\uFE0F\u20E3", "Keycap Digit Eight");
var keycapDigitNine = /* @__PURE__ */ new Emoji("9\uFE0F\u20E3", "Keycap Digit Nine");
var keycap10 = /* @__PURE__ */ new Emoji("\u{1F51F}", "Keycap: 10");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/numbers.ts
var keycapDigits = /* @__PURE__ */ new EmojiGroup(
  "Keycap Digits",
  "Keycap Digits",
  keycapDigitZero,
  keycapDigitOne,
  keycapDigitTwo,
  keycapDigitThree,
  keycapDigitFour,
  keycapDigitFive,
  keycapDigitSix,
  keycapDigitSeven,
  keycapDigitEight,
  keycapDigitNine,
  keycap10
);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/setGeometryUVsForCubemaps.ts
function setGeometryUVsForCubemaps(geom) {
  const positions = geom.attributes.position;
  const normals = geom.attributes.normal;
  const uvs = geom.attributes.uv;
  for (let n2 = 0; n2 < normals.count; ++n2) {
    const _x = n2 * normals.itemSize, _y = n2 * normals.itemSize + 1, _z = n2 * normals.itemSize + 2, nx = normals.array[_x], ny = normals.array[_y], nz = normals.array[_z], _nx_ = Math.abs(nx), _ny_ = Math.abs(ny), _nz_ = Math.abs(nz), px2 = positions.array[_x], py = positions.array[_y], pz = positions.array[_z], _px_ = Math.abs(px2), _py_ = Math.abs(py), _pz_ = Math.abs(pz), _u = n2 * uvs.itemSize, _v = n2 * uvs.itemSize + 1;
    let u = uvs.array[_u], v = uvs.array[_v], largest = 0, mx = _nx_, max3 = _px_;
    if (_ny_ > mx) {
      largest = 1;
      mx = _ny_;
      max3 = _py_;
    }
    if (_nz_ > mx) {
      largest = 2;
      mx = _nz_;
      max3 = _pz_;
    }
    if (largest === 0) {
      if (px2 < 0) {
        u = -pz;
        v = py;
      } else {
        u = pz;
        v = py;
      }
    } else if (largest === 1) {
      if (py < 0) {
        u = px2;
        v = -pz;
      } else {
        u = px2;
        v = pz;
      }
    } else {
      if (pz < 0) {
        u = px2;
        v = py;
      } else {
        u = -px2;
        v = py;
      }
    }
    u = (u / max3 + 1) / 8;
    v = (v / max3 + 1) / 6;
    if (largest === 0) {
      if (px2 < 0) {
        u += 0;
        v += 1 / 3;
      } else {
        u += 0.5;
        v += 1 / 3;
      }
    } else if (largest === 1) {
      if (py < 0) {
        u += 0.25;
        v += 0;
      } else {
        u += 0.25;
        v += 2 / 3;
      }
    } else {
      if (pz < 0) {
        u += 0.25;
        v += 1 / 3;
      } else {
        u += 0.75;
        v += 1 / 3;
      }
    }
    const arr = uvs.array;
    arr[_u] = u;
    arr[_v] = v;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Cube.ts
var cubeGeom = /* @__PURE__ */ new BoxGeometry(1, 1, 1, 1, 1, 1);
cubeGeom.name = "CubeGeom";
cubeGeom.computeBoundingBox();
cubeGeom.computeBoundingSphere();
var invCubeGeom = /* @__PURE__ */ cubeGeom.clone();
invCubeGeom.name = "InvertedCubeGeom";
setGeometryUVsForCubemaps(invCubeGeom);
var Cube = class extends Mesh {
  constructor(sx, sy, sz, material) {
    super(cubeGeom, material);
    this.scale.set(sx, sy, sz);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value) {
          this.uniforms.diffuse.value = value;
        }
      },
      worldUnits: {
        enumerable: true,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(value) {
          if (value === true) {
            this.defines.WORLD_UNITS = "";
          } else {
            delete this.defines.WORLD_UNITS;
          }
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value) {
          this.uniforms.linewidth.value = value;
        }
      },
      dashed: {
        enumerable: true,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(value) {
          if (Boolean(value) !== Boolean("USE_DASH" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_DASH = "";
          } else {
            delete this.defines.USE_DASH;
          }
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value) {
          this.uniforms.dashScale.value = value;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value) {
          this.uniforms.dashSize.value = value;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value) {
          this.uniforms.dashOffset.value = value;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value) {
          this.uniforms.gapSize.value = value;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value) {
          this.uniforms.opacity.value = value;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value) {
          this.uniforms.resolution.value.copy(value);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value) {
          if (Boolean(value) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value === true) {
            this.defines.USE_ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.USE_ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  }
};
LineMaterial.prototype.isLineMaterial = true;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/materials.ts
var materials = singleton("Juniper:Three:Materials", () => /* @__PURE__ */ new Map());
function del(obj2, name) {
  if (name in obj2) {
    delete obj2[name];
  }
}
function makeMaterial(slug, material, options) {
  const key = `${slug}_${Object.keys(options).map((k) => `${k}:${options[k]}`).join(",")}`;
  if (!materials.has(key)) {
    del(options, "name");
    materials.set(key, new material(options));
  }
  return materials.get(key);
}
function trans(options) {
  return Object.assign(options, {
    transparent: true
  });
}
function solid(options) {
  return makeMaterial("solid", MeshBasicMaterial, options);
}
function solidTransparent(options) {
  return makeMaterial("solidTransparent", MeshBasicMaterial, trans(options));
}
function convertMaterials(root, convertMaterial) {
  const oldMats = /* @__PURE__ */ new Set();
  root.traverse((obj2) => {
    if (isMesh(obj2) && isMaterial(obj2.material)) {
      const oldMat = obj2.material;
      const newMat = convertMaterial(oldMat);
      if (oldMat !== newMat) {
        oldMats.add(oldMat);
        obj2.material = newMat;
      }
    }
  });
  for (const oldMat of oldMats) {
    dispose2(oldMat);
  }
}
function materialStandardToPhong(oldMat) {
  if (oldMat.type !== "MeshStandardMaterial") {
    throw new Error("Input material is not MeshStandardMaterial");
  }
  const params = {
    alphaMap: oldMat.alphaMap,
    alphaTest: oldMat.alphaTest,
    alphaToCoverage: oldMat.alphaToCoverage,
    aoMap: oldMat.aoMap,
    aoMapIntensity: oldMat.aoMapIntensity,
    blendDst: oldMat.blendDst,
    blendDstAlpha: oldMat.blendDstAlpha,
    blendEquation: oldMat.blendEquation,
    blendEquationAlpha: oldMat.blendEquationAlpha,
    blending: oldMat.blending,
    blendSrc: oldMat.blendSrc,
    blendSrcAlpha: oldMat.blendSrcAlpha,
    bumpMap: oldMat.bumpMap,
    bumpScale: oldMat.bumpScale,
    clipIntersection: oldMat.clipIntersection,
    clippingPlanes: oldMat.clippingPlanes,
    clipShadows: oldMat.clipShadows,
    color: oldMat.color,
    colorWrite: oldMat.colorWrite,
    depthFunc: oldMat.depthFunc,
    depthTest: oldMat.depthTest,
    depthWrite: oldMat.depthWrite,
    displacementBias: oldMat.displacementBias,
    displacementMap: oldMat.displacementMap,
    displacementScale: oldMat.displacementScale,
    dithering: oldMat.dithering,
    emissive: oldMat.emissive,
    emissiveIntensity: oldMat.emissiveIntensity,
    emissiveMap: oldMat.emissiveMap,
    envMap: oldMat.envMap,
    flatShading: oldMat.flatShading,
    fog: oldMat.fog,
    lightMap: oldMat.lightMap,
    lightMapIntensity: oldMat.lightMapIntensity,
    map: oldMat.map,
    name: oldMat.name + "-Standard-To-Phong",
    normalMap: oldMat.normalMap,
    normalMapType: oldMat.normalMapType,
    normalScale: oldMat.normalScale,
    opacity: oldMat.opacity,
    polygonOffset: oldMat.polygonOffset,
    polygonOffsetFactor: oldMat.polygonOffsetFactor,
    polygonOffsetUnits: oldMat.polygonOffsetUnits,
    precision: oldMat.precision,
    premultipliedAlpha: oldMat.premultipliedAlpha,
    shadowSide: oldMat.shadowSide,
    side: oldMat.side,
    stencilFail: oldMat.stencilFail,
    stencilFunc: oldMat.stencilFunc,
    stencilFuncMask: oldMat.stencilFuncMask,
    stencilRef: oldMat.stencilRef,
    stencilWrite: oldMat.stencilWrite,
    stencilWriteMask: oldMat.stencilWriteMask,
    stencilZFail: oldMat.stencilZFail,
    stencilZPass: oldMat.stencilZPass,
    toneMapped: oldMat.toneMapped,
    transparent: oldMat.transparent,
    userData: oldMat.userData,
    vertexColors: oldMat.vertexColors,
    visible: oldMat.visible,
    wireframe: oldMat.wireframe,
    wireframeLinecap: oldMat.wireframeLinecap,
    wireframeLinejoin: oldMat.wireframeLinejoin,
    wireframeLinewidth: oldMat.wireframeLinewidth
  };
  for (const [key, value] of Object.entries(params)) {
    if (isNullOrUndefined(value)) {
      delete params[key];
    }
  }
  return new MeshPhongMaterial(params);
}
var white = 16777215;
var solidWhite = /* @__PURE__ */ solid({ color: white });

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/TextImage.ts
var TextImage = class extends CanvasImage {
  constructor(options) {
    super(10, 10, options);
    this.trueWidth = null;
    this.trueHeight = null;
    this.trueFontSize = null;
    this.dx = null;
    this._minWidth = null;
    this._maxWidth = null;
    this._minHeight = null;
    this._maxHeight = null;
    this._freezeDimensions = false;
    this._dimensionsFrozen = false;
    this._bgFillColor = null;
    this._bgStrokeColor = null;
    this._bgStrokeSize = null;
    this._textStrokeColor = null;
    this._textStrokeSize = null;
    this._textFillColor = "black";
    this._textDirection = "horizontal";
    this._fontStyle = "normal";
    this._fontVariant = "normal";
    this._fontWeight = "normal";
    this._fontFamily = "sans-serif";
    this._fontSize = 20;
    this._value = null;
    this.lastValue = null;
    if (isDefined(options)) {
      if (isDefined(options.minWidth)) {
        this._minWidth = options.minWidth;
      }
      if (isDefined(options.maxWidth)) {
        this._maxWidth = options.maxWidth;
      }
      if (isDefined(options.minHeight)) {
        this._minHeight = options.minHeight;
      }
      if (isDefined(options.maxHeight)) {
        this._maxHeight = options.maxHeight;
      }
      if (isDefined(options.freezeDimensions)) {
        this._freezeDimensions = options.freezeDimensions;
      }
      if (isDefined(options.textStrokeColor)) {
        this._textStrokeColor = options.textStrokeColor;
      }
      if (isDefined(options.textStrokeSize)) {
        this._textStrokeSize = options.textStrokeSize;
      }
      if (isDefined(options.bgFillColor)) {
        this._bgFillColor = options.bgFillColor;
      }
      if (isDefined(options.bgStrokeColor)) {
        this._bgStrokeColor = options.bgStrokeColor;
      }
      if (isDefined(options.bgStrokeSize)) {
        this._bgStrokeSize = options.bgStrokeSize;
      }
      if (isDefined(options.value)) {
        this._value = options.value;
      }
      if (isDefined(options.textFillColor)) {
        this._textFillColor = options.textFillColor;
      }
      if (isDefined(options.textDirection)) {
        this._textDirection = options.textDirection;
      }
      if (isDefined(options.fontStyle)) {
        this._fontStyle = options.fontStyle;
      }
      if (isDefined(options.fontVariant)) {
        this._fontVariant = options.fontVariant;
      }
      if (isDefined(options.fontWeight)) {
        this._fontWeight = options.fontWeight;
      }
      if (isDefined(options.fontFamily)) {
        this._fontFamily = options.fontFamily;
      }
      if (isDefined(options.fontSize)) {
        this._fontSize = options.fontSize;
      }
      if (isDefined(options.padding)) {
        if (isNumber(options.padding)) {
          this._padding = {
            left: options.padding,
            right: options.padding,
            top: options.padding,
            bottom: options.padding
          };
        } else {
          this._padding = options.padding;
        }
      }
    }
    if (isNullOrUndefined(this._padding)) {
      this._padding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    this.redraw();
  }
  get minWidth() {
    return this._minWidth;
  }
  set minWidth(v) {
    if (this.minWidth !== v) {
      this._minWidth = v;
      this.redraw();
    }
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(v) {
    if (this.maxWidth !== v) {
      this._maxWidth = v;
      this.redraw();
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  set minHeight(v) {
    if (this.minHeight !== v) {
      this._minHeight = v;
      this.redraw();
    }
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set maxHeight(v) {
    if (this.maxHeight !== v) {
      this._maxHeight = v;
      this.redraw();
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(v) {
    if (v instanceof Array) {
      throw new Error("Invalid padding");
    }
    if (this.padding.top !== v.top || this.padding.right != v.right || this.padding.bottom != v.bottom || this.padding.left != v.left) {
      this._padding = v;
      this.redraw();
    }
  }
  get textDirection() {
    return this._textDirection;
  }
  set textDirection(v) {
    if (this.textDirection !== v) {
      this._textDirection = v;
      this.redraw();
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(v) {
    if (this.fontStyle !== v) {
      this._fontStyle = v;
      this.redraw();
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(v) {
    if (this.fontVariant !== v) {
      this._fontVariant = v;
      this.redraw();
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(v) {
    if (this.fontWeight !== v) {
      this._fontWeight = v;
      this.redraw();
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(v) {
    if (this.fontSize !== v) {
      this._fontSize = v;
      this.redraw();
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(v) {
    if (this.fontFamily !== v) {
      this._fontFamily = v;
      this.redraw();
    }
  }
  get textFillColor() {
    return this._textFillColor;
  }
  set textFillColor(v) {
    if (this.textFillColor !== v) {
      this._textFillColor = v;
      this.redraw();
    }
  }
  get textStrokeColor() {
    return this._textStrokeColor;
  }
  set textStrokeColor(v) {
    if (this.textStrokeColor !== v) {
      this._textStrokeColor = v;
      this.redraw();
    }
  }
  get textStrokeSize() {
    return this._textStrokeSize;
  }
  set textStrokeSize(v) {
    if (this.textStrokeSize !== v) {
      this._textStrokeSize = v;
      this.redraw();
    }
  }
  get bgFillColor() {
    return this._bgFillColor;
  }
  set bgFillColor(v) {
    if (this.bgFillColor !== v) {
      this._bgFillColor = v;
      this.redraw();
    }
  }
  get bgStrokeColor() {
    return this._bgStrokeColor;
  }
  set bgStrokeColor(v) {
    if (this.bgStrokeColor !== v) {
      this._bgStrokeColor = v;
      this.redraw();
    }
  }
  get bgStrokeSize() {
    return this._bgStrokeSize;
  }
  set bgStrokeSize(v) {
    if (this.bgStrokeSize !== v) {
      this._bgStrokeSize = v;
      this.redraw();
    }
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (this.value !== v) {
      this._value = v;
      this.redraw();
    }
  }
  split(value) {
    return value.replace(/\r\n/g, "\n").split("\n");
  }
  unfreeze() {
    this._dimensionsFrozen = false;
  }
  onRedraw() {
    this.onClear();
    if (this.visible && this.fontFamily && this.fontSize && (this.textFillColor || this.textStrokeColor && this.textStrokeSize) && this.value && this.value !== this.lastValue) {
      const lines = this.split(this.value);
      const isVertical = this.textDirection && this.textDirection.indexOf("vertical") === 0;
      if (this.trueWidth === null || this.trueHeight === null || this.dx === null || this.trueFontSize === null || !this._dimensionsFrozen) {
        this._dimensionsFrozen = this._freezeDimensions;
        const autoResize = this.minWidth != null || this.maxWidth != null || this.minHeight != null || this.maxHeight != null;
        const _targetMinWidth = ((this.minWidth || 0) - this.padding.right - this.padding.left) * this.scale;
        const _targetMaxWidth = ((this.maxWidth || 4096) - this.padding.right - this.padding.left) * this.scale;
        const _targetMinHeight = ((this.minHeight || 0) - this.padding.top - this.padding.bottom) * this.scale;
        const _targetMaxHeight = ((this.maxHeight || 4096) - this.padding.top - this.padding.bottom) * this.scale;
        const targetMinWidth = isVertical ? _targetMinHeight : _targetMinWidth;
        const targetMaxWidth = isVertical ? _targetMaxHeight : _targetMaxWidth;
        const targetMinHeight = isVertical ? _targetMinWidth : _targetMinHeight;
        const targetMaxHeight = isVertical ? _targetMaxWidth : _targetMaxHeight;
        const tried = [];
        this.trueWidth = 0;
        this.trueHeight = 0;
        this.dx = 0;
        let tooBig = false, tooSmall = false, highFontSize = 1e4, lowFontSize = 0;
        this.trueFontSize = clamp(this.fontSize * this.scale, lowFontSize, highFontSize);
        let minFont = null, minFontDelta = Number.MAX_VALUE;
        do {
          const realFontSize = this.fontSize;
          this._fontSize = this.trueFontSize;
          const font = makeFont(this);
          this._fontSize = realFontSize;
          this.g.textAlign = "center";
          this.g.textBaseline = "middle";
          this.g.font = font;
          this.trueWidth = 0;
          this.trueHeight = 0;
          for (const line of lines) {
            const metrics = this.g.measureText(line);
            this.trueWidth = Math.max(this.trueWidth, metrics.width);
            this.trueHeight += this.trueFontSize;
            if (isNumber(metrics.actualBoundingBoxLeft) && isNumber(metrics.actualBoundingBoxRight) && isNumber(metrics.actualBoundingBoxAscent) && isNumber(metrics.actualBoundingBoxDescent)) {
              if (!autoResize) {
                this.trueWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                this.trueHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                this.dx = (metrics.actualBoundingBoxLeft - this.trueWidth / 2) / 2;
              }
            }
          }
          if (autoResize) {
            const dMinWidth = this.trueWidth - targetMinWidth;
            const dMaxWidth = this.trueWidth - targetMaxWidth;
            const dMinHeight = this.trueHeight - targetMinHeight;
            const dMaxHeight = this.trueHeight - targetMaxHeight;
            const mdMinWidth = Math.abs(dMinWidth);
            const mdMaxWidth = Math.abs(dMaxWidth);
            const mdMinHeight = Math.abs(dMinHeight);
            const mdMaxHeight = Math.abs(dMaxHeight);
            tooBig = dMaxWidth > 1 || dMaxHeight > 1;
            tooSmall = dMinWidth < -1 && dMinHeight < -1;
            const minDif = Math.min(mdMinWidth, Math.min(mdMaxWidth, Math.min(mdMinHeight, mdMaxHeight)));
            if (minDif < minFontDelta) {
              minFontDelta = minDif;
              minFont = this.g.font;
            }
            if ((tooBig || tooSmall) && tried.indexOf(this.g.font) > -1 && minFont) {
              this.g.font = minFont;
              tooBig = false;
              tooSmall = false;
            }
            if (tooBig) {
              highFontSize = this.trueFontSize;
              this.trueFontSize = (lowFontSize + this.trueFontSize) / 2;
            } else if (tooSmall) {
              lowFontSize = this.trueFontSize;
              this.trueFontSize = (this.trueFontSize + highFontSize) / 2;
            }
          }
          tried.push(this.g.font);
        } while (tooBig || tooSmall);
        if (autoResize) {
          if (this.trueWidth < targetMinWidth) {
            this.trueWidth = targetMinWidth;
          } else if (this.trueWidth > targetMaxWidth) {
            this.trueWidth = targetMaxWidth;
          }
          if (this.trueHeight < targetMinHeight) {
            this.trueHeight = targetMinHeight;
          } else if (this.trueHeight > targetMaxHeight) {
            this.trueHeight = targetMaxHeight;
          }
        }
        const newW = this.trueWidth + this.scale * (this.padding.right + this.padding.left);
        const newH = this.trueHeight + this.scale * (this.padding.top + this.padding.bottom);
        try {
          setContextSize(this.g, newW, newH);
        } catch (exp) {
          console.error(exp);
          throw exp;
        }
      }
      if (this.bgFillColor) {
        this.g.fillStyle = this.bgFillColor;
        this.g.fillRect(0, 0, this.canvas.width, this.canvas.height);
      } else {
        this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
      if (this.textStrokeColor && this.textStrokeSize) {
        this.g.lineWidth = this.textStrokeSize * this.scale;
        this.g.strokeStyle = this.textStrokeColor;
      }
      if (this.textFillColor) {
        this.g.fillStyle = this.textFillColor;
      }
      const di = 0.5 * (lines.length - 1);
      for (let i = 0; i < lines.length; ++i) {
        const line = lines[i];
        const dy = (i - di) * this.trueFontSize;
        const x = this.dx + this.trueWidth / 2 + this.scale * this.padding.left;
        const y = dy + this.trueHeight / 2 + this.scale * this.padding.top;
        if (this.textStrokeColor && this.textStrokeSize) {
          this.g.strokeText(line, x, y);
        }
        if (this.textFillColor) {
          this.g.fillText(line, x, y);
        }
      }
      if (this.bgStrokeColor && this.bgStrokeSize) {
        this.g.strokeStyle = this.bgStrokeColor;
        this.g.lineWidth = this.bgStrokeSize * this.scale;
        const s = this.bgStrokeSize / 2;
        this.g.strokeRect(s, s, this.canvas.width - this.bgStrokeSize, this.canvas.height - this.bgStrokeSize);
      }
      if (isVertical) {
        const canv = createUtilityCanvas(this.canvas.height, this.canvas.width);
        const g = canv.getContext("2d");
        if (g) {
          g.translate(canv.width / 2, canv.height / 2);
          if (this.textDirection === "vertical" || this.textDirection === "vertical-left") {
            g.rotate(HalfPi);
          } else if (this.textDirection === "vertical-right") {
            g.rotate(-HalfPi);
          }
          g.translate(-this.canvas.width / 2, -this.canvas.height / 2);
          g.drawImage(this.canvas, 0, 0);
          setContextSize(this.g, canv.width, canv.height);
        } else {
          console.warn("Couldn't rotate the TextImage");
        }
        this.g.drawImage(canv, 0, 0);
      }
      this.lastValue = this.value;
      return true;
    } else {
      const changed = this.value !== this.lastValue;
      this.lastValue = this.value;
      return changed;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/units/length.ts
var MICROMETERS_PER_MILLIMETER = 1e3;
var MILLIMETERS_PER_CENTIMETER = 10;
var CENTIMETERS_PER_INCH = 2.54;
var CENTIMETERS_PER_METER = 100;
var INCHES_PER_HAND = 4;
var HANDS_PER_FOOT = 3;
var FEET_PER_YARD = 3;
var FEET_PER_ROD = 16.5;
var METERS_PER_KILOMETER = 1e3;
var RODS_PER_FURLONG = 40;
var FURLONGS_PER_MILE = 8;
var MICROMETERS_PER_CENTIMETER = MICROMETERS_PER_MILLIMETER * MILLIMETERS_PER_CENTIMETER;
var MICROMETERS_PER_INCH = MICROMETERS_PER_CENTIMETER * CENTIMETERS_PER_INCH;
var MICROMETERS_PER_HAND = MICROMETERS_PER_INCH * INCHES_PER_HAND;
var MICROMETERS_PER_FOOT = MICROMETERS_PER_HAND * HANDS_PER_FOOT;
var MICROMETERS_PER_YARD = MICROMETERS_PER_FOOT * FEET_PER_YARD;
var MICROMETERS_PER_METER = MICROMETERS_PER_CENTIMETER * CENTIMETERS_PER_METER;
var MICROMETERS_PER_ROD = MICROMETERS_PER_FOOT * FEET_PER_ROD;
var MICROMETERS_PER_FURLONG = MICROMETERS_PER_ROD * RODS_PER_FURLONG;
var MICROMETERS_PER_KILOMETER = MICROMETERS_PER_METER * METERS_PER_KILOMETER;
var MICROMETERS_PER_MILE = MICROMETERS_PER_FURLONG * FURLONGS_PER_MILE;
var MILLIMETERS_PER_INCH = MILLIMETERS_PER_CENTIMETER * CENTIMETERS_PER_INCH;
var MILLIMETERS_PER_HAND = MILLIMETERS_PER_INCH * INCHES_PER_HAND;
var MILLIMETERS_PER_FOOT = MILLIMETERS_PER_HAND * HANDS_PER_FOOT;
var MILLIMETERS_PER_YARD = MILLIMETERS_PER_FOOT * FEET_PER_YARD;
var MILLIMETERS_PER_METER = MILLIMETERS_PER_CENTIMETER * CENTIMETERS_PER_METER;
var MILLIMETERS_PER_ROD = MILLIMETERS_PER_FOOT * FEET_PER_ROD;
var MILLIMETERS_PER_FURLONG = MILLIMETERS_PER_ROD * RODS_PER_FURLONG;
var MILLIMETERS_PER_KILOMETER = MILLIMETERS_PER_METER * METERS_PER_KILOMETER;
var MILLIMETERS_PER_MILE = MILLIMETERS_PER_FURLONG * FURLONGS_PER_MILE;
var CENTIMETERS_PER_HAND = CENTIMETERS_PER_INCH * INCHES_PER_HAND;
var CENTIMETERS_PER_FOOT = CENTIMETERS_PER_HAND * HANDS_PER_FOOT;
var CENTIMETERS_PER_YARD = CENTIMETERS_PER_FOOT * FEET_PER_YARD;
var CENTIMETERS_PER_ROD = CENTIMETERS_PER_FOOT * FEET_PER_ROD;
var CENTIMETERS_PER_FURLONG = CENTIMETERS_PER_ROD * RODS_PER_FURLONG;
var CENTIMETERS_PER_KILOMETER = CENTIMETERS_PER_METER * METERS_PER_KILOMETER;
var CENTIMETERS_PER_MILE = CENTIMETERS_PER_FURLONG * FURLONGS_PER_MILE;
var INCHES_PER_FOOT = INCHES_PER_HAND * HANDS_PER_FOOT;
var INCHES_PER_YARD = INCHES_PER_FOOT * FEET_PER_YARD;
var INCHES_PER_METER = CENTIMETERS_PER_METER / CENTIMETERS_PER_INCH;
var INCHES_PER_ROD = INCHES_PER_FOOT * FEET_PER_ROD;
var INCHES_PER_FURLONG = INCHES_PER_ROD * RODS_PER_FURLONG;
var INCHES_PER_KILOMETER = INCHES_PER_METER * METERS_PER_KILOMETER;
var INCHES_PER_MILE = INCHES_PER_FURLONG * FURLONGS_PER_MILE;
var HANDS_PER_YARD = HANDS_PER_FOOT * FEET_PER_YARD;
var HANDS_PER_METER = CENTIMETERS_PER_METER / CENTIMETERS_PER_HAND;
var HANDS_PER_ROD = HANDS_PER_FOOT * FEET_PER_ROD;
var HANDS_PER_FURLONG = HANDS_PER_ROD * RODS_PER_FURLONG;
var HANDS_PER_KILOMETER = HANDS_PER_METER * METERS_PER_KILOMETER;
var HANDS_PER_MILE = HANDS_PER_FURLONG * FURLONGS_PER_MILE;
var FEET_PER_METER = INCHES_PER_METER / INCHES_PER_FOOT;
var FEET_PER_FURLONG = FEET_PER_ROD * RODS_PER_FURLONG;
var FEET_PER_KILOMETER = FEET_PER_METER * METERS_PER_KILOMETER;
var FEET_PER_MILE = FEET_PER_FURLONG * FURLONGS_PER_MILE;
var YARDS_PER_METER = INCHES_PER_METER / INCHES_PER_YARD;
var YARDS_PER_ROD = FEET_PER_ROD / FEET_PER_YARD;
var YARDS_PER_FURLONG = YARDS_PER_ROD * RODS_PER_FURLONG;
var YARDS_PER_KILOMETER = YARDS_PER_METER * METERS_PER_KILOMETER;
var YARDS_PER_MILE = YARDS_PER_FURLONG * FURLONGS_PER_MILE;
var METERS_PER_ROD = FEET_PER_ROD / FEET_PER_METER;
var METERS_PER_FURLONG = METERS_PER_ROD * RODS_PER_FURLONG;
var METERS_PER_MILE = METERS_PER_FURLONG * FURLONGS_PER_MILE;
var RODS_PER_KILOMETER = METERS_PER_KILOMETER / METERS_PER_ROD;
var RODS_PER_MILE = RODS_PER_FURLONG * FURLONGS_PER_MILE;
var FURLONGS_PER_KILOMETER = METERS_PER_KILOMETER / METERS_PER_FURLONG;
var KILOMETERS_PER_MILE = FURLONGS_PER_MILE / FURLONGS_PER_KILOMETER;
function inches2Meters(inches) {
  return inches / INCHES_PER_METER;
}
function meters2Inches(meters) {
  return meters * INCHES_PER_METER;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/getRelativeXRRigidTransform.ts
var M = new Matrix4();
var P3 = new Vector3();
var P4 = new Vector4();
var Q = new Quaternion();
function getRelativeXRRigidTransform(ref, obj2, scale3) {
  M.copy(ref.matrixWorld).invert().multiply(obj2.matrixWorld).decompose(P3, Q, scale3);
  P4.set(P3.x, P3.y, P3.z, 1);
  return new XRRigidTransform(P4, Q);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Plane.ts
var plane = /* @__PURE__ */ new PlaneGeometry(1, 1, 1, 1);
plane.name = "PlaneGeom";

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/Image2D.ts
var S = new Vector3();
var copyCounter = 0;
var Image2D = class extends Object3D {
  constructor(env, name, webXRLayerType, materialOrOptions = null) {
    super();
    this.webXRLayerType = webXRLayerType;
    this.lastMatrixWorld = new Matrix4();
    this._imageWidth = 0;
    this._imageHeight = 0;
    this.forceUpdate = false;
    this.wasUsingLayer = false;
    this.layer = null;
    this.curImage = null;
    this.lastImage = null;
    this.lastWidth = null;
    this.lastHeight = null;
    this.env = null;
    this.mesh = null;
    this.stereoLayoutName = "mono";
    this.sizeMode = "none";
    if (env) {
      this.setEnvAndName(env, name);
      let material = isMeshBasicMaterial(materialOrOptions) ? materialOrOptions : solidTransparent(Object.assign(
        {},
        materialOrOptions,
        { name: this.name }
      ));
      objGraph(
        this,
        this.mesh = mesh(name + "-Mesh", plane, material)
      );
    }
  }
  copy(source, recursive = true) {
    super.copy(source, recursive);
    this.webXRLayerType = source.webXRLayerType;
    this.setImageSize(source.imageWidth, source.imageHeight);
    this.setEnvAndName(source.env, source.name + ++copyCounter);
    this.mesh = arrayScan(this.children, isMesh);
    if (isNullOrUndefined(this.mesh)) {
      this.mesh = source.mesh.clone();
      objGraph(this, this.mesh);
    }
    this.setTextureMap(source.curImage);
    return this;
  }
  dispose() {
    this.env.removeScope(this);
    this.disposeImage();
    cleanup(this.mesh);
  }
  disposeImage() {
    this.removeWebXRLayer();
    cleanup(this.mesh.material.map);
    this.curImage = null;
  }
  setImageSize(width, height) {
    if (width !== this.imageWidth || height !== this.imageHeight) {
      const { objectWidth, objectHeight } = this;
      this._imageWidth = width;
      this._imageHeight = height;
      if (this.sizeMode !== "none") {
        if (this.sizeMode === "fixed-width") {
          this.objectWidth = objectWidth;
        } else {
          this.objectHeight = objectHeight;
        }
      }
    }
  }
  get imageWidth() {
    return this._imageWidth;
  }
  get imageHeight() {
    return this._imageHeight;
  }
  get imageAspectRatio() {
    return this.imageWidth / this.imageHeight;
  }
  get objectWidth() {
    return this.scale.x;
  }
  set objectWidth(v) {
    this.scale.set(v, this.scale.y = v / this.imageAspectRatio, 1);
  }
  get objectHeight() {
    return this.scale.y;
  }
  set objectHeight(v) {
    this.scale.set(this.imageAspectRatio * v, v, 1);
  }
  get pixelDensity() {
    const inches = meters2Inches(this.objectWidth);
    const ppi = this.imageWidth / inches;
    return ppi;
  }
  set pixelDensity(ppi) {
    const inches = this.imageWidth / ppi;
    const meters = inches2Meters(inches);
    this.objectWidth = meters;
  }
  setEnvAndName(env, name) {
    this.env = env;
    this.name = name;
    this.env.addScopedEventListener(this, "update", (evt) => this.checkWebXRLayer(evt.frame));
  }
  get needsLayer() {
    if (!objectIsFullyVisible(this) || isNullOrUndefined(this.mesh.material.map) || isNullOrUndefined(this.curImage)) {
      return false;
    }
    if (!(this.curImage instanceof HTMLVideoElement)) {
      return true;
    }
    return !this.curImage.paused || this.curImage.currentTime > 0;
  }
  removeWebXRLayer() {
    if (isDefined(this.layer)) {
      this.wasUsingLayer = false;
      this.env.removeWebXRLayer(this.layer);
      this.mesh.visible = true;
      const layer = this.layer;
      this.layer = null;
      setTimeout(() => dispose2(layer), 100);
    }
  }
  setTextureMap(img) {
    if (this.curImage) {
      this.disposeImage();
    }
    if (img) {
      if (isImageBitmap(img)) {
        img = createUtilityCanvasFromImageBitmap(img);
      } else if (isImageData(img)) {
        img = createUtilityCanvasFromImageData(img);
      }
      if (isOffscreenCanvas(img)) {
        img = img;
      }
      this.curImage = img;
      if (img instanceof HTMLVideoElement) {
        this.setImageSize(img.videoWidth, img.videoHeight);
        this.mesh.material.map = new VideoTexture(img);
      } else {
        this.setImageSize(img.width, img.height);
        this.mesh.material.map = new Texture(img);
        this.mesh.material.map.needsUpdate = true;
      }
    }
    this.mesh.material.needsUpdate = true;
  }
  get isVideo() {
    return this.curImage instanceof HTMLVideoElement;
  }
  updateTexture() {
    if (isDefined(this.curImage)) {
      const curVideo = this.curImage;
      const newWidth = this.isVideo ? curVideo.videoWidth : this.curImage.width;
      const newHeight = this.isVideo ? curVideo.videoHeight : this.curImage.height;
      if (this.imageWidth !== newWidth || this.imageHeight !== newHeight) {
        const img = this.curImage;
        this.disposeImage();
        this.setTextureMap(img);
      } else {
        this.mesh.material.map.needsUpdate = this.forceUpdate = true;
      }
    }
  }
  checkWebXRLayer(frame) {
    if (this.mesh.material.map && this.curImage) {
      const isLayersAvailable = this.webXRLayerType !== "none" && this.env.hasXRCompositionLayers && this.env.showWebXRLayers && isDefined(frame) && (this.isVideo && isDefined(this.env.xrMediaBinding) || !this.isVideo && isDefined(this.env.xrBinding));
      const useLayer = isLayersAvailable && this.needsLayer;
      const useLayerChanged = useLayer !== this.wasUsingLayer;
      const imageChanged = this.curImage !== this.lastImage || this.mesh.material.needsUpdate || this.mesh.material.map.needsUpdate || this.forceUpdate;
      const sizeChanged = this.imageWidth !== this.lastWidth || this.imageHeight !== this.lastHeight;
      this.wasUsingLayer = useLayer;
      this.lastImage = this.curImage;
      this.lastWidth = this.imageWidth;
      this.lastHeight = this.imageHeight;
      if (useLayerChanged || sizeChanged) {
        if ((!useLayer || sizeChanged) && this.layer) {
          this.removeWebXRLayer();
        }
        if (useLayer) {
          const space = this.env.referenceSpace;
          const transform = getRelativeXRRigidTransform(this.env.stage, this.mesh, S);
          this.lastMatrixWorld.copy(this.matrixWorld);
          const width = S.x / 2;
          const height = S.y / 2;
          const layout = this.stereoLayoutName === "mono" ? "mono" : this.stereoLayoutName === "left-right" || this.stereoLayoutName === "right-left" ? "stereo-left-right" : "stereo-top-bottom";
          if (this.isVideo) {
            const invertStereo = this.stereoLayoutName === "right-left" || this.stereoLayoutName === "bottom-top";
            this.layer = this.env.xrMediaBinding.createQuadLayer(this.curImage, {
              space,
              layout,
              invertStereo,
              transform,
              width,
              height
            });
          } else {
            this.layer = this.env.xrBinding.createQuadLayer({
              space,
              layout,
              textureType: "texture",
              isStatic: this.webXRLayerType === "static",
              viewPixelWidth: this.curImage.width,
              viewPixelHeight: this.curImage.height,
              transform,
              width,
              height
            });
          }
          this.env.addWebXRLayer(this.layer, 500);
          this.mesh.visible = false;
        }
      }
      if (this.layer) {
        if (imageChanged || this.layer.needsRedraw) {
          const gl = this.env.gl;
          const gLayer = this.env.xrBinding.getSubImage(this.layer, frame);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.bindTexture(gl.TEXTURE_2D, gLayer.colorTexture);
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            this.curImage
          );
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.bindTexture(gl.TEXTURE_2D, null);
          this.forceUpdate = false;
        }
        if (arrayCompare(this.matrixWorld.elements, this.lastMatrixWorld.elements) >= 0) {
          this.layer.transform = getRelativeXRRigidTransform(this.env.stage, this.mesh, S);
          this.lastMatrixWorld.copy(this.matrixWorld);
          this.layer.width = S.x / 2;
          this.layer.height = S.y / 2;
        }
      } else {
        this.forceUpdate = false;
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/CanvasImageMesh.ts
var redrawnEvt = { type: "redrawn" };
var CanvasImageMesh = class extends Image2D {
  constructor(env, name, webXRLayerType, image2, materialOptions) {
    super(env, name, webXRLayerType, materialOptions);
    this._image = null;
    this.image = image2;
  }
  get object() {
    return this;
  }
  get element() {
    if (isHTMLCanvas(this.image.canvas)) {
      return this.image.canvas;
    } else {
      return null;
    }
  }
  onRedrawn() {
    this.updateTexture();
    this.dispatchEvent(redrawnEvt);
  }
  get image() {
    return this._image;
  }
  set image(v) {
    if (this.image) {
      this.image.removeScope(this);
    }
    this._image = v;
    if (this.image) {
      this.image.addScopedEventListener(this, "redrawn", () => this.onRedrawn());
      this.setTextureMap(this.image.canvas);
      this.onRedrawn();
    }
  }
  get imageWidth() {
    return this.image.width;
  }
  get imageHeight() {
    return this.image.height;
  }
  copy(source, recursive = true) {
    super.copy(source, recursive);
    this.image = source.image;
    return this;
  }
  get isVisible() {
    return elementIsDisplayed(this);
  }
  set isVisible(v) {
    elementSetDisplay(this, v, "inline-block");
    objectSetVisible(this, v);
    objectSetVisible(this.mesh, v);
    this.image.visible = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/TextMesh.ts
var TextMesh = class extends CanvasImageMesh {
  constructor(env, name, webXRLayerType, textOptions, materialOptions) {
    let image2;
    if (textOptions instanceof TextImage) {
      image2 = textOptions;
    } else {
      image2 = new TextImage(textOptions);
    }
    super(env, name, webXRLayerType, image2, materialOptions);
  }
  onRedrawn() {
    this.objectHeight = this.imageHeight;
    super.onRedrawn();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/PlaybackButton.ts
var playEvt = new TypedEvent("play");
var stopEvt = new TypedEvent("stop");
var size = 0.1;
var translations = new Map(
  keycapDigits.alts.map((m, i) => [m.value, i.toString()])
);
var PlaybackButton = class extends BaseProgress {
  constructor(env, buttonFactory, data, name, label, volume, player) {
    super();
    this.data = data;
    this.volume = volume;
    this.player = player;
    this.playButton = null;
    this.pauseButton = null;
    this.stopButton = null;
    this.replayButton = null;
    this.clickPlay = null;
    this.disposed = false;
    label = translations.get(label) || label || "";
    this.object = obj(`playback-${name}`);
    this.textLabel = new TextMesh(env, `playback-${name}-label`, "none", {
      minHeight: size,
      minWidth: 4 * size,
      maxWidth: 4 * size,
      padding: 0.02,
      scale: 1e3,
      bgFillColor: buttonFactory.labelFillColor,
      textFillColor: "white"
    });
    this.textLabel.image.value = label;
    this.textLabel.image.addEventListener("redrawn", () => this.repositionLabel());
    this.progressBar = new Cube(4 * size, 0.025, 0.01, solidWhite);
    this.progressBar.visible = false;
    this.clickPlay = async () => {
      if (this.player.data !== this.data) {
        await this.player.load(this.data, this);
      }
      this.player.volume = this.volume;
      await this.player.play();
    };
    this.load(buttonFactory, player);
  }
  dispose() {
    if (!this.disposed) {
      if (this.data === this.player.data) {
        this.player.clear();
      }
      cleanup(this.object);
      this.disposed = true;
    }
  }
  repositionLabel() {
    this.textLabel.position.y = -(size + this.textLabel.objectHeight) / 2;
  }
  async load(buttonFactory, player) {
    const [
      play,
      pause,
      stop,
      replay
    ] = await all(
      buttonFactory.getMeshButton("media", "play", size),
      buttonFactory.getMeshButton("media", "pause", size),
      buttonFactory.getMeshButton("media", "stop", size),
      buttonFactory.getMeshButton("media", "replay", size)
    );
    objGraph(
      this,
      this.playButton = play,
      this.pauseButton = pause,
      this.stopButton = stop,
      this.replayButton = replay,
      this.progressBar,
      this.textLabel
    );
    this.playButton.object.position.x = -1.5 * size;
    this.pauseButton.object.position.x = -0.5 * size;
    this.stopButton.object.position.x = 0.5 * size;
    this.replayButton.object.position.x = 1.5 * size;
    this.progressBar.position.y = -size / 2;
    this.progressBar.position.z = 0.01;
    this.repositionLabel();
    const refresh = () => {
      const hasMyData = player.data === this.data;
      this.playButton.disabled = hasMyData && (player.playbackState === "loading" || player.playbackState === "playing" || player.playbackState === "errored") || !hasMyData && player.playbackState === "loading";
      this.pauseButton.disabled = !hasMyData || player.playbackState === "loading" || player.playbackState !== "playing";
      this.replayButton.disabled = this.stopButton.disabled = !hasMyData || player.playbackState === "loading" || player.playbackState === "stopped" || player.playbackState === "errored";
      if (!hasMyData || player.playbackState === "loading" || player.playbackState === "stopped") {
        this.progressBar.visible = false;
      }
    };
    refresh();
    const local = (callback) => (evt) => {
      if (evt.source.data === this.data) {
        callback(evt);
      }
    };
    const localRefresh = local(refresh);
    player.addEventListener("loading", refresh);
    player.addEventListener("loaded", localRefresh);
    player.addEventListener("played", localRefresh);
    player.addEventListener("paused", localRefresh);
    player.addEventListener("stopped", refresh);
    player.addEventListener("progress", local((evt) => this.report(evt.value, evt.total)));
    player.addEventListener("played", local(() => this.dispatchEvent(playEvt)));
    player.addEventListener("stopped", local(() => this.dispatchEvent(stopEvt)));
    const onClick = (btn, callback) => {
      btn.addEventListener("click", callback);
    };
    onClick(this.playButton, this.clickPlay);
    onClick(this.pauseButton, () => player.pause());
    onClick(this.stopButton, () => player.stop());
    onClick(this.replayButton, () => player.restart());
  }
  get label() {
    if (isDefined(this.textLabel.image)) {
      return this.textLabel.image.value;
    }
    return null;
  }
  set label(v) {
    v = translations.get(v) || v;
    this.textLabel.image.value = v;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    const width = this.p * 4 * size;
    this.progressBar.position.x = 0.5 * (width - 4 * size);
    this.progressBar.scale.x = width;
    this.progressBar.visible = soFar > 0;
  }
};

// src/vr-apps/yarrow/Audio.ts
var P = new Vector3();
var Audio3 = class {
  constructor(scenario, parent, player, data) {
    this.scenario = scenario;
    this.parent = parent;
    this.player = player;
    this.clip = null;
    this.controls = null;
    this.error = null;
    this.disposed = false;
    this.zone = data.zone;
    this.minDistance = data.minDistance;
    this.maxDistance = data.maxDistance;
    this.spatialize = data.spatialize;
    this.effect = data.effect;
    this.label = data.label;
    this.volume = data.volume;
    this.enabled = data.enabled;
    this.transformID = data.transformID;
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
  }
  get effects() {
    if (isNullOrUndefined(this.effect)) {
      return [];
    } else {
      return this.effect.split(",").map((f) => f.trim()).filter((f) => f.length > 0);
    }
  }
  async load(prog) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    try {
      if (this.spatialize) {
        this.clip = await this.scenario.env.audio.createClip(
          this.transformID.toString(),
          this.filePath,
          this.spatialize,
          this.spatialize,
          this.spatialize,
          this.spatialize,
          this.volume,
          this.effects,
          prog
        );
        this.clip.spatializer.setAudioProperties(this.minDistance, this.maxDistance, this.scenario.env.audio.algorithm);
        this.updateAudioPosition();
      } else {
        objGraph(
          this.parent,
          this.controls = new PlaybackButton(
            this.scenario.env,
            this.scenario.env.uiButtons,
            this.filePath,
            `${this.fileName}(${this.transformID})`,
            this.label,
            this.volume,
            this.player
          )
        );
        this.controls.addScopedEventListener(this, "play", () => {
          this.scenario.log("play audio", { id: this.transformID });
        });
        this.controls.addScopedEventListener(this, "stop", () => {
          this.scenario.log("stop audio", { id: this.transformID });
        });
      }
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    const isPlaying = this.clip && this.clip.playbackState === "playing";
    this.dispose();
    this.player.cacheBust(this.filePath);
    await this.load(prog);
    if (isPlaying) {
      this.clip.play();
    }
  }
  updateAudioPosition() {
    this.parent.getWorldPosition(P);
    this.scenario.env.audio.setClipPosition(this.transformID.toString(), P.x, P.y, P.z);
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    if (isDefined(this.clip)) {
      this.scenario.env.audio.removeClip(this.transformID.toString());
      this.clip = null;
    }
    if (isDefined(this.controls)) {
      this.controls.removeScope(this);
      this.controls.object.removeFromParent();
      this.controls.dispose();
      this.controls = null;
    }
  }
  play() {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    if (isDefined(this.clip)) {
      return this.clip.play();
    }
    return this.controls.clickPlay();
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    if (isDefined(this.clip)) {
      this.clip.stop();
    } else {
      this.player.stop();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/RayTarget.ts
var RAY_TARGET_KEY = "Juniper:ThreeJS:EventSystem:RayTarget";
var RayTarget = class extends TypedEventBase {
  constructor(object) {
    super();
    this.object = object;
    this.meshes = new Array();
    this._disabled = false;
    this._clickable = false;
    this._draggable = false;
    this._navigable = false;
    this.object.userData[RAY_TARGET_KEY] = this;
  }
  addMesh(mesh2) {
    mesh2.userData[RAY_TARGET_KEY] = this;
    this.meshes.push(mesh2);
    return this;
  }
  removeMesh(mesh2) {
    if (arrayRemove(this.meshes, mesh2)) {
      delete mesh2.userData[RAY_TARGET_KEY];
    }
    return this;
  }
  addMeshes(...meshes) {
    for (const mesh2 of meshes) {
      this.addMesh(mesh2);
    }
    return this;
  }
  removeMeshes(...meshes) {
    for (const mesh2 of meshes) {
      this.removeMesh(mesh2);
    }
    return this;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    this._disabled = v;
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  get clickable() {
    return this._clickable;
  }
  set clickable(v) {
    this._clickable = v;
  }
  get draggable() {
    return this._draggable;
  }
  set draggable(v) {
    this._draggable = v;
  }
  get navigable() {
    return this._navigable;
  }
  set navigable(v) {
    this._navigable = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/TextMeshButton.ts
var TextMeshButton = class extends RayTarget {
  constructor(env, name, value, textImageOptions) {
    super(obj(name));
    this.env = env;
    if (isDefined(value)) {
      textImageOptions = Object.assign({
        textFillColor: "white",
        fontFamily: "Segoe UI Emoji",
        fontSize: 20,
        minHeight: 0.25,
        maxHeight: 0.25
      }, textImageOptions, {
        value
      });
      this.image = new TextImage(textImageOptions);
      const id = stringRandom(16);
      this.enabledImage = this.createImage(`${id}-enabled`, 1);
      this.disabledImage = this.createImage(`${id}-disabled`, 0.5);
      this.disabledImage.visible = false;
      objGraph(this, this.enabledImage, this.disabledImage);
    }
    this.addMesh(this.enabledImage.mesh);
    this.addMesh(this.disabledImage.mesh);
    this.clickable = true;
    if (isDefined(value)) {
      scaleOnHover(this, true);
    }
  }
  createImage(id, opacity) {
    const image2 = new TextMesh(
      this.env,
      `text-${id}`,
      "none",
      this.image,
      {
        side: FrontSide,
        opacity
      }
    );
    return image2;
  }
  get disabled() {
    return super.disabled;
  }
  set disabled(v) {
    super.disabled = v;
    this.enabledImage.visible = !v;
    this.disabledImage.visible = v;
  }
};

// src/vr-apps/yarrow/Connection.ts
var DEFAULT_NAV_ICON = ` ${upArrowText.textStyle} `;
var TEST_OBJECT = new Object3D();
var Connection = class extends BaseProgress {
  constructor(env, transform, from, to, label) {
    super();
    this.env = env;
    this.transform = transform;
    this.from = from;
    this.to = to;
    label = label || DEFAULT_NAV_ICON;
    this.icon = new TextMeshButton(this.env, "navButton", label, textButtonStyle);
    this.icon.addEventListener("click", (evt) => {
      if (this.enabled) {
        this.dispatchEvent(evt);
      }
    });
    this.transform.scale.setScalar(0.5);
    this.progressBar = new Cube(this.icon.image.width, 0.025, 0.01, solidWhite);
    this.progressBar.position.y = -this.icon.image.height / 2;
    this.progressBar.position.z = 0.01;
    objGraph(
      this.transform,
      objGraph(
        this.icon,
        this.progressBar
      )
    );
  }
  get object() {
    return this.transform;
  }
  get fromStationID() {
    return this.from.transformID;
  }
  get toStationID() {
    return this.to.transformID;
  }
  get transformID() {
    return this.transform && this.transform.transformID;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    const width = this.icon.image.width * this.p;
    this.progressBar.position.x = 0.5 * (width - this.icon.image.width);
    this.progressBar.scale.x = width;
  }
  get label() {
    return this.icon.image.value;
  }
  set label(v) {
    this.icon.image.value = this.icon.image.value = v || DEFAULT_NAV_ICON;
  }
  get enabled() {
    return !this.icon.disabled;
  }
  set enabled(v) {
    this.icon.disabled = !v;
    this.progressBar.visible = !v;
  }
  static calcMatrix(from, to, defaultAvatarHeight, object = null) {
    object = object || TEST_OBJECT;
    const parent = object.parent;
    if (parent) {
      parent.remove(object);
    }
    object.position.copy(to.position);
    object.position.sub(from.position);
    object.position.y = 0;
    object.position.normalize();
    object.position.multiplyScalar(1.5);
    object.position.y += 1;
    object.lookAt(0, defaultAvatarHeight, 0);
    object.updateMatrix();
    if (parent) {
      objGraph(parent, object);
    }
    return object.matrix;
  }
  resetPosition() {
    Connection.calcMatrix(this.from, this.to, this.env.defaultAvatarHeight, this.object);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/flags.ts
function isFirefox() {
  return "InstallTrigger" in globalThis;
}
var oculusBrowserPattern = /OculusBrowser\/(\d+)\.(\d+)\.(\d+)/i;
var oculusMatch = /* @__PURE__ */ navigator.userAgent.match(oculusBrowserPattern);
var isOculusBrowser = !!oculusMatch;
var oculusBrowserVersion = isOculusBrowser && {
  major: parseFloat(oculusMatch[1]),
  minor: parseFloat(oculusMatch[2]),
  patch: parseFloat(oculusMatch[3])
};
var isOculusGo = isOculusBrowser && /pacific/i.test(navigator.userAgent);
var isOculusQuest = isOculusBrowser && /quest/i.test(navigator.userAgent);
var isOculusQuest2 = isOculusBrowser && /quest 2/i.test(navigator.userAgent);
var isWorkerSupported = "Worker" in globalThis;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/waitFor.ts
function waitFor(test) {
  const task = new Task();
  const handle = setInterval(() => {
    if (test()) {
      clearInterval(handle);
      task.resolve();
    }
  }, 100);
  return task;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/translateResponse.ts
async function translateResponse(response, translate) {
  const {
    status,
    requestPath,
    responsePath,
    content,
    contentType,
    contentLength,
    fileName,
    headers,
    date
  } = response;
  return {
    status,
    requestPath,
    responsePath,
    content: isDefined(translate) ? await translate(content) : void 0,
    contentType,
    contentLength,
    fileName,
    headers,
    date
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/RequestBuilder.ts
var testAudio = null;
function canPlay(type2) {
  if (testAudio === null) {
    testAudio = new Audio();
  }
  return testAudio.canPlayType(type2) !== "";
}
var RequestBuilder = class {
  constructor(fetcher, method, path, useBLOBs = false) {
    this.fetcher = fetcher;
    this.method = method;
    this.path = path;
    this.useBLOBs = useBLOBs;
    this.prog = null;
    this.request = {
      method,
      path: this.path.href,
      body: null,
      headers: null,
      timeout: null,
      withCredentials: false,
      useCache: false,
      retryCount: 3
    };
  }
  retries(count) {
    this.request.retryCount = count;
    return this;
  }
  query(name, value) {
    this.path.searchParams.set(name, value);
    this.request.path = this.path.href;
    return this;
  }
  header(name, value) {
    if (this.request.headers === null) {
      this.request.headers = /* @__PURE__ */ new Map();
    }
    this.request.headers.set(name.toLowerCase(), value);
    return this;
  }
  headers(headers) {
    for (const [name, value] of headers.entries()) {
      this.header(name, value);
    }
    return this;
  }
  timeout(value) {
    this.request.timeout = value;
    return this;
  }
  progress(prog) {
    this.prog = prog;
    return this;
  }
  body(body, contentType) {
    if (isDefined(body)) {
      const seen = /* @__PURE__ */ new Set();
      const queue = new Array();
      queue.push(body);
      let isForm = false;
      while (!isForm && queue.length > 0) {
        const here = queue.shift();
        if (here && !seen.has(here)) {
          seen.add(here);
          if (here instanceof Blob) {
            isForm = true;
            break;
          } else if (!isString(here)) {
            queue.push(...Object.values(here));
          }
        }
      }
      if (isForm) {
        const form = new FormData();
        const fileNames = /* @__PURE__ */ new Map();
        const toSkip = /* @__PURE__ */ new Set();
        for (const [key, value] of Object.entries(body)) {
          if (value instanceof Blob) {
            const fileNameKey = key + ".name";
            const fileName = body[fileNameKey];
            if (isString(fileName)) {
              fileNames.set(value, fileName);
              toSkip.add(fileNameKey);
            }
          }
        }
        for (let [key, value] of Object.entries(body)) {
          if (toSkip.has(key)) {
            continue;
          }
          if (value instanceof Blob) {
            form.append(key, value, fileNames.get(value));
          } else if (isString(value)) {
            form.append(key, value);
          } else if (isDefined(value) && isFunction(value.toString)) {
            form.append(key, value.toString());
          } else {
            console.warn("Can't serialize value to formdata", key, value);
          }
        }
        body = form;
        contentType = void 0;
      }
      this.request.body = body;
      this.content(contentType);
    }
    return this;
  }
  withCredentials() {
    this.request.withCredentials = true;
    return this;
  }
  useCache(enabled = true) {
    this.request.useCache = enabled;
    return this;
  }
  media(key, mediaType) {
    if (isDefined(mediaType)) {
      if (!isString(mediaType)) {
        mediaType = mediaType.value;
      }
      this.header(key, mediaType);
    }
  }
  content(contentType) {
    this.media("content-type", contentType);
  }
  accept(acceptType) {
    this.media("accept", acceptType);
    return this;
  }
  blob(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetBlob(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetBlob(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  buffer(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetBuffer(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetBuffer(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  async file(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return await this.fetcher.sendObjectGetFile(this.request, this.prog);
    } else if (this.method === "GET") {
      if (this.useBLOBs) {
        return await this.fetcher.sendNothingGetFile(this.request, this.prog);
      } else {
        const response = await this.fetcher.sendNothingGetNothing(this.request);
        return translateResponse(response, () => this.request.path);
      }
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  text(acceptType) {
    this.accept(acceptType || Text_Plain);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetText(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetText(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  object(acceptType) {
    this.accept(acceptType || Application_Json);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetObject(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetObject(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  xml(acceptType) {
    this.accept(acceptType || Text_Xml);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetXml(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetXml(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  imageBitmap(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetImageBitmap(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetImageBitmap(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  exec() {
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetNothing(this.request, this.prog);
    } else if (this.method === "GET") {
      throw new Exception("GET requests should expect a response type");
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      return this.fetcher.sendNothingGetNothing(this.request);
    } else {
      assertNever(this.method);
    }
  }
  async audioBlob(acceptType) {
    if (isDefined(acceptType)) {
      if (!isString(acceptType)) {
        acceptType = acceptType.value;
      }
      if (!canPlay(acceptType)) {
        throw new Error(`Probably can't play file of type "${acceptType}" at path: ${this.request.path}`);
      }
    }
    const response = await this.blob(acceptType);
    if (canPlay(response.contentType)) {
      return response;
    }
    throw new Error(`Cannot play file of type "${response.contentType}" at path: ${this.request.path}`);
  }
  async audioBuffer(context, acceptType) {
    return translateResponse(
      await this.audioBlob(acceptType),
      async (blob) => await context.decodeAudioData(await blob.arrayBuffer())
    );
  }
  async htmlElement(element, resolveEvt, acceptType) {
    const response = await this.file(acceptType);
    const task = once(element, resolveEvt, "error");
    if (element instanceof HTMLLinkElement) {
      element.href = response.content;
    } else {
      element.src = response.content;
    }
    await task;
    return await translateResponse(response, () => element);
  }
  image(acceptType) {
    return this.htmlElement(
      Img(),
      "load",
      acceptType
    );
  }
  async htmlCanvas(acceptType) {
    if (false) {
      throw new Error("HTMLCanvasElement not supported in Workers.");
    }
    const canvas = createCanvas(1, 1);
    if (this.method === "GET") {
      if (hasOffscreenCanvas) {
        this.accept(acceptType);
        const response = await this.fetcher.drawImageToCanvas(this.request, canvas.transferControlToOffscreen(), this.prog);
        return await translateResponse(response, () => canvas);
      } else {
        const response = await (false ? this.imageBitmap(acceptType) : this.image(acceptType));
        return await translateResponse(response, (img) => {
          canvas.width = img.width;
          canvas.height = img.height;
          drawImageToCanvas(canvas, img);
          dispose(img);
          return canvas;
        });
      }
    } else if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE" || this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  canvas(acceptType) {
    if (hasOffscreenCanvas) {
      return this.offscreenCanvas(acceptType);
    } else {
      return this.htmlCanvas(acceptType);
    }
  }
  async offscreenCanvas(acceptType) {
    if (!hasOffscreenCanvas) {
      throw new Error("This system does not support OffscreenCanvas");
    }
    if (this.method === "GET") {
      const response = await (false ? this.imageBitmap(acceptType) : this.image(acceptType));
      return await translateResponse(response, (img) => {
        const canvas = createOffscreenCanvas(img.width, img.height);
        drawImageToCanvas(canvas, img);
        dispose(img);
        return canvas;
      });
    } else if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE" || this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  async style() {
    const tag2 = Link(
      type(Text_Css),
      rel("stylesheet")
    );
    document.head.append(tag2);
    const response = await this.htmlElement(
      tag2,
      "load",
      Text_Css
    );
    return translateResponse(response);
  }
  async getScript() {
    const tag2 = Script(type(Application_Javascript));
    document.head.append(tag2);
    const response = await this.htmlElement(
      tag2,
      "load",
      Application_Javascript
    );
    return translateResponse(response);
  }
  async script(test) {
    let response = null;
    const scriptPath = this.request.path;
    if (!test) {
      response = await this.getScript();
    } else if (!test()) {
      const scriptLoadTask = waitFor(test);
      response = await this.getScript();
      await scriptLoadTask;
    }
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return response;
  }
  async module() {
    const scriptPath = this.request.path;
    const response = await this.file(Application_Javascript);
    const value = await import(response.content);
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return translateResponse(response, () => value);
  }
  async wasm(imports) {
    const response = await this.buffer(Application_Wasm);
    if (!Application_Wasm.matches(response.contentType)) {
      throw new Error(`Server did not respond with WASM file. Was: ${response.contentType}`);
    }
    const module2 = await WebAssembly.compile(response.content);
    const instance = await WebAssembly.instantiate(module2, imports);
    return translateResponse(response, () => instance.exports);
  }
  async worker(type2 = "module") {
    const scriptPath = this.request.path;
    const response = await this.file(Application_Javascript);
    this.prog = null;
    this.request.timeout = null;
    const worker2 = new Worker(response.content, { type: type2 });
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return translateResponse(response, () => worker2);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/Fetcher.ts
var Fetcher = class {
  constructor(service, useBLOBs = false) {
    this.service = service;
    this.useBLOBs = useBLOBs;
    if (true) {
      const antiforgeryToken = getInput("input[name=__RequestVerificationToken]");
      if (antiforgeryToken) {
        this.service.setRequestVerificationToken(antiforgeryToken.value);
      }
    }
  }
  clearCache() {
    return this.service.clearCache();
  }
  evict(path, base) {
    return this.service.evict(new URL(path, base || location.href).href);
  }
  request(method, path, base) {
    return new RequestBuilder(
      this.service,
      method,
      new URL(path, base || location.href),
      this.useBLOBs
    );
  }
  head(path, base) {
    return this.request("HEAD", path, base);
  }
  options(path, base) {
    return this.request("OPTIONS", path, base);
  }
  get(path, base) {
    return this.request("GET", path, base);
  }
  post(path, base) {
    return this.request("POST", path, base);
  }
  put(path, base) {
    return this.request("PUT", path, base);
  }
  patch(path, base) {
    return this.request("PATCH", path, base);
  }
  delete(path, base) {
    return this.request("DELETE", path, base);
  }
  async assets(progressOrAsset, firstAsset, ...assets) {
    if (isNullOrUndefined(assets)) {
      assets = [];
    }
    assets.unshift(firstAsset);
    let progress;
    if (isAsset(progressOrAsset)) {
      assets.unshift(progressOrAsset);
    } else if (isDefined(progressOrAsset)) {
      progress = progressOrAsset;
    }
    assets = assets.filter(isDefined);
    const sizes = await Promise.all(assets.map((asset) => asset.getSize(this)));
    const assetSizes = new Map(sizes);
    await progressTasksWeighted(
      progress,
      assets.map((asset) => [assetSizes.get(asset), (prog) => asset.fetch(this, prog)])
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/FetchingService.ts
var FetchingService = class {
  constructor(impl) {
    this.impl = impl;
    this.defaultPostHeaders = /* @__PURE__ */ new Map();
  }
  setRequestVerificationToken(value) {
    this.defaultPostHeaders.set("RequestVerificationToken", value);
  }
  clearCache() {
    return this.impl.clearCache();
  }
  evict(path) {
    return this.impl.evict(path);
  }
  sendNothingGetNothing(request) {
    return this.impl.sendNothingGetNothing(request);
  }
  sendNothingGetBlob(request, progress) {
    return this.impl.sendNothingGetSomething("blob", request, progress);
  }
  sendObjectGetBlob(request, progress) {
    return this.impl.sendSomethingGetSomething("blob", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetBuffer(request, progress) {
    return this.impl.sendNothingGetSomething("arraybuffer", request, progress);
  }
  sendObjectGetBuffer(request, progress) {
    return this.impl.sendSomethingGetSomething("arraybuffer", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetText(request, progress) {
    return this.impl.sendNothingGetSomething("text", request, progress);
  }
  sendObjectGetText(request, progress) {
    return this.impl.sendSomethingGetSomething("text", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetObject(request, progress) {
    return this.impl.sendNothingGetSomething("json", request, progress);
  }
  sendObjectGetObject(request, progress) {
    return this.impl.sendSomethingGetSomething("json", request, this.defaultPostHeaders, progress);
  }
  sendObjectGetNothing(request, progress) {
    return this.impl.sendSomethingGetSomething("", request, this.defaultPostHeaders, progress);
  }
  drawImageToCanvas(request, canvas, progress) {
    return this.impl.drawImageToCanvas(request, canvas, progress);
  }
  async sendNothingGetFile(request, progress) {
    return translateResponse(
      await this.sendNothingGetBlob(request, progress),
      URL.createObjectURL
    );
  }
  async sendObjectGetFile(request, progress) {
    return translateResponse(
      await this.sendObjectGetBlob(request, progress),
      URL.createObjectURL
    );
  }
  async sendNothingGetXml(request, progress) {
    return translateResponse(
      await this.impl.sendNothingGetSomething("document", request, progress),
      (doc) => doc.documentElement
    );
  }
  async sendObjectGetXml(request, progress) {
    return translateResponse(
      await this.impl.sendSomethingGetSomething("document", request, this.defaultPostHeaders, progress),
      (doc) => doc.documentElement
    );
  }
  async sendNothingGetImageBitmap(request, progress) {
    return translateResponse(
      await this.sendNothingGetBlob(request, progress),
      createImageBitmap
    );
  }
  async sendObjectGetImageBitmap(request, progress) {
    return translateResponse(
      await this.sendObjectGetBlob(request, progress),
      createImageBitmap
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapMap.ts
function mapMap(items, makeID, makeValue) {
  return new Map(items.map((item) => [makeID(item), makeValue(item)]));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/makeLookup.ts
function makeLookup(items, makeID) {
  return mapMap(items, makeID, identity);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/indexdb/index.ts
var IDexDB = class {
  constructor(db) {
    this.db = db;
  }
  static delete(dbName) {
    const deleteRequest = indexedDB.deleteDatabase(dbName);
    const task = once(deleteRequest, "success", "error", "blocked");
    return success(task);
  }
  static async open(name, ...storeDefs) {
    const storesByName = makeLookup(storeDefs, (v) => v.name);
    const indexesByName = new PriorityMap(
      storeDefs.filter((storeDef) => isDefined(storeDef.indexes)).flatMap((storeDef) => storeDef.indexes.map((indexDef) => [storeDef.name, indexDef.name, indexDef]))
    );
    const storesToAdd = new Array();
    const storesToRemove = new Array();
    const storesToChange = new Array();
    const indexesToAdd = new PriorityList();
    const indexesToRemove = new PriorityList();
    let version5 = null;
    const D = indexedDB.open(name);
    if (await success(once(D, "success", "error", "blocked"))) {
      const db = D.result;
      version5 = db.version;
      const storesToScrutinize = new Array();
      for (const storeName of db.objectStoreNames) {
        if (!storesByName.has(storeName)) {
          storesToRemove.push(storeName);
        }
      }
      for (const storeName of storesByName.keys()) {
        if (!db.objectStoreNames.contains(storeName)) {
          storesToAdd.push(storeName);
        } else {
          storesToScrutinize.push(storeName);
        }
      }
      if (storesToScrutinize.length > 0) {
        const transaction = db.transaction(storesToScrutinize);
        const transacting = once(transaction, "complete", "error", "abort");
        const transacted = success(transacting);
        for (const storeName of storesToScrutinize) {
          const store = transaction.objectStore(storeName);
          const storeDef = storesByName.get(storeName);
          if (isDefined(storeDef.options) && store.keyPath !== storeDef.options.keyPath) {
            storesToRemove.push(storeName);
            storesToAdd.push(storeName);
          }
          for (const indexName of store.indexNames) {
            if (!indexesByName.has(storeName, indexName)) {
              if (storesToChange.indexOf(storeName) === -1) {
                storesToChange.push(storeName);
              }
              indexesToRemove.add(storeName, indexName);
            }
          }
          if (indexesByName.has(storeName)) {
            for (const indexName of indexesByName.get(storeName).keys()) {
              if (!store.indexNames.contains(indexName)) {
                if (storesToChange.indexOf(storeName) === -1) {
                  storesToChange.push(storeName);
                }
                indexesToAdd.add(storeName, indexName);
              } else {
                const indexDef = indexesByName.get(storeName, indexName);
                const index = store.index(indexName);
                if (isString(indexDef.keyPath) !== isString(index.keyPath) || isString(indexDef.keyPath) && isString(index.keyPath) && indexDef.keyPath !== index.keyPath || isArray(indexDef.keyPath) && isArray(index.keyPath) && arrayCompare(indexDef.keyPath, index.keyPath)) {
                  if (storesToChange.indexOf(storeName) === -1) {
                    storesToChange.push(storeName);
                  }
                  indexesToRemove.add(storeName, indexName);
                  indexesToAdd.add(storeName, indexName);
                }
              }
            }
          }
        }
        transaction.commit();
        await transacted;
      }
      dispose(db);
    } else {
      version5 = 0;
      storesToAdd.push(...storesByName.keys());
      for (const storeDef of storeDefs) {
        if (isDefined(storeDef.indexes)) {
          for (const indexDef of storeDef.indexes) {
            indexesToAdd.add(storeDef.name, indexDef.name);
          }
        }
      }
    }
    if (storesToAdd.length > 0 || storesToRemove.length > 0 || indexesToAdd.size > 0 || indexesToRemove.size > 0) {
      ++version5;
    }
    const upgrading = new Task();
    const openRequest = isDefined(version5) ? indexedDB.open(name, version5) : indexedDB.open(name);
    const opening = once(openRequest, "success", "error", "blocked");
    const upgraded = success(upgrading);
    const opened = success(opening);
    const noUpgrade = upgrading.resolver(false);
    openRequest.addEventListener("success", noUpgrade);
    openRequest.addEventListener("upgradeneeded", () => {
      const transacting = once(openRequest.transaction, "complete", "error", "abort");
      const db = openRequest.result;
      for (const storeName of storesToRemove) {
        db.deleteObjectStore(storeName);
      }
      const stores = /* @__PURE__ */ new Map();
      for (const storeName of storesToAdd) {
        const storeDef = storesByName.get(storeName);
        const store = db.createObjectStore(storeName, storeDef.options);
        stores.set(storeName, store);
      }
      for (const storeName of storesToChange) {
        const store = openRequest.transaction.objectStore(storeName);
        stores.set(storeName, store);
      }
      for (const [storeName, store] of stores) {
        for (const indexName of indexesToRemove.get(storeName)) {
          store.deleteIndex(indexName);
        }
        for (const indexName of indexesToAdd.get(storeName)) {
          const indexDef = indexesByName.get(storeName, indexName);
          store.createIndex(indexName, indexDef.keyPath, indexDef.options);
        }
      }
      success(transacting).then(upgrading.resolve).catch(upgrading.reject).finally(() => openRequest.removeEventListener("success", noUpgrade));
    });
    if (!await upgraded) {
      throw upgrading.error;
    }
    if (!await opened) {
      throw opening.error;
    }
    return new IDexDB(openRequest.result);
  }
  dispose() {
    dispose(this.db);
  }
  get name() {
    return this.db.name;
  }
  get version() {
    return this.db.version;
  }
  get storeNames() {
    return Array.from(this.db.objectStoreNames);
  }
  getStore(storeName) {
    return new IDexStore(this.db, storeName);
  }
};
var IDexStore = class {
  constructor(db, storeName) {
    this.db = db;
    this.storeName = storeName;
  }
  async request(makeRequest, mode) {
    const transaction = this.db.transaction(this.storeName, mode);
    const transacting = once(transaction, "complete", "error");
    const store = transaction.objectStore(this.storeName);
    const request = makeRequest(store);
    const requesting = once(request, "success", "error");
    if (!await success(requesting)) {
      transaction.abort();
      throw requesting.error;
    }
    transaction.commit();
    if (!await success(transacting)) {
      throw transacting.error;
    }
    return request.result;
  }
  add(value, key) {
    return this.request((store) => store.add(value, key), "readwrite");
  }
  clear() {
    return this.request((store) => store.clear(), "readwrite");
  }
  getCount(query) {
    return this.request((store) => store.count(query), "readonly");
  }
  async has(query) {
    return await this.getCount(query) > 0;
  }
  delete(query) {
    return this.request((store) => store.delete(query), "readwrite");
  }
  get(key) {
    return this.request((store) => store.get(key), "readonly");
  }
  getAll() {
    return this.request((store) => store.getAll(), "readonly");
  }
  getAllKeys() {
    return this.request((store) => store.getAllKeys(), "readonly");
  }
  getKey(query) {
    return this.request((store) => store.getKey(query), "readonly");
  }
  openCursor(query, direction) {
    return this.request((store) => store.openCursor(query, direction), "readonly");
  }
  openKeyCursor(query, direction) {
    return this.request((store) => store.openKeyCursor(query, direction), "readonly");
  }
  put(value, key) {
    return this.request((store) => store.put(value, key), "readwrite");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapJoin.ts
function mapJoin(dest, ...sources) {
  for (const source of sources) {
    if (isDefined(source)) {
      for (const [key, value] of source) {
        dest.set(key, value);
      }
    }
  }
  return dest;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/sleep.ts
var SleepTask = class extends Task {
  constructor(milliseconds) {
    super(false);
    this.milliseconds = milliseconds;
    this._timer = null;
  }
  start() {
    super.start();
    this._timer = setTimeout(() => {
      this._timer = null;
      this.resolve();
    }, this.milliseconds);
  }
  reset() {
    super.reset();
    if (isDefined(this._timer)) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
};
function sleep(milliseconds) {
  const task = new SleepTask(milliseconds);
  task.start();
  return task;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/withRetry.ts
function withRetry(retryCount, action) {
  return async () => {
    let lastError = null;
    let retryTime = 500;
    for (let retry = 0; retry <= retryCount; ++retry) {
      try {
        if (retry > 0) {
          await sleep(retryTime);
          retryTime *= 2;
        }
        return await action();
      } catch (error) {
        lastError = error;
      }
    }
    throw lastError;
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/FetchingServiceImplXHR.ts
function isXHRBodyInit(obj2) {
  return isString(obj2) || isArrayBufferView(obj2) || obj2 instanceof Blob || obj2 instanceof FormData || isArrayBuffer(obj2) || "Document" in globalThis && obj2 instanceof Document;
}
function trackProgress(name, xhr, target, prog, skipLoading, prevTask) {
  let prevDone = !prevTask;
  if (prevTask) {
    prevTask.then(() => prevDone = true);
  }
  let done = false;
  let loaded = skipLoading;
  const requestComplete = new Task();
  target.addEventListener("loadstart", () => {
    if (prevDone && !done && prog) {
      prog.start(name);
    }
  });
  target.addEventListener("progress", (ev) => {
    if (prevDone && !done) {
      const evt = ev;
      if (prog) {
        prog.report(evt.loaded, Math.max(evt.loaded, evt.total), name);
      }
      if (evt.loaded === evt.total) {
        loaded = true;
        if (done) {
          requestComplete.resolve();
        }
      }
    }
  });
  target.addEventListener("load", () => {
    if (prevDone && !done) {
      if (prog) {
        prog.end(name);
      }
      done = true;
      if (loaded) {
        requestComplete.resolve();
      }
    }
  });
  const onError = (msg) => () => {
    if (prevDone) {
      requestComplete.reject(`${msg} (${xhr.status})`);
    }
  };
  target.addEventListener("error", onError("error"));
  target.addEventListener("abort", onError("abort"));
  target.addEventListener("timeout", onError("timeout"));
  return requestComplete;
}
function sendRequest(xhr, method, path, timeout, headers, body) {
  xhr.open(method, path);
  xhr.responseType = "blob";
  xhr.timeout = timeout;
  if (headers) {
    for (const [key, value] of headers) {
      xhr.setRequestHeader(key, value);
    }
  }
  if (isDefined(body)) {
    xhr.send(body);
  } else {
    xhr.send();
  }
}
function readResponseHeader(headers, key, translate) {
  if (!headers.has(key)) {
    return null;
  }
  const value = headers.get(key);
  try {
    const translated = translate(value);
    headers.delete(key);
    return translated;
  } catch (exp) {
    console.warn(key, exp);
  }
  return null;
}
var FILE_NAME_PATTERN = /filename=\"(.+)\"(;|$)/;
var DB_NAME = "Juniper:Fetcher:Cache";
var FetchingServiceImplXHR = class {
  constructor() {
    this.cache = null;
    this.store = null;
    this.tasks = new PriorityMap();
    this.cacheReady = this.openCache();
  }
  async drawImageToCanvas(request, canvas, progress) {
    const response = await this.sendNothingGetSomething("blob", request, progress);
    const blob = response.content;
    return using(await createImageBitmap(blob, {
      imageOrientation: "from-image"
    }), (img) => {
      canvas.width = img.width;
      canvas.height = img.height;
      const g = canvas.getContext("2d");
      g.drawImage(img, 0, 0);
      return translateResponse(response);
    });
  }
  async openCache() {
    const options = {
      keyPath: "requestPath"
    };
    this.cache = await IDexDB.open(DB_NAME, {
      name: "files",
      options
    });
    this.store = await this.cache.getStore("files");
  }
  async clearCache() {
    await this.cacheReady;
    await this.store.clear();
  }
  async evict(path) {
    await this.cacheReady;
    if (this.store.has(path)) {
      await this.store.delete(path);
    }
  }
  async readResponseHeaders(requestPath, xhr) {
    const headerParts = xhr.getAllResponseHeaders().split(/[\r\n]+/).map((v) => v.trim()).filter((v) => v.length > 0).map((line) => {
      const parts = line.split(": ");
      const key = parts.shift().toLowerCase();
      const value = parts.join(": ");
      return [key, value];
    });
    const pList = new PriorityList(headerParts);
    const normalizedHeaderParts = Array.from(pList.keys()).map((key) => [
      key,
      pList.get(key).join(", ")
    ]);
    const headers = new Map(normalizedHeaderParts);
    const contentType = readResponseHeader(headers, "content-type", identity);
    const contentLength = readResponseHeader(headers, "content-length", parseFloat);
    const date = readResponseHeader(headers, "date", (v) => new Date(v));
    const fileName = readResponseHeader(headers, "content-disposition", (v) => {
      if (isDefined(v)) {
        const match = v.match(FILE_NAME_PATTERN);
        if (isDefined(match)) {
          return match[1];
        }
      }
      return null;
    });
    const response = {
      status: xhr.status,
      requestPath,
      responsePath: xhr.responseURL,
      content: void 0,
      contentType,
      contentLength,
      fileName,
      date,
      headers
    };
    return response;
  }
  async readResponse(requestPath, xhr) {
    const {
      responsePath,
      status,
      contentType,
      contentLength,
      fileName,
      date,
      headers
    } = await this.readResponseHeaders(requestPath, xhr);
    const response = {
      requestPath,
      responsePath,
      status,
      contentType,
      contentLength,
      fileName,
      date,
      headers,
      content: xhr.response
    };
    if (isDefined(response.content)) {
      response.contentType = response.contentType || response.content.type;
      response.contentLength = response.contentLength || response.content.size;
    }
    return response;
  }
  async decodeContent(xhrType, response) {
    return translateResponse(response, async (contentBlob) => {
      if (xhrType === "") {
        return null;
      } else if (isNullOrUndefined(response.contentType)) {
        const headerBlock = Array.from(response.headers.entries()).map((kv) => kv.join(": ")).join("\n  ");
        throw new Error("No content type found in headers: \n  " + headerBlock);
      } else if (xhrType === "blob") {
        return contentBlob;
      } else if (xhrType === "arraybuffer") {
        return await contentBlob.arrayBuffer();
      } else if (xhrType === "json") {
        const text2 = await contentBlob.text();
        if (text2.length > 0) {
          return JSON.parse(text2);
        } else {
          return null;
        }
      } else if (xhrType === "document") {
        const parser = new DOMParser();
        if (response.contentType === "application/xhtml+xml" || response.contentType === "text/html" || response.contentType === "application/xml" || response.contentType === "image/svg+xml" || response.contentType === "text/xml") {
          return parser.parseFromString(await contentBlob.text(), response.contentType);
        } else {
          throw new Error("Couldn't parse document");
        }
      } else if (xhrType === "text") {
        return await contentBlob.text();
      } else {
        assertNever(xhrType);
      }
    });
  }
  async withCachedTask(request, action) {
    if (request.method !== "GET" && request.method !== "HEAD" && request.method !== "OPTIONS") {
      return await action();
    }
    if (!this.tasks.has(request.method, request.path)) {
      this.tasks.add(
        request.method,
        request.path,
        action().finally(() => this.tasks.delete(request.method, request.path))
      );
    }
    return this.tasks.get(request.method, request.path);
  }
  sendNothingGetNothing(request) {
    return this.withCachedTask(
      request,
      withRetry(request.retryCount, async () => {
        const xhr = new XMLHttpRequest();
        const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, null, true);
        sendRequest(xhr, request.method, request.path, request.timeout, request.headers);
        await download;
        return await this.readResponseHeaders(request.path, xhr);
      })
    );
  }
  sendNothingGetSomething(xhrType, request, progress) {
    return this.withCachedTask(
      request,
      withRetry(request.retryCount, async () => {
        let response = null;
        const useCache = request.useCache && request.method === "GET";
        if (useCache) {
          if (isDefined(progress)) {
            progress.start();
          }
          await this.cacheReady;
          response = await this.store.get(request.path);
        }
        const noCachedResponse = isNullOrUndefined(response);
        if (noCachedResponse) {
          const xhr = new XMLHttpRequest();
          const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, progress, true);
          sendRequest(xhr, request.method, request.path, request.timeout, request.headers);
          await download;
          response = await this.readResponse(request.path, xhr);
          if (useCache) {
            await this.store.add(response);
          }
        }
        const value = await this.decodeContent(xhrType, response);
        if (noCachedResponse && isDefined(progress)) {
          progress.end();
        }
        return value;
      })
    );
  }
  sendSomethingGetSomething(xhrType, request, defaultPostHeaders, progress) {
    let body = null;
    const headers = mapJoin(/* @__PURE__ */ new Map(), defaultPostHeaders, request.headers);
    if (request.body instanceof FormData && isDefined(headers)) {
      const toDelete = new Array();
      for (const key of headers.keys()) {
        if (key.toLowerCase() === "content-type") {
          toDelete.push(key);
        }
      }
      for (const key of toDelete) {
        headers.delete(key);
      }
    }
    if (isXHRBodyInit(request.body) && !isString(request.body)) {
      body = request.body;
    } else if (isDefined(request.body)) {
      body = JSON.stringify(request.body);
    }
    const hasBody = isDefined(body);
    const progs = progressSplit(progress, hasBody ? 2 : 1);
    const [progUpload, progDownload] = progs;
    const query = async () => {
      const xhr = new XMLHttpRequest();
      const upload = hasBody ? trackProgress("uploading", xhr, xhr.upload, progUpload, false) : Promise.resolve();
      const download = trackProgress("saving", xhr, xhr, progDownload, true, upload);
      sendRequest(xhr, request.method, request.path, request.timeout, headers, body);
      await upload;
      await download;
      const response = await this.readResponse(request.path, xhr);
      return await this.decodeContent(xhrType, response);
    };
    return withRetry(request.retryCount, query)();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/workers/WorkerPool.ts
var WorkerPool = class extends TypedEventBase {
  /**
   * Creates a new pooled worker method executor.
   * @param options
   */
  constructor(options, WorkerClientClass) {
    super();
    this.scriptPath = options.scriptPath;
    let workerPoolSize = -1;
    const workersDef = options.workers;
    let workers = null;
    if (isNumber(workersDef)) {
      workerPoolSize = workersDef;
    } else if (isDefined(workersDef)) {
      this.taskCounter = workersDef.curTaskCounter;
      workers = workersDef.workers;
      workerPoolSize = workers.length;
    } else {
      workerPoolSize = navigator.hardwareConcurrency || 4;
    }
    if (workerPoolSize < 1) {
      throw new Error("Worker pool size must be a postive integer greater than 0");
    }
    this.workers = new Array(workerPoolSize);
    if (isNullOrUndefined(workers)) {
      this.taskCounter = 0;
      for (let i = 0; i < workerPoolSize; ++i) {
        this.workers[i] = new WorkerClientClass(new Worker(this.scriptPath, { type: "module" }));
      }
    } else {
      for (let i = 0; i < workerPoolSize; ++i) {
        this.workers[i] = new WorkerClientClass(workers[i]);
      }
    }
    for (const worker2 of this.workers) {
      worker2.addBubbler(this);
    }
  }
  dispose() {
    this.workers.forEach(dispose);
    arrayClear(this.workers);
  }
  nextWorker() {
    const worker2 = this.peekWorker();
    this.taskCounter++;
    return worker2;
  }
  peekWorker() {
    return this.workers[this.taskCounter % this.workers.length];
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/IProgress.ts
function isProgressCallback(obj2) {
  return isDefined(obj2) && isFunction(obj2.report) && isFunction(obj2.attach) && isFunction(obj2.end);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/workers/WorkerClient.ts
var WorkerClient = class extends TypedEventBase {
  /**
   * Creates a new pooled worker method executor.
   * @param options
   */
  constructor(worker2) {
    super();
    this.worker = worker2;
    this.invocations = /* @__PURE__ */ new Map();
    this.tasks = new Array();
    this.taskCounter = 0;
    if (!isWorkerSupported) {
      console.warn("Workers are not supported on this system.");
    }
    this.worker.addEventListener("message", (evt) => {
      const data = evt.data;
      switch (data.type) {
        case "event":
          this.propogateEvent(data);
          break;
        case "progress":
          this.progressReport(data);
          break;
        case "return":
          this.methodReturned(data);
          break;
        case "error":
          this.invocationError(data);
          break;
        default:
          assertNever(data);
      }
    });
  }
  postMessage(message, transferables) {
    if (message.type !== "methodCall") {
      assertNever(message.type);
    }
    if (transferables) {
      this.worker.postMessage(message, transferables);
    } else {
      this.worker.postMessage(message);
    }
  }
  dispose() {
    this.worker.terminate();
  }
  progressReport(data) {
    const invocation = this.invocations.get(data.taskID);
    if (invocation) {
      const { prog } = invocation;
      if (prog) {
        prog.report(data.soFar, data.total, data.msg, data.est);
      }
    }
  }
  methodReturned(data) {
    const messageHandler = this.removeInvocation(data.taskID);
    const { task } = messageHandler;
    task.resolve(data.returnValue);
  }
  invocationError(data) {
    const messageHandler = this.removeInvocation(data.taskID);
    const { task, methodName } = messageHandler;
    task.reject(new Error(`${methodName} failed. Reason: ${data.errorMessage}`));
  }
  /**
   * When the invocation has errored, we want to stop listening to the worker
   * message channel so we don't eat up processing messages that have no chance
   * ever pertaining to the invocation.
   **/
  removeInvocation(taskID) {
    const invocation = this.invocations.get(taskID);
    this.invocations.delete(taskID);
    return invocation;
  }
  /**
   * Execute a method on a round-robin selected worker thread.
   * @param methodName - the name of the method to execute.
   * @param parameters - the parameters to pass to the method.
   * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.
   * @param prog - a callback for receiving progress reports on long-running invocations.
   */
  callMethod(methodName, parameters, transferables, prog) {
    if (!isWorkerSupported) {
      return Promise.reject(new Error("Workers are not supported on this system."));
    }
    let params = null;
    let tfers = null;
    if (isProgressCallback(parameters)) {
      prog = parameters;
      parameters = null;
      transferables = null;
    }
    if (isProgressCallback(transferables) && !prog) {
      prog = transferables;
      transferables = null;
    }
    if (isArray(parameters)) {
      params = parameters;
    }
    if (isArray(transferables)) {
      tfers = transferables;
    }
    const taskID = this.taskCounter++;
    let task = arrayScan(this.tasks, (t2) => t2.finished);
    if (task) {
      task.reset();
    } else {
      task = new Task();
      this.tasks.push(task);
    }
    const invocation = {
      methodName,
      task,
      prog
    };
    this.invocations.set(taskID, invocation);
    let message = null;
    if (isDefined(parameters)) {
      message = {
        type: "methodCall",
        taskID,
        methodName,
        params
      };
    } else {
      message = {
        type: "methodCall",
        taskID,
        methodName
      };
    }
    this.postMessage(message, tfers);
    return task;
  }
};

// src/createFetcher.ts
function createFetcher(enableWorkers = true) {
  let fallback = new FetchingService(new FetchingServiceImplXHR());
  if (false) {
    fallback = new FetchingServicePool({
      scriptPath: getWorkerUrl2("fetcher")
    }, fallback);
  }
  return new Fetcher(fallback, !isDebug);
}

// src/vr-apps/yarrow/StreetViewPhotosphereRig.ts
function getStreetViewImagePath(pano, fovDegrees, headingDegrees, pitchDegrees) {
  return `/Editor/Google/StreetView/Image/${pano}/${fovDegrees}/${headingDegrees}/${pitchDegrees}/`;
}
var StreetViewPhotosphereRig = class extends PhotosphereRig {
  constructor(fetcher) {
    super(fetcher, true);
  }
  loadFiles(pano, level, progress) {
    return this.renderFaces(
      getStreetViewImagePath.bind(null, pano),
      level,
      progress
    );
  }
  loadFile(pano, level, progress) {
    return this.renderCubeMap(
      getStreetViewImagePath.bind(null, pano),
      level,
      progress
    );
  }
  async loadImages(pano, level, progress) {
    const files = await this.loadFiles(pano, level, progress);
    return await Promise.all(files.map(createImageFromFile));
  }
  async loadCanvas(pano, level, progress) {
    const file = await this.loadFile(pano, level, progress);
    const img = await createImageFromFile(file);
    return createCanvasFromImage(img);
  }
};

// src/vr-apps/yarrow/StreetViewPhotosphereServiceClient.ts
var StreetViewPhotosphereServiceClient = class extends WorkerClient {
  init(baseURL, isDebug2) {
    this.callMethod("init", [baseURL, isDebug2]);
  }
  propogateEvent(msg) {
    assertNever(msg.eventName);
  }
  loadFiles(pano, level, progress) {
    return this.callMethod("loadFiles", [pano, level], progress);
  }
  loadFile(pano, level, progress) {
    return this.callMethod("loadFile", [pano, level], progress);
  }
  async loadImages(pano, level, progress) {
    const files = await this.loadFiles(pano, level, progress);
    return await Promise.all(files.map(createImageFromFile));
  }
  async loadCanvas(pano, level, progress) {
    const file = await this.loadFile(pano, level, progress);
    const img = await createImageFromFile(file);
    return createCanvasFromImage(img);
  }
};

// src/vr-apps/yarrow/StreetViewPhotosphereServicePool.ts
var StreetViewPhotosphereServicePool = class extends WorkerPool {
  constructor(options, WorkerClientClass) {
    if (options.workers !== 1) {
      options.workers = 1;
    }
    super(options, WorkerClientClass);
  }
  get canvases() {
    return this.peekWorker().canvases;
  }
  init(baseURL, isDebug2) {
    for (const worker2 of this.workers) {
      worker2.init(baseURL, isDebug2);
    }
  }
  loadImages(pano, level, progress) {
    return this.nextWorker().loadImages(pano, level, progress);
  }
  loadCanvas(pano, level, progress) {
    return this.nextWorker().loadCanvas(pano, level, progress);
  }
};

// src/vr-apps/yarrow/createPhotosphereCaptureRig.ts
async function createPhotosphereCaptureRig(fetcher, tokenOrEnableWorkers, enableWorkers) {
  let token = null;
  if (isBoolean(tokenOrEnableWorkers)) {
    enableWorkers = tokenOrEnableWorkers;
  } else {
    token = tokenOrEnableWorkers;
  }
  token = token || new CancelToken();
  if (false) {
    throw new Exception2("Cannot create a Photosphere Capture Rig in a worker. Use StreetViewPhotosphereRig directly.");
  }
  if (!isFirefox() && enableWorkers) {
    const threejs = await fetcher.get(getLibScriptUrl("three")).text().then(unwrapResponse);
    token.check();
    const worker2 = await fetcher.get(getWorkerUrl("photosphere-capture")).text().then(unwrapResponse);
    token.check();
    const script = threejs + worker2;
    const blob = new Blob([script], {
      type: Application_Javascript.value
    });
    const scriptPath = URL.createObjectURL(blob);
    return new StreetViewPhotosphereServicePool(
      { scriptPath },
      StreetViewPhotosphereServiceClient
    );
  } else {
    fetcher = fetcher || createFetcher(false);
    return new StreetViewPhotosphereRig(fetcher);
  }
}

// src/vr-apps/yarrow/data.ts
var Video_Vnd_DlsDc_YtDlp_Json = /* @__PURE__ */ specialize("video")("vnd.dlsdc.ytdlp+json", "ytdlp.json", "ytdlp", "json");
var Image_Vendor_Google_StreetView_Pano = (
  /*@__PURE_*/
  specialize("image")("vnd.google.streetview.pano")
);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/AssetGltfModel.ts
var AssetGltfModel = class extends BaseFetchedAsset {
  constructor(env, path, type2, useCache) {
    if (!Model_Gltf_Binary.matches(type2) && !Model_Gltf_Json.matches(type2)) {
      throw new Error("Only GLTF model types are currently supported");
    }
    super(path, type2, useCache);
    this.env = env;
  }
  async getResponse(request) {
    const response = await request.file();
    return translateResponse(response, (file) => this.env.loadGltf(file));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/DwellEventer.ts
var DwellEvent = class extends TypedEvent {
  constructor(dwellTimeSeconds) {
    super("dwell");
    this.dwellTimeSeconds = dwellTimeSeconds;
  }
};
var DwellEventer = class extends TypedEventBase {
  constructor(minTimeSeconds = 1, graceTimeSeconds = 0.25) {
    super();
    this.minTimeSeconds = minTimeSeconds;
    this.graceTimeSeconds = graceTimeSeconds;
    this.startTime = null;
    this.graceTimer = null;
    Object.seal(this);
  }
  start() {
    this.stopGrace();
    if (this.startTime === null) {
      this.startTime = performance.now();
    }
  }
  stopGrace() {
    if (this.graceTimer !== null) {
      clearTimeout(this.graceTimer);
      this.graceTimer = null;
    }
  }
  stop() {
    if (this.startTime !== null) {
      this.graceTimer = setTimeout(() => {
        this.graceTimer = null;
        const delta2 = (performance.now() - this.startTime) / 1e3;
        this.startTime = null;
        if (delta2 > this.minTimeSeconds) {
          this.dispatchEvent(new DwellEvent(delta2));
        }
      }, this.graceTimeSeconds * 1e3);
    }
  }
};

// src/vr-apps/yarrow/Model.ts
var modelTemplateTasks = singleton("Yarrow:Model:modelTemplateTasks", () => /* @__PURE__ */ new Map());
var Model = class extends Object3D {
  constructor(scenario, model2, parent) {
    super();
    this.scenario = scenario;
    this.model = null;
    this.error = null;
    this.disposed = false;
    this.name = `model-${model2.fileName}`;
    this.key = model2.key;
    this.scenarioID = model2.scenarioID;
    this.fileID = model2.fileID;
    this.fileName = model2.fileName;
    this.filePath = model2.filePath;
    this.fileTagString = model2.fileTagString;
    this.transformID = model2.transformID;
    this.mediaType = model2.mediaType;
    this.trueMediaType = model2.trueMediaType;
    this.copyright = model2.copyright;
    this.copyrightDate = model2.copyrightDate;
    this.target = new RayTarget(this);
    objGraph(parent, this);
    Object.seal(this);
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    if (isDefined(this.model)) {
      this.model.removeFromParent();
      cleanup(this.model);
      this.model = null;
    }
  }
  async load(prog) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    let templateTask = modelTemplateTasks.get(this.filePath);
    if (!templateTask) {
      const asset = new AssetGltfModel(this.scenario.env, this.filePath, this.mediaType, !this.scenario.env.DEBUG);
      templateTask = asset.then((template2) => {
        try {
          convertMaterials(template2.scene, materialStandardToPhong);
        } catch (err) {
          this.error = err;
        }
        return template2;
      });
      modelTemplateTasks.set(this.filePath, templateTask);
      this.scenario.env.fetcher.assets(prog, asset);
    }
    const template = await templateTask;
    const dweller = new DwellEventer();
    dweller.addEventListener("dwell", (evt) => {
      this.scenario.log("model viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
    });
    this.model = template.scene.clone(true);
    this.model.traverse((obj2) => {
      if (isMesh(obj2)) {
        this.target.addMesh(obj2);
      }
    });
    this.target.addEventListener("enter", (evt) => {
      if (evt.pointer.type === "nose") {
        dweller.start();
      }
    });
    this.target.addEventListener("exit", (evt) => {
      if (evt.pointer.type === "nose") {
        dweller.stop();
      }
    });
    objGraph(this, this.model);
  }
  async reload(prog) {
    this.dispose();
    this.error = null;
    await this.load(prog);
  }
  get size() {
    return this.parent.scale.x;
  }
  set size(v) {
    this.parent.scale.setScalar(v);
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};

// src/vr-apps/yarrow/proxy.ts
function resolveURL(url2) {
  if (isNullOrUndefined(url2)) {
    return null;
  }
  if (isString(url2)) {
    url2 = new URL(url2, location.href);
  }
  return url2;
}
function stripParameters(url2) {
  if (isNullOrUndefined(url2)) {
    throw new Error("URL is undefined");
  }
  url2 = resolveURL(url2);
  if (isYouTube(url2)) {
    const toRemove = Array.from(url2.searchParams.keys()).filter((key) => key !== "v" && key !== "t");
    for (const key of toRemove) {
      url2.searchParams.delete(key);
    }
  }
  return url2;
}
function makeProxyURL(url2) {
  url2 = resolveURL(url2);
  if (isNullOrUndefined(url2)) {
    throw new Error("URL is undefined");
  }
  url2 = stripParameters(url2);
  return new URLBuilder("/vr/link", location.href).query("q", url2.href).toURL();
}

// src/vr-apps/yarrow/Sign.ts
var TRANSITION_TIME = 1e3;
var SPEED = 1e3 / TRANSITION_TIME;
var Q2 = new Vector3();
var iconSize = 0.15;
var textSize = 0.1;
var signLabelStyle = {
  minHeight: textSize,
  maxHeight: textSize,
  minWidth: textSize,
  padding: 0.02,
  scale: 1e3,
  bgFillColor: DLSBlue,
  textFillColor: "white"
};
var _Sign = class extends Object3D {
  constructor(scenario, data, parent) {
    super();
    this.scenario = scenario;
    this.originPoint = new Vector3();
    this.originRotation = new Quaternion();
    this._isCallout = false;
    this.wasCallout = null;
    this._alwaysVisible = false;
    this.wasAlwaysVisible = null;
    this.opacity = 1;
    this.lastOpacity = null;
    this.file = null;
    this.pdf = null;
    this.zoomInButton = null;
    this.zoomOutButton = null;
    this.prevButton = null;
    this.pageLabel = null;
    this.nextButton = null;
    this.error = null;
    this.disposed = false;
    this.invMatrix = new Matrix4();
    this.dumpScale = new Vector3();
    this.followObj = this.scenario.env.worldUISpace;
    this.onClick = () => this.toggle();
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.transformID = data.transformID;
    this.name = `sign-${data.fileName}`;
    this.originPoint.copy(this.position);
    this.originRotation.copy(this.quaternion);
    objGraph(parent, this);
    this._alwaysVisible = data.alwaysVisible;
    this._isCallout = data.isCallout;
    this.start = -1;
    this.end = 0;
    this.t = 1;
    this.direction = -1;
    this.target = new RayTarget(this);
    this.scenario.addScopedEventListener(this, "present", (evt) => {
      if (this.direction !== -1 && evt.source !== this) {
        this.toggle();
      }
    });
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    this.scenario.removeScope(this);
    if (isDefined(this.image)) {
      this.image.dispose();
      this.image = null;
    }
    this.removeButton(this.zoomInButton);
    this.zoomInButton = null;
    this.removeButton(this.zoomOutButton);
    this.zoomOutButton = null;
    this.removeButton(this.prevButton);
    this.prevButton = null;
    this.removeButton(this.nextButton);
    this.nextButton = null;
    this.removeButton(this.pageLabel);
    this.pageLabel = null;
    this.pdf = null;
  }
  removeButton(obj2) {
    if (isDefined(obj2)) {
      if (obj2 instanceof TypedEventBase) {
        obj2.removeScope(this);
      }
      if (isErsatzObject(obj2)) {
        obj2.object.removeFromParent();
        cleanup(obj2);
      }
    }
  }
  async load(progress) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    try {
      const [file, zoomInButton, zoomOutButton] = await all(
        this.scenario.env.fetcher.get(this.filePath).progress(progress).file(),
        this.scenario.env.uiButtons.getMeshButton("zoom", "in", iconSize),
        this.scenario.env.uiButtons.getMeshButton("zoom", "out", iconSize)
      );
      this.file = file;
      this.zoomInButton = zoomInButton;
      this.zoomInButton.addScopedEventListener(this, "click", this.onClick);
      this.zoomInButton.object.visible = this.isCallout;
      this.zoomOutButton = zoomOutButton;
      this.zoomOutButton.addScopedEventListener(this, "click", this.onClick);
      this.zoomOutButton.object.visible = false;
      objGraph(this, this.zoomInButton, this.zoomOutButton);
      if (Application_Pdf.matches(this.file.contentType)) {
        this.pdf = new PDFImage(this.file.content, { scale: 2 });
        const [prevButton, nextButton] = await all(
          this.scenario.env.uiButtons.getMeshButton("arrow", "left", 0.1),
          this.scenario.env.uiButtons.getMeshButton("arrow", "right", 0.1)
        );
        objGraph(
          this,
          this.prevButton = prevButton,
          this.pageLabel = new TextMesh(this.scenario.env, "label-" + this.transformID, "none", signLabelStyle, { side: FrontSide }),
          this.nextButton = nextButton
        );
        this.prevButton.addScopedEventListener(this, "click", () => this.loadImage(this.pdf.curPageIndex - 1));
        this.nextButton.addScopedEventListener(this, "click", () => this.loadImage(this.pdf.curPageIndex + 1));
      }
      objGraph(
        this,
        this.image = new Image2D(this.scenario.env, `Sign(${this.key}) ${file.fileName}`, "dynamic")
      );
      const dweller = new DwellEventer();
      dweller.addEventListener("dwell", (evt) => {
        this.scenario.log("sign viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
      });
      this.target.clickable = true;
      this.target.addEventListener("click", this.onClick);
      this.target.addEventListener("enter", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.start();
        }
      });
      this.target.addEventListener("exit", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.stop();
        }
      });
      await this.loadImage(0);
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    this.dispose();
    this.error = null;
    await this.load(prog);
  }
  async loadImage(pageIndex) {
    if (this.pdf) {
      this.prevButton.disabled = true;
      this.nextButton.disabled = true;
    }
    const image2 = await this.getFrame(pageIndex);
    this.image.setTextureMap(image2);
    this.image.objectWidth = 1;
    if (this.pdf) {
      const y = this.image.objectHeight / 2;
      this.prevButton.object.visible = this.pageLabel.object.visible = this.nextButton.object.visible = this.hasPages;
      if (this.hasPages) {
        this.prevButton.object.position.set(-0.5, -y, 0.1);
        this.pageLabel.position.set(0, -y, 0.1);
        this.nextButton.object.position.set(0.5, -y, 0.1);
        this.prevButton.disabled = !this.pdf.canGoBack;
        this.pageLabel.image.value = `${this.pdf.curPageNumber} of ${this.pdf.numPages}`;
        this.nextButton.disabled = !this.pdf.canGoForward;
      }
    }
  }
  async getFrame(pageIndex) {
    if (this.pdf) {
      this.scenario.log("view sign page", { id: this.transformID, page: pageIndex });
      await this.pdf.getPage(pageIndex);
      return this.pdf.canvas;
    } else {
      return await this.scenario.env.fetcher.get(this.file.content).image().then(unwrapResponse);
    }
  }
  get isCallout() {
    return this._isCallout;
  }
  set isCallout(v) {
    this._isCallout = v;
    this.update(0);
  }
  get hasPages() {
    return this.pdf && this.pdf.numPages > 1;
  }
  get alwaysVisible() {
    return this._alwaysVisible;
  }
  set alwaysVisible(v) {
    this._alwaysVisible = v;
    this.update(0);
  }
  get isClickable() {
    return this.isCallout || !this.alwaysVisible;
  }
  get showZoomIn() {
    return this.isClickable && this.direction === -1 && this.t >= this.end;
  }
  get showZoomOut() {
    return this.isClickable && this.direction === 1 && this.t >= this.end;
  }
  toggle() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      if (this.direction !== 1) {
        this.scenario.log("expand sign", { id: this.transformID });
        this.target.addMesh(this.image.mesh);
        this.direction = 1;
        const evt = new PresentEvent(this);
        this.scenario.dispatchEvent(evt);
      } else {
        this.target.removeMesh(this.image.mesh);
        this.direction = -1;
      }
      const left = Math.max(0, this.end - this.t);
      this.start = performance.now();
      this.end = this.start + TRANSITION_TIME;
      this.t = this.start + left;
    }
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      this.start = -1;
      this.t = 0;
      this.end = 0;
      this.direction = -1;
    }
    if (isDefined(this.image)) {
      this.image.removeWebXRLayer();
    }
  }
  update(dt) {
    if (isDefined(this.error) || !isDefined(this.parent)) {
      return;
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.visible = this.showZoomIn;
      this.zoomOutButton.object.visible = this.showZoomOut;
      if (this.isCallout !== this.wasCallout || this.alwaysVisible !== this.wasAlwaysVisible) {
        const x = this.image.objectWidth / 2;
        const y = this.image.objectHeight / 2;
        this.zoomInButton.object.visible = this.isClickable;
        this.zoomOutButton.object.visible = false;
        if (this.alwaysVisible) {
          this.zoomInButton.object.position.set(x, y, 0.1);
        } else {
          this.zoomInButton.object.position.set(0, 0, 0);
        }
        this.zoomOutButton.object.position.set(x, y, 0.1);
        this.wasCallout = this.isCallout;
        this.wasAlwaysVisible = this.alwaysVisible;
      }
    }
    this.t += SPEED * dt;
    const p = project(this.t, this.start, this.end);
    const q = clamp(p, 0, 1);
    const r = this.direction === 1 ? 1 - q : q;
    if (this.isCallout) {
      this.invMatrix.copy(this.parent.matrixWorld).invert().multiply(this.followObj.matrixWorld).multiply(_Sign.offsetMatrix).decompose(this.position, this.quaternion, this.dumpScale);
      this.position.lerp(this.originPoint, r);
      this.quaternion.slerp(this.originRotation, r);
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.lookAt(this.scenario.env.avatar.worldPos);
      this.zoomInButton.object.getWorldPosition(Q2);
      this.zoomInButton.size = this.zoomOutButton.size = iconSize * Q2.sub(this.scenario.env.avatar.worldPos).length() / (3 * this.size);
      this.zoomOutButton.object.matrix.copy(this.zoomInButton.object.matrix);
    }
    if (this.alwaysVisible) {
      this.opacity = 1;
    } else {
      this.opacity = this.alwaysVisible ? 1 : 1 - r;
    }
    if (this.opacity !== this.lastOpacity) {
      this.image.mesh.material.opacity = this.opacity;
      this.image.mesh.material.transparent = this.opacity < 1;
      this.image.mesh.material.needsUpdate = true;
      this.image.mesh.visible = 0 < this.opacity && this.opacity < 1 || !(this.scenario.env.showWebXRLayers && this.scenario.env.hasXRCompositionLayers);
      this.image.webXRLayerType = this.opacity === 1 ? "dynamic" : "none";
      if (isDefined(this.pdf)) {
        this.prevButton.object.visible = this.pageLabel.object.visible = this.nextButton.object.visible = this.hasPages && this.opacity === 1;
      }
      this.lastOpacity = this.opacity;
    }
  }
  get size() {
    return this.parent.scale.x;
  }
  set size(v) {
    this.parent.scale.setScalar(v);
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};
var Sign = _Sign;
Sign.offsetMatrix = new Matrix4().makeTranslation(0, 0, -1.5);

// src/vr-apps/yarrow/Station.ts
var Station = class {
  constructor(scenario, data) {
    this.scenario = scenario;
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.transformID = data.transformID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.location = data.location;
    this.zone = data.zone;
    this.label = data.label;
    this.rotation = data.rotation;
  }
  async reload(prog) {
    this.scenario.evict(this);
    if (this.scenario.curStation === this) {
      await this.scenario.env.withFade(async () => {
        this.scenario.env.skybox.clear();
        await this.scenario.showStation(this, false, prog);
      });
    }
  }
};

// src/vr-apps/yarrow/Text.ts
var TRANSITION_TIME2 = 1e3;
var SPEED2 = 1e3 / TRANSITION_TIME2;
var Q3 = new Vector3();
var iconSize2 = 0.15;
var textSize2 = 0.2;
var textLabelStyle2 = {
  minHeight: textSize2,
  maxHeight: textSize2,
  minWidth: textSize2,
  padding: 0.04,
  scale: 1e3,
  bgFillColor: "white",
  textFillColor: "black",
  bgStrokeColor: DLSBlue,
  bgStrokeSize: 0.01
};
var _Text = class extends Object3D {
  constructor(scenario, data, parent) {
    super();
    this.scenario = scenario;
    this.originPoint = new Vector3();
    this.originRotation = new Quaternion();
    this._isCallout = false;
    this.wasCallout = null;
    this._alwaysVisible = false;
    this.wasAlwaysVisible = null;
    this.opacity = 1;
    this.lastOpacity = null;
    this.zoomInButton = null;
    this.error = null;
    this.disposed = false;
    this.invMatrix = new Matrix4();
    this.dumpScale = new Vector3();
    this.followObj = this.scenario.env.worldUISpace;
    this.onClick = () => this.toggle();
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.transformID = data.transformID;
    this.name = `text-${data.fileName}`;
    this.originPoint.copy(this.position);
    this.originRotation.copy(this.quaternion);
    objGraph(parent, this);
    this._alwaysVisible = data.alwaysVisible;
    this._isCallout = data.isCallout;
    this.start = -1;
    this.end = 0;
    this.t = 1;
    this.direction = -1;
    this.target = new RayTarget(this);
    this.scenario.addScopedEventListener(this, "present", (evt) => {
      if (this.direction !== -1 && evt.source !== this) {
        this.toggle();
      }
    });
  }
  get text() {
    return this.image.image.value;
  }
  set text(v) {
    this.image.image.value = v;
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    this.scenario.removeScope(this);
    if (isDefined(this.image)) {
      this.image.dispose();
      this.image = null;
    }
    this.removeButton(this.zoomInButton);
    this.zoomInButton = null;
  }
  removeButton(obj2) {
    if (isDefined(obj2)) {
      if (obj2 instanceof TypedEventBase) {
        obj2.removeScope(this);
      }
      if (isErsatzObject(obj2)) {
        obj2.object.removeFromParent();
        cleanup(obj2);
      }
    }
  }
  async load(progress) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    try {
      const [text2, zoomInButton] = await all(
        this.scenario.env.fetcher.get(this.filePath).progress(progress).text(),
        this.scenario.env.uiButtons.getMeshButton("zoom", "info", iconSize2)
      );
      this.zoomInButton = zoomInButton;
      this.zoomInButton.addScopedEventListener(this, "click", this.onClick);
      this.zoomInButton.object.visible = this.isCallout;
      objGraph(this, this.zoomInButton);
      objGraph(
        this,
        this.image = new TextMesh(this.scenario.env, `Text(${this.key}) ${text2.fileName}`, "dynamic", textLabelStyle2)
      );
      const dweller = new DwellEventer();
      dweller.addEventListener("dwell", (evt) => {
        this.scenario.log("text viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
      });
      this.target.clickable = true;
      this.target.addEventListener("click", this.onClick);
      this.target.addEventListener("enter", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.start();
        }
      });
      this.target.addEventListener("exit", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.stop();
        }
      });
      this.image.image.value = text2.content;
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    this.dispose();
    this.error = null;
    await this.load(prog);
  }
  get isCallout() {
    return this._isCallout;
  }
  set isCallout(v) {
    this._isCallout = v;
    this.update(0);
  }
  get alwaysVisible() {
    return this._alwaysVisible;
  }
  set alwaysVisible(v) {
    this._alwaysVisible = v;
    this.update(0);
  }
  get isClickable() {
    return this.isCallout || !this.alwaysVisible;
  }
  get showZoomIn() {
    return this.isClickable && this.direction === -1 && this.t >= this.end;
  }
  toggle() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      if (this.direction !== 1) {
        this.scenario.log("expand text", { id: this.transformID });
        this.target.addMesh(this.image.mesh);
        this.direction = 1;
        const evt = new PresentEvent(this);
        this.scenario.dispatchEvent(evt);
      } else {
        this.target.removeMesh(this.image.mesh);
        this.direction = -1;
      }
      const left = Math.max(0, this.end - this.t);
      this.start = performance.now();
      this.end = this.start + TRANSITION_TIME2;
      this.t = this.start + left;
    }
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      this.start = -1;
      this.t = 0;
      this.end = 0;
      this.direction = -1;
    }
    if (isDefined(this.image)) {
      this.image.removeWebXRLayer();
    }
  }
  update(dt) {
    if (isDefined(this.error) || !isDefined(this.parent)) {
      return;
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.visible = this.showZoomIn;
      if (this.isCallout !== this.wasCallout || this.alwaysVisible !== this.wasAlwaysVisible) {
        const x = this.image.objectWidth / 2;
        const y = this.image.objectHeight / 2;
        this.zoomInButton.object.visible = this.isClickable;
        if (this.alwaysVisible) {
          this.zoomInButton.object.position.set(x, y, 0.1);
        } else {
          this.zoomInButton.object.position.set(0, 0, 0);
        }
        this.wasCallout = this.isCallout;
        this.wasAlwaysVisible = this.alwaysVisible;
      }
    }
    this.t += SPEED2 * dt;
    const p = project(this.t, this.start, this.end);
    const q = clamp(p, 0, 1);
    const r = this.direction === 1 ? 1 - q : q;
    if (this.isCallout) {
      this.invMatrix.copy(this.parent.matrixWorld).invert().multiply(this.followObj.matrixWorld).multiply(_Text.offsetMatrix).decompose(this.position, this.quaternion, this.dumpScale);
      this.position.lerp(this.originPoint, r);
      this.quaternion.slerp(this.originRotation, r);
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.lookAt(this.scenario.env.avatar.worldPos);
      this.zoomInButton.object.getWorldPosition(Q3);
      this.zoomInButton.size = iconSize2 * Q3.sub(this.scenario.env.avatar.worldPos).length() / (3 * this.size);
    }
    if (this.alwaysVisible) {
      this.opacity = 1;
    } else {
      this.opacity = this.alwaysVisible ? 1 : 1 - r;
    }
    if (this.opacity !== this.lastOpacity) {
      this.image.mesh.material.opacity = this.opacity;
      this.image.mesh.material.transparent = this.opacity < 1;
      this.image.mesh.material.needsUpdate = true;
      this.image.mesh.visible = 0 < this.opacity && this.opacity < 1 || !(this.scenario.env.showWebXRLayers && this.scenario.env.hasXRCompositionLayers);
      this.image.webXRLayerType = this.opacity === 1 ? "dynamic" : "none";
      this.lastOpacity = this.opacity;
    }
  }
  get size() {
    return this.parent.scale.x;
  }
  set size(v) {
    this.parent.scale.setScalar(v);
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};
var Text = _Text;
Text.offsetMatrix = new Matrix4().makeTranslation(0, 0, -1.5);

// src/vr-apps/yarrow/Transform.ts
var Transform = class extends Object3D {
  constructor(data) {
    super();
    this.M = new Matrix4();
    this.data = data;
    this.name = data.name;
    this.M.fromArray(data.matrix);
    this.M.decompose(this.position, this.quaternion, this.scale);
  }
  get transformID() {
    return this.data.id;
  }
};

// src/vr-apps/yarrow/Video.ts
var Video = class extends Object3D {
  constructor(scenario, proxy, parent, player, data) {
    super();
    this.scenario = scenario;
    this.proxy = proxy;
    this.player = player;
    this.controls = null;
    this.data = null;
    this.error = null;
    this.disposed = false;
    this.label = data.label;
    this.volume = data.volume;
    this.enabled = data.enabled;
    this.transformID = data.transformID;
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.sphereEncodingName = data.sphereEncodingName;
    this.stereoLayoutName = data.stereoLayoutName;
    this.name = "video-" + data.fileName;
    objGraph(
      parent,
      objGraph(
        this,
        this.thumbnail = new Image2D(this.scenario.env, "thumbnail-" + data.fileName, "static")
      )
    );
    this.size = parent.scale.x;
    parent.scale.setScalar(1);
    this.target = new RayTarget(this);
    Object.seal(this);
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    if (isDefined(this.thumbnail)) {
      this.thumbnail.dispose();
    }
    if (isDefined(this.controls)) {
      this.controls.removeScope(this);
      this.controls.dispose();
    }
  }
  async load(prog) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    try {
      const progs = progressSplitWeighted(prog, [10, 1]);
      if (Video_Vnd_DlsDc_YtDlp_Json.matches(this.mediaType)) {
        this.data = await this.proxy.loadData(this.filePath, progs.shift());
        const thumbnailImage = await this.scenario.env.fetcher.get(this.data.thumbnail.url).image(this.data.thumbnail.contentType).then(unwrapResponse);
        this.thumbnail.setTextureMap(thumbnailImage);
        this.thumbnail.objectWidth = 1;
        this.thumbnail.mesh.renderOrder = 4;
      }
      const title = this.label || this.data && this.data.title && this.data.title.substring(0, 25) || this.fileName;
      objGraph(
        this,
        objGraph(this.controls = new PlaybackButton(
          this.scenario.env,
          this.scenario.env.uiButtons,
          this.data || this.filePath,
          this.filePath,
          title,
          this.volume,
          this.player
        ))
      );
      this.controls.object.renderOrder = 5;
      this.controls.object.position.y = -this.thumbnail.objectHeight / 2;
      this.controls.object.position.z = 0.01;
      const showHideVideo = (v) => () => {
        this.thumbnail.visible = !v;
        this.player.object.visible = v;
        if (v) {
          this.scenario.log("play video", { id: this.transformID });
          objGraph(this, this.player);
          this.player.setStereoParameters(this.sphereEncodingName, this.stereoLayoutName);
          this.player.object.position.set(0, 0, 0);
          this.player.object.quaternion.identity();
          this.target.addMeshes(...this.player.meshes);
        } else {
          this.scenario.log("stop video", { id: this.transformID });
          this.target.removeMeshes(...this.player.meshes);
        }
      };
      this.controls.addScopedEventListener(this, "play", showHideVideo(true));
      this.controls.addScopedEventListener(this, "stop", showHideVideo(false));
      const dweller = new DwellEventer();
      dweller.addEventListener("dwell", (evt) => {
        this.scenario.log("video viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
      });
      this.target.addEventListener("enter", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.start();
        }
      });
      this.target.addEventListener("exit", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.stop();
        }
      });
      this.disposed = false;
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    this.dispose();
    await this.load(prog);
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    this.player.stop();
    if (isDefined(this.thumbnail)) {
      this.thumbnail.removeWebXRLayer();
    }
  }
  get size() {
    return this.scale.x;
  }
  set size(v) {
    this.scale.x = this.scale.y = v;
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};

// src/vr-apps/yarrow/BaseScenario.ts
var ScenarioNavigateEvent = class extends TypedEvent {
  constructor(station) {
    super("navigate");
    this.station = station;
  }
};
var PresentEvent = class extends Event {
  constructor(source) {
    super("present");
    this.source = source;
    Object.seal(this);
  }
};
var BaseScenario3 = class extends TypedEventBase {
  constructor(env, dataLogger, data) {
    super();
    this.env = env;
    this.dataLogger = dataLogger;
    this.data = data;
    this.stations = new Array();
    this.signs = new Array();
    this.videos = new Array();
    this.texts = new Array();
    this.audios = new Array();
    this.models = new Array();
    this.signsByStation = new PriorityList();
    this.videosByStation = new PriorityList();
    this.textsByStation = new PriorityList();
    this.audiosByStation = new PriorityList();
    this.modelsByStation = new PriorityList();
    this.curConnections = new PriorityMap();
    this.transformsByTransformID = /* @__PURE__ */ new Map();
    this.zonedClips = new PriorityList();
    this.playbackButtons = /* @__PURE__ */ new Map();
    this.videosReady = null;
    this.cancellationToken = null;
    this.curStationID = null;
    this.curZone = null;
    this.rootTransformID = null;
    this.__originLL = null;
    this._originUTM = null;
    this.windowQuitter = new WindowQuitEventer();
    this.disposed = false;
    this._muteEnvAudio = false;
    this.imgCache = new LRUCache(10);
    this.imgTasks = /* @__PURE__ */ new Map();
    this.imgCache.addEventListener("itemevicted", (evt) => {
      if (isImageBitmap(evt.value)) {
        evt.value.close();
      }
    });
    this.yt = new YouTubeProxy(this.env.fetcher, makeProxyURL);
    if (isDefined(data.origin)) {
      this._originLL = new LatLngPoint(data.origin);
    }
    this.startStationID = data.startStationID;
    this.startRotation = data.startRotation;
    this.transforms = data.transforms;
    this.connections = data.connections;
    this.env.addScopedEventListener(this, "environmentaudiotoggled", () => {
      this.environmentAudioMuted = env.environmentAudioMuted;
    });
    let quit = false;
    const onQuit = () => {
      if (!quit) {
        quit = true;
        this.logLeaveStation();
        this.log("leave scenario", { id: this.id });
      }
    };
    this.env.addScopedEventListener(this, "quitting", onQuit);
    this.windowQuitter.addScopedEventListener(this, "quitting", onQuit);
    this.env.addScopedEventListener(this, "sceneclearing", () => {
      this.pauseCurrentAudioZone();
      this.curZone = null;
    });
    this.env.avatar.addScopedEventListener(this, "avatarreset", () => {
      this.moveToStation(this.curStation);
    });
  }
  get isEmpty() {
    return this.stations.length === 0 && this.connections.length === 0 && this.signs.length === 0 && this.videos.length === 0 && this.texts.length === 0 && this.audios.length === 0 && this.models.length === 0;
  }
  get rootTransform() {
    return this.transformsByTransformID.get(this.rootTransformID);
  }
  get _originLL() {
    return this.__originLL;
  }
  set _originLL(v) {
    this.__originLL = v;
    if (isDefined(v)) {
      this._originUTM = this.originLL.toUTM();
    } else {
      this._originUTM = null;
    }
  }
  get originLL() {
    return this._originLL;
  }
  get originUTM() {
    return this._originUTM;
  }
  get id() {
    return this.data.id;
  }
  get name() {
    return this.data.name;
  }
  get version() {
    return this.data.version;
  }
  get published() {
    return this.data.published;
  }
  get roomName() {
    return this.data.roomName;
  }
  async loadAssets(prog) {
    this.cancellationToken = new CancelToken();
    this.clearCache();
    this.rig = await createPhotosphereCaptureRig(this.env.fetcher, this.cancellationToken);
    this.rig.init(location.href, this.env.DEBUG);
    prog = prog || this.env.loadingBar;
    const [pdfJSProg, assetProg] = progressSplitWeighted(prog, [1, 100]);
    await PDFImage.prepare(getScriptUrl("pdfjs"), this.env.fetcher, this.env.DEBUG, pdfJSProg);
    for (const transformData of this.data.transforms) {
      this.addTransformData(transformData);
    }
    for (const transformData of this.data.transforms) {
      if (transformData.parentTransformID === 0) {
        this.rootTransformID = transformData.id;
      } else {
        const parent = this.getTransform(transformData.parentTransformID);
        const child = this.getTransform(transformData.id);
        parent.attach(child);
      }
    }
    const [otherAssetProg, videoAssetProg] = progressSplitWeighted(assetProg, [10, 1]);
    this.videosReady = progressOfArray(videoAssetProg, this.data.videoClips, (videoClip, prog2) => this.createVideo(videoClip, prog2).catch((exp) => {
      if (exp instanceof CancelSignalException) {
        console.warn("Late load cancellation occured");
      } else {
        throw exp;
      }
    })).then(() => null);
    await progressTasksWeighted(otherAssetProg, [
      /////////// BUILD STATIONS ///////////
      [this.data.stations.length, (prog2) => progressOfArray(prog2, this.data.stations, (station, prog3) => this.createStation(station, prog3))],
      /////////// BUILD SIGNS ///////////
      [this.data.signs.length, (prog2) => progressOfArray(prog2, this.data.signs, (sign, prog3) => this.createSign(sign, prog3))],
      /////////// BUILD MODELS ///////////
      [this.data.models.length, (prog2) => progressOfArray(prog2, this.data.models, (model2, prog3) => this.createModel(model2, prog3))],
      /////////// BUILD AUDIO TRACKS ///////////
      [this.data.audioTracks.length, (prog2) => progressOfArray(prog2, this.data.audioTracks, (audioTrack, prog3) => this.createAudio(audioTrack, prog3))],
      /////////// BUILD TEXTS ///////////
      [this.data.texts.length, (prog2) => progressOfArray(prog2, this.data.texts, (text2, prog3) => this.createText(text2, prog3))]
    ]);
    for (const connection of this.data.connections) {
      this.createConnection(connection);
    }
    this.env.addScopedEventListener(this, "update", (evt) => this.update(evt));
  }
  dispose() {
    if (!this.disposed) {
      if (this.cancellationToken) {
        this.cancellationToken.cancel();
      }
      this.env.infoLabel.image.clear();
      this.pauseCurrentAudioZone();
      this.env.removeScope(this);
      this.env.avatar.removeScope(this);
      for (const audio of this.audios) {
        audio.dispose();
      }
      for (const sign of this.signs) {
        sign.dispose();
      }
      for (const model2 of this.models) {
        model2.dispose();
      }
      for (const video of this.videos) {
        video.dispose();
      }
      for (const text2 of this.texts) {
        text2.dispose();
      }
      const root = this.transformsByTransformID.get(this.rootTransformID);
      root.removeFromParent();
      cleanup(root);
      this.transformsByTransformID.clear();
      this.signsByStation.clear();
      this.audiosByStation.clear();
      this.videosByStation.clear();
      this.textsByStation.clear();
      this.modelsByStation.clear();
      this.zonedClips.clear();
      arrayClear(this.audios);
      arrayClear(this.videos);
      arrayClear(this.texts);
      arrayClear(this.signs);
      arrayClear(this.models);
      this.windowQuitter.removeScope(this);
      this.disposed = true;
    }
  }
  get avatarHeightOffset() {
    return this.env.avatar.height - this.env.defaultAvatarHeight;
  }
  update(evt) {
    const signs = this.signsByStation.get(this.curStation);
    for (const sign of signs) {
      sign.update(evt.dt);
    }
    const texts = this.textsByStation.get(this.curStation);
    for (const text2 of texts) {
      text2.update(evt.dt);
    }
  }
  get environmentAudioMuted() {
    return this._muteEnvAudio;
  }
  set environmentAudioMuted(v) {
    if (v !== this.environmentAudioMuted) {
      this._muteEnvAudio = v;
      if (this.environmentAudioMuted) {
        this.pauseCurrentAudioZone();
      } else {
        this.playCurrentAudioZone();
      }
    }
  }
  addTransformData(transformData) {
    const transform = new Transform(transformData);
    this.transformsByTransformID.set(transform.transformID, transform);
    return transform;
  }
  getTransform(transformID) {
    return this.transformsByTransformID.get(transformID);
  }
  getStation(stationID) {
    return arrayScan(this.stations, (s) => s.transformID === stationID);
  }
  get curStation() {
    return this.getStation(this.curStationID);
  }
  get startStation() {
    return this.getStation(this.startStationID);
  }
  async createStation(data, prog) {
    if (prog) {
      prog.end();
    }
    const station = new Station(this, data);
    this.stations.push(station);
    return station;
  }
  async createConnection(data) {
    try {
      const fromStation = this.getStation(data.fromStationID);
      const toStation = this.getStation(data.toStationID);
      const fromTransform = this.getTransform(fromStation.transformID);
      const toTransform = this.getTransform(toStation.transformID);
      let transform = this.getTransform(data.transformID);
      if (isNullOrUndefined(transform)) {
        data.transformID = -this.transforms.length;
        const transformData = {
          id: data.transformID,
          name: `nav-icon-from-${fromTransform.name}-to-${toTransform.name}`,
          matrix: Connection.calcMatrix(fromTransform, toTransform, this.env.defaultAvatarHeight).toArray(),
          parentTransformID: fromStation.transformID
        };
        this.transforms.push(transformData);
        transform = this.addTransformData(transformData);
        objGraph(fromTransform, transform);
      }
      const icon = new Connection(this.env, transform, fromTransform, toTransform, data.label);
      icon.addEventListener("click", () => {
        this.dispatchEvent(new ScenarioNavigateEvent(toStation));
        this.showStation(toStation, true, this.env.loadingBar);
      });
      this.curConnections.add(fromStation, toStation, icon);
      return icon;
    } catch (err) {
      console.error({ task: "createConnection", err, data });
      return null;
    }
  }
  async createSign(data, prog) {
    const transform = this.getTransform(data.transformID);
    const sign = new Sign(this, data, transform);
    this.signs.push(sign);
    await sign.load(prog);
    this.cancellationToken.check();
    const station = this.findStation(sign);
    this.signsByStation.add(station, sign);
    return sign;
  }
  async createModel(data, prog) {
    const transform = this.getTransform(data.transformID);
    const obj2 = new Model(this, data, transform);
    this.models.push(obj2);
    await obj2.load(prog);
    this.cancellationToken.check();
    const station = this.findStation(obj2);
    this.modelsByStation.add(station, obj2);
    return obj2;
  }
  async createAudio(data, prog) {
    const transform = this.getTransform(data.transformID);
    const audio = new Audio3(this, transform, this.env.audioPlayer, data);
    this.audios.push(audio);
    const station = this.findStation(audio.parent);
    this.audiosByStation.add(station, audio);
    await audio.load(prog);
    this.cancellationToken.check();
    if (isDefined(audio.controls)) {
      this.playbackButtons.set(audio.parent, audio.controls);
      if (isNullOrUndefined(audio.error)) {
        audio.controls.addEventListener("play", () => this.pauseCurrentAudioZone());
        audio.controls.addEventListener("stop", () => this.playCurrentAudioZone());
      }
    }
    if (isDefined(audio.clip)) {
      this.zonedClips.add(audio.zone, audio.clip);
    }
    return audio;
  }
  async createVideo(data, prog) {
    const transform = this.getTransform(data.transformID);
    const video = new Video(this, this.yt, transform, this.env.videoPlayer, data);
    this.videos.push(video);
    await video.load(prog);
    this.cancellationToken.check();
    this.playbackButtons.set(video.parent, video.controls);
    const station = this.findStation(video.parent);
    this.videosByStation.add(station, video);
    if (isNullOrUndefined(video.error)) {
      video.controls.addEventListener("play", () => this.pauseCurrentAudioZone());
      video.controls.addEventListener("stop", () => this.playCurrentAudioZone());
    }
    return video;
  }
  async createText(data, prog) {
    const transform = this.getTransform(data.transformID);
    const text2 = new Text(this, data, transform);
    this.texts.push(text2);
    await text2.load(prog);
    this.cancellationToken.check();
    const station = this.findStation(text2);
    this.textsByStation.add(station, text2);
    return text2;
  }
  getConnectionLabel(fromStation, toStation) {
    if (isNullOrUndefined(fromStation) || isNullOrUndefined(toStation)) {
      return null;
    }
    for (const connection of this.connections) {
      if (connection.fromStationID === fromStation.transformID && connection.toStationID === toStation.transformID) {
        return connection.label;
      }
    }
    return null;
  }
  getStationByObject(obj2) {
    if (obj2 instanceof Transform) {
      return this.getStation(obj2.transformID);
    }
    return null;
  }
  findStation(obj2) {
    let station = this.getStationByObject(obj2);
    while (!station && obj2 != null) {
      obj2 = obj2.parent;
      station = this.getStationByObject(obj2);
    }
    return station;
  }
  getStationCenter(station) {
    const v = new Vector3();
    const stTransform = this.getTransform(station.transformID);
    if (stTransform) {
      stTransform.getWorldPosition(v);
    }
    v.y += this.env.defaultAvatarHeight;
    return v;
  }
  get visible() {
    return isDefined(this.rootTransform.parent);
  }
  set visible(v) {
    if (v !== this.visible) {
      if (v) {
        this.curStationID = null;
        if (this.rootTransform == null) {
          throw new Error("No root transform");
        }
        objGraph(this.env.foreground, this.rootTransform);
        for (const station of this.stations) {
          const here = this.getTransform(station.transformID);
          here.visible = false;
        }
      } else {
        this.env.foreground.remove(this.rootTransform);
      }
    }
  }
  async showStart(stationProg) {
    this.visible = true;
    if (this.startStationID == null) {
      throw new Error("Scenario has no starting point");
    }
    this.log("start scenario", { id: this.id });
    await this.showStation(this.startStation, false, stationProg);
    this.env.avatar.setHeadingImmediate(this.startRotation);
  }
  async showStation(station, playTransitionSound, prog) {
    this.logLeaveStation();
    this.log("show station", { id: station.transformID });
    if (this.curStationID) {
      const station2 = this.getStation(this.curStationID);
      this.resetStationAssets(station2);
    }
    prog = prog || this.env.loadingBar;
    this.curStationID = station.transformID;
    const stepoutTask = playTransitionSound ? this.env.audio.playClipThrough("footsteps") : Promise.resolve();
    const isCached = await this.isCached(station.filePath);
    this.env.loadingBar.enabled = !isCached;
    await this.env.withFade(async () => {
      this.env.skybox.rotation = station.rotation;
      const images = await this.getImage(station.filePath, prog);
      if (images.length === 6) {
        await this.env.skybox.setImages(station.filePath, images);
      } else {
        await this.env.skybox.setImage(station.filePath, images[0]);
      }
      this.moveToStation(station);
      for (const otherStation of this.stations) {
        const there = this.getTransform(otherStation.transformID);
        there.visible = otherStation.transformID === station.transformID;
      }
      const connections = this.curConnections.get(station);
      const toStations = this.getConnectedStations(station);
      for (const toStation of toStations) {
        this.prefetchConnectedStation(connections, toStation);
      }
      this.resetStationAssets(station);
      this.env.infoLabel.image.value = station.label || station.fileName;
      await all(
        this.playAudioZone(station.zone),
        stepoutTask
      );
    });
    this.env.loadingBar.enabled = false;
  }
  logLeaveStation() {
    if (this.curStationID) {
      this.log("leave station", { id: this.curStationID });
    }
  }
  moveToStation(station) {
    if (isDefined(station)) {
      const here = this.getTransform(station.transformID);
      here.getWorldPosition(this.env.stage.position);
      this.env.stage.position.y -= this.avatarHeightOffset;
    }
  }
  resetStationAssets(station) {
    const signs = this.signsByStation.get(station);
    for (const sign of signs) {
      sign.reset();
    }
    const audios = this.audiosByStation.get(station);
    for (const audio of audios) {
      audio.reset();
    }
    const videos = this.videosByStation.get(station);
    for (const video of videos) {
      video.reset();
    }
    const texts = this.textsByStation.get(station);
    for (const text2 of texts) {
      text2.reset();
    }
  }
  evict(station) {
    this.imgCache.delete(station.filePath);
    this.imgTasks.delete(station.filePath);
  }
  async prefetchConnectedStation(connections, toStation) {
    const connection = connections.get(toStation);
    connection.enabled = false;
    if (!this.imgCache.has(toStation.filePath)) {
      await this.getImage(toStation.filePath, connection);
    }
    connection.enabled = true;
  }
  getImage(path, prog) {
    if (this.imgCache.has(path)) {
      return Promise.resolve(this.imgCache.get(path));
    }
    if (this.imgTasks.has(path)) {
      return this.imgTasks.get(path);
    }
    const task = this.getImages(path, prog).then((images) => {
      this.imgCache.set(path, images);
      this.imgTasks.delete(path);
      return images;
    });
    this.imgTasks.set(path, task);
    return task;
  }
  async getImages(path, prog) {
    const { contentType } = await this.env.fetcher.head(path).exec();
    if (contentType === Image_Vendor_Google_StreetView_Pano.value) {
      const pano = await this.env.fetcher.get(path).text().then(unwrapResponse);
      const images = await this.rig.loadImages(pano, 45 /* High */, prog);
      return images;
    } else {
      const image2 = await this.env.fetcher.get(path).useCache(!this.env.DEBUG).image().then(unwrapResponse);
      return [image2];
    }
  }
  async isCached(path) {
    return await this.imgCache.has(path);
  }
  clearCache() {
    this.imgCache.clear();
  }
  getConnectedStations(fromStation) {
    return fromStation && this.connections.filter((c) => c.fromStationID === fromStation.transformID).map((c) => this.getStation(c.toStationID));
  }
  async playAudioZone(zone) {
    if (zone !== this.curZone) {
      const toPause = /* @__PURE__ */ new Map();
      const toPlay = /* @__PURE__ */ new Map();
      for (const clip of this.zonedClips.get(this.curZone)) {
        toPause.set(clip.audio, clip);
        clip.disable();
      }
      for (const clip of this.zonedClips.get(zone)) {
        if (toPause.has(clip.audio)) {
          toPause.delete(clip.audio);
        } else {
          toPlay.set(clip.audio, clip);
        }
        clip.enable();
      }
      for (const clip of toPause.values()) {
        clip.pause();
      }
      await Promise.all(Array.from(toPlay.values()).map((clip) => clip.play()));
      this.curZone = zone;
    }
  }
  pauseCurrentAudioZone() {
    const clips = this.zonedClips.get(this.curZone);
    const toPause = /* @__PURE__ */ new Map();
    for (const clip of clips) {
      toPause.set(clip.audio, clip);
      clip.disable();
    }
    for (const clip of toPause.values()) {
      clip.pause();
    }
  }
  async playCurrentAudioZone() {
    if (!this.environmentAudioMuted) {
      const clips = this.zonedClips.get(this.curZone);
      const toPlay = /* @__PURE__ */ new Map();
      for (const clip of clips) {
        clip.enable();
        toPlay.set(clip.audio, clip);
      }
      await Promise.all(Array.from(toPlay.values()).map((clip) => clip.play()));
    }
  }
  log(key, value) {
    this.dataLogger.log(key, value);
  }
  error(page, operation, exception) {
    this.dataLogger.error(page, operation, exception);
  }
};

// src/vr-apps/yarrow/Scenario.ts
var Scenario = class extends BaseScenario3 {
  constructor(env, data, dataLogger) {
    super(env, dataLogger, data);
  }
};

// src/vr-apps/yarrow/AssetScenario.ts
var BaseAssetScenario = class extends BaseAsset {
  constructor(path) {
    super(path, Application_JsonUTF8);
  }
  async getResult(fetcher, prog) {
    const [metaLoad, assetLoad] = progressSplitWeighted(prog, [1, 89]);
    return await fetcher.get(this.path).progress(metaLoad).object().then(unwrapResponse).then(async (data) => {
      const scenario = this.createScenario(data);
      await scenario.loadAssets(assetLoad);
      return scenario;
    });
  }
};
var AssetScenario = class extends BaseAssetScenario {
  constructor(env, scenarioID, dataLogger) {
    super(`/vr/scenario/${scenarioID}`);
    this.env = env;
    this.dataLogger = dataLogger;
  }
  createScenario(data) {
    return new Scenario(this.env, data, this.dataLogger);
  }
};

// src/vr-apps/yarrow/Yarrow.ts
var Yarrow = class extends Application {
  constructor(env) {
    super(env);
    this.scenarioID = null;
    this.scenario = null;
    this.env.audio.setAudioProperties(1, 4, "exponential");
    Object.seal(this);
    Object.assign(window, {
      yarrow: this
    });
  }
  async init(params) {
    let scenarioIdNumOrString = params.get("scenarioID");
    if (isString(scenarioIdNumOrString)) {
      scenarioIdNumOrString = parseFloat(scenarioIdNumOrString);
    }
    this.scenarioID = scenarioIdNumOrString;
    if (!isNumber(this.scenarioID)) {
      throw new Exception("Expected integer scenario ID");
    }
    await super.init(params);
  }
  async load(prog) {
    const scenarioAsset = new AssetScenario(this.env, this.scenarioID, this);
    await this.env.fetcher.assets(prog, scenarioAsset);
    this.scenario = scenarioAsset.result;
  }
  async showing(prog) {
    this.join(this.scenario.roomName);
    await this.scenario.showStart(prog);
  }
  hiding() {
  }
  dispose() {
    this.scenario.dispose();
    this.env.removeScope(this);
    this.scenario = null;
    this.scenarioID = null;
  }
  get visible() {
    return isDefined(this.scenario);
  }
};

// src/vr-apps/yarrow/index.ts
var yarrow_default = Yarrow;
export {
  yarrow_default as default
};
//# sourceMappingURL=index.js.map
