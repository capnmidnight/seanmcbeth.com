{
  "version": 3,
  "sources": ["../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/typeChecks.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/arrays.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/Task.ts", "../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/tags.ts", "../../../../../Yarrow.TypeScript/src/dom-apps/named-object-creator/index.ts"],
  "sourcesContent": ["function t(o: any, s: string, c: Function) {\r\n    return typeof o === s\r\n        || o instanceof c;\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return t(obj, \"function\", Function);\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return t(obj, \"string\", String);\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return t(obj, \"boolean\", Boolean);\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return t(obj, \"number\", Number);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is the special NaN value or one of the Infinities.\r\n */\r\nexport function isBadNumber(num: number): boolean {\r\n    return isNullOrUndefined(num)\r\n        || !Number.isFinite(num)\r\n        || Number.isNaN(num);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is not the special NaN value nor one of the Infinities.\r\n */\r\nexport function isGoodNumber(obj: any): obj is number {\r\n    return isNumber(obj)\r\n        && !isBadNumber(obj);\r\n}\r\n\r\nexport function isObject(obj: any): obj is object {\r\n    return isDefined(obj)\r\n        && t(obj, \"object\", Object);\r\n}\r\n\r\nexport function isPromise<T>(obj: any): obj is Promise<T> {\r\n    return obj instanceof Promise;\r\n}\r\n\r\nexport function isDate(obj: any): obj is Date {\r\n    return obj instanceof Date;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return obj instanceof Array;\r\n}\r\n\r\nexport function assertNever(x: never, msg?: string): never {\r\n    throw new Error((msg || \"Unexpected object: \") + x);\r\n}\r\n\r\nexport function isNullOrUndefined<T>(obj: T | null | undefined): obj is null | undefined {\r\n    return obj === null\r\n        || obj === undefined;\r\n}\r\n\r\nexport function isDefined<T>(obj: T | null | undefined): obj is T {\r\n    return !isNullOrUndefined(obj);\r\n}\r\n\r\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\r\n    return isFunction(obj);\r\n}\r\n\r\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\r\n    return !isEventListener(obj);\r\n}\r\n\r\nexport function isArrayBufferView(obj: any): obj is ArrayBufferView {\r\n    return obj instanceof Uint8Array\r\n        || obj instanceof Uint8ClampedArray\r\n        || obj instanceof Int8Array\r\n        || obj instanceof Uint16Array\r\n        || obj instanceof Int16Array\r\n        || obj instanceof Uint32Array\r\n        || obj instanceof Int32Array\r\n        || obj instanceof Float32Array\r\n        || obj instanceof Float64Array\r\n        || \"BigUint64Array\" in globalThis && obj instanceof globalThis[\"BigUint64Array\"]\r\n        || \"BigInt64Array\" in globalThis && obj instanceof globalThis[\"BigInt64Array\"];\r\n}\r\n\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}", "import { isBoolean, isDefined, isFunction, isNullOrUndefined } from \"@juniper-lib/tslib/typeChecks\";\r\n\r\nfunction defaultKeySelector<T>(obj: T): any {\r\n    return obj;\r\n}\r\n\r\nexport function arrayBinarySearchFind<T, V>(arr: T[], key: V, keySelector: (obj: T) => V): T | undefined {\r\n    const idx = arrayBinarySearchByKey(arr, key, keySelector);\r\n    if (Number.isInteger(idx)) {\r\n        return arr[idx - 1];\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Performs a binary search on a list to find where the item should be inserted.\r\n *\r\n * If the item is found, the returned index will be an exact integer.\r\n *\r\n * If the item is not found, the returned insertion index will be 0.5 greater than\r\n * the index at which it should be inserted.\r\n */\r\nexport function arrayBinarySearchByKey<T, V>(arr: T[], itemKey: V, keySelector: (obj: T) => V): number {\r\n    let left = 0;\r\n    let right = arr.length;\r\n    let idx = Math.floor((left + right) / 2);\r\n    let found = false;\r\n    while (left < right && idx < arr.length) {\r\n        const compareTo = arr[idx];\r\n        const compareToKey = isNullOrUndefined(compareTo)\r\n            ? null\r\n            : keySelector(compareTo);\r\n        if (isDefined(compareToKey)\r\n            && itemKey < compareToKey) {\r\n            right = idx;\r\n        }\r\n        else {\r\n            if (itemKey === compareToKey) {\r\n                found = true;\r\n            }\r\n            left = idx + 1;\r\n        }\r\n\r\n        idx = Math.floor((left + right) / 2);\r\n    }\r\n\r\n    if (!found) {\r\n        idx += 0.5;\r\n    }\r\n\r\n    return idx;\r\n}\r\n\r\n/**\r\n * Performs a binary search on a list to find where the item should be inserted.\r\n *\r\n * If the item is found, the returned index will be an exact integer.\r\n *\r\n * If the item is not found, the returned insertion index will be 0.5 greater than\r\n * the index at which it should be inserted.\r\n */\r\nexport function arrayBinarySearch<T, V>(arr: T[], item: T, keySelector?: (obj: T) => V): number {\r\n    keySelector = keySelector || defaultKeySelector;\r\n    const itemKey = keySelector(item);\r\n    return arrayBinarySearchByKey(arr, itemKey, keySelector);\r\n}\r\n\r\nexport function arrayBinaryContains<T, V>(arr: T[], item: T, keySelector?: (obj: T) => V): boolean {\r\n    return Number.isInteger(arrayBinarySearch(arr, item, keySelector));\r\n}\r\n\r\nfunction removeAtIndex<T>(arr: T[], idx: number): boolean {\r\n    if (Number.isInteger(idx)) {\r\n        arrayRemoveAt(arr, idx - 1);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function arrayBinarySearchRemoveByKey<T, V>(arr: T[], itemKey: V, keySelector: (obj: T) => V): boolean {\r\n    const idx = arrayBinarySearchByKey(arr, itemKey, keySelector);\r\n    return removeAtIndex(arr, idx);\r\n}\r\n\r\nexport function arrayBinarySearchRemove<T, V>(arr: T[], item: T, keySelector?: (obj: T) => V): boolean {\r\n    const idx = arrayBinarySearch(arr, item, keySelector);\r\n    return removeAtIndex(arr, idx);\r\n}\r\n\r\n\r\n/**\r\n * Empties out an array, returning the items that were in the array.\r\n * \r\n * @param arr the array to empty\r\n */\r\nexport function arrayClear<T>(arr: T[]) {\r\n    return arr.splice(0);\r\n}\r\n\r\n/**\r\n * Checks to see if two arrays contain the same elements\r\n * @returns -1 if the arrays match, the index of the first mismatched item if they don't.\r\n * @param arr1\r\n * @param arr2\r\n */\r\n\r\nexport function arrayCompare<T>(arr1: ReadonlyArray<T>, arr2: ReadonlyArray<T>): number {\r\n    for (let i = 0; i < arr1.length; ++i) {\r\n        if (arr1[i] !== arr2[i]) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n\r\nexport function arrayGen<T>(count: number, thunk: (i: number) => T): T[] {\r\n    return Array.from(iterableGen(count, thunk));\r\n}\r\n\r\nexport function* iterableGen<T>(count: number, thunk: (i: number) => T) {\r\n    for (let i = 0; i < count; ++i) {\r\n        yield thunk(i);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Inserts an item at the given index into an array.\r\n * @param arr\r\n * @param item\r\n * @param idx\r\n */\r\n\r\nexport function arrayInsertAt<T>(arr: T[], item: T, idx: number) {\r\n    arr.splice(idx, 0, item);\r\n}\r\n\r\n/**\r\n * Returns a random item from an array of items.\r\n *\r\n * Provides an option to consider an additional item as part of the collection\r\n * for random selection.\r\n */\r\nexport function arrayRandom<T>(arr: T[], defaultValue?: T): T | undefined {\r\n    const offset = defaultValue != null ? 1 : 0,\r\n        idx = Math.floor(Math.random() * (arr.length + offset)) - offset;\r\n    if (idx < 0) {\r\n        return defaultValue;\r\n    }\r\n    else {\r\n        return arr[idx];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Removes a given item from an array, returning true if the item was removed.\r\n */\r\nexport function arrayRemove<T>(arr: T[], value: T) {\r\n    const idx = arr.indexOf(value);\r\n    if (idx > -1) {\r\n        arrayRemoveAt(arr, idx);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function arrayFilter<T>(arr: T[], predicate: (v: T) => boolean): T | null {\r\n    for (let i = arr.length - 1; i >= 0; --i) {\r\n        if (predicate(arr[i])) {\r\n            return arrayRemoveAt(arr, i);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function arrayRemoveByKey<T, K>(arr: T[], key: K, getKey: (v: T) => K): T | null {\r\n    return arrayFilter(arr, (v) => getKey(v) === key);\r\n}\r\n\r\n/**\r\n * Removes an item at the given index from an array.\r\n */\r\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\r\n    return arr.splice(idx, 1)[0];\r\n}\r\n\r\n/**\r\n * Replaces all of the items in an array with the given items.\r\n *\r\n * This helps reduce GC pressure as you're not creating arrays\r\n * and then dropping them on the floor.\r\n * \r\n * @param arr the array to fill\r\n * @param items the items to put into the array\r\n */\r\nexport function arrayReplace<T>(arr: T[], ...items: T[]) {\r\n    arr.splice(0, arr.length, ...items);\r\n}\r\n\r\nexport function arrayCreate<T>(count: number, make: (i: number, len?: number) => T): T[]{\r\n    const arr = new Array<T>(count);\r\n    for (let i = 0; i < count; ++i) {\r\n        arr[i] = make(i, count);\r\n    }\r\n    return arr;\r\n}\r\n\r\n\r\nfunction _arrayScan<T>(forward: boolean, arr: readonly T[], tests: ((val: T) => boolean)[]): T {\r\n    const start = forward ? 0 : arr.length - 1;\r\n    const end = forward ? arr.length : -1;\r\n    const inc = forward ? 1 : -1;\r\n    for (const test of tests) {\r\n        for (let i = start; i != end; i += inc) {\r\n            const item = arr[i];\r\n            if (test(item)) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Scans through a series of filters to find an item that matches\r\n * any of the filters. The first item of the first filter that matches\r\n * will be returned.\r\n */\r\nexport function arrayScan<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;\r\nexport function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T\r\nexport function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T {\r\n    return _arrayScan(true, arr, tests);\r\n}\r\n\r\n/**\r\n * Scans through a series of filters to find an item that matches\r\n * any of the filters. The last item of the first filter that matches\r\n * will be returned.\r\n */\r\nexport function arrayScanReverse<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;\r\nexport function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T;\r\nexport function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T {\r\n    return _arrayScan(false, arr, tests);\r\n}\r\n\r\nexport function arrayShuffleInplace<T>(arr: T[]): void {\r\n    for (let i = 0; i < arr.length - 1; ++i) {\r\n        const subLength = arr.length - i;\r\n        const subIndex = Math.floor(Math.random() * subLength);\r\n        const temp = arr[i];\r\n        const j = subIndex + i;\r\n        arr[i] = arr[j];\r\n        arr[j] = temp;\r\n    }\r\n}\r\n\r\nexport function arrayShuffle<T>(arr: readonly T[]): T[] {\r\n    const output = arr.slice();\r\n    arrayShuffleInplace(output);\r\n    return output;\r\n}\r\n\r\n/**\r\n * Performs an insert operation that maintains the sort\r\n * order of the array, returning the index at which the\r\n * item was inserted.\r\n */\r\nexport function arraySortedInsert<T>(arr: T[], item: T): number;\r\nexport function arraySortedInsert<T, V>(arr: T[], item: T, keySelector?: (obj: T) => V): number;\r\nexport function arraySortedInsert<T>(arr: T[], item: T, allowDuplicates?: boolean): number;\r\nexport function arraySortedInsert<T, V>(arr: T[], item: T, keySelector?: (obj: T) => V, allowDuplicates?: boolean): number;\r\nexport function arraySortedInsert<T, V>(arr: T[], item: T, keySelector?: ((obj: T) => V) | boolean, allowDuplicates?: boolean): number {\r\n    let ks: ((obj: T) => V) | undefined;\r\n\r\n    if (isFunction(keySelector)) {\r\n        ks = keySelector;\r\n    }\r\n    else if (isBoolean(keySelector)) {\r\n        allowDuplicates = keySelector;\r\n    }\r\n\r\n    if (isNullOrUndefined(allowDuplicates)) {\r\n        allowDuplicates = true;\r\n    }\r\n\r\n    return arraySortedInsertInternal<T, V>(arr, item, ks, allowDuplicates);\r\n}\r\n\r\nfunction arraySortedInsertInternal<T, V>(arr: T[], item: T, ks: ((obj: T) => V) | undefined, allowDuplicates: boolean) {\r\n    let idx = arrayBinarySearch(arr, item, ks);\r\n    const found = (idx % 1) === 0;\r\n    idx = idx | 0;\r\n    if (!found || allowDuplicates) {\r\n        arrayInsertAt(arr, item, idx);\r\n    }\r\n\r\n    return idx;\r\n}\r\n\r\n/**\r\n * Creates a new array that is sorted by the key extracted\r\n * by the keySelector callback, not modifying the input array,\r\n * (unlike JavaScript's own Array.prototype.sort).\r\n * @param arr\r\n * @param keySelector\r\n */\r\nexport function arraySortByKey<T, V>(arr: ReadonlyArray<T>, keySelector: (obj: T) => V): T[] {\r\n    const newArr = Array.from(arr);\r\n    arraySortByKeyInPlace<T, V>(newArr, keySelector);\r\n    return newArr;\r\n}\r\n\r\n/**\r\n * Sorts an existing array by the key extracted by the keySelector\r\n * callback, without creating a new array.\r\n * @param arr\r\n * @param keySelector\r\n */\r\nexport function arraySortByKeyInPlace<T, V>(newArr: T[], keySelector: (obj: T) => V) {\r\n    newArr.sort((a, b) => {\r\n        const keyA = keySelector(a);\r\n        const keyB = keySelector(b);\r\n        if (keyA < keyB) {\r\n            return -1;\r\n        }\r\n        else if (keyA > keyB) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    });\r\n}\r\n\r\nconst numericPattern = /^(\\d+)/;\r\n/**\r\n * Creates a new array that is sorted by the key extracted\r\n * by the keySelector callback, not modifying the input array,\r\n * (unlike JavaScript's own Array.prototype.sort).\r\n *\r\n * If the values have a number at the beginning, they'll be sorted\r\n * by that number.\r\n * @param arr\r\n * @param keySelector\r\n */\r\nexport function arraySortNumericByKey<T>(arr: ReadonlyArray<T>, keySelector: (obj: T) => string): T[] {\r\n    const newArr = Array.from(arr);\r\n    newArr.sort((a, b) => {\r\n        const keyA = keySelector(a);\r\n        const keyB = keySelector(b);\r\n        const matchA = keyA.match(numericPattern);\r\n        const matchB = keyB.match(numericPattern);\r\n        if (isDefined(matchA)\r\n            && isDefined(matchB)) {\r\n            const numberA = parseFloat(matchA[1]);\r\n            const numberB = parseFloat(matchB[1]);\r\n\r\n            if (numberA < numberB) {\r\n                return -1;\r\n            }\r\n            else if (numberA > numberB) {\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        if (keyA < keyB) {\r\n            return -1;\r\n        }\r\n        else if (keyA > keyB) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    });\r\n\r\n    return newArr;\r\n}\r\n\r\nexport function arrayZip<T, V>(arr1: readonly T[], arr2: readonly T[], combine: (a: T, b: T) => V): V[] {\r\n    const len = Math.max(arr1.length, arr2.length);\r\n    const output = new Array<V>(len);\r\n    for (let i = 0; i < len; ++i) {\r\n        output[i] = combine(arr1[i], arr2[i]);\r\n    }\r\n\r\n    return output;\r\n}\r\n", "import { arrayClear } from \"@juniper-lib/collections/arrays\";\r\nimport { isDefined } from \"@juniper-lib/tslib/typeChecks\";\r\nimport { TypedEventBase } from \"./EventBase\";\r\n\r\nexport type TaskExecutionState =\r\n    | \"waiting\"\r\n    | \"running\"\r\n    | \"finished\"\r\n\r\nexport type TaskResultState =\r\n    | \"none\"\r\n    | \"resolved\"\r\n    | \"errored\";\r\n\r\n/**\r\n * A Task represents a Promise that exposes its resolve/reject functions\r\n * as methods, rather than requiring a callback being passed to its constructor.\r\n * Tasks can be used to build manually-resolved Promises with less\r\n * boilerplate of nested function blocks.\r\n **/\r\nexport class Task<ResultsT = void> implements Promise<ResultsT> {\r\n    private readonly onThens = new Array<(v: ResultsT) => any>();\r\n    private readonly onCatches = new Array<(reason?: any) => void>();\r\n\r\n    private _result: ResultsT = undefined;\r\n    private _error: any = undefined;\r\n    private _executionState: TaskExecutionState = \"waiting\";\r\n    private _resultState: TaskResultState = \"none\";\r\n\r\n    /**\r\n     * Signal success for the Task\r\n     *\r\n     * @param value - the value to store with the resolved Task.\r\n     **/\r\n    public readonly resolve: (value: ResultsT) => void;\r\n\r\n    /**\r\n     * Signal failrue for the Task\r\n     *\r\n     * @param value - the error to store with the rejected Task.\r\n     **/\r\n    public readonly reject: (reason: any) => void;\r\n\r\n\r\n    /**\r\n     * Create a new Task\r\n     *\r\n     * @param autoStart - set to false to require manually starting the Task. Useful\r\n     * for reusable tasks that run on timers.\r\n     */\r\n    constructor(private readonly autoStart = true) {\r\n        // It's very likely that we will want to use resolve/reject\r\n        // as values to pass to another function/method, so we create\r\n        // them not as methods, but as bound lambda expressions stored\r\n        // in public fields.\r\n        this.resolve = (value) => {\r\n            if (this.running) {\r\n                this._result = value;\r\n                this._resultState = \"resolved\";\r\n\r\n                for (const thenner of this.onThens) {\r\n                    thenner(value);\r\n                }\r\n\r\n                this.clear();\r\n                this._executionState = \"finished\";\r\n            }\r\n        };\r\n\r\n        this.reject = (reason) => {\r\n            if (this.running) {\r\n                this._error = reason;\r\n                this._resultState = \"errored\";\r\n\r\n                for (const catcher of this.onCatches) {\r\n                    catcher(reason);\r\n                }\r\n\r\n                this.clear();\r\n                this._executionState = \"finished\";\r\n            }\r\n        };\r\n\r\n        if (this.autoStart) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    private clear() {\r\n        arrayClear(this.onThens);\r\n        arrayClear(this.onCatches);\r\n    }\r\n\r\n    /**\r\n     * If the task was not auto-started, signal that the task is now ready to recieve\r\n     * resolutions or rejections.\r\n     **/\r\n    start() {\r\n        this._executionState = \"running\";\r\n    }\r\n\r\n    /**\r\n     * Creates a resolving callback for a static value.\r\n     * @param value\r\n     */\r\n    resolver(value: ResultsT) {\r\n        return () => this.resolve(value);\r\n    }\r\n\r\n    resolveOn<EventMapT, EventT extends keyof EventMapT = keyof EventMapT>(\r\n        target: TypedEventBase<EventMapT> | EventTarget,\r\n        resolveEvt: EventT,\r\n        value: ResultsT) {\r\n        const resolver = this.resolver(value);\r\n        target.addEventListener(resolveEvt as any, resolver);\r\n        this.finally(() =>\r\n            target.removeEventListener(resolveEvt as any, resolver));\r\n    }\r\n\r\n    /**\r\n     * Get the last result that the task had resolved to, if any is available.\r\n     *\r\n     * If the Task had been rejected, attempting to get the result will rethrow\r\n     * the error that had rejected the task.\r\n     **/\r\n    get result(): ResultsT {\r\n        if (isDefined(this.error)) {\r\n            throw this.error;\r\n        }\r\n\r\n        return this._result;\r\n    }\r\n\r\n    /**\r\n     * Get the last error that the task had been rejected by, if any.\r\n     **/\r\n    get error(): any {\r\n        return this._error;\r\n    }\r\n\r\n    /**\r\n     * Get the current state of the task.\r\n     **/\r\n    get executionState() {\r\n        return this._executionState;\r\n    }\r\n\r\n    /**\r\n     * Returns true when the Task is hasn't started yet.\r\n     **/\r\n    get waiting(): boolean {\r\n        return this.executionState === \"waiting\";\r\n    }\r\n\r\n    /**\r\n     * Returns true when the Task is waiting to be resolved or rejected.\r\n     **/\r\n    get started(): boolean {\r\n        return this.executionState !== \"waiting\";\r\n    }\r\n\r\n    /**\r\n     * Returns true after the Task has started, but before it has finished.\r\n     **/\r\n    get running(): boolean {\r\n        return this.executionState === \"running\";\r\n    }\r\n\r\n    /**\r\n     * Returns true when the Task has been resolved or rejected.\r\n     **/\r\n    get finished(): boolean {\r\n        return this.executionState === \"finished\";\r\n    }\r\n\r\n    get resultState() {\r\n        return this._resultState;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the Task had been resolved successfully.\r\n     **/\r\n    get resolved(): boolean {\r\n        return this.resultState === \"resolved\";\r\n    }\r\n\r\n    /**\r\n     * Returns true if the Task had been rejected, regardless of any\r\n     * reason being given.\r\n     **/\r\n    get errored(): boolean {\r\n        return this.resultState === \"errored\";\r\n    }\r\n\r\n    get [Symbol.toStringTag](): string {\r\n        return this.toString();\r\n    }\r\n\r\n    /**\r\n     * Calling Task.then(), Task.catch(), or Task.finally() creates a new Promise.\r\n     * This method creates that promise and links it with the task.\r\n     **/\r\n    private project(): Promise<ResultsT> {\r\n        return new Promise<ResultsT>((resolve, reject) => {\r\n            if (!this.finished) {\r\n                this.onThens.push(resolve);\r\n                this.onCatches.push(reject);\r\n            }\r\n            else if (this.errored) {\r\n                reject(this.error);\r\n            }\r\n            else {\r\n                resolve(this.result);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Attach a handler to the task that fires when the task is resolved.\r\n     * \r\n     * @param onfulfilled\r\n     * @param onrejected\r\n     */\r\n    then<TResult1 = ResultsT, TResult2 = never>(onfulfilled?: (value: ResultsT) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\r\n        return this.project().then(onfulfilled, onrejected);\r\n    }\r\n\r\n    /**\r\n     * Attach a handler that fires when the Task is rejected.\r\n     * \r\n     * @param onrejected\r\n     */\r\n    catch<TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>): Promise<ResultsT | TResult> {\r\n        return this.project().catch(onrejected);\r\n    }\r\n\r\n    /**\r\n     * Attach a handler that fires regardless of whether the Task is resolved\r\n     * or rejected.\r\n     * \r\n     * @param onfinally\r\n     */\r\n    finally(onfinally?: () => void): Promise<ResultsT> {\r\n        return this.project().finally(onfinally);\r\n    }\r\n\r\n    /**\r\n     * Resets the Task to an unsignalled state, which is useful for\r\n     * reducing GC pressure when working with lots of tasks.\r\n     **/\r\n    reset() {\r\n        this._reset(this.autoStart);\r\n    }\r\n\r\n    restart() {\r\n        this._reset(true);\r\n    }\r\n\r\n    private _reset(start: boolean) {\r\n        if (this.running) {\r\n            this.reject(\"Resetting previous invocation\");\r\n        }\r\n\r\n        this.clear();\r\n        this._result = undefined;\r\n        this._error = undefined;\r\n        this._executionState = \"waiting\";\r\n        this._resultState = \"none\";\r\n\r\n        if (start) {\r\n            this.start();\r\n        }\r\n    }\r\n}", "import { once } from \"@juniper-lib/events/once\";\r\nimport { IProgress } from \"@juniper-lib/progress/IProgress\";\r\nimport { isBoolean, isDate, isDefined, isFunction, isNumber, isObject, isString } from \"@juniper-lib/tslib/typeChecks\";\r\nimport { Attr, classList, className, htmlFor, type } from \"./attrs\";\r\nimport { margin, PropSet } from \"./css\";\r\n\r\nexport interface ErsatzElement<T extends Element = Element> {\r\n    element: T;\r\n}\r\n\r\nexport function isErsatzElement<T extends Element = Element>(obj: any): obj is ErsatzElement<T> {\r\n    if (!isObject(obj)) {\r\n        return false;\r\n    }\r\n\r\n    const elem = obj as ErsatzElement;\r\n    return elem.element instanceof Element;\r\n}\r\n\r\nexport type Elements<T extends Element = Element> = T | ErsatzElement<T>;\r\n\r\nexport function resolveElement<T extends Element = HTMLElement>(elem: Elements<T> | string): T {\r\n    if (isErsatzElement(elem)) {\r\n        return elem.element;\r\n    }\r\n    else if (isString(elem)) {\r\n        return getElement(elem);\r\n    }\r\n\r\n    return elem;\r\n}\r\n\r\nexport interface IElementAppliable<T extends Element = Element> {\r\n    applyToElement(x: Elements<T>): void;\r\n}\r\n\r\nexport function isIElementAppliable<T extends Element = Element>(obj: any): obj is IElementAppliable<T> {\r\n    return isObject(obj)\r\n        && \"applyToElement\" in obj\r\n        && isFunction((obj as any).applyToElement);\r\n}\r\n\r\nexport type ElementChild<T extends Element = Element> = Elements<T>\r\n    | IElementAppliable\r\n    | string\r\n    | number\r\n    | boolean\r\n    | Date;\r\n\r\nexport function isElementChild(obj: any): obj is ElementChild {\r\n    return obj instanceof Element\r\n        || isErsatzElement(obj)\r\n        || isIElementAppliable(obj)\r\n        || isString(obj)\r\n        || isNumber(obj)\r\n        || isBoolean(obj)\r\n        || isDate(obj);\r\n}\r\n\r\nexport function isElements(child: ElementChild): child is Elements {\r\n    return isErsatzElement(child)\r\n        || child instanceof Element;\r\n}\r\n\r\nexport interface IFocusable {\r\n    focus(): void;\r\n}\r\n\r\nexport function isFocusable(elem: any): elem is IFocusable {\r\n    return \"focus\" in elem && isFunction((elem as IFocusable).focus);\r\n}\r\n\r\nexport function elementSetDisplay<T extends HTMLElement = HTMLElement>(elem: Elements<T>, visible: boolean, visibleDisplayType: CSSGlobalValue | CSSDisplayValue = \"\"): void {\r\n    elem = resolveElement(elem);\r\n    elem.style.display = visible ? visibleDisplayType : \"none\";\r\n}\r\n\r\nexport function elementIsDisplayed<T extends HTMLElement = HTMLElement>(elem: Elements<T>): boolean {\r\n    elem = resolveElement(elem);\r\n    return elem.style.display !== \"none\";\r\n}\r\n\r\nexport function elementToggleDisplay<T extends HTMLElement = HTMLElement>(elem: Elements<T>, visibleDisplayType: CSSGlobalValue | CSSDisplayValue = \"block\"): void {\r\n    elementSetDisplay(elem, !elementIsDisplayed(elem), visibleDisplayType);\r\n}\r\n\r\nexport function elementInsertBefore(parent: Elements, newElem: Elements, refElem: Elements): void {\r\n    parent = resolveElement(parent);\r\n    newElem = resolveElement(newElem);\r\n    refElem = resolveElement(refElem);\r\n    if (parent && newElem) {\r\n        parent.insertBefore(newElem, refElem);\r\n    }\r\n}\r\n\r\nexport function elementGetIndexInParent(elem: Elements): number {\r\n    elem = resolveElement(elem);\r\n\r\n    if (elem.parentElement) {\r\n        for (let i = 0; i < elem.parentElement.childElementCount; ++i) {\r\n            if (elem.parentElement.children[i] === elem) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n\r\nexport function elementGetCustomData(elem: Elements<HTMLElement>, name: Lowercase<string>): string {\r\n    elem = resolveElement(elem);\r\n    return elem.dataset[name.toLowerCase()];\r\n}\r\n\r\nexport function elementApply(elem: Elements | string, ...children: ElementChild[]): Elements {\r\n    elem = resolveElement(elem);\r\n\r\n    for (const child of children) {\r\n        if (isDefined(child)) {\r\n            if (child instanceof Node) {\r\n                elem.append(child);\r\n            }\r\n            else if (isErsatzElement(child)) {\r\n                elem.append(resolveElement(child));\r\n            }\r\n            else if (isIElementAppliable(child)) {\r\n                child.applyToElement(elem);\r\n            }\r\n            else {\r\n                elem.append(document.createTextNode(child.toLocaleString()));\r\n            }\r\n        }\r\n    }\r\n\r\n    return elem;\r\n}\r\n\r\nexport function elementRemoveFromParent(elem: Elements | string): void {\r\n    elem = resolveElement(elem);\r\n    if (isDefined(elem)) {\r\n        elem.remove();\r\n    }\r\n}\r\n\r\nexport function elementReplace(elem: Elements, ...elems: Elements[]): Elements {\r\n    elem = resolveElement(elem);\r\n    elem.replaceWith(...elems.map(resolveElement));\r\n    return elem;\r\n}\r\n\r\nexport function elementSwap<T extends Elements>(elem: Elements, withPlaceholder: (placeholder: Elements) => T): T {\r\n    const placeholder = Div();\r\n    const e = withPlaceholder(placeholder);\r\n    elementReplace(placeholder, elementReplace(elem, e));\r\n    return e;\r\n}\r\n\r\nexport function getElement<T extends Element = HTMLElement>(selector: string): T {\r\n    return document.querySelector<T>(selector);\r\n}\r\n\r\nexport function getElements<T extends Element = HTMLElement>(selector: string): T[] {\r\n    return Array.from(document.querySelectorAll<T>(selector));\r\n}\r\n\r\nexport function getButton(selector: string) {\r\n    return getElement<HTMLButtonElement>(selector);\r\n}\r\n\r\nexport function getButtons(selector: string) {\r\n    return getElements<HTMLButtonElement>(selector);\r\n}\r\n\r\nexport function getInput(selector: string) {\r\n    return getElement<HTMLInputElement>(selector);\r\n}\r\n\r\nexport function getDataList(selector: string) {\r\n    return getElement<HTMLDataListElement>(selector);\r\n}\r\n\r\nexport function getInputs(selector: string) {\r\n    return getElements<HTMLInputElement>(selector);\r\n}\r\n\r\nexport function getSelect(selector: string) {\r\n    return getElement<HTMLSelectElement>(selector);\r\n}\r\n\r\nexport function getCanvas(selector: string) {\r\n    return getElement<HTMLCanvasElement>(selector);\r\n}\r\n\r\n/**\r\n * Creates an HTML element for a given tag name.\r\n * \r\n * Boolean attributes that you want to default to true can be passed\r\n * as just the attribute creating function, \r\n *   e.g. `Audio(autoPlay)` vs `Audio(autoPlay(true))`\r\n * @param name - the name of the tag\r\n * @param rest - optional attributes, child elements, and text\r\n * @returns\r\n */\r\nexport function tag<K extends keyof HTMLElementTagNameMap>(name: K, ...rest: ElementChild[]): HTMLElementTagNameMap[K] {\r\n    let elem: HTMLElementTagNameMap[K] = null;\r\n\r\n    for (const attr of rest) {\r\n        if (attr instanceof Attr && attr.key === \"id\") {\r\n            elem = document.getElementById(attr.value) as HTMLElementTagNameMap[K];\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (elem == null) {\r\n        elem = document.createElement(name);\r\n    }\r\n\r\n    elementApply(elem, ...rest);\r\n\r\n    return elem;\r\n}\r\n\r\nexport interface IDisableable {\r\n    disabled: boolean;\r\n}\r\n\r\nexport function isDisableable(obj: any): obj is IDisableable {\r\n    return isObject(obj)\r\n        && \"disabled\" in obj\r\n        && isBoolean(obj.disabled);\r\n}\r\n\r\n/**\r\n * Empty an element of all children. This is faster than setting `innerHTML = \"\"`.\r\n */\r\nexport function elementClearChildren(elem: Elements) {\r\n    elem = resolveElement(elem);\r\n    while (elem.lastChild) {\r\n        elem.lastChild.remove();\r\n    }\r\n}\r\n\r\nexport function elementSetText(elem: Elements<HTMLElement>, text: string): void {\r\n    elem = resolveElement(elem);\r\n    elementClearChildren(elem);\r\n    elem.append(TextNode(text));\r\n}\r\n\r\nexport function elementGetText(elem: Elements<HTMLElement>): string {\r\n    elem = resolveElement(elem);\r\n    return elem.innerText;\r\n}\r\n\r\nexport function elementSetTitle(elem: Elements<HTMLElement>, text: string): void {\r\n    elem = resolveElement(elem);\r\n    elem.title = text;\r\n}\r\n\r\nexport function elementSetClass(elem: Elements, enabled: boolean, className: string) {\r\n    elem = resolveElement(elem);\r\n    const canEnable = isDefined(className);\r\n    const hasEnabled = canEnable && elem.classList.contains(className);\r\n\r\n    if (canEnable && hasEnabled !== enabled) {\r\n        elem.classList.toggle(className);\r\n    }\r\n}\r\n\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, enabled: boolean, label: string, title: string) {\r\n    button = resolveElement(button);\r\n    button.disabled = !enabled;\r\n    elementSetText(button, label);\r\n    elementSetTitle(button, title);\r\n}\r\n\r\n\r\nasync function mediaElementCan(type: \"canplay\" | \"canplaythrough\", elem: HTMLMediaElement, prog?: IProgress): Promise<boolean> {\r\n    if (isDefined(prog)) {\r\n        prog.start();\r\n    }\r\n\r\n    const expectedState = type === \"canplay\"\r\n        ? elem.HAVE_CURRENT_DATA\r\n        : elem.HAVE_ENOUGH_DATA;\r\n\r\n    if (elem.readyState >= expectedState) {\r\n        return true;\r\n    }\r\n\r\n    try {\r\n        await once<HTMLMediaElementEventMap>(elem, type, \"error\");\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        console.warn(elem.error, err);\r\n        return false;\r\n    }\r\n    finally {\r\n        if (isDefined(prog)) {\r\n            prog.end();\r\n        }\r\n    }\r\n}\r\n\r\nexport function mediaElementCanPlay(elem: HTMLMediaElement, prog?: IProgress): Promise<boolean> {\r\n    return mediaElementCan(\"canplay\", elem, prog);\r\n}\r\n\r\nexport function mediaElementCanPlayThrough(elem: HTMLMediaElement, prog?: IProgress): Promise<boolean> {\r\n    return mediaElementCan(\"canplaythrough\", elem, prog);\r\n}\r\n\r\nexport function A(...rest: ElementChild[]): HTMLAnchorElement { return tag(\"a\", ...rest); }\r\nexport function Abbr(...rest: ElementChild[]): HTMLElement { return tag(\"abbr\", ...rest); }\r\nexport function Address(...rest: ElementChild[]): HTMLElement { return tag(\"address\", ...rest); }\r\nexport function Area(...rest: ElementChild[]): HTMLAreaElement { return tag(\"area\", ...rest); }\r\nexport function Article(...rest: ElementChild[]): HTMLElement { return tag(\"article\", ...rest); }\r\nexport function Aside(...rest: ElementChild[]): HTMLElement { return tag(\"aside\", ...rest); }\r\nexport function Audio(...rest: ElementChild[]): HTMLAudioElement { return tag(\"audio\", ...rest); }\r\nexport function B(...rest: ElementChild[]): HTMLElement { return tag(\"b\", ...rest); }\r\nexport function Base(...rest: ElementChild[]): HTMLBaseElement { return tag(\"base\", ...rest); }\r\nexport function BDI(...rest: ElementChild[]): HTMLElement { return tag(\"bdi\", ...rest); }\r\nexport function BDO(...rest: ElementChild[]): HTMLElement { return tag(\"bdo\", ...rest); }\r\nexport function BlockQuote(...rest: ElementChild[]): HTMLQuoteElement { return tag(\"blockquote\", ...rest); }\r\nexport function Body(...rest: ElementChild[]): HTMLBodyElement { return tag(\"body\", ...rest); }\r\nexport function BR(): HTMLBRElement { return tag(\"br\"); }\r\nexport function ButtonRaw(...rest: ElementChild[]): HTMLButtonElement { return tag(\"button\", ...rest); }\r\nexport function Button(...rest: ElementChild[]): HTMLButtonElement { return ButtonRaw(...rest, type(\"button\")); }\r\nexport function ButtonSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\")); }\r\nexport function ButtonPrimary(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-primary\")); }\r\nexport function ButtonPrimaryOutline(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-outline-primary\")); }\r\nexport function ButtonPrimarySmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\", \"btn-primary\")); }\r\nexport function ButtonPrimaryOutlineSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\", \"btn-outline-primary\")); }\r\nexport function ButtonSecondary(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-secondary\")); }\r\nexport function ButtonSecondaryOutline(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-outline-secondary\")); }\r\nexport function ButtonSecondarySmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\", \"btn-secondary\")); }\r\nexport function ButtonSecondaryOutlineSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\", \"btn-outline-secondary\")); }\r\nexport function ButtonDanger(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-danger\")); }\r\nexport function ButtonDangerOutline(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-outline-danger\")); }\r\nexport function ButtonDangerSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\", \"btn-danger\")); }\r\nexport function ButtonDangerOutlineSmalle(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, classList(\"btn\", \"btn-sm\", \"btn-outline-danger\")); }\r\nexport function ButtonSubmit(...rest: ElementChild[]): HTMLButtonElement { return ButtonRaw(...rest, type(\"submit\")); }\r\nexport function ButtonReset(...rest: ElementChild[]): HTMLButtonElement { return ButtonRaw(...rest, type(\"reset\")); }\r\nexport function Canvas(...rest: ElementChild[]): HTMLCanvasElement { return tag(\"canvas\", ...rest); }\r\nexport function Caption(...rest: ElementChild[]): HTMLTableCaptionElement { return tag(\"caption\", ...rest); }\r\nexport function Cite(...rest: ElementChild[]): HTMLElement { return tag(\"cite\", ...rest); }\r\nexport function Code(...rest: ElementChild[]): HTMLElement { return tag(\"code\", ...rest); }\r\nexport function Col(...rest: ElementChild[]): HTMLTableColElement { return tag(\"col\", ...rest); }\r\nexport function ColGroup(...rest: ElementChild[]): HTMLTableColElement { return tag(\"colgroup\", ...rest); }\r\nexport function Data(...rest: ElementChild[]): HTMLDataElement { return tag(\"data\", ...rest); }\r\nexport function DataList(...rest: ElementChild[]): HTMLDataListElement { return tag(\"datalist\", ...rest); }\r\nexport function DD(...rest: ElementChild[]): HTMLElement { return tag(\"dd\", ...rest); }\r\nexport function Del(...rest: ElementChild[]): HTMLModElement { return tag(\"del\", ...rest); }\r\nexport function Details(...rest: ElementChild[]): HTMLDetailsElement { return tag(\"details\", ...rest); }\r\nexport function DFN(...rest: ElementChild[]): HTMLElement { return tag(\"dfn\", ...rest); }\r\nexport function Dialog(...rest: ElementChild[]): HTMLDialogElement { return tag(\"dialog\", ...rest); }\r\nexport function Div(...rest: ElementChild[]): HTMLDivElement { return tag(\"div\", ...rest); }\r\nexport function DL(...rest: ElementChild[]): HTMLDListElement { return tag(\"dl\", ...rest); }\r\nexport function DT(...rest: ElementChild[]): HTMLElement { return tag(\"dt\", ...rest); }\r\nexport function Em(...rest: ElementChild[]): HTMLElement { return tag(\"em\", ...rest); }\r\nexport function Embed(...rest: ElementChild[]): HTMLEmbedElement { return tag(\"embed\", ...rest); }\r\nexport function FieldSet(...rest: ElementChild[]): HTMLFieldSetElement { return tag(\"fieldset\", ...rest); }\r\nexport function FigCaption(...rest: ElementChild[]): HTMLElement { return tag(\"figcaption\", ...rest); }\r\nexport function Figure(...rest: ElementChild[]): HTMLElement { return tag(\"figure\", ...rest); }\r\nexport function Footer(...rest: ElementChild[]): HTMLElement { return tag(\"footer\", ...rest); }\r\nexport function Form(...rest: ElementChild[]): HTMLFormElement { return tag(\"form\", ...rest); }\r\nexport function H1(...rest: ElementChild[]): HTMLHeadingElement { return tag(\"h1\", ...rest); }\r\nexport function H2(...rest: ElementChild[]): HTMLHeadingElement { return tag(\"h2\", ...rest); }\r\nexport function H3(...rest: ElementChild[]): HTMLHeadingElement { return tag(\"h3\", ...rest); }\r\nexport function H4(...rest: ElementChild[]): HTMLHeadingElement { return tag(\"h4\", ...rest); }\r\nexport function H5(...rest: ElementChild[]): HTMLHeadingElement { return tag(\"h5\", ...rest); }\r\nexport function H6(...rest: ElementChild[]): HTMLHeadingElement { return tag(\"h6\", ...rest); }\r\nexport function HR(...rest: ElementChild[]): HTMLHRElement { return tag(\"hr\", ...rest); }\r\nexport function Head(...rest: ElementChild[]): HTMLHeadElement { return tag(\"head\", ...rest); }\r\nexport function Header(...rest: ElementChild[]): HTMLElement { return tag(\"header\", ...rest); }\r\nexport function HGroup(...rest: ElementChild[]): HTMLElement { return tag(\"hgroup\", ...rest); }\r\nexport function HTML(...rest: ElementChild[]): HTMLElement { return tag(\"html\", ...rest); }\r\nexport function I(...rest: ElementChild[]): HTMLElement { return tag(\"i\", ...rest); }\r\nexport function FAIcon(iconName: string, ...rest: ElementChild[]): HTMLElement { return I(className(`fa fa-${iconName}`), ...rest); }\r\nexport function IFrame(...rest: ElementChild[]): HTMLIFrameElement { return tag(\"iframe\", ...rest); }\r\nexport function Img(...rest: ElementChild[]): HTMLImageElement { return tag(\"img\", ...rest); }\r\nexport function Input(...rest: ElementChild[]): HTMLInputElement { return tag(\"input\", ...rest); }\r\nexport function Ins(...rest: ElementChild[]): HTMLModElement { return tag(\"ins\", ...rest); }\r\nexport function KBD(...rest: ElementChild[]): HTMLElement { return tag(\"kbd\", ...rest); }\r\nexport function Label(...rest: ElementChild[]): HTMLLabelElement { return tag(\"label\", ...rest); }\r\nexport function PreLabeled<T extends Elements>(id: string, label: ElementChild, input: T): [HTMLLabelElement, T] {\r\n    resolveElement(input).id = id;\r\n    return [\r\n        Label(htmlFor(id), label),\r\n        input\r\n    ];\r\n}\r\nexport function PostLabeled<T extends Elements>(id: string, label: ElementChild, input: T): [T, HTMLLabelElement] {\r\n    resolveElement(input).id = id;\r\n    return [\r\n        input,\r\n        Label(htmlFor(id), label)\r\n    ];\r\n}\r\nexport function Legend(...rest: ElementChild[]) { return tag(\"legend\", ...rest); }\r\nexport function LI(...rest: ElementChild[]) { return tag(\"li\", ...rest); }\r\nexport function Link(...rest: ElementChild[]) { return tag(\"link\", ...rest); }\r\nexport function Main(...rest: ElementChild[]) { return tag(\"main\", ...rest); }\r\nexport function HtmlMap(...rest: ElementChild[]) { return tag(\"map\", ...rest); }\r\nexport function Mark(...rest: ElementChild[]) { return tag(\"mark\", ...rest); }\r\nexport function Menu(...rest: ElementChild[]) { return tag(\"menu\", ...rest); }\r\nexport function Meta(...rest: ElementChild[]) { return tag(\"meta\", ...rest); }\r\nexport function Meter(...rest: ElementChild[]) { return tag(\"meter\", ...rest); }\r\nexport function Nav(...rest: ElementChild[]) { return tag(\"nav\", ...rest); }\r\nexport function NoScript(...rest: ElementChild[]) { return tag(\"noscript\", ...rest); }\r\nexport function HtmlObject(...rest: ElementChild[]) { return tag(\"object\", ...rest); }\r\nexport function OL(...rest: ElementChild[]) { return tag(\"ol\", ...rest); }\r\nexport function OptGroup(...rest: ElementChild[]) { return tag(\"optgroup\", ...rest); }\r\nexport function Option(...rest: ElementChild[]) { return tag(\"option\", ...rest); }\r\nexport function Output(...rest: ElementChild[]) { return tag(\"output\", ...rest); }\r\nexport function P(...rest: ElementChild[]) { return tag(\"p\", ...rest); }\r\nexport function Picture(...rest: ElementChild[]) { return tag(\"picture\", ...rest); }\r\nexport function Pre(...rest: ElementChild[]) { return tag(\"pre\", ...rest); }\r\nexport function Progress(...rest: ElementChild[]) { return tag(\"progress\", ...rest); }\r\nexport function Q(...rest: ElementChild[]) { return tag(\"q\", ...rest); }\r\nexport function RP(...rest: ElementChild[]) { return tag(\"rp\", ...rest); }\r\nexport function RT(...rest: ElementChild[]) { return tag(\"rt\", ...rest); }\r\nexport function Ruby(...rest: ElementChild[]) { return tag(\"ruby\", ...rest); }\r\nexport function S(...rest: ElementChild[]) { return tag(\"s\", ...rest); }\r\nexport function Samp(...rest: ElementChild[]) { return tag(\"samp\", ...rest); }\r\nexport function Script(...rest: ElementChild[]) { return tag(\"script\", ...rest); }\r\nexport function Section(...rest: ElementChild[]) { return tag(\"section\", ...rest); }\r\nexport function Select(...rest: ElementChild[]) { return tag(\"select\", ...rest); }\r\nexport function Slot(...rest: ElementChild[]) { return tag(\"slot\", ...rest); }\r\nexport function Small(...rest: ElementChild[]) { return tag(\"small\", ...rest); }\r\nexport function Source(...rest: ElementChild[]) { return tag(\"source\", ...rest); }\r\nexport function Span(...rest: ElementChild[]) { return tag(\"span\", ...rest); }\r\nexport function Strong(...rest: ElementChild[]) { return tag(\"strong\", ...rest); }\r\nexport function Sub(...rest: ElementChild[]) { return tag(\"sub\", ...rest); }\r\nexport function Summary(...rest: ElementChild[]) { return tag(\"summary\", ...rest); }\r\nexport function Sup(...rest: ElementChild[]) { return tag(\"sup\", ...rest); }\r\nexport function Table(...rest: ElementChild[]) { return tag(\"table\", ...rest); }\r\nexport function TBody(...rest: ElementChild[]) { return tag(\"tbody\", ...rest); }\r\nexport function TD(...rest: ElementChild[]) { return tag(\"td\", ...rest); }\r\nexport function Template(...rest: ElementChild[]) { return tag(\"template\", ...rest); }\r\nexport function TextArea(...rest: ElementChild[]) { return tag(\"textarea\", ...rest); }\r\nexport function TFoot(...rest: ElementChild[]) { return tag(\"tfoot\", ...rest); }\r\nexport function TH(...rest: ElementChild[]) { return tag(\"th\", ...rest); }\r\nexport function THead(...rest: ElementChild[]) { return tag(\"thead\", ...rest); }\r\nexport function Time(...rest: ElementChild[]) { return tag(\"time\", ...rest); }\r\nexport function Title(...rest: ElementChild[]) { return tag(\"title\", ...rest); }\r\nexport function TR(...rest: ElementChild[]) { return tag(\"tr\", ...rest); }\r\nexport function Track(...rest: ElementChild[]) { return tag(\"track\", ...rest); }\r\nexport function U(...rest: ElementChild[]) { return tag(\"u\", ...rest); }\r\nexport function UL(...rest: ElementChild[]) { return tag(\"ul\", ...rest); }\r\nexport function Var(...rest: ElementChild[]) { return tag(\"var\", ...rest); }\r\nexport function Video(...rest: ElementChild[]) { return tag(\"video\", ...rest); }\r\nexport function WBR() { return tag(\"wbr\"); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a button.\r\n */\r\nexport function InputButton(...rest: ElementChild[]) { return Input(type(\"button\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a checkbox.\r\n */\r\nexport function InputCheckbox(...rest: ElementChild[]) { return Input(type(\"checkbox\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a color picker.\r\n */\r\nexport function InputColor(...rest: ElementChild[]) { return Input(type(\"color\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a date picker.\r\n */\r\nexport function InputDate(...rest: ElementChild[]) { return Input(type(\"date\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a local date-time picker.\r\n */\r\nexport function InputDateTime(...rest: ElementChild[]) { return Input(type(\"datetime-local\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is an email entry field.\r\n */\r\nexport function InputEmail(...rest: ElementChild[]) { return Input(type(\"email\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a file picker.\r\n */\r\nexport function InputFile(...rest: ElementChild[]) { return Input(type(\"file\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a hidden field.\r\n */\r\nexport function InputHidden(...rest: ElementChild[]) { return Input(type(\"hidden\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a graphical submit button.\r\n */\r\nexport function InputImage(...rest: ElementChild[]) { return Input(type(\"image\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a month picker.\r\n */\r\nexport function InputMonth(...rest: ElementChild[]) { return Input(type(\"month\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a month picker.\r\n */\r\nexport function InputNumber(...rest: ElementChild[]) { return Input(type(\"number\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a password entry field.\r\n */\r\nexport function InputPassword(...rest: ElementChild[]) { return Input(type(\"password\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a radio button.\r\n */\r\nexport function InputRadio(...rest: ElementChild[]) { return Input(type(\"radio\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a range selector.\r\n */\r\nexport function InputRange(...rest: ElementChild[]) { return Input(type(\"range\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a form reset button.\r\n */\r\nexport function InputReset(...rest: ElementChild[]) { return Input(type(\"reset\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a search entry field.\r\n */\r\nexport function InputSearch(...rest: ElementChild[]) { return Input(type(\"search\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a submit button.\r\n */\r\nexport function InputSubmit(...rest: ElementChild[]) { return Input(type(\"submit\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a telephone number entry field.\r\n */\r\nexport function InputTelephone(...rest: ElementChild[]) { return Input(type(\"tel\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a text entry field.\r\n */\r\nexport function InputText(...rest: ElementChild[]) { return Input(type(\"text\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a time picker.\r\n */\r\nexport function InputTime(...rest: ElementChild[]) { return Input(type(\"time\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a URL entry field.\r\n */\r\nexport function InputURL(...rest: ElementChild[]) { return Input(type(\"url\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a week picker.\r\n */\r\nexport function InputWeek(...rest: ElementChild[]) { return Input(type(\"week\"), ...rest); }\r\n\r\n/**\r\n * Creates a text node out of the give input.\r\n */\r\nexport function TextNode(txt: any) {\r\n    return document.createTextNode(txt);\r\n}\r\n\r\n/**\r\n * Creates a Div element with margin: auto.\r\n */\r\nexport function Run(...rest: ElementChild[]) {\r\n    return Div(\r\n        margin(\"auto\"),\r\n        ...rest);\r\n}\r\n\r\nexport function Style(...props: PropSet[]) {\r\n    const elem = document.createElement(\"style\");\r\n    document.head.append(elem);\r\n\r\n    for (let prop of props) {\r\n        prop.applyToSheet(elem.sheet);\r\n    }\r\n}", "import { elementSetClass, getButton, getInput } from \"@juniper-lib/dom/tags\";\r\n\r\nconst roleNameInput = getInput(\"#newName\");\r\nconst submitButton = getButton(\"#submitNewNameButton\");\r\n\r\nroleNameInput.addEventListener(\"input\", () => {\r\n    const hasValue = roleNameInput.value.length > 0\r\n    submitButton.disabled = !hasValue;\r\n    elementSetClass(submitButton, hasValue, \"btn-danger\");\r\n    elementSetClass(submitButton, !hasValue, \"btn-outline-danger\");\r\n});"],
  "mappings": "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",
  "names": ["className"]
}
