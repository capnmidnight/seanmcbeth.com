var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var __privateWrapper = (obj, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj, member, value2, setter);
  },
  get _() {
    return __privateGet(obj, member, getter);
  }
});
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
  }
});

// (disabled):canvas
var require_canvas = __commonJS({
  "(disabled):canvas"() {
  }
});

// (disabled):zlib
var require_zlib = __commonJS({
  "(disabled):zlib"() {
  }
});

// (disabled):http
var require_http = __commonJS({
  "(disabled):http"() {
  }
});

// (disabled):https
var require_https = __commonJS({
  "(disabled):https"() {
  }
});

// (disabled):url
var require_url = __commonJS({
  "(disabled):url"() {
  }
});

// ../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.arrayByteLength = arrayByteLength;
              exports2.arraysToBytes = arraysToBytes;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createPromiseCapability = createPromiseCapability;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.escapeString = escapeString;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer2;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isAscii = isAscii;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF16BEString = stringToUTF16BEString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              __w_pdfjs_require__2(2);
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                FREETEXT_SIZE: 1,
                FREETEXT_COLOR: 2,
                FREETEXT_OPACITY: 3,
                INK_COLOR: 11,
                INK_THICKNESS: 12,
                INK_OPACITY: 13
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationStateModelType = {
                MARKED: "Marked",
                REVIEW: "Review"
              };
              exports2.AnnotationStateModelType = AnnotationStateModelType;
              const AnnotationMarkedState = {
                MARKED: "Marked",
                UNMARKED: "Unmarked"
              };
              exports2.AnnotationMarkedState = AnnotationMarkedState;
              const AnnotationReviewState = {
                ACCEPTED: "Accepted",
                REJECTED: "Rejected",
                CANCELLED: "Cancelled",
                COMPLETED: "Completed",
                NONE: "None"
              };
              exports2.AnnotationReviewState = AnnotationReviewState;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const StreamType = {
                UNKNOWN: "UNKNOWN",
                FLATE: "FLATE",
                LZW: "LZW",
                DCT: "DCT",
                JPX: "JPX",
                JBIG: "JBIG",
                A85: "A85",
                AHX: "AHX",
                CCF: "CCF",
                RLX: "RLX"
              };
              exports2.StreamType = StreamType;
              const FontType = {
                UNKNOWN: "UNKNOWN",
                TYPE1: "TYPE1",
                TYPE1STANDARD: "TYPE1STANDARD",
                TYPE1C: "TYPE1C",
                CIDFONTTYPE0: "CIDFONTTYPE0",
                CIDFONTTYPE0C: "CIDFONTTYPE0C",
                TRUETYPE: "TRUETYPE",
                CIDFONTTYPE2: "CIDFONTTYPE2",
                TYPE3: "TYPE3",
                OPENTYPE: "OPENTYPE",
                TYPE0: "TYPE0",
                MMTYPE1: "MMTYPE1"
              };
              exports2.FontType = FontType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1,
                STREAM: 2
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const UNSUPPORTED_FEATURES = {
                unknown: "unknown",
                forms: "forms",
                javaScript: "javaScript",
                signatures: "signatures",
                smask: "smask",
                shadingPattern: "shadingPattern",
                font: "font",
                errorTilingPattern: "errorTilingPattern",
                errorExtGState: "errorExtGState",
                errorXObject: "errorXObject",
                errorFontLoadType3: "errorFontLoadType3",
                errorFontState: "errorFontState",
                errorFontMissing: "errorFontMissing",
                errorFontTranslate: "errorFontTranslate",
                errorColorSpace: "errorColorSpace",
                errorOperatorList: "errorOperatorList",
                errorFontToUnicode: "errorFontToUnicode",
                errorFontLoadNative: "errorFontLoadNative",
                errorFontBuildPath: "errorFontBuildPath",
                errorFontGetPath: "errorFontGetPath",
                errorMarkedContent: "errorMarkedContent",
                errorContentSubStream: "errorContentSubStream"
              };
              exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url2) {
                if (!url2) {
                  return false;
                }
                switch (url2.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url2, baseUrl = null, options = null) {
                if (!url2) {
                  return null;
                }
                try {
                  if (options && typeof url2 === "string") {
                    if (options.addDefaultProtocol && url2.startsWith("www.")) {
                      const dots = url2.match(/\./g);
                      if (dots && dots.length >= 2) {
                        url2 = `http://${url2}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url2 = stringToUTF8String(url2);
                      } catch (ex) {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url2, baseUrl) : new URL(url2);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch (ex) {
                }
                return null;
              }
              function shadow(obj, prop, value2) {
                Object.defineProperty(obj, prop, {
                  value: value2,
                  enumerable: true,
                  configurable: true,
                  writable: false
                });
                return value2;
              }
              const BaseException = function BaseExceptionClosure() {
                function BaseException2(message2, name) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message2;
                  this.name = name;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException;
              class UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException;
              class InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException;
              class MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException;
              class UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              class FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError;
              class AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || bytes === null || bytes.length === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length4 = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length4 < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length4; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length4);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str3) {
                if (typeof str3 !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length4 = str3.length;
                const bytes = new Uint8Array(length4);
                for (let i = 0; i < length4; ++i) {
                  bytes[i] = str3.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function arrayByteLength(arr) {
                if (arr.length !== void 0) {
                  return arr.length;
                }
                if (arr.byteLength !== void 0) {
                  return arr.byteLength;
                }
                unreachable("Invalid argument for arrayByteLength");
              }
              function arraysToBytes(arr) {
                const length4 = arr.length;
                if (length4 === 1 && arr[0] instanceof Uint8Array) {
                  return arr[0];
                }
                let resultLength = 0;
                for (let i = 0; i < length4; i++) {
                  resultLength += arrayByteLength(arr[i]);
                }
                let pos = 0;
                const data = new Uint8Array(resultLength);
                for (let i = 0; i < length4; i++) {
                  let item = arr[i];
                  if (!(item instanceof Uint8Array)) {
                    if (typeof item === "string") {
                      item = stringToBytes(item);
                    } else {
                      item = new Uint8Array(item);
                    }
                  }
                  const itemLength = item.byteLength;
                  data.set(item, pos);
                  pos += itemLength;
                }
                return data;
              }
              function string32(value2) {
                return String.fromCharCode(value2 >> 24 & 255, value2 >> 16 & 255, value2 >> 8 & 255, value2 & 255);
              }
              function objectSize(obj) {
                return Object.keys(obj).length;
              }
              function objectFromMap(map) {
                const obj = /* @__PURE__ */ Object.create(null);
                for (const [key, value2] of map) {
                  obj[key] = value2;
                }
                return obj;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch (e) {
                  return false;
                }
              }
              class FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
              }
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n) => n.toString(16).padStart(2, "0"));
              class Util {
                static makeHexColor(r, g, b) {
                  return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform, minMax) {
                  let temp;
                  if (transform[0]) {
                    if (transform[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[0];
                    minMax[1] *= transform[0];
                    if (transform[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[3];
                    minMax[3] *= transform[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform[1];
                    minMax[3] *= transform[1];
                    if (transform[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform[2];
                    minMax[1] *= transform[2];
                  }
                  minMax[0] += transform[4];
                  minMax[1] += transform[4];
                  minMax[2] += transform[5];
                  minMax[3] += transform[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r, m) {
                  const p1 = Util.applyTransform(r, m);
                  const p2 = Util.applyTransform(r.slice(2, 4), m);
                  const p3 = Util.applyTransform([r[0], r[3]], m);
                  const p4 = Util.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static apply3dTransform(m, v) {
                  return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t2, t1, t22, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t2 = -c / b;
                      if (0 < t2 && t2 < 1) {
                        tvalues.push(t2);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t22 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t22 && t22 < 1) {
                      tvalues.push(t22);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t2 = tvalues[j];
                    mt = 1 - t2;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t2 * x1 + 3 * mt * t2 * t2 * x2 + t2 * t2 * t2 * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t2 * y1 + 3 * mt * t2 * t2 * y2 + t2 * t2 * t2 * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str3) {
                if (str3[0] >= "\xEF") {
                  let encoding;
                  if (str3[0] === "\xFE" && str3[1] === "\xFF") {
                    encoding = "utf-16be";
                  } else if (str3[0] === "\xFF" && str3[1] === "\xFE") {
                    encoding = "utf-16le";
                  } else if (str3[0] === "\xEF" && str3[1] === "\xBB" && str3[2] === "\xBF") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str3);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str3.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str3.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str3.charAt(i));
                }
                return strBuf.join("");
              }
              function escapeString(str3) {
                return str3.replace(/([()\\\n\r])/g, (match) => {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return `\\${match}`;
                });
              }
              function isAscii(str3) {
                return /^[\x00-\x7F]*$/.test(str3);
              }
              function stringToUTF16BEString(str3) {
                const buf = ["\xFE\xFF"];
                for (let i = 0, ii = str3.length; i < ii; i++) {
                  const char = str3.charCodeAt(i);
                  buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                }
                return buf.join("");
              }
              function stringToUTF8String(str3) {
                return decodeURIComponent(escape(str3));
              }
              function utf8StringToString(str3) {
                return unescape(encodeURIComponent(str3));
              }
              function isArrayBuffer2(v) {
                return typeof v === "object" && v !== null && v.byteLength !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate(date = /* @__PURE__ */ new Date()) {
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              function createPromiseCapability() {
                const capability = /* @__PURE__ */ Object.create(null);
                let isSettled = false;
                Object.defineProperty(capability, "settled", {
                  get() {
                    return isSettled;
                  }
                });
                capability.promise = new Promise(function(resolve, reject) {
                  capability.resolve = function(data) {
                    isSettled = true;
                    resolve(data);
                  };
                  capability.reject = function(reason) {
                    isSettled = true;
                    reject(reason);
                  };
                });
                return capability;
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var _is_node2 = __w_pdfjs_require__2(3);
              ;
            },
            /* 3 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            /* 4 */
            /***/
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              var _docId, _workerPorts, _docStats, _pageCache, _pagePromises, _metadataPromise, _objs, _ensureObj, ensureObj_fn, _internalRenderTask, _canvasInUse;
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              exports.getDocument = getDocument;
              exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
              exports.version = void 0;
              var _util = __w_pdfjs_require__(1);
              var _annotation_storage = __w_pdfjs_require__(5);
              var _display_utils = __w_pdfjs_require__(8);
              var _font_loader = __w_pdfjs_require__(11);
              var _canvas = __w_pdfjs_require__(12);
              var _worker_options = __w_pdfjs_require__(15);
              var _is_node = __w_pdfjs_require__(3);
              var _message_handler = __w_pdfjs_require__(16);
              var _metadata = __w_pdfjs_require__(17);
              var _optional_content_config = __w_pdfjs_require__(18);
              var _transport_stream = __w_pdfjs_require__(19);
              var _xfa_text = __w_pdfjs_require__(20);
              const DEFAULT_RANGE_CHUNK_SIZE = 65536;
              const RENDERING_CANCELLED_TIMEOUT = 100;
              let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              if (_is_node.isNodeJS) {
                const {
                  NodeCanvasFactory,
                  NodeCMapReaderFactory,
                  NodeStandardFontDataFactory
                } = __w_pdfjs_require__(21);
                exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
              }
              let createPDFNetworkStream;
              function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                createPDFNetworkStream = pdfNetworkStreamFactory;
              }
              function getDocument(src2) {
                const task = new PDFDocumentLoadingTask();
                let source;
                if (typeof src2 === "string" || src2 instanceof URL) {
                  source = {
                    url: src2
                  };
                } else if ((0, _util.isArrayBuffer)(src2)) {
                  source = {
                    data: src2
                  };
                } else if (src2 instanceof PDFDataRangeTransport) {
                  source = {
                    range: src2
                  };
                } else {
                  if (typeof src2 !== "object") {
                    throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
                  }
                  if (!src2.url && !src2.data && !src2.range) {
                    throw new Error("Invalid parameter object: need either .data, .range or .url");
                  }
                  source = src2;
                }
                const params = /* @__PURE__ */ Object.create(null);
                let rangeTransport = null, worker2 = null;
                for (const key in source) {
                  const value2 = source[key];
                  switch (key) {
                    case "url":
                      if (typeof window !== "undefined") {
                        try {
                          params[key] = new URL(value2, window.location).href;
                          continue;
                        } catch (ex) {
                          (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                        }
                      } else if (typeof value2 === "string" || value2 instanceof URL) {
                        params[key] = value2.toString();
                        continue;
                      }
                      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                    case "range":
                      rangeTransport = value2;
                      continue;
                    case "worker":
                      worker2 = value2;
                      continue;
                    case "data":
                      if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value2 instanceof Buffer) {
                        params[key] = new Uint8Array(value2);
                      } else if (value2 instanceof Uint8Array) {
                        break;
                      } else if (typeof value2 === "string") {
                        params[key] = (0, _util.stringToBytes)(value2);
                      } else if (typeof value2 === "object" && value2 !== null && !isNaN(value2.length)) {
                        params[key] = new Uint8Array(value2);
                      } else if ((0, _util.isArrayBuffer)(value2)) {
                        params[key] = new Uint8Array(value2);
                      } else {
                        throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                      }
                      continue;
                  }
                  params[key] = value2;
                }
                params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
                params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
                params.ignoreErrors = params.stopAtErrors !== true;
                params.fontExtraProperties = params.fontExtraProperties === true;
                params.pdfBug = params.pdfBug === true;
                params.enableXfa = params.enableXfa === true;
                if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
                  params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
                }
                if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                  params.docBaseUrl = null;
                }
                if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
                  params.maxImageSize = -1;
                }
                if (typeof params.cMapUrl !== "string") {
                  params.cMapUrl = null;
                }
                if (typeof params.standardFontDataUrl !== "string") {
                  params.standardFontDataUrl = null;
                }
                if (typeof params.useWorkerFetch !== "boolean") {
                  params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
                }
                if (typeof params.isEvalSupported !== "boolean") {
                  params.isEvalSupported = true;
                }
                if (typeof params.disableFontFace !== "boolean") {
                  params.disableFontFace = _is_node.isNodeJS;
                }
                if (typeof params.useSystemFonts !== "boolean") {
                  params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
                }
                if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
                  params.ownerDocument = globalThis.document;
                }
                if (typeof params.disableRange !== "boolean") {
                  params.disableRange = false;
                }
                if (typeof params.disableStream !== "boolean") {
                  params.disableStream = false;
                }
                if (typeof params.disableAutoFetch !== "boolean") {
                  params.disableAutoFetch = false;
                }
                (0, _util.setVerbosityLevel)(params.verbosity);
                if (!worker2) {
                  const workerParams = {
                    verbosity: params.verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                const docId = task.docId;
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                  const networkStreamPromise = new Promise(function(resolve) {
                    let networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length: params.length,
                        initialData: params.initialData,
                        progressiveDone: params.progressiveDone,
                        contentDispositionFilename: params.contentDispositionFilename,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      }, rangeTransport);
                    } else if (!params.data) {
                      networkStream = createPDFNetworkStream({
                        url: params.url,
                        length: params.length,
                        httpHeaders: params.httpHeaders,
                        withCredentials: params.withCredentials,
                        rangeChunkSize: params.rangeChunkSize,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                }).catch(task._capability.reject);
                return task;
              }
              async function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                if (pdfDataRangeTransport) {
                  source.length = pdfDataRangeTransport.length;
                  source.initialData = pdfDataRangeTransport.initialData;
                  source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                  source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                }
                const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", {
                  docId,
                  apiVersion: "2.16.105",
                  source: {
                    data: source.data,
                    url: source.url,
                    password: source.password,
                    disableAutoFetch: source.disableAutoFetch,
                    rangeChunkSize: source.rangeChunkSize,
                    length: source.length
                  },
                  maxImageSize: source.maxImageSize,
                  disableFontFace: source.disableFontFace,
                  docBaseUrl: source.docBaseUrl,
                  ignoreErrors: source.ignoreErrors,
                  isEvalSupported: source.isEvalSupported,
                  fontExtraProperties: source.fontExtraProperties,
                  enableXfa: source.enableXfa,
                  useSystemFonts: source.useSystemFonts,
                  cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                  standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                });
                if (source.data) {
                  source.data = null;
                }
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              }
              const _PDFDocumentLoadingTask = class {
                constructor() {
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                async destroy() {
                  this.destroyed = true;
                  await this._transport?.destroy();
                  this._transport = null;
                  if (this._worker) {
                    this._worker.destroy();
                    this._worker = null;
                  }
                }
              };
              let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
              _docId = new WeakMap();
              __privateAdd(PDFDocumentLoadingTask, _docId, 0);
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              class PDFDataRangeTransport {
                constructor(length4, initialData, progressiveDone = false, contentDispositionFilename = null) {
                  this.length = length4;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = (0, _util.createPromiseCapability)();
                }
                addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
                addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
                addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
                addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
                onDataRange(begin, chunk) {
                  for (const listener of this._rangeListeners) {
                    listener(begin, chunk);
                  }
                }
                onDataProgress(loaded, total) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressListeners) {
                      listener(loaded, total);
                    }
                  });
                }
                onDataProgressiveRead(chunk) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveReadListeners) {
                      listener(chunk);
                    }
                  });
                }
                onDataProgressiveDone() {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveDoneListeners) {
                      listener();
                    }
                  });
                }
                transportReady() {
                  this._readyCapability.resolve();
                }
                requestDataRange(begin, end) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
                abort() {
                }
              }
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              class PDFDocumentProxy {
                constructor(pdfInfo, transport) {
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                  Object.defineProperty(this, "fingerprint", {
                    get() {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.");
                      return this.fingerprints[0];
                    }
                  });
                  Object.defineProperty(this, "getStats", {
                    value: async () => {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.");
                      return this.stats || {
                        streamTypes: {},
                        fontTypes: {}
                      };
                    }
                  });
                }
                get annotationStorage() {
                  return this._transport.annotationStorage;
                }
                get numPages() {
                  return this._pdfInfo.numPages;
                }
                get fingerprints() {
                  return this._pdfInfo.fingerprints;
                }
                get stats() {
                  return this._transport.stats;
                }
                get isPureXfa() {
                  return !!this._transport._htmlForXfa;
                }
                get allXfaHtml() {
                  return this._transport._htmlForXfa;
                }
                getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
                getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
                getDestinations() {
                  return this._transport.getDestinations();
                }
                getDestination(id2) {
                  return this._transport.getDestination(id2);
                }
                getPageLabels() {
                  return this._transport.getPageLabels();
                }
                getPageLayout() {
                  return this._transport.getPageLayout();
                }
                getPageMode() {
                  return this._transport.getPageMode();
                }
                getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
                getOpenAction() {
                  return this._transport.getOpenAction();
                }
                getAttachments() {
                  return this._transport.getAttachments();
                }
                getJavaScript() {
                  return this._transport.getJavaScript();
                }
                getJSActions() {
                  return this._transport.getDocJSActions();
                }
                getOutline() {
                  return this._transport.getOutline();
                }
                getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
                getPermissions() {
                  return this._transport.getPermissions();
                }
                getMetadata() {
                  return this._transport.getMetadata();
                }
                getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
                getData() {
                  return this._transport.getData();
                }
                getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
                cleanup(keepLoadedFonts = false) {
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
                destroy() {
                  return this.loadingTask.destroy();
                }
                get loadingParams() {
                  return this._transport.loadingParams;
                }
                get loadingTask() {
                  return this._transport.loadingTask;
                }
                saveDocument() {
                  if (this._transport.annotationStorage.size <= 0) {
                    (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                  }
                  return this._transport.saveDocument();
                }
                getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
                hasJSActions() {
                  return this._transport.hasJSActions();
                }
                getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }
              exports.PDFDocumentProxy = PDFDocumentProxy;
              class PDFPageProxy {
                constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._ownerDocument = ownerDocument;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._bitmaps = /* @__PURE__ */ new Set();
                  this.cleanupAfterRender = false;
                  this.pendingCleanup = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this._annotationPromises = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                get pageNumber() {
                  return this._pageIndex + 1;
                }
                get rotate() {
                  return this._pageInfo.rotate;
                }
                get ref() {
                  return this._pageInfo.ref;
                }
                get userUnit() {
                  return this._pageInfo.userUnit;
                }
                get view() {
                  return this._pageInfo.view;
                }
                getViewport({
                  scale: scale4,
                  rotation = this.rotate,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                } = {}) {
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale: scale4,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                getAnnotations({
                  intent = "display"
                } = {}) {
                  const intentArgs = this._transport.getRenderingIntent(intent);
                  let promise = this._annotationPromises.get(intentArgs.cacheKey);
                  if (!promise) {
                    promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                    this._annotationPromises.set(intentArgs.cacheKey, promise);
                    promise = promise.then((annotations) => {
                      for (const annotation of annotations) {
                        if (annotation.titleObj !== void 0) {
                          Object.defineProperty(annotation, "title", {
                            get() {
                              (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                              return annotation.titleObj.str;
                            }
                          });
                        }
                        if (annotation.contentsObj !== void 0) {
                          Object.defineProperty(annotation, "contents", {
                            get() {
                              (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                              return annotation.contentsObj.str;
                            }
                          });
                        }
                      }
                      return annotations;
                    });
                  }
                  return promise;
                }
                getJSActions() {
                  return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);
                }
                async getXfa() {
                  return this._transport._htmlForXfa?.children[this._pageIndex] || null;
                }
                render({
                  canvasContext,
                  viewport,
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  transform = null,
                  imageLayer = null,
                  canvasFactory = null,
                  background = null,
                  optionalContentConfigPromise = null,
                  annotationCanvasMap = null,
                  pageColors = null,
                  printAnnotationStorage = null
                }) {
                  if (arguments[0]?.renderInteractiveForms !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                    }
                  }
                  if (arguments[0]?.includeAnnotationStorage !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                    }
                  }
                  if (this._stats) {
                    this._stats.time("Overall");
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                  this.pendingCleanup = false;
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                    ownerDocument: this._ownerDocument
                  });
                  const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  const complete = (error) => {
                    intentState.renderTasks.delete(internalRenderTask);
                    if (this.cleanupAfterRender || intentPrint) {
                      this.pendingCleanup = true;
                    }
                    this._tryCleanup();
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      this._abortOperatorList({
                        intentState,
                        reason: error instanceof Error ? error : new Error(error)
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Rendering");
                      this._stats.timeEnd("Overall");
                    }
                  };
                  const internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform,
                      imageLayer,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    annotationCanvasMap,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: canvasFactoryInstance,
                    useRequestAnimationFrame: !intentPrint,
                    pdfBug: this._pdfBug,
                    pageColors
                  });
                  (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
                  const renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                    if (this.pendingCleanup) {
                      complete();
                      return;
                    }
                    if (this._stats) {
                      this._stats.time("Rendering");
                    }
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                }
                getOperatorList({
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  printAnnotationStorage = null
                } = {}) {
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks.delete(opListTask);
                    }
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  let opListTask;
                  if (!intentState.opListReadCapability) {
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                    (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  return intentState.opListReadCapability.promise;
                }
                streamTextContent({
                  disableCombineTextItems = false,
                  includeMarkedContent = false
                } = {}) {
                  const TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    combineTextItems: disableCombineTextItems !== true,
                    includeMarkedContent: includeMarkedContent === true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
                getTextContent(params = {}) {
                  if (this._transport._htmlForXfa) {
                    return this.getXfa().then((xfa) => {
                      return _xfa_text.XfaText.textContent(xfa);
                    });
                  }
                  const readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function({
                        value: value2,
                        done
                      }) {
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value2.styles);
                        textContent.items.push(...value2.items);
                        pump();
                      }, reject);
                    }
                    const reader = readableStream.getReader();
                    const textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
                getStructTree() {
                  return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);
                }
                _destroy() {
                  this.destroyed = true;
                  const waitOn = [];
                  for (const intentState of this._intentStates.values()) {
                    this._abortOperatorList({
                      intentState,
                      reason: new Error("Page was destroyed."),
                      force: true
                    });
                    if (intentState.opListReadCapability) {
                      continue;
                    }
                    for (const internalRenderTask of intentState.renderTasks) {
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  }
                  this.objs.clear();
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  this.pendingCleanup = false;
                  return Promise.all(waitOn);
                }
                cleanup(resetStats = false) {
                  this.pendingCleanup = true;
                  return this._tryCleanup(resetStats);
                }
                _tryCleanup(resetStats = false) {
                  if (!this.pendingCleanup) {
                    return false;
                  }
                  for (const {
                    renderTasks,
                    operatorList
                  } of this._intentStates.values()) {
                    if (renderTasks.size > 0 || !operatorList.lastChunk) {
                      return false;
                    }
                  }
                  this._intentStates.clear();
                  this.objs.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  if (resetStats && this._stats) {
                    this._stats = new _display_utils.StatTimer();
                  }
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this.pendingCleanup = false;
                  return true;
                }
                _startRenderPage(transparency, cacheKey) {
                  const intentState = this._intentStates.get(cacheKey);
                  if (!intentState) {
                    return;
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Page Request");
                  }
                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.resolve(transparency);
                  }
                }
                _renderPageChunk(operatorListChunk, intentState) {
                  for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    this._tryCleanup();
                  }
                }
                _pumpOperatorList({
                  renderingIntent,
                  cacheKey,
                  annotationStorageMap
                }) {
                  const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    cacheKey,
                    annotationStorage: annotationStorageMap
                  });
                  const reader = readableStream.getReader();
                  const intentState = this._intentStates.get(cacheKey);
                  intentState.streamReader = reader;
                  const pump = () => {
                    reader.read().then(({
                      value: value2,
                      done
                    }) => {
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (this._transport.destroyed) {
                        return;
                      }
                      this._renderPageChunk(value2, intentState);
                      pump();
                    }, (reason) => {
                      intentState.streamReader = null;
                      if (this._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        for (const internalRenderTask of intentState.renderTasks) {
                          internalRenderTask.operatorListChanged();
                        }
                        this._tryCleanup();
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
                _abortOperatorList({
                  intentState,
                  reason,
                  force = false
                }) {
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      intentState.streamReaderCancelTimeout = setTimeout(() => {
                        this._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                        intentState.streamReaderCancelTimeout = null;
                      }, RENDERING_CANCELLED_TIMEOUT);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                  });
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  for (const [curCacheKey, curIntentState] of this._intentStates) {
                    if (curIntentState === intentState) {
                      this._intentStates.delete(curCacheKey);
                      break;
                    }
                  }
                  this.cleanup();
                }
                get stats() {
                  return this._stats;
                }
              }
              exports.PDFPageProxy = PDFPageProxy;
              class LoopbackPort {
                constructor() {
                  this._listeners = [];
                  this._deferred = Promise.resolve();
                }
                postMessage(obj, transfers) {
                  const event = {
                    data: structuredClone(obj, transfers)
                  };
                  this._deferred.then(() => {
                    for (const listener of this._listeners) {
                      listener.call(this, event);
                    }
                  });
                }
                addEventListener(name, listener) {
                  this._listeners.push(listener);
                }
                removeEventListener(name, listener) {
                  const i = this._listeners.indexOf(listener);
                  this._listeners.splice(i, 1);
                }
                terminate() {
                  this._listeners.length = 0;
                }
              }
              exports.LoopbackPort = LoopbackPort;
              const PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_is_node.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if (typeof document === "object") {
                  const pdfjsFilePath = document?.currentScript?.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e) {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url2) {
                  const wrapper = `importScripts("${url2}");`;
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              const _PDFWorker = class {
                constructor({
                  name = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && __privateGet(_PDFWorker, _workerPorts).has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  this.name = name;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    __privateGet(_PDFWorker, _workerPorts).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                    let {
                      workerSrc
                    } = _PDFWorker;
                    try {
                      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array();
                        messageHandler.send("test", testObj, [testObj.buffer]);
                      };
                      sendTest();
                      return;
                    } catch (e) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!PDFWorkerUtil.isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    PDFWorkerUtil.isWorkerDisabled = true;
                  }
                  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id2 = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                    const workerHandler = new _message_handler.MessageHandler(id2 + "_worker", id2, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id2, id2 + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  __privateGet(_PDFWorker, _workerPorts).delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!params?.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (__privateGet(this, _workerPorts).has(params.port)) {
                    return __privateGet(this, _workerPorts).get(params.port);
                  }
                  return new _PDFWorker(params);
                }
                static get workerSrc() {
                  if (_worker_options.GlobalWorkerOptions.workerSrc) {
                    return _worker_options.GlobalWorkerOptions.workerSrc;
                  }
                  if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                    if (!_is_node.isNodeJS) {
                      (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                    }
                    return PDFWorkerUtil.fallbackWorkerSrc;
                  }
                  throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                }
                static get _mainThreadWorkerMessageHandler() {
                  try {
                    return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
                  } catch (ex) {
                    return null;
                  }
                }
                static get _setupFakeWorkerGlobal() {
                  const loader = async () => {
                    const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_is_node.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(this.workerSrc);
                      return worker.WorkerMessageHandler;
                    }
                    await (0, _display_utils.loadScript)(this.workerSrc);
                    return window.pdfjsWorker.WorkerMessageHandler;
                  };
                  return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                }
              };
              let PDFWorker = _PDFWorker;
              _workerPorts = new WeakMap();
              __privateAdd(PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
              exports.PDFWorker = PDFWorker;
              {
                PDFWorker.getWorkerSrc = function() {
                  (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
                  return this.workerSrc;
                };
              }
              class WorkerTransport {
                constructor(messageHandler, loadingTask, networkStream, params) {
                  __privateAdd(this, _docStats, null);
                  __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                  __privateAdd(this, _metadataPromise, null);
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    docId: loadingTask.docId,
                    onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  if (!params.useWorkerFetch) {
                    this.CMapReaderFactory = new params.CMapReaderFactory({
                      baseUrl: params.cMapUrl,
                      isCompressed: params.cMapPacked
                    });
                    this.StandardFontDataFactory = new params.StandardFontDataFactory({
                      baseUrl: params.standardFontDataUrl
                    });
                  }
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._passwordCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                  this.setupMessageHandler();
                }
                get annotationStorage() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
                get stats() {
                  return __privateGet(this, _docStats);
                }
                getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
                  let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                  let annotationMap = null;
                  switch (intent) {
                    case "any":
                      renderingIntent = _util.RenderingIntentFlag.ANY;
                      break;
                    case "display":
                      break;
                    case "print":
                      renderingIntent = _util.RenderingIntentFlag.PRINT;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                  }
                  switch (annotationMode) {
                    case _util.AnnotationMode.DISABLE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                      break;
                    case _util.AnnotationMode.ENABLE:
                      break;
                    case _util.AnnotationMode.ENABLE_FORMS:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                      break;
                    case _util.AnnotationMode.ENABLE_STORAGE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                      const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                      annotationMap = annotationStorage.serializable;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                  }
                  if (isOpList) {
                    renderingIntent += _util.RenderingIntentFlag.OPLIST;
                  }
                  return {
                    renderingIntent,
                    cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,
                    annotationStorageMap: annotationMap
                  };
                }
                destroy() {
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = (0, _util.createPromiseCapability)();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  const waitOn = [];
                  for (const page of __privateGet(this, _pageCache).values()) {
                    waitOn.push(page._destroy());
                  }
                  __privateGet(this, _pageCache).clear();
                  __privateGet(this, _pagePromises).clear();
                  if (this.hasOwnProperty("annotationStorage")) {
                    this.annotationStorage.resetModified();
                  }
                  const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(() => {
                    this.commonObjs.clear();
                    this.fontLoader.clear();
                    __privateSet(this, _metadataPromise, null);
                    this._getFieldObjectsPromise = null;
                    this._hasJSActionsPromise = null;
                    if (this._networkStream) {
                      this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    }
                    if (this.messageHandler) {
                      this.messageHandler.destroy();
                      this.messageHandler = null;
                    }
                    this.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
                setupMessageHandler() {
                  const {
                    messageHandler,
                    loadingTask
                  } = this;
                  messageHandler.on("GetReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = (evt) => {
                      this._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = () => {
                      this._fullReader.read().then(function({
                        value: value2,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value2), "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value2), 1, [value2]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      this._fullReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", (data) => {
                    const headersCapability = (0, _util.createPromiseCapability)();
                    const fullReader = this._fullReader;
                    fullReader.headersReady.then(() => {
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (this._lastProgress) {
                          loadingTask.onProgress?.(this._lastProgress);
                        }
                        fullReader.onProgress = (evt) => {
                          loadingTask.onProgress?.({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = () => {
                      rangeReader.read().then(function({
                        value: value2,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value2), "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value2), 1, [value2]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      rangeReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", ({
                    pdfInfo
                  }) => {
                    this._numPages = pdfInfo.numPages;
                    this._htmlForXfa = pdfInfo.htmlForXfa;
                    delete pdfInfo.htmlForXfa;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                  });
                  messageHandler.on("DocException", function(ex) {
                    let reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                      default:
                        (0, _util.unreachable)("DocException - expected a valid Error.");
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", (exception) => {
                    this._passwordCapability = (0, _util.createPromiseCapability)();
                    if (loadingTask.onPassword) {
                      const updatePassword = (password) => {
                        if (password instanceof Error) {
                          this._passwordCapability.reject(password);
                        } else {
                          this._passwordCapability.resolve({
                            password
                          });
                        }
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        this._passwordCapability.reject(ex);
                      }
                    } else {
                      this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return this._passwordCapability.promise;
                  });
                  messageHandler.on("DataLoaded", (data) => {
                    loadingTask.onProgress?.({
                      loaded: data.length,
                      total: data.length
                    });
                    this.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    const page = __privateGet(this, _pageCache).get(data.pageIndex);
                    page._startRenderPage(data.transparency, data.cacheKey);
                  });
                  messageHandler.on("commonobj", ([id2, type2, exportedData]) => {
                    if (this.destroyed) {
                      return;
                    }
                    if (this.commonObjs.has(id2)) {
                      return;
                    }
                    switch (type2) {
                      case "Font":
                        const params = this._params;
                        if ("error" in exportedData) {
                          const exportedError = exportedData.error;
                          (0, _util.warn)(`Error during font loading: ${exportedError}`);
                          this.commonObjs.resolve(id2, exportedError);
                          break;
                        }
                        let fontRegistry = null;
                        if (params.pdfBug && globalThis.FontInspector?.enabled) {
                          fontRegistry = {
                            registerFont(font3, url2) {
                              globalThis.FontInspector.fontAdded(font3, url2);
                            }
                          };
                        }
                        const font2 = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                          fontRegistry
                        });
                        this.fontLoader.bind(font2).catch((reason) => {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id: id2
                          });
                        }).finally(() => {
                          if (!params.fontExtraProperties && font2.data) {
                            font2.data = null;
                          }
                          this.commonObjs.resolve(id2, font2);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                        this.commonObjs.resolve(id2, exportedData);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${type2}`);
                    }
                  });
                  messageHandler.on("obj", ([id2, pageIndex, type2, imageData]) => {
                    if (this.destroyed) {
                      return;
                    }
                    const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                    if (pageProxy.objs.has(id2)) {
                      return;
                    }
                    switch (type2) {
                      case "Image":
                        pageProxy.objs.resolve(id2, imageData);
                        const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                        if (imageData) {
                          let length4;
                          if (imageData.bitmap) {
                            const {
                              bitmap,
                              width: width2,
                              height
                            } = imageData;
                            length4 = width2 * height * 4;
                            pageProxy._bitmaps.add(bitmap);
                          } else {
                            length4 = imageData.data?.length || 0;
                          }
                          if (length4 > MAX_IMAGE_SIZE_TO_STORE) {
                            pageProxy.cleanupAfterRender = true;
                          }
                        }
                        break;
                      case "Pattern":
                        pageProxy.objs.resolve(id2, imageData);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${type2}`);
                    }
                  });
                  messageHandler.on("DocProgress", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    loadingTask.onProgress?.({
                      loaded: data.loaded,
                      total: data.total
                    });
                  });
                  messageHandler.on("DocStats", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    __privateSet(this, _docStats, Object.freeze({
                      streamTypes: Object.freeze(data.streamTypes),
                      fontTypes: Object.freeze(data.fontTypes)
                    }));
                  });
                  messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                  messageHandler.on("FetchBuiltInCMap", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.CMapReaderFactory) {
                      return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.CMapReaderFactory.fetch(data);
                  });
                  messageHandler.on("FetchStandardFontData", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.StandardFontDataFactory) {
                      return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.StandardFontDataFactory.fetch(data);
                  });
                }
                _onUnsupportedFeature({
                  featureId
                }) {
                  if (this.destroyed) {
                    return;
                  }
                  this.loadingTask.onUnsupportedFeature?.(featureId);
                }
                getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
                getPage(pageNumber) {
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request."));
                  }
                  const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then((pageInfo) => {
                    if (this.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
                    __privateGet(this, _pageCache).set(pageIndex, page);
                    return page;
                  });
                  __privateGet(this, _pagePromises).set(pageIndex, promise);
                  return promise;
                }
                getPageIndex(ref) {
                  if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                    return Promise.reject(new Error("Invalid pageIndex request."));
                  }
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    num: ref.num,
                    gen: ref.gen
                  });
                }
                getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
                saveDocument() {
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    isPureXfa: !!this._htmlForXfa,
                    numPages: this._numPages,
                    annotationStorage: this.annotationStorage.serializable,
                    filename: this._fullReader?.filename ?? null
                  }).finally(() => {
                    this.annotationStorage.resetModified();
                  });
                }
                getFieldObjects() {
                  return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise("GetFieldObjects", null);
                }
                hasJSActions() {
                  return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise("HasJSActions", null);
                }
                getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
                getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
                getDestination(id2) {
                  if (typeof id2 !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id: id2
                  });
                }
                getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
                getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
                getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
                getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
                getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
                getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
                getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                }
                getDocJSActions() {
                  return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                }
                getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
                getStructTree(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetStructTree", {
                    pageIndex
                  });
                }
                getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
                getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
                getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
                getMetadata() {
                  return __privateGet(this, _metadataPromise) || __privateSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: this._fullReader?.filename ?? null,
                      contentLength: this._fullReader?.contentLength ?? null
                    };
                  }));
                }
                getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
                async startCleanup(keepLoadedFonts = false) {
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  if (this.destroyed) {
                    return;
                  }
                  for (const page of __privateGet(this, _pageCache).values()) {
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  __privateSet(this, _metadataPromise, null);
                  this._getFieldObjectsPromise = null;
                  this._hasJSActionsPromise = null;
                }
                get loadingParams() {
                  const params = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch: params.disableAutoFetch,
                    enableXfa: params.enableXfa
                  });
                }
              }
              _docStats = new WeakMap();
              _pageCache = new WeakMap();
              _pagePromises = new WeakMap();
              _metadataPromise = new WeakMap();
              class PDFObjects {
                constructor() {
                  __privateAdd(this, _ensureObj);
                  __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
                }
                get(objId, callback = null) {
                  if (callback) {
                    const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                    obj2.capability.promise.then(() => callback(obj2.data));
                    return null;
                  }
                  const obj = __privateGet(this, _objs)[objId];
                  if (!obj?.capability.settled) {
                    throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                  }
                  return obj.data;
                }
                has(objId) {
                  const obj = __privateGet(this, _objs)[objId];
                  return obj?.capability.settled || false;
                }
                resolve(objId, data = null) {
                  const obj = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                  obj.data = data;
                  obj.capability.resolve();
                }
                clear() {
                  __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
                }
              }
              _objs = new WeakMap();
              _ensureObj = new WeakSet();
              ensureObj_fn = function(objId) {
                const obj = __privateGet(this, _objs)[objId];
                if (obj) {
                  return obj;
                }
                return __privateGet(this, _objs)[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null
                };
              };
              class RenderTask {
                constructor(internalRenderTask) {
                  __privateAdd(this, _internalRenderTask, null);
                  __privateSet(this, _internalRenderTask, internalRenderTask);
                  this.onContinue = null;
                }
                get promise() {
                  return __privateGet(this, _internalRenderTask).capability.promise;
                }
                cancel() {
                  __privateGet(this, _internalRenderTask).cancel();
                }
                get separateAnnots() {
                  const {
                    separateAnnots
                  } = __privateGet(this, _internalRenderTask).operatorList;
                  if (!separateAnnots) {
                    return false;
                  }
                  const {
                    annotationCanvasMap
                  } = __privateGet(this, _internalRenderTask);
                  return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
                }
              }
              _internalRenderTask = new WeakMap();
              exports.RenderTask = RenderTask;
              const _InternalRenderTask = class {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  annotationCanvasMap,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  useRequestAnimationFrame = false,
                  pdfBug = false,
                  pageColors = null
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics({
                  transparency = false,
                  optionalContentConfig
                }) {
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                  }
                  if (this._pdfBug && globalThis.StepperManager?.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
                  this.gfx.beginDrawing({
                    transform,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel(error = null) {
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              };
              let InternalRenderTask = _InternalRenderTask;
              _canvasInUse = new WeakMap();
              __privateAdd(InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
              const version = "2.16.105";
              exports.version = version;
              const build = "172ccdbe5";
              exports.build = build;
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _setModified, setModified_fn, _serializable;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(6);
              var _murmurhash = __w_pdfjs_require__2(10);
              class AnnotationStorage {
                constructor() {
                  __privateAdd(this, _setModified);
                  this._storage = /* @__PURE__ */ new Map();
                  this._modified = false;
                  this.onSetModified = null;
                  this.onResetModified = null;
                  this.onAnnotationEditor = null;
                }
                getValue(key, defaultValue) {
                  const value2 = this._storage.get(key);
                  if (value2 === void 0) {
                    return defaultValue;
                  }
                  return Object.assign(defaultValue, value2);
                }
                getRawValue(key) {
                  return this._storage.get(key);
                }
                remove(key) {
                  this._storage.delete(key);
                  if (this._storage.size === 0) {
                    this.resetModified();
                  }
                  if (typeof this.onAnnotationEditor === "function") {
                    for (const value2 of this._storage.values()) {
                      if (value2 instanceof _editor.AnnotationEditor) {
                        return;
                      }
                    }
                    this.onAnnotationEditor(null);
                  }
                }
                setValue(key, value2) {
                  const obj = this._storage.get(key);
                  let modified = false;
                  if (obj !== void 0) {
                    for (const [entry, val] of Object.entries(value2)) {
                      if (obj[entry] !== val) {
                        modified = true;
                        obj[entry] = val;
                      }
                    }
                  } else {
                    modified = true;
                    this._storage.set(key, value2);
                  }
                  if (modified) {
                    __privateMethod(this, _setModified, setModified_fn).call(this);
                  }
                  if (value2 instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                    this.onAnnotationEditor(value2.constructor._type);
                  }
                }
                has(key) {
                  return this._storage.has(key);
                }
                getAll() {
                  return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                }
                get size() {
                  return this._storage.size;
                }
                resetModified() {
                  if (this._modified) {
                    this._modified = false;
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
                get print() {
                  return new PrintAnnotationStorage(this);
                }
                get serializable() {
                  if (this._storage.size === 0) {
                    return null;
                  }
                  const clone4 = /* @__PURE__ */ new Map();
                  for (const [key, val] of this._storage) {
                    const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;
                    if (serialized) {
                      clone4.set(key, serialized);
                    }
                  }
                  return clone4;
                }
                static getHash(map) {
                  if (!map) {
                    return "";
                  }
                  const hash = new _murmurhash.MurmurHash3_64();
                  for (const [key, val] of map) {
                    hash.update(`${key}:${JSON.stringify(val)}`);
                  }
                  return hash.hexdigest();
                }
              }
              _setModified = new WeakSet();
              setModified_fn = function() {
                if (!this._modified) {
                  this._modified = true;
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              };
              exports2.AnnotationStorage = AnnotationStorage;
              class PrintAnnotationStorage extends AnnotationStorage {
                constructor(parent) {
                  super();
                  __privateAdd(this, _serializable, null);
                  __privateSet(this, _serializable, structuredClone(parent.serializable));
                }
                get print() {
                  (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
                }
                get serializable() {
                  return __privateGet(this, _serializable);
                }
              }
              _serializable = new WeakMap();
              exports2.PrintAnnotationStorage = PrintAnnotationStorage;
            },
            /* 6 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundFocusin, _boundFocusout, _hasBeenSelected, _isEditing, _isInEditMode, _zIndex;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditor = void 0;
              var _tools = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              const _AnnotationEditor = class {
                constructor(parameters) {
                  __privateAdd(this, _boundFocusin, this.focusin.bind(this));
                  __privateAdd(this, _boundFocusout, this.focusout.bind(this));
                  __privateAdd(this, _hasBeenSelected, false);
                  __privateAdd(this, _isEditing, false);
                  __privateAdd(this, _isInEditMode, false);
                  __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
                  if (this.constructor === _AnnotationEditor) {
                    (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                  }
                  this.parent = parameters.parent;
                  this.id = parameters.id;
                  this.width = this.height = null;
                  this.pageIndex = parameters.parent.pageIndex;
                  this.name = parameters.name;
                  this.div = null;
                  const [width2, height] = this.parent.viewportBaseDimensions;
                  this.x = parameters.x / width2;
                  this.y = parameters.y / height;
                  this.rotation = this.parent.viewport.rotation;
                  this.isAttachedToDOM = false;
                }
                static get _defaultLineColor() {
                  return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                }
                setInBackground() {
                  this.div.style.zIndex = 0;
                }
                setInForeground() {
                  this.div.style.zIndex = __privateGet(this, _zIndex);
                }
                focusin(event) {
                  if (!__privateGet(this, _hasBeenSelected)) {
                    this.parent.setSelected(this);
                  } else {
                    __privateSet(this, _hasBeenSelected, false);
                  }
                }
                focusout(event) {
                  if (!this.isAttachedToDOM) {
                    return;
                  }
                  const target = event.relatedTarget;
                  if (target?.closest(`#${this.id}`)) {
                    return;
                  }
                  event.preventDefault();
                  if (!this.parent.isMultipleSelection) {
                    this.commitOrRemove();
                  }
                }
                commitOrRemove() {
                  if (this.isEmpty()) {
                    this.remove();
                  } else {
                    this.commit();
                  }
                }
                commit() {
                  this.parent.addToAnnotationStorage(this);
                }
                dragstart(event) {
                  const rect = this.parent.div.getBoundingClientRect();
                  this.startX = event.clientX - rect.x;
                  this.startY = event.clientY - rect.y;
                  event.dataTransfer.setData("text/plain", this.id);
                  event.dataTransfer.effectAllowed = "move";
                }
                setAt(x, y, tx, ty) {
                  const [width2, height] = this.parent.viewportBaseDimensions;
                  [tx, ty] = this.screenToPageTranslation(tx, ty);
                  this.x = (x + tx) / width2;
                  this.y = (y + ty) / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                translate(x, y) {
                  const [width2, height] = this.parent.viewportBaseDimensions;
                  [x, y] = this.screenToPageTranslation(x, y);
                  this.x += x / width2;
                  this.y += y / height;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                screenToPageTranslation(x, y) {
                  const {
                    rotation
                  } = this.parent.viewport;
                  switch (rotation) {
                    case 90:
                      return [y, -x];
                    case 180:
                      return [-x, -y];
                    case 270:
                      return [-y, x];
                    default:
                      return [x, y];
                  }
                }
                setDims(width2, height) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.div.style.width = `${100 * width2 / parentWidth}%`;
                  this.div.style.height = `${100 * height / parentHeight}%`;
                }
                getInitialTranslation() {
                  return [0, 0];
                }
                render() {
                  this.div = document.createElement("div");
                  this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                  this.div.className = this.name;
                  this.div.setAttribute("id", this.id);
                  this.div.setAttribute("tabIndex", 0);
                  this.setInForeground();
                  this.div.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.addEventListener("focusout", __privateGet(this, _boundFocusout));
                  const [tx, ty] = this.getInitialTranslation();
                  this.translate(tx, ty);
                  (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
                  return this.div;
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    event.preventDefault();
                    return;
                  }
                  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                    this.parent.toggleSelected(this);
                  } else {
                    this.parent.setSelected(this);
                  }
                  __privateSet(this, _hasBeenSelected, true);
                }
                getRect(tx, ty) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  const [pageWidth, pageHeight] = this.parent.pageDimensions;
                  const shiftX = pageWidth * tx / parentWidth;
                  const shiftY = pageHeight * ty / parentHeight;
                  const x = this.x * pageWidth;
                  const y = this.y * pageHeight;
                  const width2 = this.width * pageWidth;
                  const height = this.height * pageHeight;
                  switch (this.rotation) {
                    case 0:
                      return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width2, pageHeight - y - shiftY];
                    case 90:
                      return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width2];
                    case 180:
                      return [x - shiftX - width2, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];
                    case 270:
                      return [x - shiftY - height, pageHeight - y - shiftX - width2, x - shiftY, pageHeight - y - shiftX];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRectInCurrentCoords(rect, pageHeight) {
                  const [x1, y1, x2, y2] = rect;
                  const width2 = x2 - x1;
                  const height = y2 - y1;
                  switch (this.rotation) {
                    case 0:
                      return [x1, pageHeight - y2, width2, height];
                    case 90:
                      return [x1, pageHeight - y1, height, width2];
                    case 180:
                      return [x2, pageHeight - y1, width2, height];
                    case 270:
                      return [x2, pageHeight - y2, height, width2];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                onceAdded() {
                }
                isEmpty() {
                  return false;
                }
                enableEditMode() {
                  __privateSet(this, _isInEditMode, true);
                }
                disableEditMode() {
                  __privateSet(this, _isInEditMode, false);
                }
                isInEditMode() {
                  return __privateGet(this, _isInEditMode);
                }
                shouldGetKeyboardEvents() {
                  return false;
                }
                needsToBeRebuilt() {
                  return this.div && !this.isAttachedToDOM;
                }
                rebuild() {
                  this.div?.addEventListener("focusin", __privateGet(this, _boundFocusin));
                }
                serialize() {
                  (0, _util2.unreachable)("An editor must be serializable");
                }
                static deserialize(data, parent) {
                  const editor = new this.prototype.constructor({
                    parent,
                    id: parent.getNextId()
                  });
                  editor.rotation = data.rotation;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const [x, y, width2, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
                  editor.x = x / pageWidth;
                  editor.y = y / pageHeight;
                  editor.width = width2 / pageWidth;
                  editor.height = height / pageHeight;
                  return editor;
                }
                remove() {
                  this.div.removeEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.removeEventListener("focusout", __privateGet(this, _boundFocusout));
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.parent.remove(this);
                }
                select() {
                  this.div?.classList.add("selectedEditor");
                }
                unselect() {
                  this.div?.classList.remove("selectedEditor");
                }
                updateParams(type2, value2) {
                }
                disableEditing() {
                }
                enableEditing() {
                }
                get propertiesToUpdate() {
                  return {};
                }
                get contentDiv() {
                  return this.div;
                }
                get isEditing() {
                  return __privateGet(this, _isEditing);
                }
                set isEditing(value2) {
                  __privateSet(this, _isEditing, value2);
                  if (value2) {
                    this.parent.setSelected(this);
                    this.parent.setActiveEditor(this);
                  } else {
                    this.parent.setActiveEditor(null);
                  }
                }
              };
              let AnnotationEditor = _AnnotationEditor;
              _boundFocusin = new WeakMap();
              _boundFocusout = new WeakMap();
              _hasBeenSelected = new WeakMap();
              _isEditing = new WeakMap();
              _isInEditMode = new WeakMap();
              _zIndex = new WeakMap();
              __publicField(AnnotationEditor, "_colorManager", new _tools.ColorManager());
              __publicField(AnnotationEditor, "_zIndex", 1);
              exports2.AnnotationEditor = AnnotationEditor;
            },
            /* 7 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _id, _commands, _locked, _maxSize, _position, _serialize, serialize_fn, _elements, _activeEditor, _allEditors, _allLayers, _clipboardManager, _commandManager, _currentPageIndex, _editorTypes, _eventBus, _idManager, _isEnabled, _mode, _selectedEditors, _boundKeydown, _boundOnEditingAction, _boundOnPageChanging, _previousStates, _container, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
              exports2.bindEvents = bindEvents;
              exports2.opacityToHex = opacityToHex;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              function bindEvents(obj, element, names) {
                for (const name of names) {
                  element.addEventListener(name, obj[name].bind(obj));
                }
              }
              function opacityToHex(opacity2) {
                return Math.round(Math.min(255, Math.max(1, 255 * opacity2))).toString(16).padStart(2, "0");
              }
              class IdManager {
                constructor() {
                  __privateAdd(this, _id, 0);
                }
                getId() {
                  return `${_util2.AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
                }
              }
              _id = new WeakMap();
              class CommandManager {
                constructor(maxSize = 128) {
                  __privateAdd(this, _commands, []);
                  __privateAdd(this, _locked, false);
                  __privateAdd(this, _maxSize, void 0);
                  __privateAdd(this, _position, -1);
                  __privateSet(this, _maxSize, maxSize);
                }
                add({
                  cmd,
                  undo,
                  mustExec,
                  type: type2 = NaN,
                  overwriteIfSameType = false,
                  keepUndo = false
                }) {
                  if (mustExec) {
                    cmd();
                  }
                  if (__privateGet(this, _locked)) {
                    return;
                  }
                  const save = {
                    cmd,
                    undo,
                    type: type2
                  };
                  if (__privateGet(this, _position) === -1) {
                    if (__privateGet(this, _commands).length > 0) {
                      __privateGet(this, _commands).length = 0;
                    }
                    __privateSet(this, _position, 0);
                    __privateGet(this, _commands).push(save);
                    return;
                  }
                  if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type2) {
                    if (keepUndo) {
                      save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
                    }
                    __privateGet(this, _commands)[__privateGet(this, _position)] = save;
                    return;
                  }
                  const next = __privateGet(this, _position) + 1;
                  if (next === __privateGet(this, _maxSize)) {
                    __privateGet(this, _commands).splice(0, 1);
                  } else {
                    __privateSet(this, _position, next);
                    if (next < __privateGet(this, _commands).length) {
                      __privateGet(this, _commands).splice(next);
                    }
                  }
                  __privateGet(this, _commands).push(save);
                }
                undo() {
                  if (__privateGet(this, _position) === -1) {
                    return;
                  }
                  __privateSet(this, _locked, true);
                  __privateGet(this, _commands)[__privateGet(this, _position)].undo();
                  __privateSet(this, _locked, false);
                  __privateSet(this, _position, __privateGet(this, _position) - 1);
                }
                redo() {
                  if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
                    __privateSet(this, _position, __privateGet(this, _position) + 1);
                    __privateSet(this, _locked, true);
                    __privateGet(this, _commands)[__privateGet(this, _position)].cmd();
                    __privateSet(this, _locked, false);
                  }
                }
                hasSomethingToUndo() {
                  return __privateGet(this, _position) !== -1;
                }
                hasSomethingToRedo() {
                  return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
                }
                destroy() {
                  __privateSet(this, _commands, null);
                }
              }
              _commands = new WeakMap();
              _locked = new WeakMap();
              _maxSize = new WeakMap();
              _position = new WeakMap();
              exports2.CommandManager = CommandManager;
              const _KeyboardManager = class {
                constructor(callbacks) {
                  __privateAdd(this, _serialize);
                  this.buffer = [];
                  this.callbacks = /* @__PURE__ */ new Map();
                  this.allKeys = /* @__PURE__ */ new Set();
                  const isMac = _KeyboardManager.platform.isMac;
                  for (const [keys, callback] of callbacks) {
                    for (const key of keys) {
                      const isMacKey = key.startsWith("mac+");
                      if (isMac && isMacKey) {
                        this.callbacks.set(key.slice(4), callback);
                        this.allKeys.add(key.split("+").at(-1));
                      } else if (!isMac && !isMacKey) {
                        this.callbacks.set(key, callback);
                        this.allKeys.add(key.split("+").at(-1));
                      }
                    }
                  }
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
                exec(self, event) {
                  if (!this.allKeys.has(event.key)) {
                    return;
                  }
                  const callback = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
                  if (!callback) {
                    return;
                  }
                  callback.bind(self)();
                  event.stopPropagation();
                  event.preventDefault();
                }
              };
              let KeyboardManager = _KeyboardManager;
              _serialize = new WeakSet();
              serialize_fn = function(event) {
                if (event.altKey) {
                  this.buffer.push("alt");
                }
                if (event.ctrlKey) {
                  this.buffer.push("ctrl");
                }
                if (event.metaKey) {
                  this.buffer.push("meta");
                }
                if (event.shiftKey) {
                  this.buffer.push("shift");
                }
                this.buffer.push(event.key);
                const str3 = this.buffer.join("+");
                this.buffer.length = 0;
                return str3;
              };
              exports2.KeyboardManager = KeyboardManager;
              class ClipboardManager {
                constructor() {
                  __privateAdd(this, _elements, null);
                }
                copy(element) {
                  if (!element) {
                    return;
                  }
                  if (Array.isArray(element)) {
                    __privateSet(this, _elements, element.map((el) => el.serialize()));
                  } else {
                    __privateSet(this, _elements, [element.serialize()]);
                  }
                  __privateSet(this, _elements, __privateGet(this, _elements).filter((el) => !!el));
                  if (__privateGet(this, _elements).length === 0) {
                    __privateSet(this, _elements, null);
                  }
                }
                paste() {
                  return __privateGet(this, _elements);
                }
                isEmpty() {
                  return __privateGet(this, _elements) === null;
                }
                destroy() {
                  __privateSet(this, _elements, null);
                }
              }
              _elements = new WeakMap();
              const _ColorManager = class {
                get _colors() {
                  const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                  (0, _display_utils2.getColorValues)(colors);
                  return (0, _util2.shadow)(this, "_colors", colors);
                }
                convert(color) {
                  const rgb2 = (0, _display_utils2.getRGB)(color);
                  if (!window.matchMedia("(forced-colors: active)").matches) {
                    return rgb2;
                  }
                  for (const [name, RGB] of this._colors) {
                    if (RGB.every((x, i) => x === rgb2[i])) {
                      return _ColorManager._colorsMapping.get(name);
                    }
                  }
                  return rgb2;
                }
                getHexCode(name) {
                  const rgb2 = this._colors.get(name);
                  if (!rgb2) {
                    return name;
                  }
                  return _util2.Util.makeHexColor(...rgb2);
                }
              };
              let ColorManager = _ColorManager;
              __publicField(ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
              exports2.ColorManager = ColorManager;
              const _AnnotationEditorUIManager = class {
                constructor(container, eventBus) {
                  __privateAdd(this, _addKeyboardManager);
                  __privateAdd(this, _removeKeyboardManager);
                  __privateAdd(this, _dispatchUpdateStates);
                  __privateAdd(this, _dispatchUpdateUI);
                  __privateAdd(this, _enableAll);
                  __privateAdd(this, _disableAll);
                  __privateAdd(this, _addEditorToLayer);
                  __privateAdd(this, _isEmpty);
                  __privateAdd(this, _selectEditors);
                  __privateAdd(this, _activeEditor, null);
                  __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
                  __privateAdd(this, _clipboardManager, new ClipboardManager());
                  __privateAdd(this, _commandManager, new CommandManager());
                  __privateAdd(this, _currentPageIndex, 0);
                  __privateAdd(this, _editorTypes, null);
                  __privateAdd(this, _eventBus, null);
                  __privateAdd(this, _idManager, new IdManager());
                  __privateAdd(this, _isEnabled, false);
                  __privateAdd(this, _mode, _util2.AnnotationEditorType.NONE);
                  __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
                  __privateAdd(this, _boundKeydown, this.keydown.bind(this));
                  __privateAdd(this, _boundOnEditingAction, this.onEditingAction.bind(this));
                  __privateAdd(this, _boundOnPageChanging, this.onPageChanging.bind(this));
                  __privateAdd(this, _previousStates, {
                    isEditing: false,
                    isEmpty: true,
                    hasEmptyClipboard: true,
                    hasSomethingToUndo: false,
                    hasSomethingToRedo: false,
                    hasSelectedEditor: false
                  });
                  __privateAdd(this, _container, null);
                  __privateSet(this, _container, container);
                  __privateSet(this, _eventBus, eventBus);
                  __privateGet(this, _eventBus)._on("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._on("pagechanging", __privateGet(this, _boundOnPageChanging));
                }
                destroy() {
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateGet(this, _eventBus)._off("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._off("pagechanging", __privateGet(this, _boundOnPageChanging));
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.destroy();
                  }
                  __privateGet(this, _allLayers).clear();
                  __privateGet(this, _allEditors).clear();
                  __privateSet(this, _activeEditor, null);
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _clipboardManager).destroy();
                  __privateGet(this, _commandManager).destroy();
                }
                onPageChanging({
                  pageNumber
                }) {
                  __privateSet(this, _currentPageIndex, pageNumber - 1);
                }
                focusMainContainer() {
                  __privateGet(this, _container).focus();
                }
                keydown(event) {
                  if (!this.getActive()?.shouldGetKeyboardEvents()) {
                    _AnnotationEditorUIManager._keyboardManager.exec(this, event);
                  }
                }
                onEditingAction(details) {
                  if (["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(details.name)) {
                    this[details.name]();
                  }
                }
                setEditingState(isEditing) {
                  if (isEditing) {
                    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: __privateGet(this, _mode) !== _util2.AnnotationEditorType.NONE,
                      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
                      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                      hasSelectedEditor: false,
                      hasEmptyClipboard: __privateGet(this, _clipboardManager).isEmpty()
                    });
                  } else {
                    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: false
                    });
                  }
                }
                registerEditorTypes(types) {
                  __privateSet(this, _editorTypes, types);
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
                  }
                }
                getId() {
                  return __privateGet(this, _idManager).getId();
                }
                addLayer(layer) {
                  __privateGet(this, _allLayers).set(layer.pageIndex, layer);
                  if (__privateGet(this, _isEnabled)) {
                    layer.enable();
                  } else {
                    layer.disable();
                  }
                }
                removeLayer(layer) {
                  __privateGet(this, _allLayers).delete(layer.pageIndex);
                }
                updateMode(mode) {
                  __privateSet(this, _mode, mode);
                  if (mode === _util2.AnnotationEditorType.NONE) {
                    this.setEditingState(false);
                    __privateMethod(this, _disableAll, disableAll_fn).call(this);
                  } else {
                    this.setEditingState(true);
                    __privateMethod(this, _enableAll, enableAll_fn).call(this);
                    for (const layer of __privateGet(this, _allLayers).values()) {
                      layer.updateMode(mode);
                    }
                  }
                }
                updateToolbar(mode) {
                  if (mode === __privateGet(this, _mode)) {
                    return;
                  }
                  __privateGet(this, _eventBus).dispatch("switchannotationeditormode", {
                    source: this,
                    mode
                  });
                }
                updateParams(type2, value2) {
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.updateParams(type2, value2);
                  }
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    editorType.updateDefaultParams(type2, value2);
                  }
                }
                getEditors(pageIndex) {
                  const editors = [];
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    if (editor.pageIndex === pageIndex) {
                      editors.push(editor);
                    }
                  }
                  return editors;
                }
                getEditor(id2) {
                  return __privateGet(this, _allEditors).get(id2);
                }
                addEditor(editor) {
                  __privateGet(this, _allEditors).set(editor.id, editor);
                }
                removeEditor(editor) {
                  __privateGet(this, _allEditors).delete(editor.id);
                  this.unselect(editor);
                }
                setActiveEditor(editor) {
                  if (__privateGet(this, _activeEditor) === editor) {
                    return;
                  }
                  __privateSet(this, _activeEditor, editor);
                  if (editor) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  }
                }
                toggleSelected(editor) {
                  if (__privateGet(this, _selectedEditors).has(editor)) {
                    __privateGet(this, _selectedEditors).delete(editor);
                    editor.unselect();
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasSelectedEditor: this.hasSelection
                    });
                    return;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                setSelected(editor) {
                  for (const ed of __privateGet(this, _selectedEditors)) {
                    if (ed !== editor) {
                      ed.unselect();
                    }
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                isSelected(editor) {
                  return __privateGet(this, _selectedEditors).has(editor);
                }
                unselect(editor) {
                  editor.unselect();
                  __privateGet(this, _selectedEditors).delete(editor);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                }
                get hasSelection() {
                  return __privateGet(this, _selectedEditors).size !== 0;
                }
                undo() {
                  __privateGet(this, _commandManager).undo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: true,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                redo() {
                  __privateGet(this, _commandManager).redo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                addCommands(params) {
                  __privateGet(this, _commandManager).add(params);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: false,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                delete() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [...__privateGet(this, _selectedEditors)];
                  const cmd = () => {
                    for (const editor of editors) {
                      editor.remove();
                    }
                  };
                  const undo = () => {
                    for (const editor of editors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                copy() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (this.hasSelection) {
                    const editors = [];
                    for (const editor of __privateGet(this, _selectedEditors)) {
                      if (!editor.isEmpty()) {
                        editors.push(editor);
                      }
                    }
                    if (editors.length === 0) {
                      return;
                    }
                    __privateGet(this, _clipboardManager).copy(editors);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasEmptyClipboard: false
                    });
                  }
                }
                cut() {
                  this.copy();
                  this.delete();
                }
                paste() {
                  if (__privateGet(this, _clipboardManager).isEmpty()) {
                    return;
                  }
                  this.unselectAll();
                  const layer = __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
                  const newEditors = __privateGet(this, _clipboardManager).paste().map((data) => layer.deserialize(data));
                  const cmd = () => {
                    for (const editor of newEditors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor);
                    }
                    __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
                  };
                  const undo = () => {
                    for (const editor of newEditors) {
                      editor.remove();
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                selectAll() {
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.commit();
                  }
                  __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
                }
                unselectAll() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                    return;
                  }
                  if (__privateMethod(this, _selectEditors, selectEditors_fn).size === 0) {
                    return;
                  }
                  for (const editor of __privateGet(this, _selectedEditors)) {
                    editor.unselect();
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: false
                  });
                }
                isActive(editor) {
                  return __privateGet(this, _activeEditor) === editor;
                }
                getActive() {
                  return __privateGet(this, _activeEditor);
                }
                getMode() {
                  return __privateGet(this, _mode);
                }
              };
              let AnnotationEditorUIManager = _AnnotationEditorUIManager;
              _activeEditor = new WeakMap();
              _allEditors = new WeakMap();
              _allLayers = new WeakMap();
              _clipboardManager = new WeakMap();
              _commandManager = new WeakMap();
              _currentPageIndex = new WeakMap();
              _editorTypes = new WeakMap();
              _eventBus = new WeakMap();
              _idManager = new WeakMap();
              _isEnabled = new WeakMap();
              _mode = new WeakMap();
              _selectedEditors = new WeakMap();
              _boundKeydown = new WeakMap();
              _boundOnEditingAction = new WeakMap();
              _boundOnPageChanging = new WeakMap();
              _previousStates = new WeakMap();
              _container = new WeakMap();
              _addKeyboardManager = new WeakSet();
              addKeyboardManager_fn = function() {
                __privateGet(this, _container).addEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _removeKeyboardManager = new WeakSet();
              removeKeyboardManager_fn = function() {
                __privateGet(this, _container).removeEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _dispatchUpdateStates = new WeakSet();
              dispatchUpdateStates_fn = function(details) {
                const hasChanged = Object.entries(details).some(([key, value2]) => __privateGet(this, _previousStates)[key] !== value2);
                if (hasChanged) {
                  __privateGet(this, _eventBus).dispatch("annotationeditorstateschanged", {
                    source: this,
                    details: Object.assign(__privateGet(this, _previousStates), details)
                  });
                }
              };
              _dispatchUpdateUI = new WeakSet();
              dispatchUpdateUI_fn = function(details) {
                __privateGet(this, _eventBus).dispatch("annotationeditorparamschanged", {
                  source: this,
                  details
                });
              };
              _enableAll = new WeakSet();
              enableAll_fn = function() {
                if (!__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, true);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.enable();
                  }
                }
              };
              _disableAll = new WeakSet();
              disableAll_fn = function() {
                this.unselectAll();
                if (__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, false);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.disable();
                  }
                }
              };
              _addEditorToLayer = new WeakSet();
              addEditorToLayer_fn = function(editor) {
                const layer = __privateGet(this, _allLayers).get(editor.pageIndex);
                if (layer) {
                  layer.addOrRebuild(editor);
                } else {
                  this.addEditor(editor);
                }
              };
              _isEmpty = new WeakSet();
              isEmpty_fn = function() {
                if (__privateGet(this, _allEditors).size === 0) {
                  return true;
                }
                if (__privateGet(this, _allEditors).size === 1) {
                  for (const editor of __privateGet(this, _allEditors).values()) {
                    return editor.isEmpty();
                  }
                }
                return false;
              };
              _selectEditors = new WeakSet();
              selectEditors_fn = function(editors) {
                __privateGet(this, _selectedEditors).clear();
                for (const editor of editors) {
                  if (editor.isEmpty()) {
                    continue;
                  }
                  __privateGet(this, _selectedEditors).add(editor);
                  editor.select();
                }
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              };
              __publicField(AnnotationEditorUIManager, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], _AnnotationEditorUIManager.prototype.selectAll], [["ctrl+c", "mac+meta+c"], _AnnotationEditorUIManager.prototype.copy], [["ctrl+v", "mac+meta+v"], _AnnotationEditorUIManager.prototype.paste], [["ctrl+x", "mac+meta+x"], _AnnotationEditorUIManager.prototype.cut], [["ctrl+z", "mac+meta+z"], _AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], _AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], _AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], _AnnotationEditorUIManager.prototype.unselectAll]]));
              exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = exports2.AnnotationPrefix = void 0;
              exports2.deprecated = deprecated;
              exports2.getColorValues = getColorValues;
              exports2.getCurrentTransform = getCurrentTransform;
              exports2.getCurrentTransformInverse = getCurrentTransformInverse;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getRGB = getRGB;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              var _base_factory = __w_pdfjs_require__2(9);
              var _util2 = __w_pdfjs_require__2(1);
              const SVG_NS = "http://www.w3.org/2000/svg";
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
              const _PixelsPerInch = class {
              };
              let PixelsPerInch = _PixelsPerInch;
              __publicField(PixelsPerInch, "CSS", 96);
              __publicField(PixelsPerInch, "PDF", 72);
              __publicField(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
              exports2.PixelsPerInch = PixelsPerInch;
              class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                constructor({
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  this._document = ownerDocument;
                }
                _createCanvas(width2, height) {
                  const canvas = this._document.createElement("canvas");
                  canvas.width = width2;
                  canvas.height = height;
                  return canvas;
                }
              }
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              async function fetchData(url2, asTypedArray = false) {
                if (isValidFetchUrl(url2, document.baseURI)) {
                  const response = await fetch(url2);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url2, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
              class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url2, compressionType) {
                  return fetchData(url2, this.isCompressed).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url2) {
                  return fetchData(url2, true);
                }
              }
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                _createSVG(type2) {
                  return document.createElementNS(SVG_NS, type2);
                }
              }
              exports2.DOMSVGFactory = DOMSVGFactory;
              class PageViewport {
                constructor({
                  viewBox,
                  scale: scale4,
                  rotation,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                }) {
                  this.viewBox = viewBox;
                  this.scale = scale4;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  const centerX = (viewBox[2] + viewBox[0]) / 2;
                  const centerY = (viewBox[3] + viewBox[1]) / 2;
                  let rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  let offsetCanvasX, offsetCanvasY;
                  let width2, height;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale4 + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale4 + offsetY;
                    width2 = Math.abs(viewBox[3] - viewBox[1]) * scale4;
                    height = Math.abs(viewBox[2] - viewBox[0]) * scale4;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale4 + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale4 + offsetY;
                    width2 = Math.abs(viewBox[2] - viewBox[0]) * scale4;
                    height = Math.abs(viewBox[3] - viewBox[1]) * scale4;
                  }
                  this.transform = [rotateA * scale4, rotateB * scale4, rotateC * scale4, rotateD * scale4, offsetCanvasX - rotateA * scale4 * centerX - rotateC * scale4 * centerY, offsetCanvasY - rotateB * scale4 * centerX - rotateD * scale4 * centerY];
                  this.width = width2;
                  this.height = height;
                }
                clone({
                  scale: scale4 = this.scale,
                  rotation = this.rotation,
                  offsetX = this.offsetX,
                  offsetY = this.offsetY,
                  dontFlip = false
                } = {}) {
                  return new PageViewport({
                    viewBox: this.viewBox.slice(),
                    scale: scale4,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                convertToViewportPoint(x, y) {
                  return _util2.Util.applyTransform([x, y], this.transform);
                }
                convertToViewportRectangle(rect) {
                  const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
                convertToPdfPoint(x, y) {
                  return _util2.Util.applyInverseTransform([x, y], this.transform);
                }
              }
              exports2.PageViewport = PageViewport;
              class RenderingCancelledException extends _util2.BaseException {
                constructor(msg, type2) {
                  super(msg, "RenderingCancelledException");
                  this.type = type2;
                }
              }
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url2) {
                const ii = url2.length;
                let i = 0;
                while (i < ii && url2[i].trim() === "") {
                  i++;
                }
                return url2.substring(i, i + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url2) {
                const anchor = url2.indexOf("#");
                const query = url2.indexOf("?");
                const end = Math.min(anchor > 0 ? anchor : url2.length, query > 0 ? query : url2.length);
                return url2.substring(url2.lastIndexOf("/", end) + 1, end);
              }
              function getPdfFilenameFromUrl(url2, defaultFilename = "document.pdf") {
                if (typeof url2 !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url2)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                const splitURI = reURI.exec(url2);
                let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch (ex) {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              class StatTimer {
                constructor() {
                  this.started = /* @__PURE__ */ Object.create(null);
                  this.times = [];
                }
                time(name) {
                  if (name in this.started) {
                    (0, _util2.warn)(`Timer is already running for ${name}`);
                  }
                  this.started[name] = Date.now();
                }
                timeEnd(name) {
                  if (!(name in this.started)) {
                    (0, _util2.warn)(`Timer has not been started for ${name}`);
                  }
                  this.times.push({
                    name,
                    start: this.started[name],
                    end: Date.now()
                  });
                  delete this.started[name];
                }
                toString() {
                  const outBuf = [];
                  let longest = 0;
                  for (const time of this.times) {
                    const name = time.name;
                    if (name.length > longest) {
                      longest = name.length;
                    }
                  }
                  for (const time of this.times) {
                    const duration = time.end - time.start;
                    outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                  }
                  return outBuf.join("");
                }
              }
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url2, baseUrl) {
                try {
                  const {
                    protocol
                  } = baseUrl ? new URL(url2, baseUrl) : new URL(url2);
                  return protocol === "http:" || protocol === "https:";
                } catch (ex) {
                  return false;
                }
              }
              function loadScript(src2, removeScriptElement = false) {
                return new Promise((resolve, reject) => {
                  const script = document.createElement("script");
                  script.src = src2;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error(`Cannot load script at: ${script.src}`));
                  };
                  (document.head || document.documentElement).append(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              let pdfDateStringRegex;
              class PDFDateString {
                static toDateObject(input) {
                  if (!input || typeof input !== "string") {
                    return null;
                  }
                  if (!pdfDateStringRegex) {
                    pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                  }
                  const matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  const year = parseInt(matches[1], 10);
                  let month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  let day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  let hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  let minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  let second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  const universalTimeRelation = matches[7] || "Z";
                  let offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  let offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, {
                scale: scale4 = 1,
                rotation = 0
              }) {
                const {
                  width: width2,
                  height
                } = xfaPage.attributes.style;
                const viewBox = [0, 0, parseInt(width2), parseInt(height)];
                return new PageViewport({
                  viewBox,
                  scale: scale4,
                  rotation
                });
              }
              function getRGB(color) {
                if (color.startsWith("#")) {
                  const colorRGB = parseInt(color.slice(1), 16);
                  return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
                }
                if (color.startsWith("rgb(")) {
                  return color.slice(4, -1).split(",").map((x) => parseInt(x));
                }
                if (color.startsWith("rgba(")) {
                  return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
                }
                (0, _util2.warn)(`Not a valid color format: "${color}"`);
                return [0, 0, 0];
              }
              function getColorValues(colors) {
                const span = document.createElement("span");
                span.style.visibility = "hidden";
                document.body.append(span);
                for (const name of colors.keys()) {
                  span.style.color = name;
                  const computedColor = window.getComputedStyle(span).color;
                  colors.set(name, getRGB(computedColor));
                }
                span.remove();
              }
              function getCurrentTransform(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e,
                  f: f2
                } = ctx.getTransform();
                return [a, b, c, d, e, f2];
              }
              function getCurrentTransformInverse(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e,
                  f: f2
                } = ctx.getTransform().invertSelf();
                return [a, b, c, d, e, f2];
              }
            },
            /* 9 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseCanvasFactory {
                constructor() {
                  if (this.constructor === BaseCanvasFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                create(width2, height) {
                  if (width2 <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const canvas = this._createCanvas(width2, height);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
                reset(canvasAndContext, width2, height) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width2 <= 0 || height <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width2;
                  canvasAndContext.canvas.height = height;
                }
                destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
                _createCanvas(width2, height) {
                  (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                }
              }
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              class BaseCMapReaderFactory {
                constructor({
                  baseUrl = null,
                  isCompressed = false
                }) {
                  if (this.constructor === BaseCMapReaderFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                async fetch({
                  name
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url2 = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url2, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url2}`);
                  });
                }
                _fetchData(url2, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              class BaseStandardFontDataFactory {
                constructor({
                  baseUrl = null
                }) {
                  if (this.constructor === BaseStandardFontDataFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                async fetch({
                  filename
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                  }
                  if (!filename) {
                    throw new Error("Font filename must be specified.");
                  }
                  const url2 = `${this.baseUrl}${filename}`;
                  return this._fetchData(url2).catch((reason) => {
                    throw new Error(`Unable to load font data at: ${url2}`);
                  });
                }
                _fetchData(url2) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              class BaseSVGFactory {
                constructor() {
                  if (this.constructor === BaseSVGFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                create(width2, height, skipDimensions = false) {
                  if (width2 <= 0 || height <= 0) {
                    throw new Error("Invalid SVG dimensions");
                  }
                  const svg = this._createSVG("svg:svg");
                  svg.setAttribute("version", "1.1");
                  if (!skipDimensions) {
                    svg.setAttribute("width", `${width2}px`);
                    svg.setAttribute("height", `${height}px`);
                  }
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", `0 0 ${width2} ${height}`);
                  return svg;
                }
                createElement(type2) {
                  if (typeof type2 !== "string") {
                    throw new Error("Invalid SVG element type");
                  }
                  return this._createSVG(type2);
                }
                _createSVG(type2) {
                  (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                }
              }
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            /* 10 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length4;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length4 = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length4++] = code;
                      } else {
                        data[length4++] = code >>> 8;
                        data[length4++] = code & 255;
                      }
                    }
                  } else if ((0, _util2.isArrayBuffer)(input)) {
                    data = input.slice();
                    length4 = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length4 >> 2;
                  const tailLength = length4 - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                  return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 11 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseFontLoader {
                constructor({
                  docId,
                  onUnsupportedFeature,
                  ownerDocument = globalThis.document,
                  styleElement = null
                }) {
                  if (this.constructor === BaseFontLoader) {
                    (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                  }
                  this.docId = docId;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this._document = ownerDocument;
                  this.nativeFontFaces = [];
                  this.styleElement = null;
                }
                addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.push(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
                insertRule(rule) {
                  let styleElement = this.styleElement;
                  if (!styleElement) {
                    styleElement = this.styleElement = this._document.createElement("style");
                    styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                    this._document.documentElement.getElementsByTagName("head")[0].append(styleElement);
                  }
                  const styleSheet = styleElement.sheet;
                  styleSheet.insertRule(rule, styleSheet.cssRules.length);
                }
                clear() {
                  for (const nativeFontFace of this.nativeFontFaces) {
                    this._document.fonts.delete(nativeFontFace);
                  }
                  this.nativeFontFaces.length = 0;
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
                async bind(font2) {
                  if (font2.attached || font2.missingFile) {
                    return;
                  }
                  font2.attached = true;
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font2.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        await nativeFontFace.loaded;
                      } catch (ex) {
                        this._onUnsupportedFeature({
                          featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                        });
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font2.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule = font2.createFontFaceRule();
                  if (rule) {
                    this.insertRule(rule);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    await new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent([rule], [font2], request);
                    });
                  }
                }
                _queueLoadingCallback(callback) {
                  (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                }
                get isFontLoadingAPISupported() {
                  const hasFonts = !!this._document?.fonts;
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                }
                get isSyncFontLoadingSupported() {
                  (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                }
                get _loadTestFont() {
                  (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                }
                _prepareFontLoadEvent(rules, fontsToLoad, request) {
                  (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                }
              }
              let FontLoader;
              exports2.FontLoader = FontLoader;
              {
                exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                  constructor(params) {
                    super(params);
                    this.loadingContext = {
                      requests: [],
                      nextRequestId: 0
                    };
                    this.loadTestFontId = 0;
                  }
                  get isSyncFontLoadingSupported() {
                    let supported = false;
                    if (typeof navigator === "undefined") {
                      supported = true;
                    } else {
                      const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                      if (m?.[1] >= 14) {
                        supported = true;
                      }
                    }
                    return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                  }
                  _queueLoadingCallback(callback) {
                    function completeRequest() {
                      (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                      request.done = true;
                      while (context2.requests.length > 0 && context2.requests[0].done) {
                        const otherRequest = context2.requests.shift();
                        setTimeout(otherRequest.callback, 0);
                      }
                    }
                    const context2 = this.loadingContext;
                    const request = {
                      id: `pdfjs-font-loading-${context2.nextRequestId++}`,
                      done: false,
                      complete: completeRequest,
                      callback
                    };
                    context2.requests.push(request);
                    return request;
                  }
                  get _loadTestFont() {
                    const getLoadTestFont = function() {
                      return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                    };
                    return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                  }
                  _prepareFontLoadEvent(rules, fonts, request) {
                    function int32(data2, offset) {
                      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                    }
                    function spliceString(s, offset, remove, insert) {
                      const chunk1 = s.substring(0, offset);
                      const chunk2 = s.substring(offset + remove);
                      return chunk1 + insert + chunk2;
                    }
                    let i, ii;
                    const canvas = this._document.createElement("canvas");
                    canvas.width = 1;
                    canvas.height = 1;
                    const ctx = canvas.getContext("2d");
                    let called = 0;
                    function isFontReady(name, callback) {
                      called++;
                      if (called > 30) {
                        (0, _util2.warn)("Load test font never loaded.");
                        callback();
                        return;
                      }
                      ctx.font = "30px " + name;
                      ctx.fillText(".", 0, 20);
                      const imageData = ctx.getImageData(0, 0, 1, 1);
                      if (imageData.data[3] > 0) {
                        callback();
                        return;
                      }
                      setTimeout(isFontReady.bind(null, name, callback));
                    }
                    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                    let data = this._loadTestFont;
                    const COMMENT_OFFSET = 976;
                    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                    const CFF_CHECKSUM_OFFSET = 16;
                    const XXXX_VALUE = 1482184792;
                    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                    }
                    if (i < loadTestFontId.length) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                    }
                    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                    const url2 = `url(data:font/opentype;base64,${btoa(data)});`;
                    const rule = `@font-face {font-family:"${loadTestFontId}";src:${url2}}`;
                    this.insertRule(rule);
                    const names = [];
                    for (const font2 of fonts) {
                      names.push(font2.loadedName);
                    }
                    names.push(loadTestFontId);
                    const div2 = this._document.createElement("div");
                    div2.style.visibility = "hidden";
                    div2.style.width = div2.style.height = "10px";
                    div2.style.position = "absolute";
                    div2.style.top = div2.style.left = "0px";
                    for (const name of names) {
                      const span = this._document.createElement("span");
                      span.textContent = "Hi";
                      span.style.fontFamily = name;
                      div2.append(span);
                    }
                    this._document.body.append(div2);
                    isFontReady(loadTestFontId, () => {
                      div2.remove();
                      request.complete();
                    });
                  }
                };
              }
              class FontFaceObject {
                constructor(translatedData, {
                  isEvalSupported = true,
                  disableFontFace = false,
                  ignoreErrors = false,
                  onUnsupportedFeature,
                  fontRegistry = null
                }) {
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (const i in translatedData) {
                    this[i] = translatedData[i];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this.fontRegistry = fontRegistry;
                }
                createNativeFontFace() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  let nativeFontFace;
                  if (!this.cssFontInfo) {
                    nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  } else {
                    const css = {
                      weight: this.cssFontInfo.fontWeight
                    };
                    if (this.cssFontInfo.italicAngle) {
                      css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                    }
                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this);
                  }
                  return nativeFontFace;
                }
                createFontFaceRule() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  const data = (0, _util2.bytesToString)(this.data);
                  const url2 = `url(data:${this.mimetype};base64,${btoa(data)});`;
                  let rule;
                  if (!this.cssFontInfo) {
                    rule = `@font-face {font-family:"${this.loadedName}";src:${url2}}`;
                  } else {
                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                    if (this.cssFontInfo.italicAngle) {
                      css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                    }
                    rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url2}}`;
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this, url2);
                  }
                  return rule;
                }
                getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  let cmds;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                    });
                    (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                    return this.compiledGlyphs[character] = function(c, size) {
                    };
                  }
                  if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                    const jsBuf = [];
                    for (const current of cmds) {
                      const args = current.args !== void 0 ? current.args.join(",") : "";
                      jsBuf.push("c.", current.cmd, "(", args, ");\n");
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                  }
                  return this.compiledGlyphs[character] = function(c, size) {
                    for (const current of cmds) {
                      if (current.cmd === "scale") {
                        current.args = [size, -size];
                      }
                      c[current.cmd].apply(c, current.args);
                    }
                  };
                }
              }
              exports2.FontFaceObject = FontFaceObject;
            },
            /* 12 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _restoreInitialState, restoreInitialState_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _util2 = __w_pdfjs_require__2(1);
              var _pattern_helper = __w_pdfjs_require__2(13);
              var _image_utils = __w_pdfjs_require__2(14);
              var _is_node2 = __w_pdfjs_require__2(3);
              const MIN_FONT_SIZE = 16;
              const MAX_FONT_SIZE = 100;
              const MAX_GROUP_SIZE = 4096;
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              const MAX_SIZE_TO_COMPILE = _is_node2.isNodeJS && typeof Path2D === "undefined" ? -1 : 1e3;
              const FULL_CHUNK_HEIGHT = 16;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = () => {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x, y) {
                  destCtx.translate(x, y);
                  this.__originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  destCtx.scale(x, y);
                  this.__originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e, f2) {
                  destCtx.transform(a, b, c, d, e, f2);
                  this.__originalTransform(a, b, c, d, e, f2);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f2) {
                  destCtx.setTransform(a, b, c, d, e, f2);
                  this.__originalSetTransform(a, b, c, d, e, f2);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle2) {
                  destCtx.rotate(angle2);
                  this.__originalRotate(angle2);
                };
                ctx.clip = function ctxRotate(rule) {
                  destCtx.clip(rule);
                  this.__originalClip(rule);
                };
                ctx.moveTo = function(x, y) {
                  destCtx.moveTo(x, y);
                  this.__originalMoveTo(x, y);
                };
                ctx.lineTo = function(x, y) {
                  destCtx.lineTo(x, y);
                  this.__originalLineTo(x, y);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                };
                ctx.rect = function(x, y, width2, height) {
                  destCtx.rect(x, y, width2, height);
                  this.__originalRect(x, y, width2, height);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              class CachedCanvases {
                constructor(canvasFactory) {
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                getCanvas(id2, width2, height) {
                  let canvasEntry;
                  if (this.cache[id2] !== void 0) {
                    canvasEntry = this.cache[id2];
                    this.canvasFactory.reset(canvasEntry, width2, height);
                  } else {
                    canvasEntry = this.canvasFactory.create(width2, height);
                    this.cache[id2] = canvasEntry;
                  }
                  return canvasEntry;
                }
                delete(id2) {
                  delete this.cache[id2];
                }
                clear() {
                  for (const id2 in this.cache) {
                    const canvasEntry = this.cache[id2];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id2];
                  }
                }
              }
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                const [a, b, c, d, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
                if (b === 0 && c === 0) {
                  const tlX = destX * a + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destY * d + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destX + destW) * a + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destY + destH) * d + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a === 0 && d === 0) {
                  const tlX = destY * c + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destX * b + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destY + destH) * c + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destX + destW) * b + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rHeight, rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                const scaleX = Math.hypot(a, b);
                const scaleY = Math.hypot(c, d);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                const {
                  width: width2,
                  height
                } = imgData;
                if (width2 > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                const POINT_TO_PROCESS_LIMIT = 1e3;
                const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                const width1 = width2 + 1;
                let points = new Uint8Array(width1 * (height + 1));
                let i, j, j0;
                const lineSize = width2 + 7 & ~7;
                let data = new Uint8Array(lineSize * height), pos = 0;
                for (const elem of imgData.data) {
                  let mask = 128;
                  while (mask > 0) {
                    data[pos++] = elem & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                let count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j = 1; j < width2; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j] = 2;
                  ++count;
                }
                for (i = 1; i < height; i++) {
                  pos = i * lineSize;
                  j0 = i * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j = 1; j < width2; j++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j = 1; j < width2; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                const path = new Path2D();
                for (i = 0; count && i <= height; i++) {
                  let p = i * width1;
                  const end = p + width2;
                  while (p < end && !points[p]) {
                    p++;
                  }
                  if (p === end) {
                    continue;
                  }
                  path.moveTo(p % width1, i);
                  const p0 = p;
                  let type2 = points[p];
                  do {
                    const step = steps[type2];
                    do {
                      p += step;
                    } while (!points[p]);
                    const pp = points[p];
                    if (pp !== 5 && pp !== 10) {
                      type2 = pp;
                      points[p] = 0;
                    } else {
                      type2 = pp & 51 * type2 >> 4;
                      points[p] &= type2 >> 2 | type2 << 2;
                    }
                    path.lineTo(p % width1, p / width1 | 0);
                    if (!points[p]) {
                      --count;
                    }
                  } while (p0 !== p);
                  --i;
                }
                data = null;
                points = null;
                const drawOutline = function(c) {
                  c.save();
                  c.scale(1 / width2, -1 / height);
                  c.translate(0, -height);
                  c.fill(path);
                  c.beginPath();
                  c.restore();
                };
                return drawOutline;
              }
              class CanvasExtraState {
                constructor(width2, height) {
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = null;
                  this.startNewPathAndClipBox([0, 0, width2, height]);
                }
                clone() {
                  const clone4 = Object.create(this);
                  clone4.clipBox = this.clipBox.slice();
                  return clone4;
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
                updatePathMinMax(transform, x, y) {
                  [x, y] = _util2.Util.applyTransform([x, y], transform);
                  this.minX = Math.min(this.minX, x);
                  this.minY = Math.min(this.minY, y);
                  this.maxX = Math.max(this.maxX, x);
                  this.maxY = Math.max(this.maxY, y);
                }
                updateRectMinMax(transform, rect) {
                  const p1 = _util2.Util.applyTransform(rect, transform);
                  const p2 = _util2.Util.applyTransform(rect.slice(2), transform);
                  this.minX = Math.min(this.minX, p1[0], p2[0]);
                  this.minY = Math.min(this.minY, p1[1], p2[1]);
                  this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                  this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                }
                updateScalingPathMinMax(transform, minMax) {
                  _util2.Util.scaleMinMax(transform, minMax);
                  this.minX = Math.min(this.minX, minMax[0]);
                  this.maxX = Math.max(this.maxX, minMax[1]);
                  this.minY = Math.min(this.minY, minMax[2]);
                  this.maxY = Math.max(this.maxY, minMax[3]);
                }
                updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                  const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                  if (minMax) {
                    minMax[0] = Math.min(minMax[0], box[0], box[2]);
                    minMax[1] = Math.max(minMax[1], box[0], box[2]);
                    minMax[2] = Math.min(minMax[2], box[1], box[3]);
                    minMax[3] = Math.max(minMax[3], box[1], box[3]);
                    return;
                  }
                  this.updateRectMinMax(transform, box);
                }
                getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  const box = [this.minX, this.minY, this.maxX, this.maxY];
                  if (pathType === _pattern_helper.PathType.STROKE) {
                    if (!transform) {
                      (0, _util2.unreachable)("Stroke bounding box must include transform.");
                    }
                    const scale4 = _util2.Util.singularValueDecompose2dScale(transform);
                    const xStrokePad = scale4[0] * this.lineWidth / 2;
                    const yStrokePad = scale4[1] * this.lineWidth / 2;
                    box[0] -= xStrokePad;
                    box[1] -= yStrokePad;
                    box[2] += xStrokePad;
                    box[3] += yStrokePad;
                  }
                  return box;
                }
                updateClipFromPath() {
                  const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                  this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                }
                isEmptyClip() {
                  return this.minX === Infinity;
                }
                startNewPathAndClipBox(box) {
                  this.clipBox = box;
                  this.minX = Infinity;
                  this.minY = Infinity;
                  this.maxX = 0;
                  this.maxY = 0;
                }
                getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
                  return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
                }
              }
              function putBinaryImageData(ctx, imgData, transferMaps = null) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height = imgData.height, width2 = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width2, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src2 = imgData.data;
                const dest = chunkImgData.data;
                let i, j, thisChunkHeight, elemsInThisChunk;
                let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src2.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width2 + 7 >> 3;
                  let white = 4294967295;
                  let black = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      [white, black] = [black, white];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      const srcDiff = srcLength - srcPos;
                      let k = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width2 : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src2[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white : black;
                        dest32[destPos++] = srcByte & 64 ? white : black;
                        dest32[destPos++] = srcByte & 32 ? white : black;
                        dest32[destPos++] = srcByte & 16 ? white : black;
                        dest32[destPos++] = srcByte & 8 ? white : black;
                        dest32[destPos++] = srcByte & 4 ? white : black;
                        dest32[destPos++] = srcByte & 2 ? white : black;
                        dest32[destPos++] = srcByte & 1 ? white : black;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src2[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white : black;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width2 * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src2.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width2 * partialChunkHeight * 4;
                    dest.set(src2.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width2 * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width2 * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (hasTransferMaps) {
                      for (let k = 0; k < destPos; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                const height = imgData.height, width2 = imgData.width;
                const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
                const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width2, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src2 = imgData.data;
                const dest = chunkImgData.data;
                for (let i = 0; i < totalChunks; i++) {
                  const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  ({
                    srcPos
                  } = (0, _image_utils.applyMaskImageData)({
                    src: src2,
                    srcPos,
                    dest,
                    width: width2,
                    height: thisChunkHeight
                  }));
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (let i = 0, ii = properties.length; i < ii; i++) {
                  const property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx, foregroundColor) {
                ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length4 = bytes.length;
                for (let i = 3; i < length4; i += 4) {
                  const alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length4 = maskData.length;
                const scale4 = 1 / 255;
                for (let i = 3; i < length4; i += 4) {
                  const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale4 | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length4 = maskData.length;
                for (let i = 3; i < length4; i += 4) {
                  const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width2, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                let composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width2));
                for (let row = 0; row < height; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height - row);
                  const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width2, chunkHeight);
                  const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width2, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                const layerOffsetX = layerBox[0];
                const layerOffsetY = layerBox[1];
                const layerWidth = layerBox[2] - layerOffsetX;
                const layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform, interpolate) {
                const scale4 = _util2.Util.singularValueDecompose2dScale(transform);
                scale4[0] = Math.fround(scale4[0]);
                scale4[1] = Math.fround(scale4[1]);
                const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale4[0] <= actualScale || scale4[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              const _CanvasGraphics = class {
                constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
                  __privateAdd(this, _restoreInitialState);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.imageLayer = imageLayer;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.backgroundColor = pageColors?.background || null;
                  this.foregroundColor = pageColors?.foreground || null;
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                beginDrawing({
                  transform,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  const width2 = this.ctx.canvas.width;
                  const height = this.ctx.canvas.height;
                  const defaultBackgroundColor = background || "#ffffff";
                  this.ctx.save();
                  if (this.foregroundColor && this.backgroundColor) {
                    this.ctx.fillStyle = this.foregroundColor;
                    const fg = this.foregroundColor = this.ctx.fillStyle;
                    this.ctx.fillStyle = this.backgroundColor;
                    const bg = this.backgroundColor = this.ctx.fillStyle;
                    let isValidDefaultBg = true;
                    let defaultBg = defaultBackgroundColor;
                    this.ctx.fillStyle = defaultBackgroundColor;
                    defaultBg = this.ctx.fillStyle;
                    isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
                    if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                      this.foregroundColor = this.backgroundColor = null;
                    } else {
                      const [rB, gB, bB] = (0, _display_utils2.getRGB)(defaultBg);
                      const newComp = (x) => {
                        x /= 255;
                        return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                      };
                      const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
                      this.selectColor = (r, g, b) => {
                        const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                        return Math.round(lumC) === lumB ? bg : fg;
                      };
                    }
                  }
                  this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
                  this.ctx.fillRect(0, 0, width2, height);
                  this.ctx.restore();
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width2, height);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  if (transform) {
                    this.ctx.transform(...transform);
                    this.outputScaleX = transform[0];
                    this.outputScaleY = transform[0];
                  }
                  this.ctx.transform(...viewport.transform);
                  this.viewportScale = viewport.scale;
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (this.imageLayer) {
                    (0, _display_utils2.deprecated)("The `imageLayer` functionality will be removed in the future.");
                    this.imageLayer.beginLayout();
                  }
                }
                executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                }
                endDrawing() {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  this.cachedCanvases.clear();
                  this.cachedPatterns.clear();
                  for (const cache of this._cachedBitmapsMap.values()) {
                    for (const canvas of cache.values()) {
                      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                        canvas.width = canvas.height = 0;
                      }
                    }
                    cache.clear();
                  }
                  this._cachedBitmapsMap.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                }
                _scaleImage(img, inverseTransform) {
                  const width2 = img.width;
                  const height = img.height;
                  let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                  let paintWidth = width2, paintHeight = height;
                  let tmpCanvasId = "prescale1";
                  let tmpCanvas, tmpCtx;
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    img = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  return {
                    img,
                    paintWidth,
                    paintHeight
                  };
                }
                _createMaskCanvas(img) {
                  const ctx = this.ctx;
                  const {
                    width: width2,
                    height
                  } = img;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  let cache, cacheKey, scaled, maskCanvas;
                  if ((img.bitmap || img.data) && img.count > 1) {
                    const mainKey = img.bitmap || img.data.buffer;
                    const withoutTranslation = currentTransform.slice(0, 4);
                    cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
                    cache = this._cachedBitmapsMap.get(mainKey);
                    if (!cache) {
                      cache = /* @__PURE__ */ new Map();
                      this._cachedBitmapsMap.set(mainKey, cache);
                    }
                    const cachedImage = cache.get(cacheKey);
                    if (cachedImage && !isPatternFill) {
                      const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                      const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                      return {
                        canvas: cachedImage,
                        offsetX: offsetX2,
                        offsetY: offsetY2
                      };
                    }
                    scaled = cachedImage;
                  }
                  if (!scaled) {
                    maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width2, height);
                    putBinaryImageMask(maskCanvas.context, img);
                  }
                  let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width2, 0, 0, -1 / height, 0, 0]);
                  maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
                  const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                  const cord2 = _util2.Util.applyTransform([width2, height], maskToCanvas);
                  const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                  const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                  const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                  const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                  const fillCtx = fillCanvas.context;
                  const offsetX = Math.min(cord1[0], cord2[0]);
                  const offsetY = Math.min(cord1[1], cord2[1]);
                  fillCtx.translate(-offsetX, -offsetY);
                  fillCtx.transform(...maskToCanvas);
                  if (!scaled) {
                    scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                    scaled = scaled.img;
                    if (cache && isPatternFill) {
                      cache.set(cacheKey, scaled);
                    }
                  }
                  fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                  drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width2, height);
                  fillCtx.globalCompositeOperation = "source-in";
                  const inverse2 = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                  fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse2, _pattern_helper.PathType.FILL) : fillColor;
                  fillCtx.fillRect(0, 0, width2, height);
                  if (cache && !isPatternFill) {
                    this.cachedCanvases.delete("fillCanvas");
                    cache.set(cacheKey, fillCanvas.canvas);
                  }
                  return {
                    canvas: fillCanvas.canvas,
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY)
                  };
                }
                setLineWidth(width2) {
                  if (width2 !== this.current.lineWidth) {
                    this._cachedScaleForStroking = null;
                  }
                  this.current.lineWidth = width2;
                  this.ctx.lineWidth = width2;
                }
                setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                }
                setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (let i = 0, ii = states.length; i < ii; i++) {
                    const state = states[i];
                    const key = state[0];
                    const value2 = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value2);
                        break;
                      case "LC":
                        this.setLineCap(value2);
                        break;
                      case "LJ":
                        this.setLineJoin(value2);
                        break;
                      case "ML":
                        this.setMiterLimit(value2);
                        break;
                      case "D":
                        this.setDash(value2[0], value2[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value2);
                        break;
                      case "FL":
                        this.setFlatness(value2);
                        break;
                      case "Font":
                        this.setFont(value2[0], value2[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value2;
                        break;
                      case "SMask":
                        this.current.activeSMask = value2 ? this.tempSMask : null;
                        this.tempSMask = null;
                        this.checkSMaskState();
                        break;
                      case "TR":
                        this.current.transferMaps = value2;
                    }
                  }
                }
                get inSMaskMode() {
                  return !!this.suspendedCtx;
                }
                checkSMaskState() {
                  const inSMaskMode = this.inSMaskMode;
                  if (this.current.activeSMask && !inSMaskMode) {
                    this.beginSMaskMode();
                  } else if (!this.current.activeSMask && inSMaskMode) {
                    this.endSMaskMode();
                  }
                }
                beginSMaskMode() {
                  if (this.inSMaskMode) {
                    throw new Error("beginSMaskMode called while already in smask mode");
                  }
                  const drawnWidth = this.ctx.canvas.width;
                  const drawnHeight = this.ctx.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  this.suspendedCtx = this.ctx;
                  this.ctx = scratchCanvas.context;
                  const ctx = this.ctx;
                  ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                  copyCtxState(this.suspendedCtx, ctx);
                  mirrorContextOperations(ctx, this.suspendedCtx);
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                }
                endSMaskMode() {
                  if (!this.inSMaskMode) {
                    throw new Error("endSMaskMode called while not in smask mode");
                  }
                  this.ctx._removeMirroring();
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.ctx = this.suspendedCtx;
                  this.suspendedCtx = null;
                }
                compose(dirtyBox) {
                  if (!this.current.activeSMask) {
                    return;
                  }
                  if (!dirtyBox) {
                    dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                  } else {
                    dirtyBox[0] = Math.floor(dirtyBox[0]);
                    dirtyBox[1] = Math.floor(dirtyBox[1]);
                    dirtyBox[2] = Math.ceil(dirtyBox[2]);
                    dirtyBox[3] = Math.ceil(dirtyBox[3]);
                  }
                  const smask = this.current.activeSMask;
                  const suspendedCtx = this.suspendedCtx;
                  composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                  this.ctx.restore();
                }
                save() {
                  if (this.inSMaskMode) {
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.suspendedCtx.save();
                  } else {
                    this.ctx.save();
                  }
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  if (this.stateStack.length === 0 && this.inSMaskMode) {
                    this.endSMaskMode();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    if (this.inSMaskMode) {
                      this.suspendedCtx.restore();
                      copyCtxState(this.suspendedCtx, this.ctx);
                    } else {
                      this.ctx.restore();
                    }
                    this.checkSMaskState();
                    this.pendingClip = null;
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }
                transform(a, b, c, d, e, f2) {
                  this.ctx.transform(a, b, c, d, e, f2);
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                }
                constructPath(ops, args, minMax) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let startX, startY;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                  const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                  for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width2 = args[j++];
                        const height = args[j++];
                        const xw = x + width2;
                        const yh = y + height;
                        ctx.moveTo(x, y);
                        if (width2 === 0 || height === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        if (!isScalingMatrix) {
                          current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.curveTo:
                        startX = x;
                        startY = y;
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        startX = x;
                        startY = y;
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        startX = x;
                        startY = y;
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  if (isScalingMatrix) {
                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                  }
                  current.setCurrentPoint(x, y);
                }
                closePath() {
                  this.ctx.closePath();
                }
                stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && strokeColor?.getPattern) {
                      ctx.save();
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                      this.rescaleAndStroke(false);
                      ctx.restore();
                    } else {
                      this.rescaleAndStroke(true);
                    }
                  }
                  if (consumePath) {
                    this.consumePath(this.current.getClippedPathBoundingBox());
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    needRestore = true;
                  }
                  const intersect = this.current.getClippedPathBoundingBox();
                  if (this.contentVisible && intersect !== null) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath(intersect);
                  }
                }
                eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                }
                fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                }
                eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                }
                endPath() {
                  this.consumePath();
                }
                clip() {
                  this.pendingClip = NORMAL_CLIP;
                }
                eoClip() {
                  this.pendingClip = EO_CLIP;
                }
                beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (const path of paths) {
                    ctx.setTransform(...path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                }
                setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                }
                setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                }
                setHScale(scale4) {
                  this.current.textHScale = scale4 / 100;
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setFont(fontRefName, size) {
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size < 0) {
                    size = -size;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  const typeface = `"${name}", ${fontObj.fallbackName}`;
                  let browserFontSize = size;
                  if (size < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                }
                setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                }
                setTextRise(rise) {
                  this.current.textRise = rise;
                }
                moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                setTextMatrix(a, b, c, d, e, f2) {
                  this.current.textMatrix = [a, b, c, d, e, f2];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                paintChar(character, x, y, patternTransform) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font2 = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font2.missingFile;
                  let addToPath;
                  if (font2.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font2.getPathGenerator(this.commonObjs, character);
                  }
                  if (font2.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize);
                    if (patternTransform) {
                      ctx.setTransform(...patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: (0, _display_utils2.getCurrentTransform)(ctx),
                      x,
                      y,
                      fontSize,
                      addToPath
                    });
                  }
                }
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                }
                showText(glyphs) {
                  const current = this.current;
                  const font2 = current.font;
                  if (font2.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize = current.fontSize;
                  if (fontSize === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font2.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font2.defaultVMetrics;
                  const widthAdvanceScale = fontSize * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font2.disableFontFace && !current.patternFill;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  let lineWidth = current.lineWidth;
                  const scale4 = current.textMatrixScale;
                  if (scale4 === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      lineWidth = this.getSinglePixelWidth();
                    }
                  } else {
                    lineWidth /= scale4;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  let x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    const glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      x += spacingDir * glyph * fontSize / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width2 = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width2 * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width2 = vmetric ? -vmetric[0] : width2;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font2.remeasure && width2 > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize * fontSizeScale;
                      if (width2 < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width2 / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width2 !== measuredWidth) {
                        scaledX += (width2 - measuredWidth) / 2e3 * fontSize / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font2.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width2 * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width2 * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font2 = current.font;
                  const fontSize = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font2.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i, glyph, width2, spacingLength;
                  if (isTextInvisible || fontSize === 0) {
                    return;
                  }
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      spacingLength = spacingDir * glyph * fontSize / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font2.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize, fontSize);
                      ctx.transform(...fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width2 = transformed[0] * fontSize + spacing;
                    ctx.translate(width2, 0);
                    current.x += width2 * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                }
                setCharWidth(xWidth, yWidth) {
                }
                setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.ctx.clip();
                  this.endPath();
                }
                getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color = IR[1];
                    const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = this._getPattern(IR[1], IR[2]);
                  }
                  return pattern;
                }
                setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                }
                setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                }
                setStrokeRGBColor(r, g, b) {
                  const color = this.selectColor?.(r, g, b) || _util2.Util.makeHexColor(r, g, b);
                  this.ctx.strokeStyle = color;
                  this.current.strokeColor = color;
                }
                setFillRGBColor(r, g, b) {
                  const color = this.selectColor?.(r, g, b) || _util2.Util.makeHexColor(r, g, b);
                  this.ctx.fillStyle = color;
                  this.current.fillColor = color;
                  this.current.patternFill = false;
                }
                _getPattern(objId, matrix = null) {
                  let pattern;
                  if (this.cachedPatterns.has(objId)) {
                    pattern = this.cachedPatterns.get(objId);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
                    this.cachedPatterns.set(objId, pattern);
                  }
                  if (matrix) {
                    pattern.matrix = matrix;
                  }
                  return pattern;
                }
                shadingFill(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = this._getPattern(objId);
                  ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                  const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                  if (inv) {
                    const canvas = ctx.canvas;
                    const width2 = canvas.width;
                    const height = canvas.height;
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width2, 0], inv);
                    const ur = _util2.Util.applyTransform([width2, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.compose(this.current.getClippedPathBoundingBox());
                  this.restore();
                }
                beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                }
                beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(...matrix);
                  }
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (bbox) {
                    const width2 = bbox[2] - bbox[0];
                    const height = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width2, height);
                    this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                    this.clip();
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                }
                beginGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  if (this.inSMaskMode) {
                    this.endSMaskMode();
                    this.current.activeSMask = null;
                  }
                  const currentCtx = this.ctx;
                  if (!group.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                  if (group.matrix) {
                    currentCtx.transform(...group.matrix);
                  }
                  if (!group.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform(...currentTransform);
                  if (group.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group.smask.subtype,
                      backdrop: group.smask.backdrop,
                      transferMap: group.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                    currentCtx.save();
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                }
                endGroup(group) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  const ctx = this.groupStack.pop();
                  this.ctx = ctx;
                  this.ctx.imageSmoothingEnabled = false;
                  if (group.smask) {
                    this.tempSMask = this.smaskStack.pop();
                    this.restore();
                  } else {
                    this.ctx.restore();
                    const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    this.restore();
                    this.ctx.save();
                    this.ctx.setTransform(...currentMtx);
                    const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    this.ctx.restore();
                    this.compose(dirtyBox);
                  }
                }
                beginAnnotation(id2, rect, transform, matrix, hasOwnCanvas) {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  this.ctx.save();
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform(...this.baseTransform);
                  }
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width2 = rect[2] - rect[0];
                    const height = rect[3] - rect[1];
                    if (hasOwnCanvas && this.annotationCanvasMap) {
                      transform = transform.slice();
                      transform[4] -= rect[0];
                      transform[5] -= rect[1];
                      rect = rect.slice();
                      rect[0] = rect[1] = 0;
                      rect[2] = width2;
                      rect[3] = height;
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                      const {
                        viewportScale
                      } = this;
                      const canvasWidth = Math.ceil(width2 * this.outputScaleX * viewportScale);
                      const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                      this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                      const {
                        canvas,
                        context: context2
                      } = this.annotationCanvas;
                      this.annotationCanvasMap.set(id2, canvas);
                      this.annotationCanvas.savedCtx = this.ctx;
                      this.ctx = context2;
                      this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                    } else {
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                      this.ctx.rect(rect[0], rect[1], width2, height);
                      this.ctx.clip();
                      this.endPath();
                    }
                  }
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.transform(...transform);
                  this.transform(...matrix);
                }
                endAnnotation() {
                  if (this.annotationCanvas) {
                    this.ctx = this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas;
                  }
                }
                paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const count = img.count;
                  img = this.getObject(img.data, img);
                  img.count = count;
                  const ctx = this.ctx;
                  const glyph = this.processingType3;
                  if (glyph) {
                    if (glyph.compiled === void 0) {
                      glyph.compiled = compileType3Glyph(img);
                    }
                    if (glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                  }
                  const mask = this._createMaskCanvas(img);
                  const maskCanvas = mask.canvas;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  img = this.getObject(img.data, img);
                  const ctx = this.ctx;
                  ctx.save();
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                  const mask = this._createMaskCanvas(img);
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    const trans = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                    const [x, y] = _util2.Util.applyTransform([0, 0], trans);
                    ctx.drawImage(mask.canvas, x, y);
                  }
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (const image2 of images) {
                    const {
                      data,
                      width: width2,
                      height,
                      transform
                    } = image2;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width2, height);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    const img = this.getObject(data, image2);
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                    maskCtx.fillRect(0, 0, width2, height);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform(...transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width2, height, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width2 = imgData.width;
                  const height = imgData.height;
                  const map = [];
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width2,
                      h: height
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                }
                paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width2 = imgData.width;
                  const height = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width2, -1 / height);
                  let imgToPaint;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width2, height);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                  ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                  const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width2, height);
                  if (this.imageLayer) {
                    const [left, top] = _util2.Util.applyTransform([0, -height], (0, _display_utils2.getCurrentTransform)(this.ctx));
                    this.imageLayer.appendImage({
                      imgData,
                      left,
                      top,
                      width: rWidth,
                      height: rHeight
                    });
                  }
                  this.compose();
                  this.restore();
                }
                paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const w = imgData.width;
                  const h = imgData.height;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                  for (const entry of map) {
                    ctx.save();
                    ctx.transform(...entry.transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      const [left, top] = _util2.Util.applyTransform([entry.x, entry.y], (0, _display_utils2.getCurrentTransform)(this.ctx));
                      this.imageLayer.appendImage({
                        imgData,
                        left,
                        top,
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                  this.compose();
                }
                paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                  this.compose();
                }
                markPoint(tag2) {
                }
                markPointProps(tag2, properties) {
                }
                beginMarkedContent(tag2) {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                beginMarkedContentProps(tag2, properties) {
                  if (tag2 === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                }
                endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                }
                beginCompat() {
                }
                endCompat() {
                }
                consumePath(clipBox) {
                  const isEmpty = this.current.isEmptyClip();
                  if (this.pendingClip) {
                    this.current.updateClipFromPath();
                  }
                  if (!this.pendingClip) {
                    this.compose(clipBox);
                  }
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (!isEmpty) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                    }
                    this.pendingClip = null;
                  }
                  this.current.startNewPathAndClipBox(this.current.clipBox);
                  ctx.beginPath();
                }
                getSinglePixelWidth() {
                  if (!this._cachedGetSinglePixelWidth) {
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    if (m[1] === 0 && m[2] === 0) {
                      this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[2]);
                      const normY = Math.hypot(m[1], m[3]);
                      this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                }
                getScaleForStroking() {
                  if (!this._cachedScaleForStroking) {
                    const {
                      lineWidth
                    } = this.current;
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    let scaleX, scaleY;
                    if (m[1] === 0 && m[2] === 0) {
                      const normX = Math.abs(m[0]);
                      const normY = Math.abs(m[3]);
                      if (lineWidth === 0) {
                        scaleX = 1 / normX;
                        scaleY = 1 / normY;
                      } else {
                        const scaledXLineWidth = normX * lineWidth;
                        const scaledYLineWidth = normY * lineWidth;
                        scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                        scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                      }
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[1]);
                      const normY = Math.hypot(m[2], m[3]);
                      if (lineWidth === 0) {
                        scaleX = normY / absDet;
                        scaleY = normX / absDet;
                      } else {
                        const baseArea = lineWidth * absDet;
                        scaleX = normY > baseArea ? normY / baseArea : 1;
                        scaleY = normX > baseArea ? normX / baseArea : 1;
                      }
                    }
                    this._cachedScaleForStroking = [scaleX, scaleY];
                  }
                  return this._cachedScaleForStroking;
                }
                rescaleAndStroke(saveRestore) {
                  const {
                    ctx
                  } = this;
                  const {
                    lineWidth
                  } = this.current;
                  const [scaleX, scaleY] = this.getScaleForStroking();
                  ctx.lineWidth = lineWidth || 1;
                  if (scaleX === 1 && scaleY === 1) {
                    ctx.stroke();
                    return;
                  }
                  let savedMatrix, savedDashes, savedDashOffset;
                  if (saveRestore) {
                    savedMatrix = (0, _display_utils2.getCurrentTransform)(ctx);
                    savedDashes = ctx.getLineDash().slice();
                    savedDashOffset = ctx.lineDashOffset;
                  }
                  ctx.scale(scaleX, scaleY);
                  const scale4 = Math.max(scaleX, scaleY);
                  ctx.setLineDash(ctx.getLineDash().map((x) => x / scale4));
                  ctx.lineDashOffset /= scale4;
                  ctx.stroke();
                  if (saveRestore) {
                    ctx.setTransform(...savedMatrix);
                    ctx.setLineDash(savedDashes);
                    ctx.lineDashOffset = savedDashOffset;
                  }
                }
                isContentVisible() {
                  for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              let CanvasGraphics = _CanvasGraphics;
              _restoreInitialState = new WeakSet();
              restoreInitialState_fn = function() {
                while (this.stateStack.length || this.inSMaskMode) {
                  this.restore();
                }
                this.ctx.restore();
                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }
              };
              exports2.CanvasGraphics = CanvasGraphics;
              for (const op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _is_node2 = __w_pdfjs_require__2(3);
              const PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox || _is_node2.isNodeJS) {
                  return;
                }
                const width2 = bbox[2] - bbox[0];
                const height = bbox[3] - bbox[1];
                const region = new Path2D();
                region.rect(bbox[0], bbox[1], width2, height);
                ctx.clip(region);
              }
              class BaseShadingPattern {
                constructor() {
                  if (this.constructor === BaseShadingPattern) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                getPattern() {
                  (0, _util2.unreachable)("Abstract method `getPattern` called.");
                }
              }
              class RadialAxialShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._type = IR[1];
                  this._bbox = IR[2];
                  this._colorStops = IR[3];
                  this._p0 = IR[4];
                  this._p1 = IR[5];
                  this._r0 = IR[6];
                  this._r1 = IR[7];
                  this.matrix = null;
                }
                _createGradient(ctx) {
                  let grad;
                  if (this._type === "axial") {
                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                  } else if (this._type === "radial") {
                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                  }
                  for (const colorStop of this._colorStops) {
                    grad.addColorStop(colorStop[0], colorStop[1]);
                  }
                  return grad;
                }
                getPattern(ctx, owner, inverse2, pathType) {
                  let pattern;
                  if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                    const width2 = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                    const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width2, height, true);
                    const tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.beginPath();
                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                    inverse2 = _util2.Util.transform(inverse2, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                    tmpCtx.transform(...owner.baseTransform);
                    if (this.matrix) {
                      tmpCtx.transform(...this.matrix);
                    }
                    applyBoundingBox(tmpCtx, this._bbox);
                    tmpCtx.fillStyle = this._createGradient(tmpCtx);
                    tmpCtx.fill();
                    pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                    const domMatrix = new DOMMatrix(inverse2);
                    try {
                      pattern.setTransform(domMatrix);
                    } catch (ex) {
                      (0, _util2.warn)(`RadialAxialShadingPattern.getPattern: "${ex?.message}".`);
                    }
                  } else {
                    applyBoundingBox(ctx, this._bbox);
                    pattern = this._createGradient(ctx);
                  }
                  return pattern;
                }
              }
              function drawTriangle(data, context2, p1, p2, p3, c1, c2, c3) {
                const coords = context2.coords, colors = context2.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                const x1 = (coords[p1] + context2.offsetX) * context2.scaleX;
                const y1 = (coords[p1 + 1] + context2.offsetY) * context2.scaleY;
                const x2 = (coords[p2] + context2.offsetX) * context2.scaleX;
                const y2 = (coords[p2 + 1] + context2.offsetY) * context2.scaleY;
                const x3 = (coords[p3] + context2.offsetX) * context2.scaleX;
                const y3 = (coords[p3 + 1] + context2.offsetY) * context2.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  const x1_ = Math.round(Math.min(xa, xb));
                  const x2_ = Math.round(Math.max(xa, xb));
                  let j = rowSize * y + x1_ * 4;
                  for (let x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context2) {
                const ps = figure.coords;
                const cs = figure.colors;
                let i, ii;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      let q = i * verticesPerRow;
                      for (let j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context2, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context2, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context2, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              class MeshShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._coords = IR[2];
                  this._colors = IR[3];
                  this._figures = IR[4];
                  this._bounds = IR[5];
                  this._bbox = IR[7];
                  this._background = IR[8];
                  this.matrix = null;
                }
                _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
                  const EXPECTED_SCALE = 1.1;
                  const MAX_PATTERN_SIZE = 3e3;
                  const BORDER_SIZE = 2;
                  const offsetX = Math.floor(this._bounds[0]);
                  const offsetY = Math.floor(this._bounds[1]);
                  const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                  const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                  const width2 = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const scaleX = boundsWidth / width2;
                  const scaleY = boundsHeight / height;
                  const context2 = {
                    coords: this._coords,
                    colors: this._colors,
                    offsetX: -offsetX,
                    offsetY: -offsetY,
                    scaleX: 1 / scaleX,
                    scaleY: 1 / scaleY
                  };
                  const paddedWidth = width2 + BORDER_SIZE * 2;
                  const paddedHeight = height + BORDER_SIZE * 2;
                  const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width2, height);
                  if (backgroundColor) {
                    const bytes = data.data;
                    for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor[0];
                      bytes[i + 1] = backgroundColor[1];
                      bytes[i + 2] = backgroundColor[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (const figure of this._figures) {
                    drawFigure(data, figure, context2);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  const canvas = tmpCanvas.canvas;
                  return {
                    canvas,
                    offsetX: offsetX - BORDER_SIZE * scaleX,
                    offsetY: offsetY - BORDER_SIZE * scaleY,
                    scaleX,
                    scaleY
                  };
                }
                getPattern(ctx, owner, inverse2, pathType) {
                  applyBoundingBox(ctx, this._bbox);
                  let scale4;
                  if (pathType === PathType.SHADING) {
                    scale4 = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                  } else {
                    scale4 = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                    if (this.matrix) {
                      const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                      scale4 = [scale4[0] * matrixScale[0], scale4[1] * matrixScale[1]];
                    }
                  }
                  const temporaryPatternCanvas = this._createMeshCanvas(scale4, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                  if (pathType !== PathType.SHADING) {
                    ctx.setTransform(...owner.baseTransform);
                    if (this.matrix) {
                      ctx.transform(...this.matrix);
                    }
                  }
                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              }
              class DummyShadingPattern extends BaseShadingPattern {
                getPattern() {
                  return "hotpink";
                }
              }
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error(`Unknown IR type: ${IR[0]}`);
              }
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              class TilingPattern {
                static get MAX_PATTERN_SIZE() {
                  return (0, _util2.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
                }
                constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color);
                  let adjustedX0 = x0;
                  let adjustedY0 = y0;
                  let adjustedX1 = x1;
                  let adjustedY1 = y1;
                  if (x0 < 0) {
                    adjustedX0 = 0;
                    adjustedX1 += Math.abs(x0);
                  }
                  if (y0 < 0) {
                    adjustedY0 = 0;
                    adjustedY1 += Math.abs(y0);
                  }
                  tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  tmpCtx.save();
                  this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                  graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                  graphics.executeOperatorList(operatorList);
                  graphics.endDrawing();
                  return {
                    canvas: tmpCanvas.canvas,
                    scaleX: dimx.scale,
                    scaleY: dimy.scale,
                    offsetX: adjustedX0,
                    offsetY: adjustedY0
                  };
                }
                getSizeAndScale(step, realOutputSize, scale4) {
                  step = Math.abs(step);
                  const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                  let size = Math.ceil(step * scale4);
                  if (size >= maxSize) {
                    size = maxSize;
                  } else {
                    scale4 = size / step;
                  }
                  return {
                    scale: scale4,
                    size
                  };
                }
                clipBbox(graphics, x0, y0, x1, y1) {
                  const bboxWidth = x1 - x0;
                  const bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                  graphics.clip();
                  graphics.endPath();
                }
                setFillAndStrokeStyleToContext(graphics, paintType, color) {
                  const context2 = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context2.fillStyle = ctx.fillStyle;
                      context2.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color[0], color[1], color[2]);
                      context2.fillStyle = cssColor;
                      context2.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                }
                getPattern(ctx, owner, inverse2, pathType) {
                  let matrix = inverse2;
                  if (pathType !== PathType.SHADING) {
                    matrix = _util2.Util.transform(matrix, owner.baseTransform);
                    if (this.matrix) {
                      matrix = _util2.Util.transform(matrix, this.matrix);
                    }
                  }
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  let domMatrix = new DOMMatrix(matrix);
                  domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                  const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                  try {
                    pattern.setTransform(domMatrix);
                  } catch (ex) {
                    (0, _util2.warn)(`TilingPattern.getPattern: "${ex?.message}".`);
                  }
                  return pattern;
                }
              }
              exports2.TilingPattern = TilingPattern;
            },
            /* 14 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.applyMaskImageData = applyMaskImageData;
              var _util2 = __w_pdfjs_require__2(1);
              function applyMaskImageData({
                src: src2,
                srcPos = 0,
                dest,
                destPos = 0,
                width: width2,
                height,
                inverseDecode = false
              }) {
                const opaque = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
                const widthInSource = width2 >> 3;
                const widthRemainder = width2 & 7;
                const srcLength = src2.length;
                dest = new Uint32Array(dest.buffer);
                for (let i = 0; i < height; i++) {
                  for (const max2 = srcPos + widthInSource; srcPos < max2; srcPos++) {
                    const elem2 = srcPos < srcLength ? src2[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src2[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
            },
            /* 15 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions;
              GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
              GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
            },
            /* 16 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      this._processStreamMessage(data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      this._createStreamSink(data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = (0, _util2.createPromiseCapability)();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                _createStreamSink(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const self = this, action = this.actionHandler[data.action];
                  const streamSink = {
                    enqueue(chunk, size = 1, transfers) {
                      if (this.isCancelled) {
                        return;
                      }
                      const lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ENQUEUE,
                        streamId,
                        chunk
                      }, transfers);
                    },
                    close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CLOSE,
                        streamId
                      });
                      delete self.streamSinks[streamId];
                    },
                    error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ERROR,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    },
                    sinkCapability: (0, _util2.createPromiseCapability)(),
                    onPull: null,
                    onCancel: null,
                    isCancelled: false,
                    desiredSize: data.desiredSize,
                    ready: null
                  };
                  streamSink.sinkCapability.resolve();
                  streamSink.ready = streamSink.sinkCapability.promise;
                  this.streamSinks[streamId] = streamSink;
                  new Promise(function(resolve) {
                    resolve(action(data.data, streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                }
                _processStreamMessage(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                  switch (data.stream) {
                    case StreamKind.START_COMPLETE:
                      if (data.success) {
                        streamController.startCall.resolve();
                      } else {
                        streamController.startCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL_COMPLETE:
                      if (data.success) {
                        streamController.pullCall.resolve();
                      } else {
                        streamController.pullCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL:
                      if (!streamSink) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                        break;
                      }
                      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                        streamSink.sinkCapability.resolve();
                      }
                      streamSink.desiredSize = data.desiredSize;
                      new Promise(function(resolve) {
                        resolve(streamSink.onPull && streamSink.onPull());
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      break;
                    case StreamKind.ENQUEUE:
                      (0, _util2.assert)(streamController, "enqueue should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.controller.enqueue(data.chunk);
                      break;
                    case StreamKind.CLOSE:
                      (0, _util2.assert)(streamController, "close should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.isClosed = true;
                      streamController.controller.close();
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.ERROR:
                      (0, _util2.assert)(streamController, "error should have stream controller");
                      streamController.controller.error(wrapReason(data.reason));
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL_COMPLETE:
                      if (data.success) {
                        streamController.cancelCall.resolve();
                      } else {
                        streamController.cancelCall.reject(wrapReason(data.reason));
                      }
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL:
                      if (!streamSink) {
                        break;
                      }
                      new Promise(function(resolve) {
                        resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      streamSink.sinkCapability.reject(wrapReason(data.reason));
                      streamSink.isCancelled = true;
                      delete this.streamSinks[streamId];
                      break;
                    default:
                      throw new Error("Unexpected stream case");
                  }
                }
                async _deleteStreamController(streamController, streamId) {
                  await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                  delete this.streamControllers[streamId];
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              exports2.MessageHandler = MessageHandler;
            },
            /* 17 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _metadataMap, _data;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class Metadata {
                constructor({
                  parsedData,
                  rawData
                }) {
                  __privateAdd(this, _metadataMap, void 0);
                  __privateAdd(this, _data, void 0);
                  __privateSet(this, _metadataMap, parsedData);
                  __privateSet(this, _data, rawData);
                }
                getRaw() {
                  return __privateGet(this, _data);
                }
                get(name) {
                  return __privateGet(this, _metadataMap).get(name) ?? null;
                }
                getAll() {
                  return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
                }
                has(name) {
                  return __privateGet(this, _metadataMap).has(name);
                }
              }
              _metadataMap = new WeakMap();
              _data = new WeakMap();
              exports2.Metadata = Metadata;
            },
            /* 18 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _visible, _cachedHasInitialVisibility, _groups, _initialVisibility, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const INTERNAL = Symbol("INTERNAL");
              class OptionalContentGroup {
                constructor(name, intent) {
                  __privateAdd(this, _visible, true);
                  this.name = name;
                  this.intent = intent;
                }
                get visible() {
                  return __privateGet(this, _visible);
                }
                _setVisible(internal, visible) {
                  if (internal !== INTERNAL) {
                    (0, _util2.unreachable)("Internal method `_setVisible` called.");
                  }
                  __privateSet(this, _visible, visible);
                }
              }
              _visible = new WeakMap();
              class OptionalContentConfig {
                constructor(data) {
                  __privateAdd(this, _evaluateVisibilityExpression);
                  __privateAdd(this, _cachedHasInitialVisibility, true);
                  __privateAdd(this, _groups, /* @__PURE__ */ new Map());
                  __privateAdd(this, _initialVisibility, null);
                  __privateAdd(this, _order, null);
                  this.name = null;
                  this.creator = null;
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  __privateSet(this, _order, data.order);
                  for (const group of data.groups) {
                    __privateGet(this, _groups).set(group.id, new OptionalContentGroup(group.name, group.intent));
                  }
                  if (data.baseState === "OFF") {
                    for (const group of __privateGet(this, _groups).values()) {
                      group._setVisible(INTERNAL, false);
                    }
                  }
                  for (const on of data.on) {
                    __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
                  }
                  for (const off of data.off) {
                    __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
                  }
                  __privateSet(this, _initialVisibility, /* @__PURE__ */ new Map());
                  for (const [id2, group] of __privateGet(this, _groups)) {
                    __privateGet(this, _initialVisibility).set(id2, group.visible);
                  }
                }
                isVisible(group) {
                  if (__privateGet(this, _groups).size === 0) {
                    return true;
                  }
                  if (!group) {
                    (0, _util2.warn)("Optional content group not defined.");
                    return true;
                  }
                  if (group.type === "OCG") {
                    if (!__privateGet(this, _groups).has(group.id)) {
                      (0, _util2.warn)(`Optional content group not found: ${group.id}`);
                      return true;
                    }
                    return __privateGet(this, _groups).get(group.id).visible;
                  } else if (group.type === "OCMD") {
                    if (group.expression) {
                      return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group.expression);
                    }
                    if (!group.policy || group.policy === "AnyOn") {
                      for (const id2 of group.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id2).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOn") {
                      for (const id2 of group.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id2).visible) {
                          return false;
                        }
                      }
                      return true;
                    } else if (group.policy === "AnyOff") {
                      for (const id2 of group.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id2).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group.policy === "AllOff") {
                      for (const id2 of group.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id2).visible) {
                          return false;
                        }
                      }
                      return true;
                    }
                    (0, _util2.warn)(`Unknown optional content policy ${group.policy}.`);
                    return true;
                  }
                  (0, _util2.warn)(`Unknown group type ${group.type}.`);
                  return true;
                }
                setVisibility(id2, visible = true) {
                  if (!__privateGet(this, _groups).has(id2)) {
                    (0, _util2.warn)(`Optional content group not found: ${id2}`);
                    return;
                  }
                  __privateGet(this, _groups).get(id2)._setVisible(INTERNAL, !!visible);
                  __privateSet(this, _cachedHasInitialVisibility, null);
                }
                get hasInitialVisibility() {
                  if (__privateGet(this, _cachedHasInitialVisibility) !== null) {
                    return __privateGet(this, _cachedHasInitialVisibility);
                  }
                  for (const [id2, group] of __privateGet(this, _groups)) {
                    const visible = __privateGet(this, _initialVisibility).get(id2);
                    if (group.visible !== visible) {
                      return __privateSet(this, _cachedHasInitialVisibility, false);
                    }
                  }
                  return __privateSet(this, _cachedHasInitialVisibility, true);
                }
                getOrder() {
                  if (!__privateGet(this, _groups).size) {
                    return null;
                  }
                  if (__privateGet(this, _order)) {
                    return __privateGet(this, _order).slice();
                  }
                  return [...__privateGet(this, _groups).keys()];
                }
                getGroups() {
                  return __privateGet(this, _groups).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _groups)) : null;
                }
                getGroup(id2) {
                  return __privateGet(this, _groups).get(id2) || null;
                }
              }
              _cachedHasInitialVisibility = new WeakMap();
              _groups = new WeakMap();
              _initialVisibility = new WeakMap();
              _order = new WeakMap();
              _evaluateVisibilityExpression = new WeakSet();
              evaluateVisibilityExpression_fn = function(array) {
                const length4 = array.length;
                if (length4 < 2) {
                  return true;
                }
                const operator = array[0];
                for (let i = 1; i < length4; i++) {
                  const element = array[i];
                  let state;
                  if (Array.isArray(element)) {
                    state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
                  } else if (__privateGet(this, _groups).has(element)) {
                    state = __privateGet(this, _groups).get(element).visible;
                  } else {
                    (0, _util2.warn)(`Optional content group not found: ${element}`);
                    return true;
                  }
                  switch (operator) {
                    case "And":
                      if (!state) {
                        return false;
                      }
                      break;
                    case "Or":
                      if (state) {
                        return true;
                      }
                      break;
                    case "Not":
                      return !state;
                    default:
                      return true;
                  }
                }
                return operator === "And";
              };
              exports2.OptionalContentConfig = OptionalContentConfig;
            },
            /* 19 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              class PDFDataTransportStream {
                constructor(params, pdfDataRangeTransport) {
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = params.progressiveDone || false;
                  this._contentDispositionFilename = params.contentDispositionFilename || null;
                  const initialData = params.initialData;
                  if (initialData?.length > 0) {
                    const buffer = new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !params.disableStream;
                  this._isRangeSupported = !params.disableRange;
                  this._contentLength = params.length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                    this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                    this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                    this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                    this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _onReceiveData(args) {
                  const buffer = new Uint8Array(args.chunk).buffer;
                  if (args.begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    const found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== args.begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                _onProgress(evt) {
                  if (evt.total === void 0) {
                    const firstReader = this._rangeReaders[0];
                    if (firstReader?.onProgress) {
                      firstReader.onProgress({
                        loaded: evt.loaded
                      });
                    }
                  } else {
                    const fullReader = this._fullRequestReader;
                    if (fullReader?.onProgress) {
                      fullReader.onProgress({
                        loaded: evt.loaded,
                        total: evt.total
                      });
                    }
                  }
                }
                _onProgressiveDone() {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.progressiveDone();
                  }
                  this._progressiveDone = true;
                }
                _removeRangeReader(reader) {
                  const i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  const queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
                  this._pdfDataRangeTransport.requestDataRange(begin, end);
                  this._rangeReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                  this._pdfDataRangeTransport.abort();
                }
              }
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              class PDFDataTransportStreamReader {
                constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  for (const chunk of this._queuedChunks) {
                    this._loaded += chunk.byteLength;
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
                get headersReady() {
                  return this._headersReady;
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                }
                get contentLength() {
                  return this._stream._contentLength;
                }
                async read() {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }
              class PDFDataTransportStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    const requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._stream._removeRangeReader(this);
                }
              }
            },
            /* 20 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              class XfaText {
                static textContent(xfa) {
                  const items = [];
                  const output = {
                    items,
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  function walk(node) {
                    if (!node) {
                      return;
                    }
                    let str3 = null;
                    const name = node.name;
                    if (name === "#text") {
                      str3 = node.value;
                    } else if (!XfaText.shouldBuildText(name)) {
                      return;
                    } else if (node?.attributes?.textContent) {
                      str3 = node.attributes.textContent;
                    } else if (node.value) {
                      str3 = node.value;
                    }
                    if (str3 !== null) {
                      items.push({
                        str: str3
                      });
                    }
                    if (!node.children) {
                      return;
                    }
                    for (const child of node.children) {
                      walk(child);
                    }
                  }
                  walk(xfa);
                  return output;
                }
                static shouldBuildText(name) {
                  return !(name === "textarea" || name === "input" || name === "option" || name === "select");
                }
              }
              exports2.XfaText = XfaText;
            },
            /* 21 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(9);
              ;
              const fetchData = function(url2) {
                return new Promise((resolve, reject) => {
                  const fs = require_fs();
                  fs.readFile(url2, (error, data) => {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                _createCanvas(width2, height) {
                  const Canvas2 = require_canvas();
                  return Canvas2.createCanvas(width2, height);
                }
              }
              exports2.NodeCanvasFactory = NodeCanvasFactory;
              class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url2, compressionType) {
                  return fetchData(url2).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
              class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url2) {
                  return fetchData(url2);
                }
              }
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
            },
            /* 22 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _accessibilityManager, _allowClick, _boundPointerup, _boundPointerdown, _editors, _hadPointerDown, _isCleaningUp, _uiManager, _changeParent, changeParent_fn, _createNewEditor, createNewEditor_fn, _createAndAddNewEditor, createAndAddNewEditor_fn, _cleanup, cleanup_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayer = void 0;
              var _tools = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              var _freetext = __w_pdfjs_require__2(23);
              var _ink = __w_pdfjs_require__2(24);
              const _AnnotationEditorLayer = class {
                constructor(options) {
                  __privateAdd(this, _changeParent);
                  __privateAdd(this, _createNewEditor);
                  __privateAdd(this, _createAndAddNewEditor);
                  __privateAdd(this, _cleanup);
                  __privateAdd(this, _accessibilityManager, void 0);
                  __privateAdd(this, _allowClick, false);
                  __privateAdd(this, _boundPointerup, this.pointerup.bind(this));
                  __privateAdd(this, _boundPointerdown, this.pointerdown.bind(this));
                  __privateAdd(this, _editors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _hadPointerDown, false);
                  __privateAdd(this, _isCleaningUp, false);
                  __privateAdd(this, _uiManager, void 0);
                  if (!_AnnotationEditorLayer._initialized) {
                    _AnnotationEditorLayer._initialized = true;
                    _freetext.FreeTextEditor.initialize(options.l10n);
                    _ink.InkEditor.initialize(options.l10n);
                    options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
                  }
                  __privateSet(this, _uiManager, options.uiManager);
                  this.annotationStorage = options.annotationStorage;
                  this.pageIndex = options.pageIndex;
                  this.div = options.div;
                  __privateSet(this, _accessibilityManager, options.accessibilityManager);
                  __privateGet(this, _uiManager).addLayer(this);
                }
                updateToolbar(mode) {
                  __privateGet(this, _uiManager).updateToolbar(mode);
                }
                updateMode(mode = __privateGet(this, _uiManager).getMode()) {
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (mode === _util2.AnnotationEditorType.INK) {
                    this.addInkEditorIfNeeded(false);
                    this.disableClick();
                  } else {
                    this.enableClick();
                  }
                  __privateGet(this, _uiManager).unselectAll();
                }
                addInkEditorIfNeeded(isCommitting) {
                  if (!isCommitting && __privateGet(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                    return;
                  }
                  if (!isCommitting) {
                    for (const editor2 of __privateGet(this, _editors).values()) {
                      if (editor2.isEmpty()) {
                        editor2.setInBackground();
                        return;
                      }
                    }
                  }
                  const editor = __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, {
                    offsetX: 0,
                    offsetY: 0
                  });
                  editor.setInBackground();
                }
                setEditingState(isEditing) {
                  __privateGet(this, _uiManager).setEditingState(isEditing);
                }
                addCommands(params) {
                  __privateGet(this, _uiManager).addCommands(params);
                }
                enable() {
                  this.div.style.pointerEvents = "auto";
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.enableEditing();
                  }
                }
                disable() {
                  this.div.style.pointerEvents = "none";
                  for (const editor of __privateGet(this, _editors).values()) {
                    editor.disableEditing();
                  }
                }
                setActiveEditor(editor) {
                  const currentActive = __privateGet(this, _uiManager).getActive();
                  if (currentActive === editor) {
                    return;
                  }
                  __privateGet(this, _uiManager).setActiveEditor(editor);
                }
                enableClick() {
                  this.div.addEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.addEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                disableClick() {
                  this.div.removeEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.removeEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                attach(editor) {
                  __privateGet(this, _editors).set(editor.id, editor);
                }
                detach(editor) {
                  __privateGet(this, _editors).delete(editor.id);
                  __privateGet(this, _accessibilityManager)?.removePointerInTextLayer(editor.contentDiv);
                }
                remove(editor) {
                  __privateGet(this, _uiManager).removeEditor(editor);
                  this.detach(editor);
                  this.annotationStorage.remove(editor.id);
                  editor.div.style.display = "none";
                  setTimeout(() => {
                    editor.div.style.display = "";
                    editor.div.remove();
                    editor.isAttachedToDOM = false;
                    if (document.activeElement === document.body) {
                      __privateGet(this, _uiManager).focusMainContainer();
                    }
                  }, 0);
                  if (!__privateGet(this, _isCleaningUp)) {
                    this.addInkEditorIfNeeded(false);
                  }
                }
                add(editor) {
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor);
                  __privateGet(this, _uiManager).addEditor(editor);
                  this.attach(editor);
                  if (!editor.isAttachedToDOM) {
                    const div2 = editor.render();
                    this.div.append(div2);
                    editor.isAttachedToDOM = true;
                  }
                  this.moveEditorInDOM(editor);
                  editor.onceAdded();
                  this.addToAnnotationStorage(editor);
                }
                moveEditorInDOM(editor) {
                  __privateGet(this, _accessibilityManager)?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
                }
                addToAnnotationStorage(editor) {
                  if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {
                    this.annotationStorage.setValue(editor.id, editor);
                  }
                }
                addOrRebuild(editor) {
                  if (editor.needsToBeRebuilt()) {
                    editor.rebuild();
                  } else {
                    this.add(editor);
                  }
                }
                addANewEditor(editor) {
                  const cmd = () => {
                    this.addOrRebuild(editor);
                  };
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                addUndoableEditor(editor) {
                  const cmd = () => {
                    this.addOrRebuild(editor);
                  };
                  const undo = () => {
                    editor.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: false
                  });
                }
                getNextId() {
                  return __privateGet(this, _uiManager).getId();
                }
                deserialize(data) {
                  switch (data.annotationType) {
                    case _util2.AnnotationEditorType.FREETEXT:
                      return _freetext.FreeTextEditor.deserialize(data, this);
                    case _util2.AnnotationEditorType.INK:
                      return _ink.InkEditor.deserialize(data, this);
                  }
                  return null;
                }
                setSelected(editor) {
                  __privateGet(this, _uiManager).setSelected(editor);
                }
                toggleSelected(editor) {
                  __privateGet(this, _uiManager).toggleSelected(editor);
                }
                isSelected(editor) {
                  return __privateGet(this, _uiManager).isSelected(editor);
                }
                unselect(editor) {
                  __privateGet(this, _uiManager).unselect(editor);
                }
                pointerup(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  if (!__privateGet(this, _hadPointerDown)) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, false);
                  if (!__privateGet(this, _allowClick)) {
                    __privateSet(this, _allowClick, true);
                    return;
                  }
                  __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, event);
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, true);
                  const editor = __privateGet(this, _uiManager).getActive();
                  __privateSet(this, _allowClick, !editor || editor.isEmpty());
                }
                drop(event) {
                  const id2 = event.dataTransfer.getData("text/plain");
                  const editor = __privateGet(this, _uiManager).getEditor(id2);
                  if (!editor) {
                    return;
                  }
                  event.preventDefault();
                  event.dataTransfer.dropEffect = "move";
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor);
                  const rect = this.div.getBoundingClientRect();
                  const endX = event.clientX - rect.x;
                  const endY = event.clientY - rect.y;
                  editor.translate(endX - editor.startX, endY - editor.startY);
                  this.moveEditorInDOM(editor);
                  editor.div.focus();
                }
                dragover(event) {
                  event.preventDefault();
                }
                destroy() {
                  if (__privateGet(this, _uiManager).getActive()?.parent === this) {
                    __privateGet(this, _uiManager).setActiveEditor(null);
                  }
                  for (const editor of __privateGet(this, _editors).values()) {
                    __privateGet(this, _accessibilityManager)?.removePointerInTextLayer(editor.contentDiv);
                    editor.isAttachedToDOM = false;
                    editor.div.remove();
                    editor.parent = null;
                  }
                  this.div = null;
                  __privateGet(this, _editors).clear();
                  __privateGet(this, _uiManager).removeLayer(this);
                }
                render(parameters) {
                  this.viewport = parameters.viewport;
                  (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
                  this.setDimensions();
                  for (const editor of __privateGet(this, _uiManager).getEditors(this.pageIndex)) {
                    this.add(editor);
                  }
                  this.updateMode();
                }
                update(parameters) {
                  this.viewport = parameters.viewport;
                  this.setDimensions();
                  this.updateMode();
                }
                get scaleFactor() {
                  return this.viewport.scale;
                }
                get pageDimensions() {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const width2 = pageURx - pageLLx;
                  const height = pageURy - pageLLy;
                  return [width2, height];
                }
                get viewportBaseDimensions() {
                  const {
                    width: width2,
                    height,
                    rotation
                  } = this.viewport;
                  return rotation % 180 === 0 ? [width2, height] : [height, width2];
                }
                setDimensions() {
                  const {
                    width: width2,
                    height,
                    rotation
                  } = this.viewport;
                  const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width2) + "px", heightStr = Math.floor(height) + "px";
                  this.div.style.width = flipOrientation ? heightStr : widthStr;
                  this.div.style.height = flipOrientation ? widthStr : heightStr;
                  this.div.setAttribute("data-main-rotation", rotation);
                }
              };
              let AnnotationEditorLayer = _AnnotationEditorLayer;
              _accessibilityManager = new WeakMap();
              _allowClick = new WeakMap();
              _boundPointerup = new WeakMap();
              _boundPointerdown = new WeakMap();
              _editors = new WeakMap();
              _hadPointerDown = new WeakMap();
              _isCleaningUp = new WeakMap();
              _uiManager = new WeakMap();
              _changeParent = new WeakSet();
              changeParent_fn = function(editor) {
                if (editor.parent === this) {
                  return;
                }
                this.attach(editor);
                editor.pageIndex = this.pageIndex;
                editor.parent?.detach(editor);
                editor.parent = this;
                if (editor.div && editor.isAttachedToDOM) {
                  editor.div.remove();
                  this.div.append(editor.div);
                }
              };
              _createNewEditor = new WeakSet();
              createNewEditor_fn = function(params) {
                switch (__privateGet(this, _uiManager).getMode()) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return new _freetext.FreeTextEditor(params);
                  case _util2.AnnotationEditorType.INK:
                    return new _ink.InkEditor(params);
                }
                return null;
              };
              _createAndAddNewEditor = new WeakSet();
              createAndAddNewEditor_fn = function(event) {
                const id2 = this.getNextId();
                const editor = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                  parent: this,
                  id: id2,
                  x: event.offsetX,
                  y: event.offsetY
                });
                if (editor) {
                  this.add(editor);
                }
                return editor;
              };
              _cleanup = new WeakSet();
              cleanup_fn = function() {
                __privateSet(this, _isCleaningUp, true);
                for (const editor of __privateGet(this, _editors).values()) {
                  if (editor.isEmpty()) {
                    editor.remove();
                  }
                }
                __privateSet(this, _isCleaningUp, false);
              };
              __publicField(AnnotationEditorLayer, "_initialized", false);
              exports2.AnnotationEditorLayer = AnnotationEditorLayer;
            },
            /* 23 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundEditorDivBlur, _boundEditorDivFocus, _boundEditorDivKeydown, _color, _content, _hasAlreadyBeenCommitted, _fontSize, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FreeTextEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _tools = __w_pdfjs_require__2(7);
              var _editor = __w_pdfjs_require__2(6);
              const _FreeTextEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "freeTextEditor"
                  });
                  __privateAdd(this, _updateFontSize);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _extractText);
                  __privateAdd(this, _setEditorDimensions);
                  __privateAdd(this, _boundEditorDivBlur, this.editorDivBlur.bind(this));
                  __privateAdd(this, _boundEditorDivFocus, this.editorDivFocus.bind(this));
                  __privateAdd(this, _boundEditorDivKeydown, this.editorDivKeydown.bind(this));
                  __privateAdd(this, _color, void 0);
                  __privateAdd(this, _content, "");
                  __privateAdd(this, _hasAlreadyBeenCommitted, false);
                  __privateAdd(this, _fontSize, void 0);
                  __privateSet(this, _color, params.color || _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  __privateSet(this, _fontSize, params.fontSize || _FreeTextEditor._defaultFontSize);
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((str3) => [str3, l10n.get(str3)]));
                  const style = getComputedStyle(document.documentElement);
                  this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
                }
                static updateDefaultParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      _FreeTextEditor._defaultFontSize = value2;
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      _FreeTextEditor._defaultColor = value2;
                      break;
                  }
                }
                updateParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value2);
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value2);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color)]];
                }
                getInitialTranslation() {
                  return [-_FreeTextEditor._internalPadding * this.parent.scaleFactor, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize)) * this.parent.scaleFactor];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                enableEditMode() {
                  if (this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(false);
                  this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                  super.enableEditMode();
                  this.enableEditing();
                  this.overlayDiv.classList.remove("enabled");
                  this.editorDiv.contentEditable = true;
                  this.div.draggable = false;
                  this.editorDiv.addEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.addEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.addEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                }
                disableEditMode() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(true);
                  super.disableEditMode();
                  this.disableEditing();
                  this.overlayDiv.classList.add("enabled");
                  this.editorDiv.contentEditable = false;
                  this.div.draggable = true;
                  this.editorDiv.removeEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.removeEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.removeEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.div.focus();
                  this.isEditing = false;
                }
                focusin(event) {
                  super.focusin(event);
                  if (event.target !== this.editorDiv) {
                    this.editorDiv.focus();
                  }
                }
                onceAdded() {
                  if (this.width) {
                    return;
                  }
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                isEmpty() {
                  return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                }
                remove() {
                  this.isEditing = false;
                  this.parent.setEditingState(true);
                  super.remove();
                }
                commit() {
                  super.commit();
                  if (!__privateGet(this, _hasAlreadyBeenCommitted)) {
                    __privateSet(this, _hasAlreadyBeenCommitted, true);
                    this.parent.addUndoableEditor(this);
                  }
                  this.disableEditMode();
                  __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                }
                shouldGetKeyboardEvents() {
                  return this.isInEditMode();
                }
                dblclick(event) {
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                keydown(event) {
                  if (event.target === this.div && event.key === "Enter") {
                    this.enableEditMode();
                    this.editorDiv.focus();
                  }
                }
                editorDivKeydown(event) {
                  _FreeTextEditor._keyboardManager.exec(this, event);
                }
                editorDivFocus(event) {
                  this.isEditing = true;
                }
                editorDivBlur(event) {
                  this.isEditing = false;
                }
                disableEditing() {
                  this.editorDiv.setAttribute("role", "comment");
                  this.editorDiv.removeAttribute("aria-multiline");
                }
                enableEditing() {
                  this.editorDiv.setAttribute("role", "textbox");
                  this.editorDiv.setAttribute("aria-multiline", true);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.editorDiv = document.createElement("div");
                  this.editorDiv.className = "internal";
                  this.editorDiv.setAttribute("id", `${this.id}-editor`);
                  this.enableEditing();
                  _FreeTextEditor._l10nPromise.get("editor_free_text_aria_label").then((msg) => this.editorDiv?.setAttribute("aria-label", msg));
                  _FreeTextEditor._l10nPromise.get("free_text_default_content").then((msg) => this.editorDiv?.setAttribute("default-content", msg));
                  this.editorDiv.contentEditable = true;
                  const {
                    style
                  } = this.editorDiv;
                  style.fontSize = `calc(${__privateGet(this, _fontSize)}px * var(--scale-factor))`;
                  style.color = __privateGet(this, _color);
                  this.div.append(this.editorDiv);
                  this.overlayDiv = document.createElement("div");
                  this.overlayDiv.classList.add("overlay", "enabled");
                  this.div.append(this.overlayDiv);
                  (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    for (const line of __privateGet(this, _content).split("\n")) {
                      const div2 = document.createElement("div");
                      div2.append(line ? document.createTextNode(line) : document.createElement("br"));
                      this.editorDiv.append(div2);
                    }
                    this.div.draggable = true;
                    this.editorDiv.contentEditable = false;
                  } else {
                    this.div.draggable = false;
                    this.editorDiv.contentEditable = true;
                  }
                  return this.div;
                }
                get contentDiv() {
                  return this.editorDiv;
                }
                static deserialize(data, parent) {
                  const editor = super.deserialize(data, parent);
                  __privateSet(editor, _fontSize, data.fontSize);
                  __privateSet(editor, _color, _util2.Util.makeHexColor(...data.color));
                  __privateSet(editor, _content, data.value);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const padding = _FreeTextEditor._internalPadding * this.parent.scaleFactor;
                  const rect = this.getRect(padding, padding);
                  const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
                  return {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color,
                    fontSize: __privateGet(this, _fontSize),
                    value: __privateGet(this, _content),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let FreeTextEditor = _FreeTextEditor;
              _boundEditorDivBlur = new WeakMap();
              _boundEditorDivFocus = new WeakMap();
              _boundEditorDivKeydown = new WeakMap();
              _color = new WeakMap();
              _content = new WeakMap();
              _hasAlreadyBeenCommitted = new WeakMap();
              _fontSize = new WeakMap();
              _updateFontSize = new WeakSet();
              updateFontSize_fn = function(fontSize) {
                const setFontsize = (size) => {
                  this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
                  this.translate(0, -(size - __privateGet(this, _fontSize)) * this.parent.scaleFactor);
                  __privateSet(this, _fontSize, size);
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                };
                const savedFontsize = __privateGet(this, _fontSize);
                this.parent.addCommands({
                  cmd: () => {
                    setFontsize(fontSize);
                  },
                  undo: () => {
                    setFontsize(savedFontsize);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = __privateGet(this, _color);
                this.parent.addCommands({
                  cmd: () => {
                    __privateSet(this, _color, color);
                    this.editorDiv.style.color = color;
                  },
                  undo: () => {
                    __privateSet(this, _color, savedColor);
                    this.editorDiv.style.color = savedColor;
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _extractText = new WeakSet();
              extractText_fn = function() {
                const divs = this.editorDiv.getElementsByTagName("div");
                if (divs.length === 0) {
                  return this.editorDiv.innerText;
                }
                const buffer = [];
                for (let i = 0, ii = divs.length; i < ii; i++) {
                  const div2 = divs[i];
                  const first = div2.firstChild;
                  if (first?.nodeName === "#text") {
                    buffer.push(first.data);
                  } else {
                    buffer.push("");
                  }
                }
                return buffer.join("\n");
              };
              _setEditorDimensions = new WeakSet();
              setEditorDimensions_fn = function() {
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                const rect = this.div.getBoundingClientRect();
                this.width = rect.width / parentWidth;
                this.height = rect.height / parentHeight;
              };
              __publicField(FreeTextEditor, "_freeTextDefaultContent", "");
              __publicField(FreeTextEditor, "_l10nPromise");
              __publicField(FreeTextEditor, "_internalPadding", 0);
              __publicField(FreeTextEditor, "_defaultColor", null);
              __publicField(FreeTextEditor, "_defaultFontSize", 10);
              __publicField(FreeTextEditor, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], _FreeTextEditor.prototype.commitOrRemove]]));
              __publicField(FreeTextEditor, "_type", "freetext");
              exports2.FreeTextEditor = FreeTextEditor;
            },
            /* 24 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _aspectRatio, _baseHeight, _baseWidth, _boundCanvasPointermove, _boundCanvasPointerleave, _boundCanvasPointerup, _boundCanvasPointerdown, _disableEditing, _isCanvasInitialized, _lastPoint, _observer, _realWidth, _realHeight, _requestFrameCallback, _updateThickness, updateThickness_fn, _updateColor, updateColor_fn, _updateOpacity, updateOpacity_fn, _getInitialBBox, getInitialBBox_fn, _setStroke, setStroke_fn, _startDrawing, startDrawing_fn, _draw, draw_fn, _stopDrawing, stopDrawing_fn, _redraw, redraw_fn, _endDrawing, endDrawing_fn, _createCanvas, createCanvas_fn, _createObserver, createObserver_fn, _setCanvasDims, setCanvasDims_fn, _setScaleFactor, setScaleFactor_fn, _updateTransform, updateTransform_fn, _buildPath2D, buildPath2D_fn, _serializePaths, serializePaths_fn, _extractPointsOnBezier, extractPointsOnBezier_fn, _isAlmostFlat, isAlmostFlat_fn, _getBbox, getBbox_fn, _getPadding, getPadding_fn, _fitToContent, fitToContent_fn, _setMinDims, setMinDims_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkEditor = void 0;
              Object.defineProperty(exports2, "fitCurve", {
                enumerable: true,
                get: function() {
                  return _pdfjsFitCurve.fitCurve;
                }
              });
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(6);
              var _pdfjsFitCurve = __w_pdfjs_require__2(25);
              var _tools = __w_pdfjs_require__2(7);
              const RESIZER_SIZE = 16;
              const _InkEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "inkEditor"
                  });
                  __privateAdd(this, _updateThickness);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _updateOpacity);
                  __privateAdd(this, _getInitialBBox);
                  __privateAdd(this, _setStroke);
                  __privateAdd(this, _startDrawing);
                  __privateAdd(this, _draw);
                  __privateAdd(this, _stopDrawing);
                  __privateAdd(this, _redraw);
                  __privateAdd(this, _endDrawing);
                  __privateAdd(this, _createCanvas);
                  __privateAdd(this, _createObserver);
                  __privateAdd(this, _setCanvasDims);
                  __privateAdd(this, _setScaleFactor);
                  __privateAdd(this, _updateTransform);
                  __privateAdd(this, _serializePaths);
                  __privateAdd(this, _extractPointsOnBezier);
                  __privateAdd(this, _isAlmostFlat);
                  __privateAdd(this, _getBbox);
                  __privateAdd(this, _getPadding);
                  __privateAdd(this, _fitToContent);
                  __privateAdd(this, _setMinDims);
                  __privateAdd(this, _aspectRatio, 0);
                  __privateAdd(this, _baseHeight, 0);
                  __privateAdd(this, _baseWidth, 0);
                  __privateAdd(this, _boundCanvasPointermove, this.canvasPointermove.bind(this));
                  __privateAdd(this, _boundCanvasPointerleave, this.canvasPointerleave.bind(this));
                  __privateAdd(this, _boundCanvasPointerup, this.canvasPointerup.bind(this));
                  __privateAdd(this, _boundCanvasPointerdown, this.canvasPointerdown.bind(this));
                  __privateAdd(this, _disableEditing, false);
                  __privateAdd(this, _isCanvasInitialized, false);
                  __privateAdd(this, _lastPoint, null);
                  __privateAdd(this, _observer, null);
                  __privateAdd(this, _realWidth, 0);
                  __privateAdd(this, _realHeight, 0);
                  __privateAdd(this, _requestFrameCallback, null);
                  this.color = params.color || null;
                  this.thickness = params.thickness || null;
                  this.opacity = params.opacity || null;
                  this.paths = [];
                  this.bezierPath2D = [];
                  this.currentPath = [];
                  this.scaleFactor = 1;
                  this.translationX = this.translationY = 0;
                  this.x = 0;
                  this.y = 0;
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((str3) => [str3, l10n.get(str3)]));
                }
                static updateDefaultParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      _InkEditor._defaultThickness = value2;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      _InkEditor._defaultColor = value2;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      _InkEditor._defaultOpacity = value2 / 100;
                      break;
                  }
                }
                updateParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value2);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value2);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      __privateMethod(this, _updateOpacity, updateOpacity_fn).call(this, value2);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(_InkEditor._defaultOpacity * 100)]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.canvas) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                    __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  }
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                }
                remove() {
                  if (this.canvas === null) {
                    return;
                  }
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.canvas.width = this.canvas.height = 0;
                  this.canvas.remove();
                  this.canvas = null;
                  __privateGet(this, _observer).disconnect();
                  __privateSet(this, _observer, null);
                  super.remove();
                }
                enableEditMode() {
                  if (__privateGet(this, _disableEditing) || this.canvas === null) {
                    return;
                  }
                  super.enableEditMode();
                  this.div.draggable = false;
                  this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                  this.canvas.addEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                }
                disableEditMode() {
                  if (!this.isInEditMode() || this.canvas === null) {
                    return;
                  }
                  super.disableEditMode();
                  this.div.draggable = !this.isEmpty();
                  this.div.classList.remove("editing");
                  this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                  this.canvas.removeEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                }
                onceAdded() {
                  this.div.draggable = !this.isEmpty();
                }
                isEmpty() {
                  return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                }
                commit() {
                  if (__privateGet(this, _disableEditing)) {
                    return;
                  }
                  super.commit();
                  this.isEditing = false;
                  this.disableEditMode();
                  this.setInForeground();
                  __privateSet(this, _disableEditing, true);
                  this.div.classList.add("disabled");
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this, true);
                  this.parent.addInkEditorIfNeeded(true);
                  this.parent.moveEditorInDOM(this);
                  this.div.focus();
                }
                focusin(event) {
                  super.focusin(event);
                  this.enableEditMode();
                }
                canvasPointerdown(event) {
                  if (event.button !== 0 || !this.isInEditMode() || __privateGet(this, _disableEditing)) {
                    return;
                  }
                  this.setInForeground();
                  if (event.type !== "mouse") {
                    this.div.focus();
                  }
                  event.stopPropagation();
                  this.canvas.addEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                  this.canvas.addEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                  __privateMethod(this, _startDrawing, startDrawing_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointermove(event) {
                  event.stopPropagation();
                  __privateMethod(this, _draw, draw_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointerup(event) {
                  if (event.button !== 0) {
                    return;
                  }
                  if (this.isInEditMode() && this.currentPath.length !== 0) {
                    event.stopPropagation();
                    __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                    this.setInBackground();
                  }
                }
                canvasPointerleave(event) {
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                  this.setInBackground();
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  _InkEditor._l10nPromise.get("editor_ink_aria_label").then((msg) => this.div?.setAttribute("aria-label", msg));
                  const [x, y, w, h] = __privateMethod(this, _getInitialBBox, getInitialBBox_fn).call(this);
                  this.setAt(x, y, 0, 0);
                  this.setDims(w, h);
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    __privateSet(this, _isCanvasInitialized, true);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                    this.setDims(this.width * parentWidth, this.height * parentHeight);
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                    __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                    this.div.classList.add("disabled");
                  } else {
                    this.div.classList.add("editing");
                    this.enableEditMode();
                  }
                  __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  return this.div;
                }
                setDimensions(width2, height) {
                  const roundedWidth = Math.round(width2);
                  const roundedHeight = Math.round(height);
                  if (__privateGet(this, _realWidth) === roundedWidth && __privateGet(this, _realHeight) === roundedHeight) {
                    return;
                  }
                  __privateSet(this, _realWidth, roundedWidth);
                  __privateSet(this, _realHeight, roundedHeight);
                  this.canvas.style.visibility = "hidden";
                  if (__privateGet(this, _aspectRatio) && Math.abs(__privateGet(this, _aspectRatio) - width2 / height) > 0.01) {
                    height = Math.ceil(width2 / __privateGet(this, _aspectRatio));
                    this.setDims(width2, height);
                  }
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.width = width2 / parentWidth;
                  this.height = height / parentHeight;
                  if (__privateGet(this, _disableEditing)) {
                    __privateMethod(this, _setScaleFactor, setScaleFactor_fn).call(this, width2, height);
                  }
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  this.canvas.style.visibility = "visible";
                }
                static deserialize(data, parent) {
                  var _a, _b;
                  const editor = super.deserialize(data, parent);
                  editor.thickness = data.thickness;
                  editor.color = _util2.Util.makeHexColor(...data.color);
                  editor.opacity = data.opacity;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const width2 = editor.width * pageWidth;
                  const height = editor.height * pageHeight;
                  const scaleFactor = parent.scaleFactor;
                  const padding = data.thickness / 2;
                  __privateSet(editor, _aspectRatio, width2 / height);
                  __privateSet(editor, _disableEditing, true);
                  __privateSet(editor, _realWidth, Math.round(width2));
                  __privateSet(editor, _realHeight, Math.round(height));
                  for (const {
                    bezier: bezier2
                  } of data.paths) {
                    const path = [];
                    editor.paths.push(path);
                    let p0 = scaleFactor * (bezier2[0] - padding);
                    let p1 = scaleFactor * (height - bezier2[1] - padding);
                    for (let i = 2, ii = bezier2.length; i < ii; i += 6) {
                      const p10 = scaleFactor * (bezier2[i] - padding);
                      const p11 = scaleFactor * (height - bezier2[i + 1] - padding);
                      const p20 = scaleFactor * (bezier2[i + 2] - padding);
                      const p21 = scaleFactor * (height - bezier2[i + 3] - padding);
                      const p30 = scaleFactor * (bezier2[i + 4] - padding);
                      const p31 = scaleFactor * (height - bezier2[i + 5] - padding);
                      path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                      p0 = p30;
                      p1 = p31;
                    }
                    const path2D = __privateMethod(this, _buildPath2D, buildPath2D_fn).call(this, path);
                    editor.bezierPath2D.push(path2D);
                  }
                  const bbox = __privateMethod(_a = editor, _getBbox, getBbox_fn).call(_a);
                  __privateSet(editor, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                  __privateSet(editor, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                  __privateMethod(_b = editor, _setScaleFactor, setScaleFactor_fn).call(_b, width2, height);
                  return editor;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const rect = this.getRect(0, 0);
                  const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];
                  const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                  return {
                    annotationType: _util2.AnnotationEditorType.INK,
                    color,
                    thickness: this.thickness,
                    opacity: this.opacity,
                    paths: __privateMethod(this, _serializePaths, serializePaths_fn).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let InkEditor = _InkEditor;
              _aspectRatio = new WeakMap();
              _baseHeight = new WeakMap();
              _baseWidth = new WeakMap();
              _boundCanvasPointermove = new WeakMap();
              _boundCanvasPointerleave = new WeakMap();
              _boundCanvasPointerup = new WeakMap();
              _boundCanvasPointerdown = new WeakMap();
              _disableEditing = new WeakMap();
              _isCanvasInitialized = new WeakMap();
              _lastPoint = new WeakMap();
              _observer = new WeakMap();
              _realWidth = new WeakMap();
              _realHeight = new WeakMap();
              _requestFrameCallback = new WeakMap();
              _updateThickness = new WeakSet();
              updateThickness_fn = function(thickness) {
                const savedThickness = this.thickness;
                this.parent.addCommands({
                  cmd: () => {
                    this.thickness = thickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  undo: () => {
                    this.thickness = savedThickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color) {
                const savedColor = this.color;
                this.parent.addCommands({
                  cmd: () => {
                    this.color = color;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.color = savedColor;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateOpacity = new WeakSet();
              updateOpacity_fn = function(opacity2) {
                opacity2 /= 100;
                const savedOpacity = this.opacity;
                this.parent.addCommands({
                  cmd: () => {
                    this.opacity = opacity2;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.opacity = savedOpacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _getInitialBBox = new WeakSet();
              getInitialBBox_fn = function() {
                const {
                  width: width2,
                  height,
                  rotation
                } = this.parent.viewport;
                switch (rotation) {
                  case 90:
                    return [0, width2, width2, height];
                  case 180:
                    return [width2, height, width2, height];
                  case 270:
                    return [height, 0, width2, height];
                  default:
                    return [0, 0, width2, height];
                }
              };
              _setStroke = new WeakSet();
              setStroke_fn = function() {
                this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;
                this.ctx.lineCap = "round";
                this.ctx.lineJoin = "round";
                this.ctx.miterLimit = 10;
                this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;
              };
              _startDrawing = new WeakSet();
              startDrawing_fn = function(x, y) {
                this.isEditing = true;
                if (!__privateGet(this, _isCanvasInitialized)) {
                  __privateSet(this, _isCanvasInitialized, true);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  this.thickness ||= _InkEditor._defaultThickness;
                  this.color ||= _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
                  this.opacity ??= _InkEditor._defaultOpacity;
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _lastPoint, null);
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                __privateSet(this, _requestFrameCallback, () => {
                  if (!__privateGet(this, _requestFrameCallback)) {
                    return;
                  }
                  if (__privateGet(this, _lastPoint)) {
                    if (this.isEmpty()) {
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } else {
                      __privateMethod(this, _redraw, redraw_fn).call(this);
                    }
                    this.ctx.lineTo(...__privateGet(this, _lastPoint));
                    __privateSet(this, _lastPoint, null);
                    this.ctx.stroke();
                  }
                  window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
                });
                window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
              };
              _draw = new WeakSet();
              draw_fn = function(x, y) {
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x === lastX && y === lastY) {
                  return;
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _lastPoint, [x, y]);
              };
              _stopDrawing = new WeakSet();
              stopDrawing_fn = function(x, y) {
                var _a;
                this.ctx.closePath();
                __privateSet(this, _requestFrameCallback, null);
                x = Math.min(Math.max(x, 0), this.canvas.width);
                y = Math.min(Math.max(y, 0), this.canvas.height);
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x !== lastX || y !== lastY) {
                  this.currentPath.push([x, y]);
                }
                let bezier2;
                if (this.currentPath.length !== 1) {
                  bezier2 = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);
                } else {
                  const xy = [x, y];
                  bezier2 = [[xy, xy.slice(), xy.slice(), xy]];
                }
                const path2D = __privateMethod(_a = _InkEditor, _buildPath2D, buildPath2D_fn).call(_a, bezier2);
                this.currentPath.length = 0;
                const cmd = () => {
                  this.paths.push(bezier2);
                  this.bezierPath2D.push(path2D);
                  this.rebuild();
                };
                const undo = () => {
                  this.paths.pop();
                  this.bezierPath2D.pop();
                  if (this.paths.length === 0) {
                    this.remove();
                  } else {
                    if (!this.canvas) {
                      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                      __privateMethod(this, _createObserver, createObserver_fn).call(this);
                    }
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  }
                };
                this.parent.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              };
              _redraw = new WeakSet();
              redraw_fn = function() {
                if (this.isEmpty()) {
                  __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                  return;
                }
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                const {
                  canvas,
                  ctx
                } = this;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
              };
              _endDrawing = new WeakSet();
              endDrawing_fn = function(event) {
                __privateMethod(this, _stopDrawing, stopDrawing_fn).call(this, event.offsetX, event.offsetY);
                this.canvas.removeEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.removeEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.parent.addToAnnotationStorage(this);
              };
              _createCanvas = new WeakSet();
              createCanvas_fn = function() {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.canvas.height = 0;
                this.canvas.className = "inkEditorCanvas";
                _InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => this.canvas?.setAttribute("aria-label", msg));
                this.div.append(this.canvas);
                this.ctx = this.canvas.getContext("2d");
              };
              _createObserver = new WeakSet();
              createObserver_fn = function() {
                __privateSet(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    this.setDimensions(rect.width, rect.height);
                  }
                }));
                __privateGet(this, _observer).observe(this.div);
              };
              _setCanvasDims = new WeakSet();
              setCanvasDims_fn = function() {
                if (!__privateGet(this, _isCanvasInitialized)) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.canvas.width = Math.ceil(this.width * parentWidth);
                this.canvas.height = Math.ceil(this.height * parentHeight);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
              };
              _setScaleFactor = new WeakSet();
              setScaleFactor_fn = function(width2, height) {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                const scaleFactorW = (width2 - padding) / __privateGet(this, _baseWidth);
                const scaleFactorH = (height - padding) / __privateGet(this, _baseHeight);
                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
              };
              _updateTransform = new WeakSet();
              updateTransform_fn = function() {
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this) / 2;
                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
              };
              _buildPath2D = new WeakSet();
              buildPath2D_fn = function(bezier2) {
                const path2D = new Path2D();
                for (let i = 0, ii = bezier2.length; i < ii; i++) {
                  const [first, control1, control2, second] = bezier2[i];
                  if (i === 0) {
                    path2D.moveTo(...first);
                  }
                  path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
                }
                return path2D;
              };
              _serializePaths = new WeakSet();
              serializePaths_fn = function(s, tx, ty, h) {
                const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;
                const paths = [];
                const padding = this.thickness / 2;
                let buffer, points;
                for (const bezier2 of this.paths) {
                  buffer = [];
                  points = [];
                  for (let i = 0, ii = bezier2.length; i < ii; i++) {
                    const [first, control1, control2, second] = bezier2[i];
                    const p10 = s * (first[0] + tx) + padding;
                    const p11 = h - s * (first[1] + ty) - padding;
                    const p20 = s * (control1[0] + tx) + padding;
                    const p21 = h - s * (control1[1] + ty) - padding;
                    const p30 = s * (control2[0] + tx) + padding;
                    const p31 = h - s * (control2[1] + ty) - padding;
                    const p40 = s * (second[0] + tx) + padding;
                    const p41 = h - s * (second[1] + ty) - padding;
                    if (i === 0) {
                      buffer.push(p10, p11);
                      points.push(p10, p11);
                    }
                    buffer.push(p20, p21, p30, p31, p40, p41);
                    __privateMethod(this, _extractPointsOnBezier, extractPointsOnBezier_fn).call(this, p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);
                  }
                  paths.push({
                    bezier: buffer,
                    points
                  });
                }
                return paths;
              };
              _extractPointsOnBezier = new WeakSet();
              extractPointsOnBezier_fn = function(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {
                if (__privateMethod(this, _isAlmostFlat, isAlmostFlat_fn).call(this, p10, p11, p20, p21, p30, p31, p40, p41)) {
                  points.push(p40, p41);
                  return;
                }
                for (let i = 1; i < n - 1; i++) {
                  const t2 = i / n;
                  const mt = 1 - t2;
                  let q10 = t2 * p10 + mt * p20;
                  let q11 = t2 * p11 + mt * p21;
                  let q20 = t2 * p20 + mt * p30;
                  let q21 = t2 * p21 + mt * p31;
                  const q30 = t2 * p30 + mt * p40;
                  const q31 = t2 * p31 + mt * p41;
                  q10 = t2 * q10 + mt * q20;
                  q11 = t2 * q11 + mt * q21;
                  q20 = t2 * q20 + mt * q30;
                  q21 = t2 * q21 + mt * q31;
                  q10 = t2 * q10 + mt * q20;
                  q11 = t2 * q11 + mt * q21;
                  points.push(q10, q11);
                }
                points.push(p40, p41);
              };
              _isAlmostFlat = new WeakSet();
              isAlmostFlat_fn = function(p10, p11, p20, p21, p30, p31, p40, p41) {
                const tol = 10;
                const ax = (3 * p20 - 2 * p10 - p40) ** 2;
                const ay = (3 * p21 - 2 * p11 - p41) ** 2;
                const bx = (3 * p30 - p10 - 2 * p40) ** 2;
                const by = (3 * p31 - p11 - 2 * p41) ** 2;
                return Math.max(ax, bx) + Math.max(ay, by) <= tol;
              };
              _getBbox = new WeakSet();
              getBbox_fn = function() {
                let xMin = Infinity;
                let xMax = -Infinity;
                let yMin = Infinity;
                let yMax = -Infinity;
                for (const path of this.paths) {
                  for (const [first, control1, control2, second] of path) {
                    const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                    xMin = Math.min(xMin, bbox[0]);
                    yMin = Math.min(yMin, bbox[1]);
                    xMax = Math.max(xMax, bbox[2]);
                    yMax = Math.max(yMax, bbox[3]);
                  }
                }
                return [xMin, yMin, xMax, yMax];
              };
              _getPadding = new WeakSet();
              getPadding_fn = function() {
                return __privateGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
              };
              _fitToContent = new WeakSet();
              fitToContent_fn = function(firstTime = false) {
                if (this.isEmpty()) {
                  return;
                }
                if (!__privateGet(this, _disableEditing)) {
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  return;
                }
                const bbox = __privateMethod(this, _getBbox, getBbox_fn).call(this);
                const padding = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                __privateSet(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                __privateSet(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                const width2 = Math.ceil(padding + __privateGet(this, _baseWidth) * this.scaleFactor);
                const height = Math.ceil(padding + __privateGet(this, _baseHeight) * this.scaleFactor);
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.width = width2 / parentWidth;
                this.height = height / parentHeight;
                __privateSet(this, _aspectRatio, width2 / height);
                __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                const prevTranslationX = this.translationX;
                const prevTranslationY = this.translationY;
                this.translationX = -bbox[0];
                this.translationY = -bbox[1];
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                __privateMethod(this, _redraw, redraw_fn).call(this);
                __privateSet(this, _realWidth, width2);
                __privateSet(this, _realHeight, height);
                this.setDims(width2, height);
                const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
              };
              _setMinDims = new WeakSet();
              setMinDims_fn = function() {
                const {
                  style
                } = this.div;
                if (__privateGet(this, _aspectRatio) >= 1) {
                  style.minHeight = `${RESIZER_SIZE}px`;
                  style.minWidth = `${Math.round(__privateGet(this, _aspectRatio) * RESIZER_SIZE)}px`;
                } else {
                  style.minWidth = `${RESIZER_SIZE}px`;
                  style.minHeight = `${Math.round(RESIZER_SIZE / __privateGet(this, _aspectRatio))}px`;
                }
              };
              __privateAdd(InkEditor, _buildPath2D);
              __publicField(InkEditor, "_defaultColor", null);
              __publicField(InkEditor, "_defaultOpacity", 1);
              __publicField(InkEditor, "_defaultThickness", 1);
              __publicField(InkEditor, "_l10nPromise");
              __publicField(InkEditor, "_type", "ink");
              exports2.InkEditor = InkEditor;
            },
            /* 25 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.fitCurve = void 0;
              const fitCurve = __w_pdfjs_require__2(26);
              exports2.fitCurve = fitCurve;
            },
            /* 26 */
            /***/
            (module2) => {
              function fitCurve(points, maxError, progressCallback) {
                if (!Array.isArray(points)) {
                  throw new TypeError("First argument should be an array");
                }
                points.forEach((point) => {
                  if (!Array.isArray(point) || point.some((item) => typeof item !== "number") || point.length !== points[0].length) {
                    throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
                  }
                });
                points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));
                if (points.length < 2) {
                  return [];
                }
                const len3 = points.length;
                const leftTangent = createTangent(points[1], points[0]);
                const rightTangent = createTangent(points[len3 - 2], points[len3 - 1]);
                return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
              }
              function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
                const MaxIterations = 20;
                var bezCurve, u2, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist2, i;
                if (points.length === 2) {
                  dist2 = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
                  bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist2)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist2)), points[1]];
                  return [bezCurve];
                }
                u2 = chordLengthParameterize(points);
                [bezCurve, maxError, splitPoint] = generateAndReport(points, u2, u2, leftTangent, rightTangent, progressCallback);
                if (maxError === 0 || maxError < error) {
                  return [bezCurve];
                }
                if (maxError < error * error) {
                  uPrime = u2;
                  prevErr = maxError;
                  prevSplit = splitPoint;
                  for (i = 0; i < MaxIterations; i++) {
                    uPrime = reparameterize(bezCurve, points, uPrime);
                    [bezCurve, maxError, splitPoint] = generateAndReport(points, u2, uPrime, leftTangent, rightTangent, progressCallback);
                    if (maxError < error) {
                      return [bezCurve];
                    } else if (splitPoint === prevSplit) {
                      let errChange = maxError / prevErr;
                      if (errChange > 0.9999 && errChange < 1.0001) {
                        break;
                      }
                    }
                    prevErr = maxError;
                    prevSplit = splitPoint;
                  }
                }
                beziers = [];
                centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
                if (centerVector.every((val) => val === 0)) {
                  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
                  [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
                }
                toCenterTangent = maths.normalize(centerVector);
                fromCenterTangent = maths.mulItems(toCenterTangent, -1);
                beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
                beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
                return beziers;
              }
              ;
              function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
                var bezCurve, maxError, splitPoint;
                bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
                [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);
                if (progressCallback) {
                  progressCallback({
                    bez: bezCurve,
                    points,
                    params: paramsOrig,
                    maxErr: maxError,
                    maxPoint: splitPoint
                  });
                }
                return [bezCurve, maxError, splitPoint];
              }
              function generateBezier(points, parameters, leftTangent, rightTangent) {
                var bezCurve, A, a, C, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len3, tmp, u2, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
                bezCurve = [firstPoint, null, null, lastPoint];
                A = maths.zeros_Xx2x2(parameters.length);
                for (i = 0, len3 = parameters.length; i < len3; i++) {
                  u2 = parameters[i];
                  ux = 1 - u2;
                  a = A[i];
                  a[0] = maths.mulItems(leftTangent, 3 * u2 * (ux * ux));
                  a[1] = maths.mulItems(rightTangent, 3 * ux * (u2 * u2));
                }
                C = [[0, 0], [0, 0]];
                X = [0, 0];
                for (i = 0, len3 = points.length; i < len3; i++) {
                  u2 = parameters[i];
                  a = A[i];
                  C[0][0] += maths.dot(a[0], a[0]);
                  C[0][1] += maths.dot(a[0], a[1]);
                  C[1][0] += maths.dot(a[0], a[1]);
                  C[1][1] += maths.dot(a[1], a[1]);
                  tmp = maths.subtract(points[i], bezier2.q([firstPoint, firstPoint, lastPoint, lastPoint], u2));
                  X[0] += maths.dot(a[0], tmp);
                  X[1] += maths.dot(a[1], tmp);
                }
                det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
                det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
                det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
                alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
                alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
                segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
                epsilon = 1e-6 * segLength;
                if (alpha_l < epsilon || alpha_r < epsilon) {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
                } else {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
                }
                return bezCurve;
              }
              ;
              function reparameterize(bezier3, points, parameters) {
                return parameters.map((p, i) => newtonRaphsonRootFind(bezier3, points[i], p));
              }
              ;
              function newtonRaphsonRootFind(bez, point, u2) {
                var d = maths.subtract(bezier2.q(bez, u2), point), qprime = bezier2.qprime(bez, u2), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier2.qprimeprime(bez, u2));
                if (denominator === 0) {
                  return u2;
                } else {
                  return u2 - numerator / denominator;
                }
              }
              ;
              function chordLengthParameterize(points) {
                var u2 = [], currU, prevU, prevP;
                points.forEach((p, i) => {
                  currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
                  u2.push(currU);
                  prevU = currU;
                  prevP = p;
                });
                u2 = u2.map((x) => x / prevU);
                return u2;
              }
              ;
              function computeMaxError(points, bez, parameters) {
                var dist2, maxDist, splitPoint, v, i, count, point, t2;
                maxDist = 0;
                splitPoint = Math.floor(points.length / 2);
                const t_distMap = mapTtoRelativeDistances(bez, 10);
                for (i = 0, count = points.length; i < count; i++) {
                  point = points[i];
                  t2 = find_t(bez, parameters[i], t_distMap, 10);
                  v = maths.subtract(bezier2.q(bez, t2), point);
                  dist2 = v[0] * v[0] + v[1] * v[1];
                  if (dist2 > maxDist) {
                    maxDist = dist2;
                    splitPoint = i;
                  }
                }
                return [maxDist, splitPoint];
              }
              ;
              var mapTtoRelativeDistances = function(bez, B_parts) {
                var B_t_curr;
                var B_t_dist = [0];
                var B_t_prev = bez[0];
                var sumLen = 0;
                for (var i = 1; i <= B_parts; i++) {
                  B_t_curr = bezier2.q(bez, i / B_parts);
                  sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
                  B_t_dist.push(sumLen);
                  B_t_prev = B_t_curr;
                }
                B_t_dist = B_t_dist.map((x) => x / sumLen);
                return B_t_dist;
              };
              function find_t(bez, param, t_distMap, B_parts) {
                if (param < 0) {
                  return 0;
                }
                if (param > 1) {
                  return 1;
                }
                var lenMax, lenMin, tMax, tMin, t2;
                for (var i = 1; i <= B_parts; i++) {
                  if (param <= t_distMap[i]) {
                    tMin = (i - 1) / B_parts;
                    tMax = i / B_parts;
                    lenMin = t_distMap[i - 1];
                    lenMax = t_distMap[i];
                    t2 = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
                    break;
                  }
                }
                return t2;
              }
              function createTangent(pointA, pointB) {
                return maths.normalize(maths.subtract(pointA, pointB));
              }
              class maths {
                static zeros_Xx2x2(x) {
                  var zs = [];
                  while (x--) {
                    zs.push([0, 0]);
                  }
                  return zs;
                }
                static mulItems(items, multiplier) {
                  return items.map((x) => x * multiplier);
                }
                static mulMatrix(m1, m2) {
                  return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);
                }
                static subtract(arr1, arr2) {
                  return arr1.map((x1, i) => x1 - arr2[i]);
                }
                static addArrays(arr1, arr2) {
                  return arr1.map((x1, i) => x1 + arr2[i]);
                }
                static addItems(items, addition) {
                  return items.map((x) => x + addition);
                }
                static sum(items) {
                  return items.reduce((sum, x) => sum + x);
                }
                static dot(m1, m2) {
                  return maths.mulMatrix(m1, m2);
                }
                static vectorLen(v) {
                  return Math.hypot(...v);
                }
                static divItems(items, divisor) {
                  return items.map((x) => x / divisor);
                }
                static squareItems(items) {
                  return items.map((x) => x * x);
                }
                static normalize(v) {
                  return this.divItems(v, this.vectorLen(v));
                }
              }
              class bezier2 {
                static q(ctrlPoly, t2) {
                  var tx = 1 - t2;
                  var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t2), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t2 * t2), pD = maths.mulItems(ctrlPoly[3], t2 * t2 * t2);
                  return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
                }
                static qprime(ctrlPoly, t2) {
                  var tx = 1 - t2;
                  var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t2), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t2 * t2);
                  return maths.addArrays(maths.addArrays(pA, pB), pC);
                }
                static qprimeprime(ctrlPoly, t2) {
                  return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t2)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t2));
                }
              }
              module2.exports = fitCurve;
              module2.exports.fitCubic = fitCubic;
              module2.exports.createTangent = createTangent;
            },
            /* 27 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _appendElement, appendElement_fn, _setDimensions, setDimensions_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _annotation_storage2 = __w_pdfjs_require__2(5);
              var _scripting_utils = __w_pdfjs_require__2(28);
              var _xfa_layer = __w_pdfjs_require__2(29);
              const DEFAULT_TAB_INDEX = 1e3;
              const DEFAULT_FONT_SIZE = 9;
              const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              class AnnotationElementFactory {
                static create(parameters) {
                  const subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      const fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }
              class AnnotationElement {
                constructor(parameters, {
                  isRenderable = false,
                  ignoreBorder = false,
                  createQuadrilaterals = false
                } = {}) {
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.page = parameters.page;
                  this.viewport = parameters.viewport;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this._mouseState = parameters.mouseState;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                  }
                }
                _createContainer(ignoreBorder = false) {
                  const data = this.data, page = this.page, viewport = this.viewport;
                  const container = document.createElement("section");
                  const {
                    width: width2,
                    height
                  } = getRectDims(data.rect);
                  const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  container.setAttribute("data-annotation-id", data.id);
                  const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = `${data.borderStyle.width}px`;
                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    const verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                      const radius = `calc(${width2}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
                      container.style.borderRadius = radius;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    const borderColor = data.borderColor || null;
                    if (borderColor) {
                      container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;
                  container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;
                  const {
                    rotation
                  } = data;
                  if (data.hasOwnCanvas || rotation === 0) {
                    container.style.width = `${100 * width2 / pageWidth}%`;
                    container.style.height = `${100 * height / pageHeight}%`;
                  } else {
                    this.setRotation(rotation, container);
                  }
                  return container;
                }
                setRotation(angle2, container = this.container) {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  const {
                    width: width2,
                    height
                  } = getRectDims(this.data.rect);
                  let elementWidth, elementHeight;
                  if (angle2 % 180 === 0) {
                    elementWidth = 100 * width2 / pageWidth;
                    elementHeight = 100 * height / pageHeight;
                  } else {
                    elementWidth = 100 * height / pageWidth;
                    elementHeight = 100 * width2 / pageHeight;
                  }
                  container.style.width = `${elementWidth}%`;
                  container.style.height = `${elementHeight}%`;
                  container.setAttribute("data-main-rotation", (360 - angle2) % 360);
                }
                get _commonActions() {
                  const setColor = (jsName, styleName, event) => {
                    const color = event.detail[jsName];
                    event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
                  };
                  return (0, _util2.shadow)(this, "_commonActions", {
                    display: (event) => {
                      const hidden = event.detail.display % 2 === 1;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden,
                        print: event.detail.display === 0 || event.detail.display === 3
                      });
                    },
                    print: (event) => {
                      this.annotationStorage.setValue(this.data.id, {
                        print: event.detail.print
                      });
                    },
                    hidden: (event) => {
                      this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden: event.detail.hidden
                      });
                    },
                    focus: (event) => {
                      setTimeout(() => event.target.focus({
                        preventScroll: false
                      }), 0);
                    },
                    userName: (event) => {
                      event.target.title = event.detail.userName;
                    },
                    readonly: (event) => {
                      if (event.detail.readonly) {
                        event.target.setAttribute("readonly", "");
                      } else {
                        event.target.removeAttribute("readonly");
                      }
                    },
                    required: (event) => {
                      this._setRequired(event.target, event.detail.required);
                    },
                    bgColor: (event) => {
                      setColor("bgColor", "backgroundColor", event);
                    },
                    fillColor: (event) => {
                      setColor("fillColor", "backgroundColor", event);
                    },
                    fgColor: (event) => {
                      setColor("fgColor", "color", event);
                    },
                    textColor: (event) => {
                      setColor("textColor", "color", event);
                    },
                    borderColor: (event) => {
                      setColor("borderColor", "borderColor", event);
                    },
                    strokeColor: (event) => {
                      setColor("strokeColor", "borderColor", event);
                    },
                    rotation: (event) => {
                      const angle2 = event.detail.rotation;
                      this.setRotation(angle2);
                      this.annotationStorage.setValue(this.data.id, {
                        rotation: angle2
                      });
                    }
                  });
                }
                _dispatchEventFromSandbox(actions, jsEvent) {
                  const commonActions = this._commonActions;
                  for (const name of Object.keys(jsEvent.detail)) {
                    const action = actions[name] || commonActions[name];
                    if (action) {
                      action(jsEvent);
                    }
                  }
                }
                _setDefaultPropertiesFromJS(element) {
                  if (!this.enableScripting) {
                    return;
                  }
                  const storedData = this.annotationStorage.getRawValue(this.data.id);
                  if (!storedData) {
                    return;
                  }
                  const commonActions = this._commonActions;
                  for (const [actionName, detail] of Object.entries(storedData)) {
                    const action = commonActions[actionName];
                    if (action) {
                      const eventProxy = {
                        detail: {
                          [actionName]: detail
                        },
                        target: element
                      };
                      action(eventProxy);
                      delete storedData[actionName];
                    }
                  }
                }
                _createQuadrilaterals(ignoreBorder = false) {
                  if (!this.data.quadPoints) {
                    return null;
                  }
                  const quadrilaterals = [];
                  const savedRect = this.data.rect;
                  for (const quadPoint of this.data.quadPoints) {
                    this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                    quadrilaterals.push(this._createContainer(ignoreBorder));
                  }
                  this.data.rect = savedRect;
                  return quadrilaterals;
                }
                _createPopup(trigger, data) {
                  let container = this.container;
                  if (this.quadrilaterals) {
                    trigger = trigger || this.quadrilaterals;
                    container = this.quadrilaterals[0];
                  }
                  if (!trigger) {
                    trigger = document.createElement("div");
                    trigger.className = "popupTriggerArea";
                    container.append(trigger);
                  }
                  const popupElement = new PopupElement({
                    container,
                    trigger,
                    color: data.color,
                    titleObj: data.titleObj,
                    modificationDate: data.modificationDate,
                    contentsObj: data.contentsObj,
                    richText: data.richText,
                    hideWrapper: true
                  });
                  const popup = popupElement.render();
                  popup.style.left = "100%";
                  container.append(popup);
                }
                _renderQuadrilaterals(className2) {
                  for (const quadrilateral of this.quadrilaterals) {
                    quadrilateral.className = className2;
                  }
                  return this.quadrilaterals;
                }
                render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
                _getElementsByName(name, skipId = null) {
                  const fields = [];
                  if (this._fieldObjects) {
                    const fieldObj = this._fieldObjects[name];
                    if (fieldObj) {
                      for (const {
                        page,
                        id: id2,
                        exportValues
                      } of fieldObj) {
                        if (page === -1) {
                          continue;
                        }
                        if (id2 === skipId) {
                          continue;
                        }
                        const exportValue = typeof exportValues === "string" ? exportValues : null;
                        const domElement = document.querySelector(`[data-element-id="${id2}"]`);
                        if (domElement && !GetElementsByNameSet.has(domElement)) {
                          (0, _util2.warn)(`_getElementsByName - element not allowed: ${id2}`);
                          continue;
                        }
                        fields.push({
                          id: id2,
                          exportValue,
                          domElement
                        });
                      }
                    }
                    return fields;
                  }
                  for (const domElement of document.getElementsByName(name)) {
                    const {
                      id: id2,
                      exportValue
                    } = domElement;
                    if (id2 === skipId) {
                      continue;
                    }
                    if (!GetElementsByNameSet.has(domElement)) {
                      continue;
                    }
                    fields.push({
                      id: id2,
                      exportValue,
                      domElement
                    });
                  }
                  return fields;
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
              }
              class LinkAnnotationElement extends AnnotationElement {
                constructor(parameters, options = null) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: !!options?.ignoreBorder,
                    createQuadrilaterals: true
                  });
                  this.isTooltipOnly = parameters.data.isTooltipOnly;
                }
                render() {
                  const {
                    data,
                    linkService
                  } = this;
                  const link = document.createElement("a");
                  link.setAttribute("data-element-id", data.id);
                  let isBound = false;
                  if (data.url) {
                    linkService.addLinkAttributes(link, data.url, data.newWindow);
                    isBound = true;
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                    isBound = true;
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                    isBound = true;
                  } else {
                    if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                      this._bindJSAction(link, data);
                      isBound = true;
                    }
                    if (data.resetForm) {
                      this._bindResetFormAction(link, data.resetForm);
                      isBound = true;
                    } else if (this.isTooltipOnly && !isBound) {
                      this._bindLink(link, "");
                      isBound = true;
                    }
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                      const linkElement = index === 0 ? link : link.cloneNode();
                      quadrilateral.append(linkElement);
                      return quadrilateral;
                    });
                  }
                  this.container.className = "linkAnnotation";
                  if (isBound) {
                    this.container.append(link);
                  }
                  return this.container;
                }
                _bindLink(link, destination) {
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = () => {
                    if (destination) {
                      this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    link.className = "internalLink";
                  }
                }
                _bindNamedAction(link, action) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    this.linkService.executeNamedAction(action);
                    return false;
                  };
                  link.className = "internalLink";
                }
                _bindJSAction(link, data) {
                  link.href = this.linkService.getAnchorUrl("");
                  const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  for (const name of Object.keys(data.actions)) {
                    const jsName = map.get(name);
                    if (!jsName) {
                      continue;
                    }
                    link[jsName] = () => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: data.id,
                          name
                        }
                      });
                      return false;
                    };
                  }
                  if (!link.onclick) {
                    link.onclick = () => false;
                  }
                  link.className = "internalLink";
                }
                _bindResetFormAction(link, resetForm) {
                  const otherClickAction = link.onclick;
                  if (!otherClickAction) {
                    link.href = this.linkService.getAnchorUrl("");
                  }
                  link.className = "internalLink";
                  if (!this._fieldObjects) {
                    (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                    if (!otherClickAction) {
                      link.onclick = () => false;
                    }
                    return;
                  }
                  link.onclick = () => {
                    if (otherClickAction) {
                      otherClickAction();
                    }
                    const {
                      fields: resetFormFields,
                      refs: resetFormRefs,
                      include
                    } = resetForm;
                    const allFields = [];
                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                      const fieldIds = new Set(resetFormRefs);
                      for (const fieldName of resetFormFields) {
                        const fields = this._fieldObjects[fieldName] || [];
                        for (const {
                          id: id2
                        } of fields) {
                          fieldIds.add(id2);
                        }
                      }
                      for (const fields of Object.values(this._fieldObjects)) {
                        for (const field of fields) {
                          if (fieldIds.has(field.id) === include) {
                            allFields.push(field);
                          }
                        }
                      }
                    } else {
                      for (const fields of Object.values(this._fieldObjects)) {
                        allFields.push(...fields);
                      }
                    }
                    const storage = this.annotationStorage;
                    const allIds = [];
                    for (const field of allFields) {
                      const {
                        id: id2
                      } = field;
                      allIds.push(id2);
                      switch (field.type) {
                        case "text": {
                          const value2 = field.defaultValue || "";
                          storage.setValue(id2, {
                            value: value2
                          });
                          break;
                        }
                        case "checkbox":
                        case "radiobutton": {
                          const value2 = field.defaultValue === field.exportValues;
                          storage.setValue(id2, {
                            value: value2
                          });
                          break;
                        }
                        case "combobox":
                        case "listbox": {
                          const value2 = field.defaultValue || "";
                          storage.setValue(id2, {
                            value: value2
                          });
                          break;
                        }
                        default:
                          continue;
                      }
                      const domElement = document.querySelector(`[data-element-id="${id2}"]`);
                      if (!domElement) {
                        continue;
                      } else if (!GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id2}`);
                        continue;
                      }
                      domElement.dispatchEvent(new Event("resetform"));
                    }
                    if (this.enableScripting) {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: "app",
                          ids: allIds,
                          name: "ResetForm"
                        }
                      });
                    }
                    return false;
                  };
                }
              }
              class TextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  this.container.className = "textAnnotation";
                  const image2 = document.createElement("img");
                  image2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image2.alt = "[{{type}} Annotation]";
                  image2.dataset.l10nId = "text_annotation_type";
                  image2.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.hasPopup) {
                    this._createPopup(image2, this.data);
                  }
                  this.container.append(image2);
                  return this.container;
                }
              }
              class WidgetAnnotationElement extends AnnotationElement {
                render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
                _getKeyModifier(event) {
                  const {
                    isWin,
                    isMac
                  } = AnnotationElement.platform;
                  return isWin && event.ctrlKey || isMac && event.metaKey;
                }
                _setEventListener(element, baseName, eventName, valueGetter) {
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, (event) => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: this._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, (event) => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event)
                        }
                      });
                    });
                  }
                }
                _setEventListeners(element, names, getter) {
                  for (const [baseName, eventName] of names) {
                    if (eventName === "Action" || this.data.actions?.[eventName]) {
                      this._setEventListener(element, baseName, eventName, getter);
                    }
                  }
                }
                _setBackgroundColor(element) {
                  const color = this.data.backgroundColor || null;
                  element.style.backgroundColor = color === null ? "transparent" : _util2.Util.makeHexColor(color[0], color[1], color[2]);
                }
                _setTextStyle(element) {
                  const TEXT_ALIGNMENT = ["left", "center", "right"];
                  const {
                    fontColor
                  } = this.data.defaultAppearanceData;
                  const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                  const style = element.style;
                  let computedFontSize;
                  if (this.data.multiLine) {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    const numberOfLines = Math.round(height / (_util2.LINE_FACTOR * fontSize)) || 1;
                    const lineHeight = height / numberOfLines;
                    computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util2.LINE_FACTOR));
                  } else {
                    const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    computedFontSize = Math.min(fontSize, Math.round(height / _util2.LINE_FACTOR));
                  }
                  style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
                _setRequired(element, isRequired) {
                  if (isRequired) {
                    element.setAttribute("required", true);
                  } else {
                    element.removeAttribute("required");
                  }
                  element.setAttribute("aria-required", isRequired);
                }
              }
              class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  super(parameters, {
                    isRenderable
                  });
                }
                setPropertyOnSiblings(base, key, value2, keyInStorage) {
                  const storage = this.annotationStorage;
                  for (const element of this._getElementsByName(base.name, base.id)) {
                    if (element.domElement) {
                      element.domElement[key] = value2;
                    }
                    storage.setValue(element.id, {
                      [keyInStorage]: value2
                    });
                  }
                }
                render() {
                  const storage = this.annotationStorage;
                  const id2 = this.data.id;
                  this.container.className = "textWidgetAnnotation";
                  let element = null;
                  if (this.renderForms) {
                    const storedData = storage.getValue(id2, {
                      value: this.data.fieldValue
                    });
                    let textContent = storedData.formattedValue || storedData.value || "";
                    const maxLen = storage.getValue(id2, {
                      charLimit: this.data.maxLen
                    }).charLimit;
                    if (maxLen && textContent.length > maxLen) {
                      textContent = textContent.slice(0, maxLen);
                    }
                    const elementData = {
                      userValue: textContent,
                      formattedValue: null,
                      valueOnFocus: ""
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = textContent;
                      if (this.data.doNotScroll) {
                        element.style.overflowY = "hidden";
                      }
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", textContent);
                      if (this.data.doNotScroll) {
                        element.style.overflowX = "hidden";
                      }
                    }
                    GetElementsByNameSet.add(element);
                    element.setAttribute("data-element-id", id2);
                    element.disabled = this.data.readOnly;
                    element.name = this.data.fieldName;
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    this._setRequired(element, this.data.required);
                    if (maxLen) {
                      element.maxLength = maxLen;
                    }
                    element.addEventListener("input", (event) => {
                      storage.setValue(id2, {
                        value: event.target.value
                      });
                      this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = this.data.defaultFieldValue ?? "";
                      element.value = elementData.userValue = defaultValue;
                      elementData.formattedValue = null;
                    });
                    let blurListener = (event) => {
                      const {
                        formattedValue
                      } = elementData;
                      if (formattedValue !== null && formattedValue !== void 0) {
                        event.target.value = formattedValue;
                      }
                      event.target.scrollLeft = 0;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("focus", (event) => {
                        if (elementData.userValue) {
                          event.target.value = elementData.userValue;
                        }
                        elementData.valueOnFocus = event.target.value;
                      });
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value(event) {
                            elementData.userValue = event.detail.value ?? "";
                            storage.setValue(id2, {
                              value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                          },
                          formattedValue(event) {
                            const {
                              formattedValue
                            } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                              event.target.value = formattedValue;
                            }
                            storage.setValue(id2, {
                              formattedValue
                            });
                          },
                          selRange(event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                          },
                          charLimit: (event) => {
                            const {
                              charLimit
                            } = event.detail;
                            const {
                              target
                            } = event;
                            if (charLimit === 0) {
                              target.removeAttribute("maxLength");
                              return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value2 = elementData.userValue;
                            if (!value2 || value2.length <= charLimit) {
                              return;
                            }
                            value2 = value2.slice(0, charLimit);
                            target.value = elementData.userValue = value2;
                            storage.setValue(id2, {
                              value: value2
                            });
                            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id: id2,
                                name: "Keystroke",
                                value: value2,
                                willCommit: true,
                                commitKey: 1,
                                selStart: target.selectionStart,
                                selEnd: target.selectionEnd
                              }
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      element.addEventListener("keydown", (event) => {
                        let commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter") {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        const {
                          value: value2
                        } = event.target;
                        if (elementData.valueOnFocus === value2) {
                          return;
                        }
                        elementData.userValue = value2;
                        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: id2,
                            name: "Keystroke",
                            value: value2,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      const _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", (event) => {
                        const {
                          value: value2
                        } = event.target;
                        elementData.userValue = value2;
                        if (this._mouseState.isDown && elementData.valueOnFocus !== value2) {
                          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id: id2,
                              name: "Keystroke",
                              value: value2,
                              willCommit: true,
                              commitKey: 1,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      if (this.data.actions?.Keystroke) {
                        element.addEventListener("beforeinput", (event) => {
                          const {
                            data,
                            target
                          } = event;
                          const {
                            value: value2,
                            selectionStart,
                            selectionEnd
                          } = target;
                          let selStart = selectionStart, selEnd = selectionEnd;
                          switch (event.inputType) {
                            case "deleteWordBackward": {
                              const match = value2.substring(0, selectionStart).match(/\w*[^\w]*$/);
                              if (match) {
                                selStart -= match[0].length;
                              }
                              break;
                            }
                            case "deleteWordForward": {
                              const match = value2.substring(selectionStart).match(/^[^\w]*\w*/);
                              if (match) {
                                selEnd += match[0].length;
                              }
                              break;
                            }
                            case "deleteContentBackward":
                              if (selectionStart === selectionEnd) {
                                selStart -= 1;
                              }
                              break;
                            case "deleteContentForward":
                              if (selectionStart === selectionEnd) {
                                selEnd += 1;
                              }
                              break;
                          }
                          event.preventDefault();
                          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id: id2,
                              name: "Keystroke",
                              value: value2,
                              change: data || "",
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    if (this.data.comb) {
                      const fieldWidth = this.data.rect[2] - this.data.rect[0];
                      const combWidth = fieldWidth / maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id2 = data.id;
                  let value2 = storage.getValue(id2, {
                    value: data.exportValue === data.fieldValue
                  }).value;
                  if (typeof value2 === "string") {
                    value2 = value2 !== "Off";
                    storage.setValue(id2, {
                      value: value2
                    });
                  }
                  this.container.className = "buttonWidgetAnnotation checkBox";
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id2);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "checkbox";
                  element.name = data.fieldName;
                  if (value2) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("exportValue", data.exportValue);
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const checkbox of this._getElementsByName(name, id2)) {
                      const curChecked = checked && checkbox.exportValue === data.exportValue;
                      if (checkbox.domElement) {
                        checkbox.domElement.checked = curChecked;
                      }
                      storage.setValue(checkbox.id, {
                        value: curChecked
                      });
                    }
                    storage.setValue(id2, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue || "Off";
                    event.target.checked = defaultValue === data.exportValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          event.target.checked = event.detail.value !== "Off";
                          storage.setValue(id2, {
                            value: event.target.checked
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "buttonWidgetAnnotation radioButton";
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id2 = data.id;
                  let value2 = storage.getValue(id2, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  if (typeof value2 === "string") {
                    value2 = value2 !== data.buttonValue;
                    storage.setValue(id2, {
                      value: value2
                    });
                  }
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id2);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "radio";
                  element.name = data.fieldName;
                  if (value2) {
                    element.setAttribute("checked", true);
                  }
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name,
                      checked
                    } = event.target;
                    for (const radio of this._getElementsByName(name, id2)) {
                      storage.setValue(radio.id, {
                        value: false
                      });
                    }
                    storage.setValue(id2, {
                      value: checked
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue;
                    event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    const pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value: (event) => {
                          const checked = pdfButtonValue === event.detail.value;
                          for (const radio of this._getElementsByName(event.target.name)) {
                            const curChecked = checked && radio.id === id2;
                            if (radio.domElement) {
                              radio.domElement.checked = curChecked;
                            }
                            storage.setValue(radio.id, {
                              value: curChecked
                            });
                          }
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                render() {
                  const container = super.render();
                  container.className = "buttonWidgetAnnotation pushButton";
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  const linkElement = container.lastChild;
                  if (this.enableScripting && this.hasJSActions && linkElement) {
                    this._setDefaultPropertiesFromJS(linkElement);
                    linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      this._dispatchEventFromSandbox({}, jsEvent);
                    });
                  }
                  return container;
                }
              }
              class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "choiceWidgetAnnotation";
                  const storage = this.annotationStorage;
                  const id2 = this.data.id;
                  const storedData = storage.getValue(id2, {
                    value: this.data.fieldValue
                  });
                  const selectElement = document.createElement("select");
                  GetElementsByNameSet.add(selectElement);
                  selectElement.setAttribute("data-element-id", id2);
                  selectElement.disabled = this.data.readOnly;
                  this._setRequired(selectElement, this.data.required);
                  selectElement.name = this.data.fieldName;
                  selectElement.tabIndex = DEFAULT_TAB_INDEX;
                  let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  selectElement.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue;
                    for (const option of selectElement.options) {
                      option.selected = option.value === defaultValue;
                    }
                  });
                  for (const option of this.data.options) {
                    const optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (storedData.value.includes(option.exportValue)) {
                      optionElement.setAttribute("selected", true);
                      addAnEmptyEntry = false;
                    }
                    selectElement.append(optionElement);
                  }
                  let removeEmptyEntry = null;
                  if (addAnEmptyEntry) {
                    const noneOptionElement = document.createElement("option");
                    noneOptionElement.value = " ";
                    noneOptionElement.setAttribute("hidden", true);
                    noneOptionElement.setAttribute("selected", true);
                    selectElement.prepend(noneOptionElement);
                    removeEmptyEntry = () => {
                      noneOptionElement.remove();
                      selectElement.removeEventListener("input", removeEmptyEntry);
                      removeEmptyEntry = null;
                    };
                    selectElement.addEventListener("input", removeEmptyEntry);
                  }
                  const getValue = (event, isExport) => {
                    const name = isExport ? "value" : "textContent";
                    const options = event.target.options;
                    if (!event.target.multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                    }
                    return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
                  };
                  const getItems = (event) => {
                    const options = event.target.options;
                    return Array.prototype.map.call(options, (option) => {
                      return {
                        displayValue: option.textContent,
                        exportValue: option.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          removeEmptyEntry?.();
                          const value2 = event.detail.value;
                          const values = new Set(Array.isArray(value2) ? value2 : [value2]);
                          for (const option of selectElement.options) {
                            option.selected = values.has(option.value);
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true)
                          });
                        },
                        multipleSelection(event) {
                          selectElement.multiple = true;
                        },
                        remove(event) {
                          const options = selectElement.options;
                          const index = event.detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                            if (i === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        clear(event) {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id2, {
                            value: null,
                            items: []
                          });
                        },
                        insert(event) {
                          const {
                            index,
                            displayValue,
                            exportValue
                          } = event.detail.insert;
                          const selectChild = selectElement.children[index];
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          if (selectChild) {
                            selectChild.before(optionElement);
                          } else {
                            selectElement.append(optionElement);
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        items(event) {
                          const {
                            items
                          } = event.detail;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          for (const item of items) {
                            const {
                              displayValue,
                              exportValue
                            } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        indices(event) {
                          const indices = new Set(event.detail.indices);
                          for (const option of event.target.options) {
                            option.selected = indices.has(option.index);
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true)
                          });
                        },
                        editable(event) {
                          event.target.disabled = !event.detail.editable;
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    selectElement.addEventListener("input", (event) => {
                      const exportValue = getValue(event, true);
                      const value2 = getValue(event, false);
                      storage.setValue(id2, {
                        value: exportValue
                      });
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: id2,
                          name: "Keystroke",
                          value: value2,
                          changeEx: exportValue,
                          willCommit: true,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (event) => event.target.checked);
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id2, {
                        value: getValue(event, true)
                      });
                    });
                  }
                  if (this.data.combo) {
                    this._setTextStyle(selectElement);
                  } else {
                  }
                  this._setBackgroundColor(selectElement);
                  this._setDefaultPropertiesFromJS(selectElement);
                  this.container.append(selectElement);
                  return this.container;
                }
              }
              class PopupAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                  this.container.className = "popupAnnotation";
                  if (IGNORE_TYPES.includes(this.data.parentType)) {
                    return this.container;
                  }
                  const selector = `[data-annotation-id="${this.data.parentId}"]`;
                  const parentElements = this.layer.querySelectorAll(selector);
                  if (parentElements.length === 0) {
                    return this.container;
                  }
                  const popup = new PopupElement({
                    container: this.container,
                    trigger: Array.from(parentElements),
                    color: this.data.color,
                    titleObj: this.data.titleObj,
                    modificationDate: this.data.modificationDate,
                    contentsObj: this.data.contentsObj,
                    richText: this.data.richText
                  });
                  const page = this.page;
                  const rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                  const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                  const popupTop = rect[1];
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;
                  this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;
                  this.container.append(popup.render());
                  return this.container;
                }
              }
              class PopupElement {
                constructor(parameters) {
                  this.container = parameters.container;
                  this.trigger = parameters.trigger;
                  this.color = parameters.color;
                  this.titleObj = parameters.titleObj;
                  this.modificationDate = parameters.modificationDate;
                  this.contentsObj = parameters.contentsObj;
                  this.richText = parameters.richText;
                  this.hideWrapper = parameters.hideWrapper || false;
                  this.pinned = false;
                }
                render() {
                  const BACKGROUND_ENLIGHT = 0.7;
                  const wrapper = document.createElement("div");
                  wrapper.className = "popupWrapper";
                  this.hideElement = this.hideWrapper ? wrapper : this.container;
                  this.hideElement.hidden = true;
                  const popup = document.createElement("div");
                  popup.className = "popup";
                  const color = this.color;
                  if (color) {
                    const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                    const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                    const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                    popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                  }
                  const title2 = document.createElement("h1");
                  title2.dir = this.titleObj.dir;
                  title2.textContent = this.titleObj.str;
                  popup.append(title2);
                  const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                  if (dateObject) {
                    const modificationDate = document.createElement("span");
                    modificationDate.className = "popupDate";
                    modificationDate.textContent = "{{date}}, {{time}}";
                    modificationDate.dataset.l10nId = "annotation_date_string";
                    modificationDate.dataset.l10nArgs = JSON.stringify({
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    });
                    popup.append(modificationDate);
                  }
                  if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {
                    _xfa_layer.XfaLayer.render({
                      xfaHtml: this.richText.html,
                      intent: "richText",
                      div: popup
                    });
                    popup.lastChild.className = "richText popupContent";
                  } else {
                    const contents = this._formatContents(this.contentsObj);
                    popup.append(contents);
                  }
                  if (!Array.isArray(this.trigger)) {
                    this.trigger = [this.trigger];
                  }
                  for (const element of this.trigger) {
                    element.addEventListener("click", this._toggle.bind(this));
                    element.addEventListener("mouseover", this._show.bind(this, false));
                    element.addEventListener("mouseout", this._hide.bind(this, false));
                  }
                  popup.addEventListener("click", this._hide.bind(this, true));
                  wrapper.append(popup);
                  return wrapper;
                }
                _formatContents({
                  str: str3,
                  dir
                }) {
                  const p = document.createElement("p");
                  p.className = "popupContent";
                  p.dir = dir;
                  const lines = str3.split(/(?:\r\n?|\n)/);
                  for (let i = 0, ii = lines.length; i < ii; ++i) {
                    const line = lines[i];
                    p.append(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.append(document.createElement("br"));
                    }
                  }
                  return p;
                }
                _toggle() {
                  if (this.pinned) {
                    this._hide(true);
                  } else {
                    this._show(true);
                  }
                }
                _show(pin = false) {
                  if (pin) {
                    this.pinned = true;
                  }
                  if (this.hideElement.hidden) {
                    this.hideElement.hidden = false;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3;
                  }
                }
                _hide(unpin = true) {
                  if (unpin) {
                    this.pinned = false;
                  }
                  if (!this.hideElement.hidden && !this.pinned) {
                    this.hideElement.hidden = true;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3;
                  }
                }
              }
              class FreeTextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.textContent = parameters.data.textContent;
                }
                render() {
                  this.container.className = "freeTextAnnotation";
                  if (this.textContent) {
                    const content = document.createElement("div");
                    content.className = "annotationTextContent";
                    content.setAttribute("role", "comment");
                    for (const line of this.textContent) {
                      const lineSpan = document.createElement("span");
                      lineSpan.textContent = line;
                      content.append(lineSpan);
                    }
                    this.container.append(content);
                  }
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class LineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "lineAnnotation";
                  const data = this.data;
                  const {
                    width: width2,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height, true);
                  const line = this.svgFactory.createElement("svg:line");
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  line.setAttribute("fill", "transparent");
                  svg.append(line);
                  this.container.append(svg);
                  this._createPopup(line, data);
                  return this.container;
                }
              }
              class SquareAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "squareAnnotation";
                  const data = this.data;
                  const {
                    width: width2,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height, true);
                  const borderWidth = data.borderStyle.width;
                  const square = this.svgFactory.createElement("svg:rect");
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width2 - borderWidth);
                  square.setAttribute("height", height - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "transparent");
                  svg.append(square);
                  this.container.append(svg);
                  this._createPopup(square, data);
                  return this.container;
                }
              }
              class CircleAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "circleAnnotation";
                  const data = this.data;
                  const {
                    width: width2,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height, true);
                  const borderWidth = data.borderStyle.width;
                  const circle = this.svgFactory.createElement("svg:ellipse");
                  circle.setAttribute("cx", width2 / 2);
                  circle.setAttribute("cy", height / 2);
                  circle.setAttribute("rx", width2 / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "transparent");
                  svg.append(circle);
                  this.container.append(svg);
                  this._createPopup(circle, data);
                  return this.container;
                }
              }
              class PolylineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "polylineAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width: width2,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height, true);
                  let points = [];
                  for (const coordinate of data.vertices) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(x + "," + y);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  svg.append(polyline);
                  this.container.append(svg);
                  this._createPopup(polyline, data);
                  return this.container;
                }
              }
              class PolygonAnnotationElement extends PolylineAnnotationElement {
                constructor(parameters) {
                  super(parameters);
                  this.containerClassName = "polygonAnnotation";
                  this.svgElementName = "svg:polygon";
                }
              }
              class CaretAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "caretAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class InkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "inkAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width: width2,
                    height
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height, true);
                  for (const inkList of data.inkLists) {
                    let points = [];
                    for (const coordinate of inkList) {
                      const x = coordinate.x - data.rect[0];
                      const y = data.rect[3] - coordinate.y;
                      points.push(`${x},${y}`);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    this._createPopup(polyline, data);
                    svg.append(polyline);
                  }
                  this.container.append(svg);
                  return this.container;
                }
              }
              class HighlightAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("highlightAnnotation");
                  }
                  this.container.className = "highlightAnnotation";
                  return this.container;
                }
              }
              class UnderlineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("underlineAnnotation");
                  }
                  this.container.className = "underlineAnnotation";
                  return this.container;
                }
              }
              class SquigglyAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("squigglyAnnotation");
                  }
                  this.container.className = "squigglyAnnotation";
                  return this.container;
                }
              }
              class StrikeOutAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("strikeoutAnnotation");
                  }
                  this.container.className = "strikeoutAnnotation";
                  return this.container;
                }
              }
              class StampAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "stampAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class FileAttachmentAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true
                  });
                  const {
                    filename,
                    content
                  } = this.data.file;
                  this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                  this.content = content;
                  this.linkService.eventBus?.dispatch("fileattachmentannotation", {
                    source: this,
                    filename,
                    content
                  });
                }
                render() {
                  this.container.className = "fileAttachmentAnnotation";
                  const trigger = document.createElement("div");
                  trigger.className = "popupTriggerArea";
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {
                    this._createPopup(trigger, this.data);
                  }
                  this.container.append(trigger);
                  return this.container;
                }
                _download() {
                  this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
                }
              }
              const _AnnotationLayer = class {
                static render(parameters) {
                  var _a, _b;
                  const {
                    annotations,
                    div: div2,
                    viewport,
                    accessibilityManager
                  } = parameters;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, div2, viewport);
                  let zIndex = 0;
                  for (const data of annotations) {
                    if (data.annotationType !== _util2.AnnotationType.POPUP) {
                      const {
                        width: width2,
                        height
                      } = getRectDims(data.rect);
                      if (width2 <= 0 || height <= 0) {
                        continue;
                      }
                    }
                    const element = AnnotationElementFactory.create({
                      data,
                      layer: div2,
                      page: parameters.page,
                      viewport,
                      linkService: parameters.linkService,
                      downloadManager: parameters.downloadManager,
                      imageResourcesPath: parameters.imageResourcesPath || "",
                      renderForms: parameters.renderForms !== false,
                      svgFactory: new _display_utils2.DOMSVGFactory(),
                      annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                      enableScripting: parameters.enableScripting,
                      hasJSActions: parameters.hasJSActions,
                      fieldObjects: parameters.fieldObjects,
                      mouseState: parameters.mouseState || {
                        isDown: false
                      }
                    });
                    if (element.isRenderable) {
                      const rendered = element.render();
                      if (data.hidden) {
                        rendered.style.visibility = "hidden";
                      }
                      if (Array.isArray(rendered)) {
                        for (const renderedElement of rendered) {
                          renderedElement.style.zIndex = zIndex++;
                          __privateMethod(_a = _AnnotationLayer, _appendElement, appendElement_fn).call(_a, renderedElement, data.id, div2, accessibilityManager);
                        }
                      } else {
                        rendered.style.zIndex = zIndex++;
                        if (element instanceof PopupAnnotationElement) {
                          div2.prepend(rendered);
                        } else {
                          __privateMethod(_b = _AnnotationLayer, _appendElement, appendElement_fn).call(_b, rendered, data.id, div2, accessibilityManager);
                        }
                      }
                    }
                  }
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div2, parameters.annotationCanvasMap);
                }
                static update(parameters) {
                  const {
                    annotationCanvasMap,
                    div: div2,
                    viewport
                  } = parameters;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, div2, viewport);
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div2, annotationCanvasMap);
                  div2.hidden = false;
                }
              };
              let AnnotationLayer = _AnnotationLayer;
              _appendElement = new WeakSet();
              appendElement_fn = function(element, id2, div2, accessibilityManager) {
                const contentElement = element.firstChild || element;
                contentElement.id = `${_display_utils2.AnnotationPrefix}${id2}`;
                div2.append(element);
                accessibilityManager?.moveElementInDOM(div2, element, contentElement, false);
              };
              _setDimensions = new WeakSet();
              setDimensions_fn = function(div2, {
                width: width2,
                height,
                rotation
              }) {
                const {
                  style
                } = div2;
                const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width2) + "px", heightStr = Math.floor(height) + "px";
                style.width = flipOrientation ? heightStr : widthStr;
                style.height = flipOrientation ? widthStr : heightStr;
                div2.setAttribute("data-main-rotation", rotation);
              };
              _setAnnotationCanvasMap = new WeakSet();
              setAnnotationCanvasMap_fn = function(div2, annotationCanvasMap) {
                if (!annotationCanvasMap) {
                  return;
                }
                for (const [id2, canvas] of annotationCanvasMap) {
                  const element = div2.querySelector(`[data-annotation-id="${id2}"]`);
                  if (!element) {
                    continue;
                  }
                  const {
                    firstChild
                  } = element;
                  if (!firstChild) {
                    element.append(canvas);
                  } else if (firstChild.nodeName === "CANVAS") {
                    firstChild.replaceWith(canvas);
                  } else {
                    firstChild.before(canvas);
                  }
                }
                annotationCanvasMap.clear();
              };
              __privateAdd(AnnotationLayer, _appendElement);
              __privateAdd(AnnotationLayer, _setDimensions);
              __privateAdd(AnnotationLayer, _setAnnotationCanvasMap);
              exports2.AnnotationLayer = AnnotationLayer;
            },
            /* 28 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function makeColorComp(n) {
                return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
              }
              class ColorConverters {
                static CMYK_G([c, y, m, k]) {
                  return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                }
                static G_CMYK([g]) {
                  return ["CMYK", 0, 0, 0, 1 - g];
                }
                static G_RGB([g]) {
                  return ["RGB", g, g, g];
                }
                static G_HTML([g]) {
                  const G = makeColorComp(g);
                  return `#${G}${G}${G}`;
                }
                static RGB_G([r, g, b]) {
                  return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                }
                static RGB_HTML([r, g, b]) {
                  const R = makeColorComp(r);
                  const G = makeColorComp(g);
                  const B = makeColorComp(b);
                  return `#${R}${G}${B}`;
                }
                static T_HTML() {
                  return "#00000000";
                }
                static CMYK_RGB([c, y, m, k]) {
                  return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                }
                static CMYK_HTML(components) {
                  const rgb2 = this.CMYK_RGB(components).slice(1);
                  return this.RGB_HTML(rgb2);
                }
                static RGB_CMYK([r, g, b]) {
                  const c = 1 - r;
                  const m = 1 - g;
                  const y = 1 - b;
                  const k = Math.min(c, m, y);
                  return ["CMYK", c, m, y, k];
                }
              }
              exports2.ColorConverters = ColorConverters;
            },
            /* 29 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(20);
              class XfaLayer {
                static setupStorage(html, id2, element, storage, intent) {
                  const storedData = storage.getValue(id2, {
                    value: null
                  });
                  switch (element.name) {
                    case "textarea":
                      if (storedData.value !== null) {
                        html.textContent = storedData.value;
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id2, {
                          value: event.target.value
                        });
                      });
                      break;
                    case "input":
                      if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                        if (storedData.value === element.attributes.xfaOn) {
                          html.setAttribute("checked", true);
                        } else if (storedData.value === element.attributes.xfaOff) {
                          html.removeAttribute("checked");
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("change", (event) => {
                          storage.setValue(id2, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                          });
                        });
                      } else {
                        if (storedData.value !== null) {
                          html.setAttribute("value", storedData.value);
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id2, {
                            value: event.target.value
                          });
                        });
                      }
                      break;
                    case "select":
                      if (storedData.value !== null) {
                        for (const option of element.children) {
                          if (option.attributes.value === storedData.value) {
                            option.attributes.selected = true;
                          }
                        }
                      }
                      html.addEventListener("input", (event) => {
                        const options = event.target.options;
                        const value2 = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                        storage.setValue(id2, {
                          value: value2
                        });
                      });
                      break;
                  }
                }
                static setAttributes({
                  html,
                  element,
                  storage = null,
                  intent,
                  linkService
                }) {
                  const {
                    attributes
                  } = element;
                  const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                  if (attributes.type === "radio") {
                    attributes.name = `${attributes.name}-${intent}`;
                  }
                  for (const [key, value2] of Object.entries(attributes)) {
                    if (value2 === null || value2 === void 0) {
                      continue;
                    }
                    switch (key) {
                      case "class":
                        if (value2.length) {
                          html.setAttribute(key, value2.join(" "));
                        }
                        break;
                      case "dataId":
                        break;
                      case "id":
                        html.setAttribute("data-element-id", value2);
                        break;
                      case "style":
                        Object.assign(html.style, value2);
                        break;
                      case "textContent":
                        html.textContent = value2;
                        break;
                      default:
                        if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                          html.setAttribute(key, value2);
                        }
                    }
                  }
                  if (isHTMLAnchorElement) {
                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                  }
                  if (storage && attributes.dataId) {
                    this.setupStorage(html, attributes.dataId, element, storage);
                  }
                }
                static render(parameters) {
                  const storage = parameters.annotationStorage;
                  const linkService = parameters.linkService;
                  const root = parameters.xfaHtml;
                  const intent = parameters.intent || "display";
                  const rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    this.setAttributes({
                      html: rootHtml,
                      element: root,
                      intent,
                      linkService
                    });
                  }
                  const stack = [[root, -1, rootHtml]];
                  const rootDiv = parameters.div;
                  rootDiv.append(rootHtml);
                  if (parameters.viewport) {
                    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                    rootDiv.style.transform = transform;
                  }
                  if (intent !== "richText") {
                    rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  }
                  const textDivs = [];
                  while (stack.length > 0) {
                    const [parent, i, html] = stack.at(-1);
                    if (i + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = parent.children[++stack.at(-1)[1]];
                    if (child === null) {
                      continue;
                    }
                    const {
                      name
                    } = child;
                    if (name === "#text") {
                      const node = document.createTextNode(child.value);
                      textDivs.push(node);
                      html.append(node);
                      continue;
                    }
                    let childHtml;
                    if (child?.attributes?.xmlns) {
                      childHtml = document.createElementNS(child.attributes.xmlns, name);
                    } else {
                      childHtml = document.createElement(name);
                    }
                    html.append(childHtml);
                    if (child.attributes) {
                      this.setAttributes({
                        html: childHtml,
                        element: child,
                        storage,
                        intent,
                        linkService
                      });
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      const node = document.createTextNode(child.value);
                      if (_xfa_text2.XfaText.shouldBuildText(name)) {
                        textDivs.push(node);
                      }
                      childHtml.append(node);
                    }
                  }
                  for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                    el.setAttribute("readOnly", true);
                  }
                  return {
                    textDivs
                  };
                }
                static update(parameters) {
                  const transform = `matrix(${parameters.viewport.transform.join(",")})`;
                  parameters.div.style.transform = transform;
                  parameters.div.hidden = false;
                }
              }
              exports2.XfaLayer = XfaLayer;
            },
            /* 30 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerRenderTask = void 0;
              exports2.renderTextLayer = renderTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              const AllWhitespaceRegexp = /^\s+$/g;
              function getAscent(fontFamily, ctx) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                  if (pixels[i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom, styles, ctx) {
                const textDiv = document.createElement("span");
                const textDivProperties = task._enhanceTextSelection ? {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1,
                  fontSize: 0
                } : {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom.str !== "",
                  hasEOL: geom.hasEOL,
                  fontSize: 0
                };
                task._textDivs.push(textDiv);
                const tx = _util2.Util.transform(task._viewport.transform, geom.transform);
                let angle2 = Math.atan2(tx[1], tx[0]);
                const style = styles[geom.fontName];
                if (style.vertical) {
                  angle2 += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                let left, top;
                if (angle2 === 0) {
                  left = tx[4];
                  top = tx[5] - fontAscent;
                } else {
                  left = tx[4] + fontAscent * Math.sin(angle2);
                  top = tx[5] - fontAscent * Math.cos(angle2);
                }
                textDiv.style.left = `${left}px`;
                textDiv.style.top = `${top}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDivProperties.fontSize = fontHeight;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom.str;
                textDiv.dir = geom.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom.fontName;
                }
                if (angle2 !== 0) {
                  textDivProperties.angle = angle2 * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
                  shouldScaleText = true;
                } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
                  const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection && textDivProperties.hasText) {
                  let angleCos = 1, angleSin = 0;
                  if (angle2 !== 0) {
                    angleCos = Math.cos(angle2);
                    angleSin = Math.sin(angle2);
                  }
                  const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
                  const divHeight = fontHeight;
                  let m, b;
                  if (angle2 !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left, top];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left, top, left + divWidth, top + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (let i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                let result = 0;
                for (let i = 0; i < count; i++) {
                  const t2 = ts[offset++];
                  if (t2 > 0) {
                    result = result ? Math.min(t2, result) : t2;
                  }
                }
                return result;
              }
              function expand(task) {
                const bounds = task._bounds;
                const viewport = task._viewport;
                const expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (let i = 0; i < expanded.length; i++) {
                  const div2 = bounds[i].div;
                  const divProperties = task._textDivProperties.get(div2);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div2, divProperties);
                    continue;
                  }
                  const e = expanded[i], b = bounds[i];
                  const m = b.m, c = m[0], s = m[1];
                  const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  const ts = new Float64Array(64);
                  for (let j = 0, jj = points.length; j < jj; j++) {
                    const t2 = _util2.Util.applyTransform(points[j], m);
                    ts[j + 0] = c && (e.left - t2[0]) / c;
                    ts[j + 4] = s && (e.top - t2[1]) / s;
                    ts[j + 8] = c && (e.right - t2[0]) / c;
                    ts[j + 12] = s && (e.bottom - t2[1]) / s;
                    ts[j + 16] = s && (e.left - t2[0]) / -s;
                    ts[j + 20] = c && (e.top - t2[1]) / c;
                    ts[j + 24] = s && (e.right - t2[0]) / -s;
                    ts[j + 28] = c && (e.bottom - t2[1]) / c;
                    ts[j + 32] = c && (e.left - t2[0]) / -c;
                    ts[j + 36] = s && (e.top - t2[1]) / -s;
                    ts[j + 40] = c && (e.right - t2[0]) / -c;
                    ts[j + 44] = s && (e.bottom - t2[1]) / -s;
                    ts[j + 48] = s && (e.left - t2[0]) / s;
                    ts[j + 52] = c && (e.top - t2[1]) / -c;
                    ts[j + 56] = s && (e.right - t2[0]) / s;
                    ts[j + 60] = c && (e.bottom - t2[1]) / -c;
                  }
                  const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div2, divProperties);
                }
              }
              function expandBounds(width2, height, boxes) {
                const bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width2, bounds);
                const expanded = new Array(boxes.length);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                }
                boxes.map(function(box, i) {
                  const e = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width2 - e.right;
                  b.x2 = box.bottom;
                  b.y2 = width2 - e.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height, bounds);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                }
                return expanded;
              }
              function expandBoundsLTR(width2, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                const fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                const horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                for (const boundary of bounds) {
                  let i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  let j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  let horizonPart, affectedBoundary;
                  let q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    let xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  const changedHorizon = [];
                  let lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon.at(-1).end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon.at(-1).end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    let used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);
                }
                for (const horizonPart of horizon) {
                  const affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width2, affectedBoundary.x2);
                  }
                }
              }
              class TextLayerRenderTask {
                constructor({
                  textContent,
                  textContentStream,
                  container,
                  viewport,
                  textDivs,
                  textContentItemsStr,
                  enhanceTextSelection
                }) {
                  if (enhanceTextSelection) {
                    (0, _display_utils2.deprecated)("The `enhanceTextSelection` functionality will be removed in the future.");
                  }
                  this._textContent = textContent;
                  this._textContentStream = textContentStream;
                  this._container = container;
                  this._document = container.ownerDocument;
                  this._viewport = viewport;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._enhanceTextSelection = !!enhanceTextSelection;
                  this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
                  this._reader = null;
                  this._layoutTextLastFontSize = null;
                  this._layoutTextLastFontFamily = null;
                  this._layoutTextCtx = null;
                  this._textDivProperties = /* @__PURE__ */ new WeakMap();
                  this._renderingDone = false;
                  this._canceled = false;
                  this._capability = (0, _util2.createPromiseCapability)();
                  this._renderTimer = null;
                  this._bounds = [];
                  this._devicePixelRatio = globalThis.devicePixelRatio || 1;
                  this._capability.promise.finally(() => {
                    if (!this._enhanceTextSelection) {
                      this._textDivProperties = null;
                    }
                    if (this._layoutTextCtx) {
                      this._layoutTextCtx.canvas.width = 0;
                      this._layoutTextCtx.canvas.height = 0;
                      this._layoutTextCtx = null;
                    }
                  }).catch(() => {
                  });
                }
                get promise() {
                  return this._capability.promise;
                }
                cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                    });
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                }
                _processItems(items, styleCache) {
                  for (let i = 0, len3 = items.length; i < len3; i++) {
                    if (items[i].str === void 0) {
                      if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                        const parent = this._container;
                        this._container = document.createElement("span");
                        this._container.classList.add("markedContent");
                        if (items[i].id !== null) {
                          this._container.setAttribute("id", `${items[i].id}`);
                        }
                        parent.append(this._container);
                      } else if (items[i].type === "endMarkedContent") {
                        this._container = this._container.parentNode;
                      }
                      continue;
                    }
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache, this._layoutTextCtx);
                  }
                }
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  let transform = "";
                  if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                    const {
                      fontFamily
                    } = textDiv.style;
                    const {
                      fontSize
                    } = textDivProperties;
                    if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width: width2
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width2 > 0) {
                      const scale4 = this._devicePixelRatio * textDivProperties.canvasWidth / width2;
                      if (this._enhanceTextSelection) {
                        textDivProperties.scale = scale4;
                      }
                      transform = `scaleX(${scale4})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
                  }
                  if (transform.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform;
                    }
                    textDiv.style.transform = transform;
                  }
                  if (textDivProperties.hasText) {
                    this._container.append(textDiv);
                  }
                  if (textDivProperties.hasEOL) {
                    const br = document.createElement("br");
                    br.setAttribute("role", "presentation");
                    this._container.append(br);
                  }
                }
                _render(timeout = 0) {
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = this._document.createElement("canvas");
                  canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value: value2,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value2.styles);
                        this._processItems(value2.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                }
                expandTextDivs(expandDivs = false) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
                    const div2 = this._textDivs[i];
                    const divProps = this._textDivProperties.get(div2);
                    if (!divProps.hasText) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div2.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div2.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div2.style.padding = null;
                      div2.style.transform = divProps.originalTransform;
                    }
                  }
                }
              }
              exports2.TextLayerRenderTask = TextLayerRenderTask;
              function renderTextLayer(renderParameters) {
                const task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
            },
            /* 31 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(3);
              let SVGGraphics = class {
                constructor() {
                  (0, _util2.unreachable)("Not implemented: SVGGraphics");
                }
              };
              exports2.SVGGraphics = SVGGraphics;
              {
                let opListToTree = function(opList) {
                  let opTree = [];
                  const tmp = [];
                  for (const opListElement of opList) {
                    if (opListElement.fn === "save") {
                      opTree.push({
                        fnId: 92,
                        fn: "group",
                        items: []
                      });
                      tmp.push(opTree);
                      opTree = opTree.at(-1).items;
                      continue;
                    }
                    if (opListElement.fn === "restore") {
                      opTree = tmp.pop();
                    } else {
                      opTree.push(opListElement);
                    }
                  }
                  return opTree;
                }, pf = function(value2) {
                  if (Number.isInteger(value2)) {
                    return value2.toString();
                  }
                  const s = value2.toFixed(10);
                  let i = s.length - 1;
                  if (s[i] !== "0") {
                    return s;
                  }
                  do {
                    i--;
                  } while (s[i] === "0");
                  return s.substring(0, s[i] === "." ? i : i + 1);
                }, pm = function(m) {
                  if (m[4] === 0 && m[5] === 0) {
                    if (m[1] === 0 && m[2] === 0) {
                      if (m[0] === 1 && m[3] === 1) {
                        return "";
                      }
                      return `scale(${pf(m[0])} ${pf(m[3])})`;
                    }
                    if (m[0] === m[3] && m[1] === -m[2]) {
                      const a = Math.acos(m[0]) * 180 / Math.PI;
                      return `rotate(${pf(a)})`;
                    }
                  } else {
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                      return `translate(${pf(m[4])} ${pf(m[5])})`;
                    }
                  }
                  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
                };
                const SVG_DEFAULTS = {
                  fontStyle: "normal",
                  fontWeight: "normal",
                  fillColor: "#000000"
                };
                const XML_NS = "http://www.w3.org/XML/1998/namespace";
                const XLINK_NS = "http://www.w3.org/1999/xlink";
                const LINE_CAP_STYLES = ["butt", "round", "square"];
                const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                const createObjectURL = function(data, contentType = "", forceDataSchema = false) {
                  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                    return URL.createObjectURL(new Blob([data], {
                      type: contentType
                    }));
                  }
                  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  let buffer = `data:${contentType};base64,`;
                  for (let i = 0, ii = data.length; i < ii; i += 3) {
                    const b1 = data[i] & 255;
                    const b2 = data[i + 1] & 255;
                    const b3 = data[i + 2] & 255;
                    const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                    const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                    const d4 = i + 2 < ii ? b3 & 63 : 64;
                    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                  }
                  return buffer;
                };
                const convertImgDataToPng = function() {
                  const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                  const CHUNK_WRAPPER_SIZE = 12;
                  const crcTable = new Int32Array(256);
                  for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let h = 0; h < 8; h++) {
                      if (c & 1) {
                        c = 3988292384 ^ c >> 1 & 2147483647;
                      } else {
                        c = c >> 1 & 2147483647;
                      }
                    }
                    crcTable[i] = c;
                  }
                  function crc32(data, start, end) {
                    let crc = -1;
                    for (let i = start; i < end; i++) {
                      const a = (crc ^ data[i]) & 255;
                      const b = crcTable[a];
                      crc = crc >>> 8 ^ b;
                    }
                    return crc ^ -1;
                  }
                  function writePngChunk(type2, body, data, offset) {
                    let p = offset;
                    const len3 = body.length;
                    data[p] = len3 >> 24 & 255;
                    data[p + 1] = len3 >> 16 & 255;
                    data[p + 2] = len3 >> 8 & 255;
                    data[p + 3] = len3 & 255;
                    p += 4;
                    data[p] = type2.charCodeAt(0) & 255;
                    data[p + 1] = type2.charCodeAt(1) & 255;
                    data[p + 2] = type2.charCodeAt(2) & 255;
                    data[p + 3] = type2.charCodeAt(3) & 255;
                    p += 4;
                    data.set(body, p);
                    p += body.length;
                    const crc = crc32(data, offset + 4, p);
                    data[p] = crc >> 24 & 255;
                    data[p + 1] = crc >> 16 & 255;
                    data[p + 2] = crc >> 8 & 255;
                    data[p + 3] = crc & 255;
                  }
                  function adler32(data, start, end) {
                    let a = 1;
                    let b = 0;
                    for (let i = start; i < end; ++i) {
                      a = (a + (data[i] & 255)) % 65521;
                      b = (b + a) % 65521;
                    }
                    return b << 16 | a;
                  }
                  function deflateSync(literals) {
                    if (!_is_node2.isNodeJS) {
                      return deflateSyncUncompressed(literals);
                    }
                    try {
                      let input;
                      if (parseInt(process.versions.node) >= 8) {
                        input = literals;
                      } else {
                        input = Buffer.from(literals);
                      }
                      const output = require_zlib().deflateSync(input, {
                        level: 9
                      });
                      return output instanceof Uint8Array ? output : new Uint8Array(output);
                    } catch (e) {
                      (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
                    }
                    return deflateSyncUncompressed(literals);
                  }
                  function deflateSyncUncompressed(literals) {
                    let len3 = literals.length;
                    const maxBlockLength = 65535;
                    const deflateBlocks = Math.ceil(len3 / maxBlockLength);
                    const idat = new Uint8Array(2 + len3 + deflateBlocks * 5 + 4);
                    let pi = 0;
                    idat[pi++] = 120;
                    idat[pi++] = 156;
                    let pos = 0;
                    while (len3 > maxBlockLength) {
                      idat[pi++] = 0;
                      idat[pi++] = 255;
                      idat[pi++] = 255;
                      idat[pi++] = 0;
                      idat[pi++] = 0;
                      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                      pi += maxBlockLength;
                      pos += maxBlockLength;
                      len3 -= maxBlockLength;
                    }
                    idat[pi++] = 1;
                    idat[pi++] = len3 & 255;
                    idat[pi++] = len3 >> 8 & 255;
                    idat[pi++] = ~len3 & 65535 & 255;
                    idat[pi++] = (~len3 & 65535) >> 8 & 255;
                    idat.set(literals.subarray(pos), pi);
                    pi += literals.length - pos;
                    const adler = adler32(literals, 0, literals.length);
                    idat[pi++] = adler >> 24 & 255;
                    idat[pi++] = adler >> 16 & 255;
                    idat[pi++] = adler >> 8 & 255;
                    idat[pi++] = adler & 255;
                    return idat;
                  }
                  function encode(imgData, kind, forceDataSchema, isMask) {
                    const width2 = imgData.width;
                    const height = imgData.height;
                    let bitDepth, colorType, lineSize;
                    const bytes = imgData.data;
                    switch (kind) {
                      case _util2.ImageKind.GRAYSCALE_1BPP:
                        colorType = 0;
                        bitDepth = 1;
                        lineSize = width2 + 7 >> 3;
                        break;
                      case _util2.ImageKind.RGB_24BPP:
                        colorType = 2;
                        bitDepth = 8;
                        lineSize = width2 * 3;
                        break;
                      case _util2.ImageKind.RGBA_32BPP:
                        colorType = 6;
                        bitDepth = 8;
                        lineSize = width2 * 4;
                        break;
                      default:
                        throw new Error("invalid format");
                    }
                    const literals = new Uint8Array((1 + lineSize) * height);
                    let offsetLiterals = 0, offsetBytes = 0;
                    for (let y = 0; y < height; ++y) {
                      literals[offsetLiterals++] = 0;
                      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                      offsetBytes += lineSize;
                      offsetLiterals += lineSize;
                    }
                    if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                      offsetLiterals = 0;
                      for (let y = 0; y < height; y++) {
                        offsetLiterals++;
                        for (let i = 0; i < lineSize; i++) {
                          literals[offsetLiterals++] ^= 255;
                        }
                      }
                    }
                    const ihdr = new Uint8Array([width2 >> 24 & 255, width2 >> 16 & 255, width2 >> 8 & 255, width2 & 255, height >> 24 & 255, height >> 16 & 255, height >> 8 & 255, height & 255, bitDepth, colorType, 0, 0, 0]);
                    const idat = deflateSync(literals);
                    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                    const data = new Uint8Array(pngLength);
                    let offset = 0;
                    data.set(PNG_HEADER, offset);
                    offset += PNG_HEADER.length;
                    writePngChunk("IHDR", ihdr, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                    writePngChunk("IDATA", idat, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + idat.length;
                    writePngChunk("IEND", new Uint8Array(0), data, offset);
                    return createObjectURL(data, "image/png", forceDataSchema);
                  }
                  return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                    const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                    return encode(imgData, kind, forceDataSchema, isMask);
                  };
                }();
                class SVGExtraState {
                  constructor() {
                    this.fontSizeScale = 1;
                    this.fontWeight = SVG_DEFAULTS.fontWeight;
                    this.fontSize = 0;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textMatrixScale = 1;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                    this.fillColor = SVG_DEFAULTS.fillColor;
                    this.strokeColor = "#000000";
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.lineJoin = "";
                    this.lineCap = "";
                    this.miterLimit = 0;
                    this.dashArray = [];
                    this.dashPhase = 0;
                    this.dependencies = [];
                    this.activeClipUrl = null;
                    this.clipGroup = null;
                    this.maskId = "";
                  }
                  clone() {
                    return Object.create(this);
                  }
                  setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                }
                let clipCount = 0;
                let maskCount = 0;
                let shadingCount = 0;
                exports2.SVGGraphics = SVGGraphics = class {
                  constructor(commonObjs, objs, forceDataSchema = false) {
                    (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                    this.svgFactory = new _display_utils2.DOMSVGFactory();
                    this.current = new SVGExtraState();
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.transformStack = [];
                    this.extraStack = [];
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.embedFonts = false;
                    this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                    this.cssStyle = null;
                    this.forceDataSchema = !!forceDataSchema;
                    this._operatorIdMapping = [];
                    for (const op in _util2.OPS) {
                      this._operatorIdMapping[_util2.OPS[op]] = op;
                    }
                  }
                  save() {
                    this.transformStack.push(this.transformMatrix);
                    const old = this.current;
                    this.extraStack.push(old);
                    this.current = old.clone();
                  }
                  restore() {
                    this.transformMatrix = this.transformStack.pop();
                    this.current = this.extraStack.pop();
                    this.pendingClip = null;
                    this.tgrp = null;
                  }
                  group(items) {
                    this.save();
                    this.executeOpTree(items);
                    this.restore();
                  }
                  loadDependencies(operatorList) {
                    const fnArray = operatorList.fnArray;
                    const argsArray = operatorList.argsArray;
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      if (fnArray[i] !== _util2.OPS.dependency) {
                        continue;
                      }
                      for (const obj of argsArray[i]) {
                        const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
                        const promise = new Promise((resolve) => {
                          objsPool.get(obj, resolve);
                        });
                        this.current.dependencies.push(promise);
                      }
                    }
                    return Promise.all(this.current.dependencies);
                  }
                  transform(a, b, c, d, e, f2) {
                    const transformMatrix = [a, b, c, d, e, f2];
                    this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                    this.tgrp = null;
                  }
                  getSVG(operatorList, viewport) {
                    this.viewport = viewport;
                    const svgElement = this._initialize(viewport);
                    return this.loadDependencies(operatorList).then(() => {
                      this.transformMatrix = _util2.IDENTITY_MATRIX;
                      this.executeOpTree(this.convertOpList(operatorList));
                      return svgElement;
                    });
                  }
                  convertOpList(operatorList) {
                    const operatorIdMapping = this._operatorIdMapping;
                    const argsArray = operatorList.argsArray;
                    const fnArray = operatorList.fnArray;
                    const opList = [];
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      const fnId = fnArray[i];
                      opList.push({
                        fnId,
                        fn: operatorIdMapping[fnId],
                        args: argsArray[i]
                      });
                    }
                    return opListToTree(opList);
                  }
                  executeOpTree(opTree) {
                    for (const opTreeElement of opTree) {
                      const fn = opTreeElement.fn;
                      const fnId = opTreeElement.fnId;
                      const args = opTreeElement.args;
                      switch (fnId | 0) {
                        case _util2.OPS.beginText:
                          this.beginText();
                          break;
                        case _util2.OPS.dependency:
                          break;
                        case _util2.OPS.setLeading:
                          this.setLeading(args);
                          break;
                        case _util2.OPS.setLeadingMoveText:
                          this.setLeadingMoveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setFont:
                          this.setFont(args);
                          break;
                        case _util2.OPS.showText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.showSpacedText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.endText:
                          this.endText();
                          break;
                        case _util2.OPS.moveText:
                          this.moveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setCharSpacing:
                          this.setCharSpacing(args[0]);
                          break;
                        case _util2.OPS.setWordSpacing:
                          this.setWordSpacing(args[0]);
                          break;
                        case _util2.OPS.setHScale:
                          this.setHScale(args[0]);
                          break;
                        case _util2.OPS.setTextMatrix:
                          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.setTextRise:
                          this.setTextRise(args[0]);
                          break;
                        case _util2.OPS.setTextRenderingMode:
                          this.setTextRenderingMode(args[0]);
                          break;
                        case _util2.OPS.setLineWidth:
                          this.setLineWidth(args[0]);
                          break;
                        case _util2.OPS.setLineJoin:
                          this.setLineJoin(args[0]);
                          break;
                        case _util2.OPS.setLineCap:
                          this.setLineCap(args[0]);
                          break;
                        case _util2.OPS.setMiterLimit:
                          this.setMiterLimit(args[0]);
                          break;
                        case _util2.OPS.setFillRGBColor:
                          this.setFillRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeRGBColor:
                          this.setStrokeRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeColorN:
                          this.setStrokeColorN(args);
                          break;
                        case _util2.OPS.setFillColorN:
                          this.setFillColorN(args);
                          break;
                        case _util2.OPS.shadingFill:
                          this.shadingFill(args[0]);
                          break;
                        case _util2.OPS.setDash:
                          this.setDash(args[0], args[1]);
                          break;
                        case _util2.OPS.setRenderingIntent:
                          this.setRenderingIntent(args[0]);
                          break;
                        case _util2.OPS.setFlatness:
                          this.setFlatness(args[0]);
                          break;
                        case _util2.OPS.setGState:
                          this.setGState(args[0]);
                          break;
                        case _util2.OPS.fill:
                          this.fill();
                          break;
                        case _util2.OPS.eoFill:
                          this.eoFill();
                          break;
                        case _util2.OPS.stroke:
                          this.stroke();
                          break;
                        case _util2.OPS.fillStroke:
                          this.fillStroke();
                          break;
                        case _util2.OPS.eoFillStroke:
                          this.eoFillStroke();
                          break;
                        case _util2.OPS.clip:
                          this.clip("nonzero");
                          break;
                        case _util2.OPS.eoClip:
                          this.clip("evenodd");
                          break;
                        case _util2.OPS.paintSolidColorImageMask:
                          this.paintSolidColorImageMask();
                          break;
                        case _util2.OPS.paintImageXObject:
                          this.paintImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintInlineImageXObject:
                          this.paintInlineImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintImageMaskXObject:
                          this.paintImageMaskXObject(args[0]);
                          break;
                        case _util2.OPS.paintFormXObjectBegin:
                          this.paintFormXObjectBegin(args[0], args[1]);
                          break;
                        case _util2.OPS.paintFormXObjectEnd:
                          this.paintFormXObjectEnd();
                          break;
                        case _util2.OPS.closePath:
                          this.closePath();
                          break;
                        case _util2.OPS.closeStroke:
                          this.closeStroke();
                          break;
                        case _util2.OPS.closeFillStroke:
                          this.closeFillStroke();
                          break;
                        case _util2.OPS.closeEOFillStroke:
                          this.closeEOFillStroke();
                          break;
                        case _util2.OPS.nextLine:
                          this.nextLine();
                          break;
                        case _util2.OPS.transform:
                          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.constructPath:
                          this.constructPath(args[0], args[1]);
                          break;
                        case _util2.OPS.endPath:
                          this.endPath();
                          break;
                        case 92:
                          this.group(opTreeElement.items);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented operator ${fn}`);
                          break;
                      }
                    }
                  }
                  setWordSpacing(wordSpacing) {
                    this.current.wordSpacing = wordSpacing;
                  }
                  setCharSpacing(charSpacing) {
                    this.current.charSpacing = charSpacing;
                  }
                  nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                  setTextMatrix(a, b, c, d, e, f2) {
                    const current = this.current;
                    current.textMatrix = current.lineMatrix = [a, b, c, d, e, f2];
                    current.textMatrixScale = Math.hypot(a, b);
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtElement.append(current.tspan);
                  }
                  beginText() {
                    const current = this.current;
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.textMatrix = _util2.IDENTITY_MATRIX;
                    current.lineMatrix = _util2.IDENTITY_MATRIX;
                    current.textMatrixScale = 1;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtgrp = this.svgFactory.createElement("svg:g");
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  moveText(x, y) {
                    const current = this.current;
                    current.x = current.lineX += x;
                    current.y = current.lineY += y;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  showText(glyphs) {
                    const current = this.current;
                    const font2 = current.font;
                    const fontSize = current.fontSize;
                    if (fontSize === 0) {
                      return;
                    }
                    const fontSizeScale = current.fontSizeScale;
                    const charSpacing = current.charSpacing;
                    const wordSpacing = current.wordSpacing;
                    const fontDirection = current.fontDirection;
                    const textHScale = current.textHScale * fontDirection;
                    const vertical = font2.vertical;
                    const spacingDir = vertical ? 1 : -1;
                    const defaultVMetrics = font2.defaultVMetrics;
                    const widthAdvanceScale = fontSize * current.fontMatrix[0];
                    let x = 0;
                    for (const glyph of glyphs) {
                      if (glyph === null) {
                        x += fontDirection * wordSpacing;
                        continue;
                      } else if (typeof glyph === "number") {
                        x += spacingDir * glyph * fontSize / 1e3;
                        continue;
                      }
                      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      const character = glyph.fontChar;
                      let scaledX, scaledY;
                      let width2 = glyph.width;
                      if (vertical) {
                        let vx;
                        const vmetric = glyph.vmetric || defaultVMetrics;
                        vx = glyph.vmetric ? vmetric[1] : width2 * 0.5;
                        vx = -vx * widthAdvanceScale;
                        const vy = vmetric[2] * widthAdvanceScale;
                        width2 = vmetric ? -vmetric[0] : width2;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (glyph.isInFont || font2.missingFile) {
                        current.xcoords.push(current.x + scaledX);
                        if (vertical) {
                          current.ycoords.push(-current.y + scaledY);
                        }
                        current.tspan.textContent += character;
                      } else {
                      }
                      let charWidth;
                      if (vertical) {
                        charWidth = width2 * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width2 * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                    }
                    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                    if (vertical) {
                      current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                    } else {
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                    }
                    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                    }
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                        current.tspan.setAttributeNS(null, "fill", current.fillColor);
                      }
                      if (current.fillAlpha < 1) {
                        current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      }
                    } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                      current.tspan.setAttributeNS(null, "fill", "transparent");
                    } else {
                      current.tspan.setAttributeNS(null, "fill", "none");
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      const lineWidthScale = 1 / (current.textMatrixScale || 1);
                      this._setStrokeAttributes(current.tspan, lineWidthScale);
                    }
                    let textMatrix = current.textMatrix;
                    if (current.textRise !== 0) {
                      textMatrix = textMatrix.slice();
                      textMatrix[5] += current.textRise;
                    }
                    current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                    current.txtElement.append(current.tspan);
                    current.txtgrp.append(current.txtElement);
                    this._ensureTransformGroup().append(current.txtElement);
                  }
                  setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                  addFontStyle(fontObj) {
                    if (!fontObj.data) {
                      throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                    }
                    if (!this.cssStyle) {
                      this.cssStyle = this.svgFactory.createElement("svg:style");
                      this.cssStyle.setAttributeNS(null, "type", "text/css");
                      this.defs.append(this.cssStyle);
                    }
                    const url2 = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                    this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url2}); }
`;
                  }
                  setFont(details) {
                    const current = this.current;
                    const fontObj = this.commonObjs.get(details[0]);
                    let size = details[1];
                    current.font = fontObj;
                    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                      this.addFontStyle(fontObj);
                      this.embeddedFonts[fontObj.loadedName] = fontObj;
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    let bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    const italic = fontObj.italic ? "italic" : "normal";
                    if (size < 0) {
                      size = -size;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    current.fontSize = size;
                    current.fontFamily = fontObj.loadedName;
                    current.fontWeight = bold;
                    current.fontStyle = italic;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  endText() {
                    const current = this.current;
                    if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
                      current.element = current.txtElement;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  setLineWidth(width2) {
                    if (width2 > 0) {
                      this.current.lineWidth = width2;
                    }
                  }
                  setLineCap(style) {
                    this.current.lineCap = LINE_CAP_STYLES[style];
                  }
                  setLineJoin(style) {
                    this.current.lineJoin = LINE_JOIN_STYLES[style];
                  }
                  setMiterLimit(limit) {
                    this.current.miterLimit = limit;
                  }
                  setStrokeAlpha(strokeAlpha) {
                    this.current.strokeAlpha = strokeAlpha;
                  }
                  setStrokeRGBColor(r, g, b) {
                    this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                  }
                  setFillAlpha(fillAlpha) {
                    this.current.fillAlpha = fillAlpha;
                  }
                  setFillRGBColor(r, g, b) {
                    this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.xcoords = [];
                    this.current.ycoords = [];
                  }
                  setStrokeColorN(args) {
                    this.current.strokeColor = this._makeColorN_Pattern(args);
                  }
                  setFillColorN(args) {
                    this.current.fillColor = this._makeColorN_Pattern(args);
                  }
                  shadingFill(args) {
                    const width2 = this.viewport.width;
                    const height = this.viewport.height;
                    const inv = _util2.Util.inverseTransform(this.transformMatrix);
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height], inv);
                    const ul = _util2.Util.applyTransform([width2, 0], inv);
                    const ur = _util2.Util.applyTransform([width2, height], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", x0);
                    rect.setAttributeNS(null, "y", y0);
                    rect.setAttributeNS(null, "width", x1 - x0);
                    rect.setAttributeNS(null, "height", y1 - y0);
                    rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                    if (this.current.fillAlpha < 1) {
                      rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                    }
                    this._ensureTransformGroup().append(rect);
                  }
                  _makeColorN_Pattern(args) {
                    if (args[0] === "TilingPattern") {
                      return this._makeTilingPattern(args);
                    }
                    return this._makeShadingPattern(args);
                  }
                  _makeTilingPattern(args) {
                    const color = args[1];
                    const operatorList = args[2];
                    const matrix = args[3] || _util2.IDENTITY_MATRIX;
                    const [x0, y0, x1, y1] = args[4];
                    const xstep = args[5];
                    const ystep = args[6];
                    const paintType = args[7];
                    const tilingId = `shading${shadingCount++}`;
                    const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                    const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                    const txstep = xstep * xscale;
                    const tystep = ystep * yscale;
                    const tiling = this.svgFactory.createElement("svg:pattern");
                    tiling.setAttributeNS(null, "id", tilingId);
                    tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                    tiling.setAttributeNS(null, "width", txstep);
                    tiling.setAttributeNS(null, "height", tystep);
                    tiling.setAttributeNS(null, "x", `${tx0}`);
                    tiling.setAttributeNS(null, "y", `${ty0}`);
                    const svg = this.svg;
                    const transformMatrix = this.transformMatrix;
                    const fillColor = this.current.fillColor;
                    const strokeColor = this.current.strokeColor;
                    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                    this.svg = bbox;
                    this.transformMatrix = matrix;
                    if (paintType === 2) {
                      const cssColor = _util2.Util.makeHexColor(...color);
                      this.current.fillColor = cssColor;
                      this.current.strokeColor = cssColor;
                    }
                    this.executeOpTree(this.convertOpList(operatorList));
                    this.svg = svg;
                    this.transformMatrix = transformMatrix;
                    this.current.fillColor = fillColor;
                    this.current.strokeColor = strokeColor;
                    tiling.append(bbox.childNodes[0]);
                    this.defs.append(tiling);
                    return `url(#${tilingId})`;
                  }
                  _makeShadingPattern(args) {
                    if (typeof args === "string") {
                      args = this.objs.get(args);
                    }
                    switch (args[0]) {
                      case "RadialAxial":
                        const shadingId = `shading${shadingCount++}`;
                        const colorStops = args[3];
                        let gradient;
                        switch (args[1]) {
                          case "axial":
                            const point0 = args[4];
                            const point1 = args[5];
                            gradient = this.svgFactory.createElement("svg:linearGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "x1", point0[0]);
                            gradient.setAttributeNS(null, "y1", point0[1]);
                            gradient.setAttributeNS(null, "x2", point1[0]);
                            gradient.setAttributeNS(null, "y2", point1[1]);
                            break;
                          case "radial":
                            const focalPoint = args[4];
                            const circlePoint = args[5];
                            const focalRadius = args[6];
                            const circleRadius = args[7];
                            gradient = this.svgFactory.createElement("svg:radialGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "cx", circlePoint[0]);
                            gradient.setAttributeNS(null, "cy", circlePoint[1]);
                            gradient.setAttributeNS(null, "r", circleRadius);
                            gradient.setAttributeNS(null, "fx", focalPoint[0]);
                            gradient.setAttributeNS(null, "fy", focalPoint[1]);
                            gradient.setAttributeNS(null, "fr", focalRadius);
                            break;
                          default:
                            throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                        }
                        for (const colorStop of colorStops) {
                          const stop = this.svgFactory.createElement("svg:stop");
                          stop.setAttributeNS(null, "offset", colorStop[0]);
                          stop.setAttributeNS(null, "stop-color", colorStop[1]);
                          gradient.append(stop);
                        }
                        this.defs.append(gradient);
                        return `url(#${shadingId})`;
                      case "Mesh":
                        (0, _util2.warn)("Unimplemented pattern Mesh");
                        return null;
                      case "Dummy":
                        return "hotpink";
                      default:
                        throw new Error(`Unknown IR type: ${args[0]}`);
                    }
                  }
                  setDash(dashArray, dashPhase) {
                    this.current.dashArray = dashArray;
                    this.current.dashPhase = dashPhase;
                  }
                  constructPath(ops, args) {
                    const current = this.current;
                    let x = current.x, y = current.y;
                    let d = [];
                    let j = 0;
                    for (const op of ops) {
                      switch (op | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          const width2 = args[j++];
                          const height = args[j++];
                          const xw = x + width2;
                          const yh = y + height;
                          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("M", pf(x), pf(y));
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("L", pf(x), pf(y));
                          break;
                        case _util2.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          d.push("Z");
                          break;
                      }
                    }
                    d = d.join(" ");
                    if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                      d = current.path.getAttributeNS(null, "d") + d;
                    } else {
                      current.path = this.svgFactory.createElement("svg:path");
                      this._ensureTransformGroup().append(current.path);
                    }
                    current.path.setAttributeNS(null, "d", d);
                    current.path.setAttributeNS(null, "fill", "none");
                    current.element = current.path;
                    current.setCurrentPoint(x, y);
                  }
                  endPath() {
                    const current = this.current;
                    current.path = null;
                    if (!this.pendingClip) {
                      return;
                    }
                    if (!current.element) {
                      this.pendingClip = null;
                      return;
                    }
                    const clipId = `clippath${clipCount++}`;
                    const clipPath = this.svgFactory.createElement("svg:clipPath");
                    clipPath.setAttributeNS(null, "id", clipId);
                    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    const clipElement = current.element.cloneNode(true);
                    if (this.pendingClip === "evenodd") {
                      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                    } else {
                      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                    }
                    this.pendingClip = null;
                    clipPath.append(clipElement);
                    this.defs.append(clipPath);
                    if (current.activeClipUrl) {
                      current.clipGroup = null;
                      for (const prev of this.extraStack) {
                        prev.clipGroup = null;
                      }
                      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                    }
                    current.activeClipUrl = `url(#${clipId})`;
                    this.tgrp = null;
                  }
                  clip(type2) {
                    this.pendingClip = type2;
                  }
                  closePath() {
                    const current = this.current;
                    if (current.path) {
                      const d = `${current.path.getAttributeNS(null, "d")}Z`;
                      current.path.setAttributeNS(null, "d", d);
                    }
                  }
                  setLeading(leading) {
                    this.current.leading = -leading;
                  }
                  setTextRise(textRise) {
                    this.current.textRise = textRise;
                  }
                  setTextRenderingMode(textRenderingMode) {
                    this.current.textRenderingMode = textRenderingMode;
                  }
                  setHScale(scale4) {
                    this.current.textHScale = scale4 / 100;
                  }
                  setRenderingIntent(intent) {
                  }
                  setFlatness(flatness) {
                  }
                  setGState(states) {
                    for (const [key, value2] of states) {
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value2);
                          break;
                        case "LC":
                          this.setLineCap(value2);
                          break;
                        case "LJ":
                          this.setLineJoin(value2);
                          break;
                        case "ML":
                          this.setMiterLimit(value2);
                          break;
                        case "D":
                          this.setDash(value2[0], value2[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value2);
                          break;
                        case "FL":
                          this.setFlatness(value2);
                          break;
                        case "Font":
                          this.setFont(value2);
                          break;
                        case "CA":
                          this.setStrokeAlpha(value2);
                          break;
                        case "ca":
                          this.setFillAlpha(value2);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                          break;
                      }
                    }
                  }
                  fill() {
                    const current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "fill", current.fillColor);
                      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      this.endPath();
                    }
                  }
                  stroke() {
                    const current = this.current;
                    if (current.element) {
                      this._setStrokeAttributes(current.element);
                      current.element.setAttributeNS(null, "fill", "none");
                      this.endPath();
                    }
                  }
                  _setStrokeAttributes(element, lineWidthScale = 1) {
                    const current = this.current;
                    let dashArray = current.dashArray;
                    if (lineWidthScale !== 1 && dashArray.length > 0) {
                      dashArray = dashArray.map(function(value2) {
                        return lineWidthScale * value2;
                      });
                    }
                    element.setAttributeNS(null, "stroke", current.strokeColor);
                    element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                    element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                    element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                    element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                    element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                    element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                    element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                  }
                  eoFill() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fill();
                  }
                  fillStroke() {
                    this.stroke();
                    this.fill();
                  }
                  eoFillStroke() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fillStroke();
                  }
                  closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                  closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                  closeEOFillStroke() {
                    this.closePath();
                    this.eoFillStroke();
                  }
                  paintSolidColorImageMask() {
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", "1px");
                    rect.setAttributeNS(null, "height", "1px");
                    rect.setAttributeNS(null, "fill", this.current.fillColor);
                    this._ensureTransformGroup().append(rect);
                  }
                  paintImageXObject(objId) {
                    const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                  paintInlineImageXObject(imgData, mask) {
                    const width2 = imgData.width;
                    const height = imgData.height;
                    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", "0");
                    cliprect.setAttributeNS(null, "y", "0");
                    cliprect.setAttributeNS(null, "width", pf(width2));
                    cliprect.setAttributeNS(null, "height", pf(height));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    const imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-height));
                    imgEl.setAttributeNS(null, "width", pf(width2) + "px");
                    imgEl.setAttributeNS(null, "height", pf(height) + "px");
                    imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width2)} ${pf(-1 / height)})`);
                    if (mask) {
                      mask.append(imgEl);
                    } else {
                      this._ensureTransformGroup().append(imgEl);
                    }
                  }
                  paintImageMaskXObject(imgData) {
                    const current = this.current;
                    const width2 = imgData.width;
                    const height = imgData.height;
                    const fillColor = current.fillColor;
                    current.maskId = `mask${maskCount++}`;
                    const mask = this.svgFactory.createElement("svg:mask");
                    mask.setAttributeNS(null, "id", current.maskId);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", pf(width2));
                    rect.setAttributeNS(null, "height", pf(height));
                    rect.setAttributeNS(null, "fill", fillColor);
                    rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                    this.defs.append(mask);
                    this._ensureTransformGroup().append(rect);
                    this.paintInlineImageXObject(imgData, mask);
                  }
                  paintFormXObjectBegin(matrix, bbox) {
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                    }
                    if (bbox) {
                      const width2 = bbox[2] - bbox[0];
                      const height = bbox[3] - bbox[1];
                      const cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", bbox[0]);
                      cliprect.setAttributeNS(null, "y", bbox[1]);
                      cliprect.setAttributeNS(null, "width", pf(width2));
                      cliprect.setAttributeNS(null, "height", pf(height));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  paintFormXObjectEnd() {
                  }
                  _initialize(viewport) {
                    const svg = this.svgFactory.create(viewport.width, viewport.height);
                    const definitions = this.svgFactory.createElement("svg:defs");
                    svg.append(definitions);
                    this.defs = definitions;
                    const rootGroup = this.svgFactory.createElement("svg:g");
                    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                    svg.append(rootGroup);
                    this.svg = rootGroup;
                    return svg;
                  }
                  _ensureClipGroup() {
                    if (!this.current.clipGroup) {
                      const clipGroup = this.svgFactory.createElement("svg:g");
                      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                      this.svg.append(clipGroup);
                      this.current.clipGroup = clipGroup;
                    }
                    return this.current.clipGroup;
                  }
                  _ensureTransformGroup() {
                    if (!this.tgrp) {
                      this.tgrp = this.svgFactory.createElement("svg:g");
                      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      if (this.current.activeClipUrl) {
                        this._ensureClipGroup().append(this.tgrp);
                      } else {
                        this.svg.append(this.tgrp);
                      }
                    }
                    return this.tgrp;
                  }
                };
              }
            },
            /* 32 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              const fs = require_fs();
              const http = require_http();
              const https = require_https();
              const url2 = require_url();
              const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                const parsedUrl = url2.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url2.parse(`file:///${sourceUrl}`);
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              class PDFNodeStream {
                constructor(source) {
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(start, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNodeStream = PDFNodeStream;
              class BaseFullReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  const source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              class BaseRangeReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  const source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              class PDFNodeStreamFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._headersCapability.resolve();
                    this._setReadableStream(response);
                    const getResponseHeader = (name) => {
                      return this._readableStream.headers[name.toLowerCase()];
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                    this._headersCapability.reject(reason);
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  this._httpHeaders = {};
                  for (const property in stream.httpHeaders) {
                    const value2 = stream.httpHeaders[property];
                    if (typeof value2 === "undefined") {
                      continue;
                    }
                    this._httpHeaders[property] = value2;
                  }
                  this._httpHeaders.Range = `bytes=${start}-${end - 1}`;
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      return;
                    }
                    this._setReadableStream(response);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamFsFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  fs.lstat(path, (error, stat) => {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                      }
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._contentLength = stat.size;
                    this._setReadableStream(fs.createReadStream(path));
                    this._headersCapability.resolve();
                  });
                }
              }
              class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                constructor(stream, start, end) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  this._setReadableStream(fs.createReadStream(path, {
                    start,
                    end: end - 1
                  }));
                }
              }
            },
            /* 33 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(34);
              var _display_utils2 = __w_pdfjs_require__2(8);
              function validateRangeRequestCapabilities({
                getResponseHeader,
                isHttp,
                rangeChunkSize,
                disableRange
              }) {
                const returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                const length4 = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length4)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length4;
                if (length4 <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                const contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch (ex) {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url2) {
                if (status === 404 || status === 0 && url2.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url2 + '".');
                }
                return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url2}".`, status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            /* 34 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                let needsEncodingFixup = true;
                let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  const filename = rfc2047decode(tmp);
                  return fixupEncoding(filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value2) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value2)) {
                      return value2;
                    }
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = (0, _util2.stringToBytes)(value2);
                      value2 = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch (e) {
                    }
                  }
                  return value2;
                }
                function fixupEncoding(value2) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value2)) {
                    value2 = textdecode("utf-8", value2);
                    if (needsEncodingFixup) {
                      value2 = textdecode("iso-8859-1", value2);
                    }
                  }
                  return value2;
                }
                function rfc2231getparam(contentDispositionStr) {
                  const matches = [];
                  let match;
                  const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    let [, n, quot, part] = match;
                    n = parseInt(n, 10);
                    if (n in matches) {
                      if (n === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n] = [quot, part];
                  }
                  const parts = [];
                  for (let n = 0; n < matches.length; ++n) {
                    if (!(n in matches)) {
                      break;
                    }
                    let [quot, part] = matches[n];
                    part = rfc2616unquote(part);
                    if (quot) {
                      part = unescape(part);
                      if (n === 0) {
                        part = rfc5987decode(part);
                      }
                    }
                    parts.push(part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value2) {
                  if (value2.startsWith('"')) {
                    const parts = value2.slice(1).split('\\"');
                    for (let i = 0; i < parts.length; ++i) {
                      const quotindex = parts[i].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i] = parts[i].slice(0, quotindex);
                        parts.length = i + 1;
                      }
                      parts[i] = parts[i].replace(/\\(.)/g, "$1");
                    }
                    value2 = parts.join('"');
                  }
                  return value2;
                }
                function rfc5987decode(extvalue) {
                  const encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  const encoding = extvalue.slice(0, encodingend);
                  const langvalue = extvalue.slice(encodingend + 1);
                  const value2 = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value2);
                }
                function rfc2047decode(value2) {
                  if (!value2.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value2)) {
                    return value2;
                  }
                  return value2.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text2) {
                    if (encoding === "q" || encoding === "Q") {
                      text2 = text2.replace(/_/g, " ");
                      text2 = text2.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text2);
                    }
                    try {
                      text2 = atob(text2);
                    } catch (e) {
                    }
                    return textdecode(charset, text2);
                  });
                }
                return "";
              }
            },
            /* 35 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              const OK_RESPONSE = 200;
              const PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                const data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                const array = (0, _util2.stringToBytes)(data);
                return array.buffer;
              }
              class NetworkManager {
                constructor(url2, args = {}) {
                  this.url = url2;
                  this.isHttp = /^https?:/i.test(url2);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                    return new XMLHttpRequest();
                  };
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                requestRange(begin, end, listeners) {
                  const args = {
                    begin,
                    end
                  };
                  for (const prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
                requestFull(listeners) {
                  return this.request(listeners);
                }
                request(args) {
                  const xhr = this.getXhr();
                  const xhrId = this.currXhrId++;
                  const pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (const property in this.httpHeaders) {
                    const value2 = this.httpHeaders[property];
                    if (typeof value2 === "undefined") {
                      continue;
                    }
                    xhr.setRequestHeader(property, value2);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
                onProgress(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  pendingRequest.onProgress?.(evt);
                }
                onStateChange(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  const xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    pendingRequest.onError?.(xhr.status);
                    return;
                  }
                  const xhrStatus = xhr.status || OK_RESPONSE;
                  const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    pendingRequest.onError?.(xhr.status);
                    return;
                  }
                  const chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    const rangeHeader = xhr.getResponseHeader("Content-Range");
                    const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else {
                    pendingRequest.onError?.(xhr.status);
                  }
                }
                getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
                isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
                abortRequest(xhrId) {
                  const xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }
              class PDFNetworkStream {
                constructor(source) {
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _onRangeRequestReaderClosed(reader) {
                  const i = this._rangeRequestReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeRequestReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  this._fullRequestReader?.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNetworkStream = PDFNetworkStream;
              class PDFNetworkStreamFullRequestReader {
                constructor(manager, source) {
                  this._manager = manager;
                  const args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _onHeadersReceived() {
                  const fullRequestXhrId = this._fullRequestId;
                  const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  const getResponseHeader = (name) => {
                    return fullRequestXhr.getResponseHeader(name);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
                _onDone(data) {
                  if (data) {
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: data.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(data.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  this._headersReceivedCapability.reject(this._storedError);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._cachedChunks.length = 0;
                }
                _onProgress(evt) {
                  this.onProgress?.({
                    loaded: evt.loaded,
                    total: evt.lengthComputable ? evt.total : this._contentLength
                  });
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get headersReady() {
                  return this._headersReceivedCapability.promise;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }
              class PDFNetworkStreamRangeRequestReader {
                constructor(manager, begin, end) {
                  this._manager = manager;
                  const args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _close() {
                  this.onClosed?.(this);
                }
                _onDone(data) {
                  const chunk = data.chunk;
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._close();
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._queuedChunk = null;
                }
                _onProgress(evt) {
                  if (!this.isStreamingSupported) {
                    this.onProgress?.({
                      loaded: evt.loaded
                    });
                  }
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }
            },
            /* 36 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                const headers = new Headers();
                for (const property in httpHeaders) {
                  const value2 = httpHeaders[property];
                  if (typeof value2 === "undefined") {
                    continue;
                  }
                  headers.append(property, value2);
                }
                return headers;
              }
              class PDFFetchStream {
                constructor(source) {
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end) {
                  if (end <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFFetchStreamRangeReader(this, begin, end);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFFetchStream = PDFFetchStream;
              class PDFFetchStreamReader {
                constructor(stream) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._abortController = new AbortController();
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  const url2 = source.url;
                  fetch(url2, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url2);
                    }
                    this._reader = response.body.getReader();
                    this._headersCapability.resolve();
                    const getResponseHeader = (name) => {
                      return response.headers.get(name);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  }).catch(this._headersCapability.reject);
                  this.onProgress = null;
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._headersCapability.promise;
                  const {
                    value: value2,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: value2,
                      done
                    };
                  }
                  this._loaded += value2.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(value2).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
              class PDFFetchStreamRangeReader {
                constructor(stream, begin, end) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._isStreamingSupported = !source.disableStream;
                  this._abortController = new AbortController();
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", `bytes=${begin}-${end - 1}`);
                  const url2 = source.url;
                  fetch(url2, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url2);
                    }
                    this._readCapability.resolve();
                    this._reader = response.body.getReader();
                  }).catch(this._readCapability.reject);
                  this.onProgress = null;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  const {
                    value: value2,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: value2,
                      done
                    };
                  }
                  this._loaded += value2.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(value2).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AnnotationEditorLayer", {
              enumerable: true,
              get: function() {
                return _annotation_editor_layer.AnnotationEditorLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorParamsType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorParamsType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorUIManager", {
              enumerable: true,
              get: function() {
                return _tools.AnnotationEditorUIManager;
              }
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "LoopbackPort", {
              enumerable: true,
              get: function() {
                return _api.LoopbackPort;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            Object.defineProperty(exports2, "SVGGraphics", {
              enumerable: true,
              get: function() {
                return _svg.SVGGraphics;
              }
            });
            Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
              enumerable: true,
              get: function() {
                return _util2.UNSUPPORTED_FEATURES;
              }
            });
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createPromiseCapability", {
              enumerable: true,
              get: function() {
                return _util2.createPromiseCapability;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(4);
            var _display_utils2 = __w_pdfjs_require__(8);
            var _annotation_editor_layer = __w_pdfjs_require__(22);
            var _tools = __w_pdfjs_require__(7);
            var _annotation_layer = __w_pdfjs_require__(27);
            var _worker_options2 = __w_pdfjs_require__(15);
            var _is_node2 = __w_pdfjs_require__(3);
            var _text_layer = __w_pdfjs_require__(30);
            var _svg = __w_pdfjs_require__(31);
            var _xfa_layer = __w_pdfjs_require__(29);
            const pdfjsVersion = "2.16.105";
            const pdfjsBuild = "172ccdbe5";
            {
              if (_is_node2.isNodeJS) {
                const {
                  PDFNodeStream
                } = __w_pdfjs_require__(32);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  return new PDFNodeStream(params);
                });
              } else {
                const {
                  PDFNetworkStream
                } = __w_pdfjs_require__(35);
                const {
                  PDFFetchStream
                } = __w_pdfjs_require__(36);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  if ((0, _display_utils2.isValidFetchUrl)(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/onUserGesture.ts
var USER_GESTURE_EVENTS = [
  "change",
  "click",
  "contextmenu",
  "dblclick",
  "mouseup",
  "pointerup",
  "reset",
  "submit",
  "touchend"
];
function onUserGesture(callback, perpetual = false) {
  const check = async (evt) => {
    if (evt.isTrusted) {
      if (!perpetual) {
        for (const gesture of USER_GESTURE_EVENTS) {
          window.removeEventListener(gesture, check);
        }
      }
      callback();
    }
  };
  for (const gesture of USER_GESTURE_EVENTS) {
    window.addEventListener(gesture, check);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/typeChecks.ts
function t(o, s, c) {
  return typeof o === s || o instanceof c;
}
function isFunction(obj) {
  return t(obj, "function", Function);
}
function isString(obj) {
  return t(obj, "string", String);
}
function isBoolean(obj) {
  return t(obj, "boolean", Boolean);
}
function isNumber(obj) {
  return t(obj, "number", Number);
}
function isObject(obj) {
  return isDefined(obj) && t(obj, "object", Object);
}
function isArray(obj) {
  return obj instanceof Array;
}
function assertNever(x, msg) {
  throw new Error((msg || "Unexpected object: ") + x);
}
function isNullOrUndefined(obj) {
  return obj === null || obj === void 0;
}
function isDefined(obj) {
  return !isNullOrUndefined(obj);
}
function isArrayBufferView(obj) {
  return obj instanceof Uint8Array || obj instanceof Uint8ClampedArray || obj instanceof Int8Array || obj instanceof Uint16Array || obj instanceof Int16Array || obj instanceof Uint32Array || obj instanceof Int32Array || obj instanceof Float32Array || obj instanceof Float64Array || "BigUint64Array" in globalThis && obj instanceof globalThis["BigUint64Array"] || "BigInt64Array" in globalThis && obj instanceof globalThis["BigInt64Array"];
}
function isArrayBuffer(val) {
  return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
  val.constructor && val.constructor.name === "ArrayBuffer");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/arrays.ts
function defaultKeySelector(obj) {
  return obj;
}
function arrayBinarySearchByKey(arr, itemKey, keySelector) {
  let left = 0;
  let right = arr.length;
  let idx = Math.floor((left + right) / 2);
  let found = false;
  while (left < right && idx < arr.length) {
    const compareTo = arr[idx];
    const compareToKey = isNullOrUndefined(compareTo) ? null : keySelector(compareTo);
    if (isDefined(compareToKey) && itemKey < compareToKey) {
      right = idx;
    } else {
      if (itemKey === compareToKey) {
        found = true;
      }
      left = idx + 1;
    }
    idx = Math.floor((left + right) / 2);
  }
  if (!found) {
    idx += 0.5;
  }
  return idx;
}
function arrayBinarySearch(arr, item, keySelector) {
  keySelector = keySelector || defaultKeySelector;
  const itemKey = keySelector(item);
  return arrayBinarySearchByKey(arr, itemKey, keySelector);
}
function arrayClear(arr) {
  return arr.splice(0);
}
function arrayCompare(arr1, arr2) {
  for (let i = 0; i < arr1.length; ++i) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return -1;
}
function arrayInsertAt(arr, item, idx) {
  arr.splice(idx, 0, item);
}
function arrayRemove(arr, value2) {
  const idx = arr.indexOf(value2);
  if (idx > -1) {
    arrayRemoveAt(arr, idx);
    return true;
  }
  return false;
}
function arrayRemoveAt(arr, idx) {
  return arr.splice(idx, 1)[0];
}
function arrayReplace(arr, ...items) {
  arr.splice(0, arr.length, ...items);
}
function _arrayScan(forward, arr, tests) {
  const start = forward ? 0 : arr.length - 1;
  const end = forward ? arr.length : -1;
  const inc = forward ? 1 : -1;
  for (const test of tests) {
    for (let i = start; i != end; i += inc) {
      const item = arr[i];
      if (test(item)) {
        return item;
      }
    }
  }
  return null;
}
function arrayScan(arr, ...tests) {
  return _arrayScan(true, arr, tests);
}
function arraySortedInsert(arr, item, keySelector, allowDuplicates) {
  let ks;
  if (isFunction(keySelector)) {
    ks = keySelector;
  } else if (isBoolean(keySelector)) {
    allowDuplicates = keySelector;
  }
  if (isNullOrUndefined(allowDuplicates)) {
    allowDuplicates = true;
  }
  return arraySortedInsertInternal(arr, item, ks, allowDuplicates);
}
function arraySortedInsertInternal(arr, item, ks, allowDuplicates) {
  let idx = arrayBinarySearch(arr, item, ks);
  const found = idx % 1 === 0;
  idx = idx | 0;
  if (!found || allowDuplicates) {
    arrayInsertAt(arr, item, idx);
  }
  return idx;
}
function arraySortByKeyInPlace(newArr, keySelector) {
  newArr.sort((a, b) => {
    const keyA = keySelector(a);
    const keyB = keySelector(b);
    if (keyA < keyB) {
      return -1;
    } else if (keyA > keyB) {
      return 1;
    } else {
      return 0;
    }
  });
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/BaseGraphNode.ts
function breadthFirstPeek(arr) {
  return arr[0];
}
function breadthFirstRemove(arr) {
  return arr.shift();
}
function depthFirstPeek(arr) {
  return arr[arr.length - 1];
}
function depthFirstRemove(arr) {
  return arr.pop();
}
var BaseGraphNode = class {
  constructor(value2) {
    this.value = value2;
    this._forward = new Array();
    this._reverse = new Array();
  }
  connectSorted(child, keySelector) {
    if (isDefined(keySelector)) {
      arraySortedInsert(this._forward, child, (n) => keySelector(n.value));
      arraySortedInsert(child._reverse, this, (n) => keySelector(n.value));
    } else {
      this.connectTo(child);
    }
  }
  connectTo(child) {
    this.connectAt(child, this._forward.length);
  }
  connectAt(child, index) {
    arrayInsertAt(this._forward, child, index);
    child._reverse.push(this);
  }
  disconnectFrom(child) {
    arrayRemove(this._forward, child);
    arrayRemove(child._reverse, this);
  }
  isConnectedTo(node) {
    return this._forward.indexOf(node) >= 0 || this._reverse.indexOf(node) >= 0;
  }
  flatten() {
    const visited = /* @__PURE__ */ new Set();
    const queue = [this];
    while (queue.length > 0) {
      const here = queue.shift();
      if (isDefined(here) && !visited.has(here)) {
        visited.add(here);
        queue.push(...here._forward);
      }
    }
    return Array.from(visited);
  }
  *traverse(breadthFirst) {
    const visited = /* @__PURE__ */ new Set();
    const queue = [this];
    const peek = breadthFirst ? breadthFirstPeek : depthFirstPeek;
    const remove = breadthFirst ? breadthFirstRemove : depthFirstRemove;
    while (queue.length > 0) {
      const here = peek(queue);
      if (!visited.has(here)) {
        visited.add(here);
        if (breadthFirst) {
          remove(queue);
          yield here;
        }
        if (here._forward.length > 0) {
          queue.push(...here._forward);
        }
      } else if (!breadthFirst) {
        remove(queue);
        yield here;
      }
    }
  }
  breadthFirst() {
    return this.traverse(true);
  }
  depthFirst() {
    return this.traverse(false);
  }
  search(predicate, breadthFirst = true) {
    for (const node of this.traverse(breadthFirst)) {
      if (predicate(node)) {
        return node;
      }
    }
    return null;
  }
  *searchAll(predicate, breadthFirst = true) {
    for (const node of this.traverse(breadthFirst)) {
      if (predicate(node)) {
        yield node;
      }
    }
  }
  find(v, breadthFirst = true) {
    return this.search((n) => n.value === v, breadthFirst);
  }
  findAll(v, breadthFirst = true) {
    return this.searchAll((n) => n.value === v, breadthFirst);
  }
  contains(node, breadthFirst = true) {
    for (const child of this.traverse(breadthFirst)) {
      if (child === node) {
        return true;
      }
    }
    return false;
  }
  containsValue(v, breadthFirst = true) {
    for (const child of this.traverse(breadthFirst)) {
      if (child.value === v) {
        return true;
      }
    }
    return false;
  }
  get _isEntryPoint() {
    return this._reverse.length === 0;
  }
  get _isExitPoint() {
    return this._forward.length === 0;
  }
  get isDisconnected() {
    return this._isEntryPoint && this._isExitPoint;
  }
  get isConnected() {
    return !this._isExitPoint || !this._isEntryPoint;
  }
  get isTerminus() {
    return this._isEntryPoint || this._isExitPoint;
  }
  get isInternal() {
    return !this._isEntryPoint && !this._isExitPoint;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/GraphNode.ts
var GraphNode = class extends BaseGraphNode {
  get connections() {
    return this._forward;
  }
  get isEntryPoint() {
    return this._isEntryPoint;
  }
  get isExitPoint() {
    return this._isExitPoint;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/Task.ts
var Task = class {
  /**
   * Create a new Task
   *
   * @param autoStart - set to false to require manually starting the Task. Useful
   * for reusable tasks that run on timers.
   */
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.onThens = new Array();
    this.onCatches = new Array();
    this._result = void 0;
    this._error = void 0;
    this._executionState = "waiting";
    this._resultState = "none";
    this.resolve = (value2) => {
      if (this.running) {
        this._result = value2;
        this._resultState = "resolved";
        for (const thenner of this.onThens) {
          thenner(value2);
        }
        this.clear();
        this._executionState = "finished";
      }
    };
    this.reject = (reason) => {
      if (this.running) {
        this._error = reason;
        this._resultState = "errored";
        for (const catcher of this.onCatches) {
          catcher(reason);
        }
        this.clear();
        this._executionState = "finished";
      }
    };
    if (this.autoStart) {
      this.start();
    }
  }
  clear() {
    arrayClear(this.onThens);
    arrayClear(this.onCatches);
  }
  /**
   * If the task was not auto-started, signal that the task is now ready to recieve
   * resolutions or rejections.
   **/
  start() {
    this._executionState = "running";
  }
  /**
   * Creates a resolving callback for a static value.
   * @param value
   */
  resolver(value2) {
    return () => this.resolve(value2);
  }
  resolveOn(target, resolveEvt, value2) {
    const resolver = this.resolver(value2);
    target.addEventListener(resolveEvt, resolver);
    this.finally(() => target.removeEventListener(resolveEvt, resolver));
  }
  /**
   * Get the last result that the task had resolved to, if any is available.
   *
   * If the Task had been rejected, attempting to get the result will rethrow
   * the error that had rejected the task.
   **/
  get result() {
    if (isDefined(this.error)) {
      throw this.error;
    }
    return this._result;
  }
  /**
   * Get the last error that the task had been rejected by, if any.
   **/
  get error() {
    return this._error;
  }
  /**
   * Get the current state of the task.
   **/
  get executionState() {
    return this._executionState;
  }
  /**
   * Returns true when the Task is hasn't started yet.
   **/
  get waiting() {
    return this.executionState === "waiting";
  }
  /**
   * Returns true when the Task is waiting to be resolved or rejected.
   **/
  get started() {
    return this.executionState !== "waiting";
  }
  /**
   * Returns true after the Task has started, but before it has finished.
   **/
  get running() {
    return this.executionState === "running";
  }
  /**
   * Returns true when the Task has been resolved or rejected.
   **/
  get finished() {
    return this.executionState === "finished";
  }
  get resultState() {
    return this._resultState;
  }
  /**
   * Returns true if the Task had been resolved successfully.
   **/
  get resolved() {
    return this.resultState === "resolved";
  }
  /**
   * Returns true if the Task had been rejected, regardless of any
   * reason being given.
   **/
  get errored() {
    return this.resultState === "errored";
  }
  get [Symbol.toStringTag]() {
    return this.toString();
  }
  /**
   * Calling Task.then(), Task.catch(), or Task.finally() creates a new Promise.
   * This method creates that promise and links it with the task.
   **/
  project() {
    return new Promise((resolve, reject) => {
      if (!this.finished) {
        this.onThens.push(resolve);
        this.onCatches.push(reject);
      } else if (this.errored) {
        reject(this.error);
      } else {
        resolve(this.result);
      }
    });
  }
  /**
   * Attach a handler to the task that fires when the task is resolved.
   * 
   * @param onfulfilled
   * @param onrejected
   */
  then(onfulfilled, onrejected) {
    return this.project().then(onfulfilled, onrejected);
  }
  /**
   * Attach a handler that fires when the Task is rejected.
   * 
   * @param onrejected
   */
  catch(onrejected) {
    return this.project().catch(onrejected);
  }
  /**
   * Attach a handler that fires regardless of whether the Task is resolved
   * or rejected.
   * 
   * @param onfinally
   */
  finally(onfinally) {
    return this.project().finally(onfinally);
  }
  /**
   * Resets the Task to an unsignalled state, which is useful for
   * reducing GC pressure when working with lots of tasks.
   **/
  reset() {
    this._reset(this.autoStart);
  }
  restart() {
    this._reset(true);
  }
  _reset(start) {
    if (this.running) {
      this.reject("Resetting previous invocation");
    }
    this.clear();
    this._result = void 0;
    this._error = void 0;
    this._executionState = "waiting";
    this._resultState = "none";
    if (start) {
      this.start();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/IAudioNode.ts
function isEndpoint(obj) {
  return isDefined(obj) && "_resolveInput" in obj;
}
function isIAudioNode(obj) {
  return isEndpoint(obj) && "_resolveOutput" in obj;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/EventBase.ts
var EventBase = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.listenerOptions = /* @__PURE__ */ new Map();
  }
  addEventListener(type2, callback, options) {
    if (isFunction(callback)) {
      let listeners = this.listeners.get(type2);
      if (!listeners) {
        listeners = new Array();
        this.listeners.set(type2, listeners);
      }
      if (!listeners.find((c) => c === callback)) {
        listeners.push(callback);
        if (options) {
          this.listenerOptions.set(callback, options);
        }
      }
    }
  }
  removeEventListener(type2, callback) {
    if (isFunction(callback)) {
      const listeners = this.listeners.get(type2);
      if (listeners) {
        this.removeListener(listeners, callback);
      }
    }
  }
  clearEventListeners(type2) {
    for (const [evtName, handlers] of this.listeners) {
      if (isNullOrUndefined(type2) || type2 === evtName) {
        for (const handler of handlers) {
          this.removeEventListener(type2, handler);
        }
        arrayClear(handlers);
        this.listeners.delete(evtName);
      }
    }
  }
  removeListener(listeners, callback) {
    const idx = listeners.findIndex((c) => c === callback);
    if (idx >= 0) {
      arrayRemoveAt(listeners, idx);
      if (this.listenerOptions.has(callback)) {
        this.listenerOptions.delete(callback);
      }
    }
  }
  dispatchEvent(evt) {
    const listeners = this.listeners.get(evt.type);
    if (listeners) {
      for (const callback of listeners) {
        const options = this.listenerOptions.get(callback);
        if (isDefined(options) && !isBoolean(options) && options.once) {
          this.removeListener(listeners, callback);
        }
        callback.call(this, evt);
      }
    }
    return !evt.defaultPrevented;
  }
};
var TypedEvent = class extends Event {
  get type() {
    return super.type;
  }
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
  }
};
var TypedEventBase = class extends EventBase {
  constructor() {
    super(...arguments);
    this.bubblers = /* @__PURE__ */ new Set();
    this.scopes = /* @__PURE__ */ new WeakMap();
  }
  addBubbler(bubbler) {
    this.bubblers.add(bubbler);
  }
  removeBubbler(bubbler) {
    this.bubblers.delete(bubbler);
  }
  addEventListener(type2, callback, options) {
    super.addEventListener(type2, callback, options);
  }
  removeEventListener(type2, callback) {
    super.removeEventListener(type2, callback);
  }
  clearEventListeners(type2) {
    return super.clearEventListeners(type2);
  }
  addScopedEventListener(scope, type2, callback, options) {
    if (!this.scopes.has(scope)) {
      this.scopes.set(scope, []);
    }
    this.scopes.get(scope).push([type2, callback]);
    this.addEventListener(type2, callback, options);
  }
  removeScope(scope) {
    const listeners = this.scopes.get(scope);
    if (listeners) {
      this.scopes.delete(scope);
      for (const [type2, listener] of listeners) {
        this.removeEventListener(type2, listener);
      }
    }
  }
  dispatchEvent(evt) {
    if (!super.dispatchEvent(evt)) {
      return false;
    }
    if (!evt.cancelBubble) {
      for (const bubbler of this.bubblers) {
        if (!bubbler.dispatchEvent(evt)) {
          return false;
        }
      }
    }
    return true;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/BaseNode.ts
var BaseNode = class extends TypedEventBase {
  constructor(nodeType, context2) {
    super();
    this.nodeType = nodeType;
    this.context = context2;
    this._name = null;
    this.disposed = false;
  }
  get name() {
    return this._name;
  }
  set name(v) {
    this._name = v;
    this.context._name(this, v);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.onDisposing();
    }
  }
  onDisposing() {
  }
  isConnected(dest, output, input) {
    return this.context._isConnected(this, dest, output, input);
  }
  resolveOutput(output) {
    let resolution = {
      source: this,
      output
    };
    while (isIAudioNode(resolution.source)) {
      resolution = resolution.source._resolveOutput(resolution.output);
    }
    return resolution;
  }
  resolveInput(input) {
    let resolution = {
      destination: this,
      input
    };
    while (isEndpoint(resolution.destination)) {
      resolution = resolution.destination._resolveInput(resolution.input);
    }
    return resolution;
  }
  toggle(dest, outp, inp) {
    this._toggle(dest, outp, inp);
  }
  _toggle(dest, outp, inp) {
    if (this.isConnected(dest, outp, inp)) {
      this._disconnect(dest, outp, inp);
    } else {
      return this._connect(dest, outp, inp);
    }
  }
  connect(dest, outp, inp) {
    return this._connect(dest, outp, inp);
  }
  _connect(dest, outp, inp) {
    return this.context._connect(this, dest, outp, inp);
  }
  disconnect(destinationOrOutput, outp, inp) {
    this._disconnect(destinationOrOutput, outp, inp);
  }
  _disconnect(destinationOrOutput, outp, inp) {
    this.context._disconnect(this, destinationOrOutput, outp, inp);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioNode.ts
var JuniperAudioNode = class extends BaseNode {
  constructor(type2, context2, _node) {
    super(type2, context2);
    this._node = _node;
    this.context._init(this._node, this.nodeType);
  }
  onDisposing() {
    this.disconnect();
    this.context._dispose(this._node);
    super.onDisposing();
  }
  parent(param) {
    this.context._parent(this, param);
  }
  get channelCount() {
    return this._node.channelCount;
  }
  set channelCount(v) {
    this._node.channelCount = v;
  }
  get channelCountMode() {
    return this._node.channelCountMode;
  }
  set channelCountMode(v) {
    this._node.channelCountMode = v;
  }
  get channelInterpretation() {
    return this._node.channelInterpretation;
  }
  set channelInterpretation(v) {
    this._node.channelInterpretation = v;
  }
  get numberOfInputs() {
    return this._node.numberOfInputs;
  }
  get numberOfOutputs() {
    return this._node.numberOfOutputs;
  }
  _resolveInput(input) {
    return {
      destination: this._node,
      input
    };
  }
  _resolveOutput(output) {
    return {
      source: this._node,
      output
    };
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAnalyserNode.ts
var JuniperAnalyserNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("analyser", context2, new AnalyserNode(context2, options));
  }
  get fftSize() {
    return this._node.fftSize;
  }
  set fftSize(v) {
    this._node.fftSize = v;
  }
  get frequencyBinCount() {
    return this._node.frequencyBinCount;
  }
  get maxDecibels() {
    return this._node.maxDecibels;
  }
  set maxDecibels(v) {
    this._node.maxDecibels = v;
  }
  get minDecibels() {
    return this._node.minDecibels;
  }
  set minDecibels(v) {
    this._node.minDecibels = v;
  }
  get smoothingTimeConstant() {
    return this._node.smoothingTimeConstant;
  }
  set smoothingTimeConstant(v) {
    this._node.smoothingTimeConstant = v;
  }
  getByteFrequencyData(array) {
    this._node.getByteFrequencyData(array);
  }
  getByteTimeDomainData(array) {
    this._node.getByteTimeDomainData(array);
  }
  getFloatFrequencyData(array) {
    this._node.getFloatFrequencyData(array);
  }
  getFloatTimeDomainData(array) {
    this._node.getFloatTimeDomainData(array);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioParam.ts
var JuniperAudioParam = class {
  constructor(nodeType, context2, param) {
    this.nodeType = nodeType;
    this.context = context2;
    this.param = param;
    this._name = null;
    this.disposed = false;
    this.context._init(this.param, this.nodeType);
  }
  get name() {
    return this._name;
  }
  set name(v) {
    this._name = v;
    this.context._name(this, v);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.onDisposing();
    }
  }
  onDisposing() {
    this.context._dispose(this.param);
  }
  get automationRate() {
    return this.param.automationRate;
  }
  set automationRate(v) {
    this.param.automationRate = v;
  }
  get defaultValue() {
    return this.param.defaultValue;
  }
  get maxValue() {
    return this.param.maxValue;
  }
  get minValue() {
    return this.param.minValue;
  }
  get value() {
    return this.param.value;
  }
  set value(v) {
    this.param.value = v;
  }
  cancelAndHoldAtTime(cancelTime) {
    this.param.cancelAndHoldAtTime(cancelTime);
    return this;
  }
  cancelScheduledValues(cancelTime) {
    this.param.cancelScheduledValues(cancelTime);
    return this;
  }
  exponentialRampToValueAtTime(value2, endTime) {
    this.param.exponentialRampToValueAtTime(value2, endTime);
    return this;
  }
  linearRampToValueAtTime(value2, endTime) {
    this.param.linearRampToValueAtTime(value2, endTime);
    return this;
  }
  setTargetAtTime(target, startTime, timeConstant) {
    this.param.setTargetAtTime(target, startTime, timeConstant);
    return this;
  }
  setValueAtTime(value2, startTime) {
    this.param.setValueAtTime(value2, startTime);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration) {
    this.param.setValueCurveAtTime(values, startTime, duration);
    return this;
  }
  _resolveInput() {
    return {
      destination: this.param
    };
  }
  resolveInput() {
    return this._resolveInput();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioBufferSourceNode.ts
var JuniperAudioBufferSourceNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("audio-buffer-source", context2, new AudioBufferSourceNode(context2, options));
    this._node.addEventListener("ended", () => this.dispatchEvent(new TypedEvent("ended")));
    this.parent(this.playbackRate = new JuniperAudioParam("playbackRate", context2, this._node.playbackRate));
    this.parent(this.detune = new JuniperAudioParam("detune", context2, this._node.detune));
  }
  get buffer() {
    return this._node.buffer;
  }
  set buffer(v) {
    this._node.buffer = v;
  }
  get loop() {
    return this._node.loop;
  }
  set loop(v) {
    this._node.loop = v;
  }
  get loopEnd() {
    return this._node.loopEnd;
  }
  set loopEnd(v) {
    this._node.loopEnd = v;
  }
  get loopStart() {
    return this._node.loopStart;
  }
  set loopStart(v) {
    this._node.loopStart = v;
  }
  get onended() {
    return this._node.onended;
  }
  set onended(v) {
    this._node.onended = v;
  }
  start(when, offset, duration) {
    this._node.start(when, offset, duration);
  }
  stop(when) {
    this._node.stop(when);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioDestinationNode.ts
var JuniperAudioDestinationNode = class extends JuniperAudioNode {
  constructor(context2, destination) {
    super("destination", context2, destination);
  }
  get maxChannelCount() {
    return this._node.maxChannelCount;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperBiquadFilterNode.ts
var JuniperBiquadFilterNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("biquad-filter", context2, new BiquadFilterNode(context2, options));
    this.parent(this.Q = new JuniperAudioParam("Q", this.context, this._node.Q));
    this.parent(this.detune = new JuniperAudioParam("detune", this.context, this._node.detune));
    this.parent(this.frequency = new JuniperAudioParam("frequency", this.context, this._node.frequency));
    this.parent(this.gain = new JuniperAudioParam("gain", this.context, this._node.gain));
  }
  get type() {
    return this._node.type;
  }
  set type(v) {
    this._node.type = v;
  }
  getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
    this._node.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperChannelMergerNode.ts
var JuniperChannelMergerNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("channel-merger", context2, new ChannelMergerNode(context2, options));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperChannelSplitterNode.ts
var JuniperChannelSplitterNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("channel-splitter", context2, new ChannelSplitterNode(context2, options));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperConstantSourceNode.ts
var JuniperConstantSourceNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("constant-source", context2, new ConstantSourceNode(context2, options));
    this._node.addEventListener("ended", () => this.dispatchEvent(new TypedEvent("ended")));
    this.parent(this.offset = new JuniperAudioParam("offset", this.context, this._node.offset));
  }
  get onended() {
    return this._node.onended;
  }
  set onended(v) {
    this._node.onended = v;
  }
  start(when) {
    this._node.start(when);
  }
  stop(when) {
    this._node.stop(when);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperConvolverNode.ts
var JuniperConvolverNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("convolver", context2, new ConvolverNode(context2, options));
  }
  get buffer() {
    return this._node.buffer;
  }
  set buffer(v) {
    this._node.buffer = v;
  }
  get normalize() {
    return this._node.normalize;
  }
  set normalize(v) {
    this._node.normalize = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperDelayNode.ts
var JuniperDelayNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("delay", context2, new DelayNode(context2, options));
    this.parent(this.delayTime = new JuniperAudioParam("delay", this.context, this._node.delayTime));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperDynamicsCompressorNode.ts
var JuniperDynamicsCompressorNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("dynamics-compressor", context2, new DynamicsCompressorNode(context2, options));
    this.parent(this.attack = new JuniperAudioParam("attack", this.context, this._node.attack));
    this.parent(this.knee = new JuniperAudioParam("knee", this.context, this._node.knee));
    this.parent(this.ratio = new JuniperAudioParam("ratio", this.context, this._node.ratio));
    this.parent(this.release = new JuniperAudioParam("release", this.context, this._node.release));
    this.parent(this.threshold = new JuniperAudioParam("threshold", this.context, this._node.threshold));
  }
  get reduction() {
    return this._node.reduction;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperGainNode.ts
var JuniperGainNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("gain", context2, new GainNode(context2, options));
    this.parent(this.gain = new JuniperAudioParam("gain", this.context, this._node.gain));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperIIRFilterNode.ts
var JuniperIIRFilterNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("iir-filter", context2, new IIRFilterNode(context2, options));
  }
  getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
    this._node.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperMediaElementAudioSourceNode.ts
var JuniperMediaElementAudioSourceNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("media-element-audio-source", context2, new MediaElementAudioSourceNode(context2, options));
  }
  get mediaElement() {
    return this._node.mediaElement;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperMediaStreamAudioDestinationNode.ts
var JuniperMediaStreamAudioDestinationNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("media-stream-audio-destination", context2, new MediaStreamAudioDestinationNode(context2, options));
  }
  get stream() {
    return this._node.stream;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/identity.ts
function identity(item) {
  return item;
}
function alwaysTrue() {
  return true;
}
function alwaysFalse() {
  return false;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/attrs.ts
var Attr = class {
  /**
   * Creates a new setter functor for HTML Attributes
   * @param key - the attribute name.
   * @param value - the value to set for the attribute.
   * @param tags - the HTML tags that support this attribute.
   */
  constructor(key, value2, bySetAttribute, ...tags) {
    this.key = key;
    this.value = value2;
    this.bySetAttribute = bySetAttribute;
    this.tags = tags.map((t2) => t2.toLocaleUpperCase());
    Object.freeze(this);
  }
  /**
   * Set the attribute value on an HTMLElement
   * @param elem - the element on which to set the attribute.
   */
  applyToElement(elem) {
    const isDataSet = this.key.startsWith("data-");
    const isValid = this.tags.length === 0 || this.tags.indexOf(elem.tagName) > -1 || isDataSet;
    if (!isValid) {
      console.warn(`Element ${elem.tagName} does not support Attribute ${this.key}`);
    } else if (isDataSet) {
      const subkey = this.key.substring(5);
      elem.dataset[subkey] = this.value;
    } else if (this.key === "style") {
      Object.assign(elem.style, this.value);
    } else if (this.key === "classList") {
      const arr = this.value.filter(identity);
      if (arr.length > 0) {
        arr.forEach((v) => elem.classList.add(v));
      }
    } else if (this.bySetAttribute) {
      elem.setAttribute(this.key, this.value);
    } else if (this.key in elem) {
      elem[this.key] = this.value;
    } else if (this.value === false) {
      elem.removeAttribute(this.key);
    } else if (this.value === true) {
      elem.setAttribute(this.key, "");
    } else {
      elem.setAttribute(this.key, this.value);
    }
  }
};
function autoPlay(value2) {
  return new Attr("autoplay", value2, false, "audio", "video");
}
function className(value2) {
  return new Attr("className", value2, false);
}
function classList(...values) {
  return new Attr("classList", values, false);
}
function controls(value2) {
  return new Attr("controls", value2, false, "audio", "video");
}
function htmlHeight(value2) {
  return new Attr("height", value2, false, "canvas", "embed", "iframe", "img", "input", "object", "video");
}
function id(value2) {
  return new Attr("id", value2, false);
}
function list(value2) {
  return new Attr("list", value2, true, "input");
}
function loop(value2) {
  return new Attr("loop", value2, false, "audio", "bgsound", "marquee", "video");
}
function multiple(value2) {
  return new Attr("multiple", value2, false, "input", "select");
}
function muted(value2) {
  return new Attr("muted", value2, false, "audio", "video");
}
function rel(value2) {
  return new Attr("rel", value2, false, "a", "area", "link");
}
function unpackURL(value2) {
  if (value2 instanceof URL) {
    value2 = value2.href;
  }
  return value2;
}
function src(value2) {
  return new Attr("src", unpackURL(value2), false, "audio", "embed", "iframe", "img", "input", "script", "source", "track", "video");
}
function srcObject(value2) {
  return new Attr("srcObject", value2, false, "audio", "video");
}
function title(value2) {
  return new Attr("title", value2, false);
}
function type(value2) {
  if (!isString(value2)) {
    value2 = value2.value;
  }
  return new Attr("type", value2, false, "button", "input", "command", "embed", "link", "object", "script", "source", "style", "menu");
}
function value(value2) {
  return new Attr("value", value2, false, "button", "data", "input", "li", "meter", "option", "progress", "param");
}
function htmlWidth(value2) {
  return new Attr("width", value2, false, "canvas", "embed", "iframe", "img", "input", "object", "video");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/css.ts
function perc(value2) {
  return `${value2}%`;
}
function em(value2) {
  return `${value2}em`;
}
function rgb(...v) {
  return `rgb(${v.join(", ")})`;
}
var Prop = class {
  constructor(_value) {
    this._value = _value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this.value;
  }
};
var KeyValueProp = class extends Prop {
  constructor(_name, sep, value2) {
    super(value2);
    this._name = _name;
    this.sep = sep;
  }
  get name() {
    return this._name;
  }
  toString() {
    return this.name + this.sep + this.value + ";";
  }
};
var CssDeclareProp = class extends KeyValueProp {
  constructor(key, value2) {
    super(key, ": ", value2);
  }
};
var CssElementStyleProp = class extends CssDeclareProp {
  constructor(key, value2) {
    super(key.replace(/[A-Z]/g, (m) => `-${m.toLocaleLowerCase()}`), value2.toString());
    this.key = key;
    this.priority = "";
  }
  /**
   * Set the attribute value on an HTMLElement
   * @param elem - the element on which to set the attribute.
   */
  applyToElement(elem) {
    elem.style[this.key] = this.value + this.priority;
  }
  important() {
    this.priority = " !important";
    return this;
  }
  get value() {
    return super.value + this.priority;
  }
};
function cursor(v) {
  return new CssElementStyleProp("cursor", v);
}
function display(v) {
  return new CssElementStyleProp("display", v);
}
function gridAutoFlow(v) {
  return new CssElementStyleProp("gridAutoFlow", v);
}
function opacity(v) {
  return new CssElementStyleProp("opacity", v);
}
function width(v) {
  return new CssElementStyleProp("width", v);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/Exception.ts
var Exception = class extends Error {
  constructor(message2, innerError = null) {
    super(message2);
    this.innerError = innerError;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/once.ts
function targetValidateEvent(target, type2) {
  return "on" + type2 in target;
}
function once(target, resolveEvt, rejectEvtOrTimeout, ...rejectEvts) {
  if (isNullOrUndefined(rejectEvts)) {
    rejectEvts = [];
  }
  let timeout = void 0;
  if (isString(rejectEvtOrTimeout)) {
    rejectEvts.unshift(rejectEvtOrTimeout);
  } else if (isNumber(rejectEvtOrTimeout)) {
    timeout = rejectEvtOrTimeout;
  }
  if (!(target instanceof EventBase)) {
    if (!targetValidateEvent(target, resolveEvt)) {
      throw new Exception(`Target does not have a ${resolveEvt} rejection event`);
    }
    for (const evt of rejectEvts) {
      if (!targetValidateEvent(target, evt)) {
        throw new Exception(`Target does not have a ${evt} rejection event`);
      }
    }
  }
  const task = new Task();
  if (isNumber(timeout)) {
    const timeoutHandle = setTimeout(task.reject, timeout, `'${resolveEvt}' has timed out.`);
    task.finally(clearTimeout.bind(globalThis, timeoutHandle));
  }
  const register = (evt, callback) => {
    target.addEventListener(evt, callback);
    task.finally(() => target.removeEventListener(evt, callback));
  };
  register(resolveEvt, (evt) => task.resolve(evt));
  const onReject = (evt) => task.reject(evt);
  for (const rejectEvt of rejectEvts) {
    register(rejectEvt, onReject);
  }
  return task;
}
function success(task) {
  return task.then(alwaysTrue).catch(alwaysFalse);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/tags.ts
function isErsatzElement(obj) {
  if (!isObject(obj)) {
    return false;
  }
  const elem = obj;
  return elem.element instanceof Element;
}
function resolveElement(elem) {
  if (isErsatzElement(elem)) {
    return elem.element;
  } else if (isString(elem)) {
    return getElement(elem);
  }
  return elem;
}
function isIElementAppliable(obj) {
  return isObject(obj) && "applyToElement" in obj && isFunction(obj.applyToElement);
}
function elementSetDisplay(elem, visible, visibleDisplayType = "") {
  elem = resolveElement(elem);
  elem.style.display = visible ? visibleDisplayType : "none";
}
function elementApply(elem, ...children) {
  elem = resolveElement(elem);
  for (const child of children) {
    if (isDefined(child)) {
      if (child instanceof Node) {
        elem.append(child);
      } else if (isErsatzElement(child)) {
        elem.append(resolveElement(child));
      } else if (isIElementAppliable(child)) {
        child.applyToElement(elem);
      } else {
        elem.append(document.createTextNode(child.toLocaleString()));
      }
    }
  }
  return elem;
}
function getElement(selector) {
  return document.querySelector(selector);
}
function getButton(selector) {
  return getElement(selector);
}
function getInput(selector) {
  return getElement(selector);
}
function getSelect(selector) {
  return getElement(selector);
}
function tag(name, ...rest) {
  let elem = null;
  for (const attr of rest) {
    if (attr instanceof Attr && attr.key === "id") {
      elem = document.getElementById(attr.value);
      break;
    }
  }
  if (elem == null) {
    elem = document.createElement(name);
  }
  elementApply(elem, ...rest);
  return elem;
}
function elementClearChildren(elem) {
  elem = resolveElement(elem);
  while (elem.lastChild) {
    elem.lastChild.remove();
  }
}
function elementSetText(elem, text2) {
  elem = resolveElement(elem);
  elementClearChildren(elem);
  elem.append(TextNode(text2));
}
async function mediaElementCan(type2, elem, prog) {
  if (isDefined(prog)) {
    prog.start();
  }
  const expectedState = type2 === "canplay" ? elem.HAVE_CURRENT_DATA : elem.HAVE_ENOUGH_DATA;
  if (elem.readyState >= expectedState) {
    return true;
  }
  try {
    await once(elem, type2, "error");
    return true;
  } catch (err) {
    console.warn(elem.error, err);
    return false;
  } finally {
    if (isDefined(prog)) {
      prog.end();
    }
  }
}
function mediaElementCanPlayThrough(elem, prog) {
  return mediaElementCan("canplaythrough", elem, prog);
}
function Audio2(...rest) {
  return tag("audio", ...rest);
}
function ButtonRaw(...rest) {
  return tag("button", ...rest);
}
function Button(...rest) {
  return ButtonRaw(...rest, type("button"));
}
function ButtonPrimary(...rest) {
  return Button(...rest, classList("btn", "btn-primary"));
}
function ButtonDanger(...rest) {
  return Button(...rest, classList("btn", "btn-danger"));
}
function Canvas(...rest) {
  return tag("canvas", ...rest);
}
function Div(...rest) {
  return tag("div", ...rest);
}
function H2(...rest) {
  return tag("h2", ...rest);
}
function IFrame(...rest) {
  return tag("iframe", ...rest);
}
function Img(...rest) {
  return tag("img", ...rest);
}
function Input(...rest) {
  return tag("input", ...rest);
}
function Link(...rest) {
  return tag("link", ...rest);
}
function Option(...rest) {
  return tag("option", ...rest);
}
function Script(...rest) {
  return tag("script", ...rest);
}
function Select(...rest) {
  return tag("select", ...rest);
}
function TextArea(...rest) {
  return tag("textarea", ...rest);
}
function Video(...rest) {
  return tag("video", ...rest);
}
function InputText(...rest) {
  return Input(type("text"), ...rest);
}
function TextNode(txt) {
  return document.createTextNode(txt);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/util.ts
var hasAudioContext = "AudioContext" in globalThis;
var hasAudioListener = hasAudioContext && "AudioListener" in globalThis;
var hasOldAudioListener = hasAudioListener && "setPosition" in AudioListener.prototype;
var hasNewAudioListener = hasAudioListener && "positionX" in AudioListener.prototype;
var hasStreamSources = "createMediaStreamSource" in AudioContext.prototype;
var canCaptureStream = /* @__PURE__ */ isFunction(HTMLMediaElement.prototype.captureStream) || isFunction(HTMLMediaElement.prototype.mozCaptureStream);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperMediaStreamAudioSourceNode.ts
var JuniperMediaStreamAudioSourceNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    const element = Audio2(
      controls(false),
      muted(hasStreamSources),
      autoPlay(true),
      loop(false),
      display("none"),
      srcObject(options.mediaStream)
    );
    let node;
    if (hasStreamSources) {
      node = new MediaStreamAudioSourceNode(context2, options);
    } else {
      node = new MediaElementAudioSourceNode(context2, {
        mediaElement: element
      });
    }
    super("media-stream-audio-source", context2, node);
    this._stream = options.mediaStream;
    this._element = element;
  }
  onDisposing() {
    this._element.pause();
    super.onDisposing();
  }
  get mediaStream() {
    return this._stream;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperOscillatorNode.ts
var JuniperOscillatorNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("oscillator", context2, new OscillatorNode(context2, options));
    this._node.addEventListener("ended", () => this.dispatchEvent(new TypedEvent("ended")));
    this.parent(this.detune = new JuniperAudioParam("detune", this.context, this._node.detune));
    this.parent(this.frequency = new JuniperAudioParam("frequency", this.context, this._node.frequency));
  }
  get type() {
    return this._node.type;
  }
  set type(v) {
    this._node.type = v;
  }
  get onended() {
    return this._node.onended;
  }
  set onended(v) {
    this._node.onended = v;
  }
  setPeriodicWave(periodicWave) {
    this._node.setPeriodicWave(periodicWave);
  }
  start(when) {
    this._node.start(when);
  }
  stop(when) {
    this._node.stop(when);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperPannerNode.ts
var JuniperPannerNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("panner", context2, new PannerNode(context2, options));
    this.parent(this.positionX = new JuniperAudioParam("positionX", this.context, this._node.positionX));
    this.parent(this.positionY = new JuniperAudioParam("positionY", this.context, this._node.positionY));
    this.parent(this.positionZ = new JuniperAudioParam("positionZ", this.context, this._node.positionZ));
    this.parent(this.orientationX = new JuniperAudioParam("orientationX", this.context, this._node.orientationX));
    this.parent(this.orientationY = new JuniperAudioParam("orientationY", this.context, this._node.orientationY));
    this.parent(this.orientationZ = new JuniperAudioParam("orientationZ", this.context, this._node.orientationZ));
  }
  get coneInnerAngle() {
    return this._node.coneInnerAngle;
  }
  set coneInnerAngle(v) {
    this._node.coneInnerAngle = v;
  }
  get coneOuterAngle() {
    return this._node.coneOuterAngle;
  }
  set coneOuterAngle(v) {
    this._node.coneOuterAngle = v;
  }
  get coneOuterGain() {
    return this._node.coneOuterGain;
  }
  set coneOuterGain(v) {
    this._node.coneOuterGain = v;
  }
  get distanceModel() {
    return this._node.distanceModel;
  }
  set distanceModel(v) {
    this._node.distanceModel = v;
  }
  get maxDistance() {
    return this._node.maxDistance;
  }
  set maxDistance(v) {
    this._node.maxDistance = v;
  }
  get panningModel() {
    return this._node.panningModel;
  }
  set panningModel(v) {
    this._node.panningModel = v;
  }
  get refDistance() {
    return this._node.refDistance;
  }
  set refDistance(v) {
    this._node.refDistance = v;
  }
  get rolloffFactor() {
    return this._node.rolloffFactor;
  }
  set rolloffFactor(v) {
    this._node.rolloffFactor = v;
  }
  setOrientation(x, y, z) {
    this._node.setOrientation(x, y, z);
  }
  setPosition(x, y, z) {
    this._node.setPosition(x, y, z);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperStereoPannerNode.ts
var JuniperStereoPannerNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("stereo-panner", context2, new StereoPannerNode(context2, options));
    this.parent(this.pan = new JuniperAudioParam("pan", this.context, this._node.pan));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperWaveShaperNode.ts
var JuniperWaveShaperNode = class extends JuniperAudioNode {
  constructor(context2, options) {
    super("wave-shaper", context2, new WaveShaperNode(context2, options));
  }
  get curve() {
    return this._node.curve;
  }
  set curve(v) {
    this._node.curve = v;
  }
  get oversample() {
    return this._node.oversample;
  }
  set oversample(v) {
    this._node.oversample = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioContext.ts
if (!("AudioContext" in globalThis) && "webkitAudioContext" in globalThis) {
  globalThis.AudioContext = globalThis.webkitAudioContext;
}
if (!("OfflineAudioContext" in globalThis) && "webkitOfflineAudioContext" in globalThis) {
  globalThis.OfflineAudioContext = globalThis.webkitOfflineAudioContext;
}
var NodeInfo = class {
  constructor(type2, name) {
    this.type = type2;
    this.name = name;
    this.connections = /* @__PURE__ */ new Set();
  }
};
function isMatchingConnection(conn, type2, destination, output, input) {
  return conn.type === type2 && (isNullOrUndefined(destination) || destination === conn.destination) && (isNullOrUndefined(output) || output === conn.output) && (isNullOrUndefined(input) || input === conn.input);
}
function resolveInput(dest, inp) {
  let destination = null;
  let input = null;
  if (isDefined(dest)) {
    ({ destination, input } = dest.resolveInput(inp));
  }
  return { destination, input };
}
var JuniperAudioContext = class extends AudioContext {
  constructor(contextOptions) {
    super(contextOptions);
    this.counters = /* @__PURE__ */ new Map();
    this.nodes = /* @__PURE__ */ new Map();
    this._ready = new Task();
    this._destination = new JuniperAudioDestinationNode(this, super.destination);
    if (this.state === "running") {
      this._ready.resolve();
    } else if (this.state === "closed") {
      this.resume().then(() => this._ready.resolve());
    } else {
      onUserGesture(() => this.resume().then(() => this._ready.resolve()));
    }
    this.ready.then(() => console.log("Audio is now ready"));
  }
  get ready() {
    return this._ready;
  }
  get isReady() {
    return this._ready.finished && this._ready.resolved;
  }
  _init(node, type2) {
    if (!this.nodes.has(node)) {
      if (!this.counters.has(type2)) {
        this.counters.set(type2, 0);
      }
      const count = this.counters.get(type2);
      const name = `${type2}-${count}`;
      this.nodes.set(node, new NodeInfo(type2, name));
      if (isEndpoint(node)) {
        node.name = name;
      }
      this.counters.set(type2, count + 1);
    }
  }
  _name(dest, name) {
    const { destination } = resolveInput(dest);
    if (this.nodes.has(destination)) {
      const info = this.nodes.get(destination);
      info.name = `${name}-${info.type}`;
    }
  }
  _dispose(node) {
    this.nodes.delete(node);
  }
  _isConnected(src2, dest, outp, inp) {
    const { source, output } = src2.resolveOutput(outp);
    const { destination, input } = resolveInput(dest, inp);
    if (isNullOrUndefined(source) || !this.nodes.has(source)) {
      return null;
    } else {
      const info = this.nodes.get(source);
      for (const conn of info.connections) {
        if (isMatchingConnection(conn, "conn", destination, output, input)) {
          return true;
        }
      }
      return false;
    }
  }
  _parent(src2, dest) {
    const { source } = src2.resolveOutput();
    const { destination } = resolveInput(dest);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      conns.add({
        type: "parent",
        src: src2,
        dest,
        destination,
        source
      });
    }
  }
  _unparent(src2, dest) {
    const { source } = src2.resolveOutput();
    const { destination } = resolveInput(dest);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      const toDelete = /* @__PURE__ */ new Set();
      for (const conn of conns) {
        if (isMatchingConnection(conn, "parent", destination)) {
          toDelete.add(conn);
        }
      }
      for (const conn of toDelete) {
        conns.delete(conn);
      }
    }
  }
  _getConnections(node) {
    if (!this.nodes.has(node)) {
      return null;
    }
    return this.nodes.get(node).connections;
  }
  _connect(src2, dest, outp, inp) {
    const { source, output } = src2.resolveOutput(outp);
    const { destination, input } = resolveInput(dest, inp);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      let matchFound = false;
      for (const conn of conns) {
        if (isMatchingConnection(conn, "conn", destination, output, input)) {
          matchFound = true;
        }
      }
      if (!matchFound) {
        conns.add({
          type: "conn",
          src: src2,
          dest,
          outp,
          inp,
          source,
          destination,
          output,
          input
        });
      }
    }
    if (destination instanceof AudioNode) {
      dest = dest;
      if (isDefined(input)) {
        source.connect(destination, output, input);
        return dest;
      } else if (isDefined(output)) {
        source.connect(destination, output);
        return dest;
      } else {
        source.connect(destination);
        return dest;
      }
    } else if (destination instanceof AudioParam) {
      if (isDefined(output)) {
        source.connect(destination, output);
      } else if (isDefined(destination)) {
        source.connect(destination);
      } else {
        assertNever(destination);
      }
    } else {
      assertNever(destination);
    }
  }
  _disconnect(src2, destinationOrOutput, outp, inp) {
    let dest;
    if (isNumber(destinationOrOutput)) {
      dest = void 0;
      outp = destinationOrOutput;
    } else {
      dest = destinationOrOutput;
    }
    const { source, output } = src2.resolveOutput(outp);
    const { destination, input } = resolveInput(dest, inp);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      const toDelete = /* @__PURE__ */ new Set();
      for (const conn of conns) {
        if (isMatchingConnection(conn, "conn", destination, output, input)) {
          toDelete.add(conn);
        }
      }
      for (const conn of toDelete) {
        conns.delete(conn);
      }
    }
    if (destination instanceof AudioNode) {
      if (isDefined(inp)) {
        source.disconnect(destination, outp, inp);
      } else if (isDefined(outp)) {
        source.disconnect(destination, outp);
      } else if (isDefined(destination)) {
        source.disconnect(destination);
      } else {
        source.disconnect();
      }
    } else if (isDefined(outp)) {
      source.disconnect(destination, outp);
    } else if (isDefined(destination)) {
      source.disconnect(destination);
    } else {
      source.disconnect();
    }
  }
  getAudioGraph(includeParams) {
    const nodes = /* @__PURE__ */ new Map();
    for (const [node, info] of this.nodes) {
      const nodeClass = node instanceof AudioNode ? "node" : node instanceof AudioParam ? "param" : "unknown";
      if (includeParams || nodeClass !== "param") {
        nodes.set(node, new GraphNode({
          name: info.name,
          type: info.type,
          nodeClass
        }));
      }
    }
    for (const [source, info] of this.nodes) {
      const branch = nodes.get(source);
      for (const child of info.connections) {
        const destination = child.destination;
        if (nodes.has(destination)) {
          const cnode = nodes.get(destination);
          branch.connectTo(cnode);
          cnode.connectTo(branch);
        }
      }
    }
    return Array.from(nodes.values());
  }
  get destination() {
    return this._destination;
  }
  createAnalyser() {
    return new JuniperAnalyserNode(this);
  }
  createBiquadFilter() {
    return new JuniperBiquadFilterNode(this);
  }
  createBufferSource() {
    return new JuniperAudioBufferSourceNode(this);
  }
  createChannelMerger(numberOfInputs) {
    return new JuniperChannelMergerNode(this, {
      numberOfInputs
    });
  }
  createChannelSplitter(numberOfOutputs) {
    return new JuniperChannelSplitterNode(this, {
      numberOfOutputs
    });
  }
  createConstantSource() {
    return new JuniperConstantSourceNode(this);
  }
  createConvolver() {
    return new JuniperConvolverNode(this);
  }
  createDelay(maxDelayTime) {
    return new JuniperDelayNode(this, {
      maxDelayTime
    });
  }
  createDynamicsCompressor() {
    return new JuniperDynamicsCompressorNode(this);
  }
  createGain() {
    return new JuniperGainNode(this);
  }
  createIIRFilter(feedforward, feedback) {
    return new JuniperIIRFilterNode(this, {
      feedforward,
      feedback
    });
  }
  createMediaElementSource(mediaElement) {
    return new JuniperMediaElementAudioSourceNode(this, {
      mediaElement
    });
  }
  createMediaStreamDestination() {
    return new JuniperMediaStreamAudioDestinationNode(this);
  }
  createMediaStreamSource(mediaStream) {
    return new JuniperMediaStreamAudioSourceNode(this, {
      mediaStream
    });
  }
  createOscillator() {
    return new JuniperOscillatorNode(this);
  }
  createPanner() {
    return new JuniperPannerNode(this);
  }
  createStereoPanner() {
    return new JuniperStereoPannerNode(this);
  }
  createWaveShaper() {
    return new JuniperWaveShaperNode(this);
  }
  createScriptProcessor() {
    throw new Error("Script processor nodes are deprecated");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/application.ts
var application_exports = {};
__export(application_exports, {
  Application_A2L: () => Application_A2L,
  Application_AML: () => Application_AML,
  Application_ATF: () => Application_ATF,
  Application_ATFX: () => Application_ATFX,
  Application_ATXML: () => Application_ATXML,
  Application_Activemessage: () => Application_Activemessage,
  Application_Alto_CostmapJson: () => Application_Alto_CostmapJson,
  Application_Alto_CostmapfilterJson: () => Application_Alto_CostmapfilterJson,
  Application_Alto_DirectoryJson: () => Application_Alto_DirectoryJson,
  Application_Alto_EndpointcostJson: () => Application_Alto_EndpointcostJson,
  Application_Alto_EndpointcostparamsJson: () => Application_Alto_EndpointcostparamsJson,
  Application_Alto_EndpointpropJson: () => Application_Alto_EndpointpropJson,
  Application_Alto_EndpointpropparamsJson: () => Application_Alto_EndpointpropparamsJson,
  Application_Alto_ErrorJson: () => Application_Alto_ErrorJson,
  Application_Alto_NetworkmapJson: () => Application_Alto_NetworkmapJson,
  Application_Alto_NetworkmapfilterJson: () => Application_Alto_NetworkmapfilterJson,
  Application_Andrew_Inset: () => Application_Andrew_Inset,
  Application_Applefile: () => Application_Applefile,
  Application_Applixware: () => Application_Applixware,
  Application_AtomXml: () => Application_AtomXml,
  Application_AtomcatXml: () => Application_AtomcatXml,
  Application_AtomdeletedXml: () => Application_AtomdeletedXml,
  Application_Atomicmail: () => Application_Atomicmail,
  Application_AtomsvcXml: () => Application_AtomsvcXml,
  Application_Atsc_DwdXml: () => Application_Atsc_DwdXml,
  Application_Atsc_HeldXml: () => Application_Atsc_HeldXml,
  Application_Atsc_RdtJson: () => Application_Atsc_RdtJson,
  Application_Atsc_RsatXml: () => Application_Atsc_RsatXml,
  Application_Auth_PolicyXml: () => Application_Auth_PolicyXml,
  Application_Bacnet_XddZip: () => Application_Bacnet_XddZip,
  Application_Batch_SMTP: () => Application_Batch_SMTP,
  Application_Bdoc: () => Application_Bdoc,
  Application_BeepXml: () => Application_BeepXml,
  Application_CALS_1840: () => Application_CALS_1840,
  Application_CDFXXML: () => Application_CDFXXML,
  Application_CEA: () => Application_CEA,
  Application_CSTAdataXml: () => Application_CSTAdataXml,
  Application_CalendarJson: () => Application_CalendarJson,
  Application_CalendarXml: () => Application_CalendarXml,
  Application_Call_Completion: () => Application_Call_Completion,
  Application_Cbor: () => Application_Cbor,
  Application_Cbor_Seq: () => Application_Cbor_Seq,
  Application_Cccex: () => Application_Cccex,
  Application_CcmpXml: () => Application_CcmpXml,
  Application_CcxmlXml: () => Application_CcxmlXml,
  Application_Cdmi_Capability: () => Application_Cdmi_Capability,
  Application_Cdmi_Container: () => Application_Cdmi_Container,
  Application_Cdmi_Domain: () => Application_Cdmi_Domain,
  Application_Cdmi_Object: () => Application_Cdmi_Object,
  Application_Cdmi_Queue: () => Application_Cdmi_Queue,
  Application_Cdni: () => Application_Cdni,
  Application_Cea_2018Xml: () => Application_Cea_2018Xml,
  Application_CellmlXml: () => Application_CellmlXml,
  Application_Cfw: () => Application_Cfw,
  Application_ClueXml: () => Application_ClueXml,
  Application_Clue_infoXml: () => Application_Clue_infoXml,
  Application_Cms: () => Application_Cms,
  Application_CnrpXml: () => Application_CnrpXml,
  Application_Coap_GroupJson: () => Application_Coap_GroupJson,
  Application_Coap_Payload: () => Application_Coap_Payload,
  Application_Commonground: () => Application_Commonground,
  Application_Conference_InfoXml: () => Application_Conference_InfoXml,
  Application_Cose: () => Application_Cose,
  Application_Cose_Key: () => Application_Cose_Key,
  Application_Cose_Key_Set: () => Application_Cose_Key_Set,
  Application_CplXml: () => Application_CplXml,
  Application_Csrattrs: () => Application_Csrattrs,
  Application_CstaXml: () => Application_CstaXml,
  Application_CsvmJson: () => Application_CsvmJson,
  Application_Cu_Seeme: () => Application_Cu_Seeme,
  Application_Cwt: () => Application_Cwt,
  Application_Cybercash: () => Application_Cybercash,
  Application_DCD: () => Application_DCD,
  Application_DII: () => Application_DII,
  Application_DIT: () => Application_DIT,
  Application_Dart: () => Application_Dart,
  Application_DashXml: () => Application_DashXml,
  Application_Dashdelta: () => Application_Dashdelta,
  Application_DavmountXml: () => Application_DavmountXml,
  Application_Dca_Rft: () => Application_Dca_Rft,
  Application_Dec_Dx: () => Application_Dec_Dx,
  Application_Dialog_InfoXml: () => Application_Dialog_InfoXml,
  Application_Dicom: () => Application_Dicom,
  Application_DicomJson: () => Application_DicomJson,
  Application_DicomXml: () => Application_DicomXml,
  Application_Dns: () => Application_Dns,
  Application_DnsJson: () => Application_DnsJson,
  Application_Dns_Message: () => Application_Dns_Message,
  Application_DocbookXml: () => Application_DocbookXml,
  Application_DotsCbor: () => Application_DotsCbor,
  Application_DskppXml: () => Application_DskppXml,
  Application_DsscDer: () => Application_DsscDer,
  Application_DsscXml: () => Application_DsscXml,
  Application_Dvcs: () => Application_Dvcs,
  Application_EDIFACT: () => Application_EDIFACT,
  Application_EDI_Consent: () => Application_EDI_Consent,
  Application_EDI_X12: () => Application_EDI_X12,
  Application_Ecmascript: () => Application_Ecmascript,
  Application_Efi: () => Application_Efi,
  Application_EmergencyCallDataCommentXml: () => Application_EmergencyCallDataCommentXml,
  Application_EmergencyCallDataControlXml: () => Application_EmergencyCallDataControlXml,
  Application_EmergencyCallDataDeviceInfoXml: () => Application_EmergencyCallDataDeviceInfoXml,
  Application_EmergencyCallDataECallMSD: () => Application_EmergencyCallDataECallMSD,
  Application_EmergencyCallDataProviderInfoXml: () => Application_EmergencyCallDataProviderInfoXml,
  Application_EmergencyCallDataServiceInfoXml: () => Application_EmergencyCallDataServiceInfoXml,
  Application_EmergencyCallDataSubscriberInfoXml: () => Application_EmergencyCallDataSubscriberInfoXml,
  Application_EmergencyCallDataVEDSXml: () => Application_EmergencyCallDataVEDSXml,
  Application_EmmaXml: () => Application_EmmaXml,
  Application_EmotionmlXml: () => Application_EmotionmlXml,
  Application_Encaprtp: () => Application_Encaprtp,
  Application_EppXml: () => Application_EppXml,
  Application_EpubZip: () => Application_EpubZip,
  Application_Eshop: () => Application_Eshop,
  Application_Example: () => Application_Example,
  Application_Exi: () => Application_Exi,
  Application_Expect_Ct_ReportJson: () => Application_Expect_Ct_ReportJson,
  Application_Fastinfoset: () => Application_Fastinfoset,
  Application_Fastsoap: () => Application_Fastsoap,
  Application_FdtXml: () => Application_FdtXml,
  Application_FhirJson: () => Application_FhirJson,
  Application_FhirXml: () => Application_FhirXml,
  Application_Fido_TrustedAppsJson: () => Application_Fido_TrustedAppsJson,
  Application_Fits: () => Application_Fits,
  Application_Flexfec: () => Application_Flexfec,
  Application_Font_Sfnt: () => Application_Font_Sfnt,
  Application_Font_Tdpfr: () => Application_Font_Tdpfr,
  Application_Font_Woff: () => Application_Font_Woff,
  Application_Framework_AttributesXml: () => Application_Framework_AttributesXml,
  Application_GeoJson: () => Application_GeoJson,
  Application_GeoJson_Seq: () => Application_GeoJson_Seq,
  Application_GeopackageSqlite3: () => Application_GeopackageSqlite3,
  Application_GeoxacmlXml: () => Application_GeoxacmlXml,
  Application_Gltf_Buffer: () => Application_Gltf_Buffer,
  Application_GmlXml: () => Application_GmlXml,
  Application_GpxXml: () => Application_GpxXml,
  Application_Gxf: () => Application_Gxf,
  Application_Gzip: () => Application_Gzip,
  Application_H224: () => Application_H224,
  Application_HeldXml: () => Application_HeldXml,
  Application_Hjson: () => Application_Hjson,
  Application_Http: () => Application_Http,
  Application_Hyperstudio: () => Application_Hyperstudio,
  Application_IOTP: () => Application_IOTP,
  Application_ISUP: () => Application_ISUP,
  Application_Ibe_Key_RequestXml: () => Application_Ibe_Key_RequestXml,
  Application_Ibe_Pkg_ReplyXml: () => Application_Ibe_Pkg_ReplyXml,
  Application_Ibe_Pp_Data: () => Application_Ibe_Pp_Data,
  Application_Iges: () => Application_Iges,
  Application_Im_IscomposingXml: () => Application_Im_IscomposingXml,
  Application_Index: () => Application_Index,
  Application_IndexCmd: () => Application_IndexCmd,
  Application_IndexObj: () => Application_IndexObj,
  Application_IndexResponse: () => Application_IndexResponse,
  Application_IndexVnd: () => Application_IndexVnd,
  Application_InkmlXml: () => Application_InkmlXml,
  Application_Ipfix: () => Application_Ipfix,
  Application_Ipp: () => Application_Ipp,
  Application_ItsXml: () => Application_ItsXml,
  Application_Java_Archive: () => Application_Java_Archive,
  Application_Java_Serialized_Object: () => Application_Java_Serialized_Object,
  Application_Java_Vm: () => Application_Java_Vm,
  Application_Javascript: () => Application_Javascript,
  Application_Jf2feedJson: () => Application_Jf2feedJson,
  Application_Jose: () => Application_Jose,
  Application_JoseJson: () => Application_JoseJson,
  Application_JrdJson: () => Application_JrdJson,
  Application_Json: () => Application_Json,
  Application_Json5: () => Application_Json5,
  Application_JsonUTF8: () => Application_JsonUTF8,
  Application_Json_PatchJson: () => Application_Json_PatchJson,
  Application_Json_Seq: () => Application_Json_Seq,
  Application_JsonmlJson: () => Application_JsonmlJson,
  Application_JwkJson: () => Application_JwkJson,
  Application_Jwk_SetJson: () => Application_Jwk_SetJson,
  Application_Jwt: () => Application_Jwt,
  Application_Kpml_RequestXml: () => Application_Kpml_RequestXml,
  Application_Kpml_ResponseXml: () => Application_Kpml_ResponseXml,
  Application_LXF: () => Application_LXF,
  Application_LdJson: () => Application_LdJson,
  Application_LgrXml: () => Application_LgrXml,
  Application_Link_Format: () => Application_Link_Format,
  Application_Load_ControlXml: () => Application_Load_ControlXml,
  Application_LostXml: () => Application_LostXml,
  Application_LostsyncXml: () => Application_LostsyncXml,
  Application_MF4: () => Application_MF4,
  Application_Mac_Binhex40: () => Application_Mac_Binhex40,
  Application_Mac_Compactpro: () => Application_Mac_Compactpro,
  Application_Macwriteii: () => Application_Macwriteii,
  Application_MadsXml: () => Application_MadsXml,
  Application_ManifestJson: () => Application_ManifestJson,
  Application_Marc: () => Application_Marc,
  Application_MarcxmlXml: () => Application_MarcxmlXml,
  Application_Mathematica: () => Application_Mathematica,
  Application_MathmlXml: () => Application_MathmlXml,
  Application_Mathml_ContentXml: () => Application_Mathml_ContentXml,
  Application_Mathml_PresentationXml: () => Application_Mathml_PresentationXml,
  Application_Mbms_Associated_Procedure_DescriptionXml: () => Application_Mbms_Associated_Procedure_DescriptionXml,
  Application_Mbms_DeregisterXml: () => Application_Mbms_DeregisterXml,
  Application_Mbms_EnvelopeXml: () => Application_Mbms_EnvelopeXml,
  Application_Mbms_MskXml: () => Application_Mbms_MskXml,
  Application_Mbms_Msk_ResponseXml: () => Application_Mbms_Msk_ResponseXml,
  Application_Mbms_Protection_DescriptionXml: () => Application_Mbms_Protection_DescriptionXml,
  Application_Mbms_Reception_ReportXml: () => Application_Mbms_Reception_ReportXml,
  Application_Mbms_RegisterXml: () => Application_Mbms_RegisterXml,
  Application_Mbms_Register_ResponseXml: () => Application_Mbms_Register_ResponseXml,
  Application_Mbms_ScheduleXml: () => Application_Mbms_ScheduleXml,
  Application_Mbms_User_Service_DescriptionXml: () => Application_Mbms_User_Service_DescriptionXml,
  Application_Mbox: () => Application_Mbox,
  Application_Media_Policy_DatasetXml: () => Application_Media_Policy_DatasetXml,
  Application_Media_controlXml: () => Application_Media_controlXml,
  Application_MediaservercontrolXml: () => Application_MediaservercontrolXml,
  Application_Merge_PatchJson: () => Application_Merge_PatchJson,
  Application_Metalink4Xml: () => Application_Metalink4Xml,
  Application_MetalinkXml: () => Application_MetalinkXml,
  Application_MetsXml: () => Application_MetsXml,
  Application_Mikey: () => Application_Mikey,
  Application_Mipc: () => Application_Mipc,
  Application_Mmt_AeiXml: () => Application_Mmt_AeiXml,
  Application_Mmt_UsdXml: () => Application_Mmt_UsdXml,
  Application_ModsXml: () => Application_ModsXml,
  Application_Moss_Keys: () => Application_Moss_Keys,
  Application_Moss_Signature: () => Application_Moss_Signature,
  Application_Mosskey_Data: () => Application_Mosskey_Data,
  Application_Mosskey_Request: () => Application_Mosskey_Request,
  Application_Mp21: () => Application_Mp21,
  Application_Mp4: () => Application_Mp4,
  Application_Mpeg4_Generic: () => Application_Mpeg4_Generic,
  Application_Mpeg4_Iod: () => Application_Mpeg4_Iod,
  Application_Mpeg4_Iod_Xmt: () => Application_Mpeg4_Iod_Xmt,
  Application_Mrb_ConsumerXml: () => Application_Mrb_ConsumerXml,
  Application_Mrb_PublishXml: () => Application_Mrb_PublishXml,
  Application_Msc_IvrXml: () => Application_Msc_IvrXml,
  Application_Msc_MixerXml: () => Application_Msc_MixerXml,
  Application_Msword: () => Application_Msword,
  Application_MudJson: () => Application_MudJson,
  Application_Multipart_Core: () => Application_Multipart_Core,
  Application_Mxf: () => Application_Mxf,
  Application_N_Quads: () => Application_N_Quads,
  Application_N_Triples: () => Application_N_Triples,
  Application_Nasdata: () => Application_Nasdata,
  Application_News_Checkgroups: () => Application_News_Checkgroups,
  Application_News_Groupinfo: () => Application_News_Groupinfo,
  Application_News_Transmission: () => Application_News_Transmission,
  Application_NlsmlXml: () => Application_NlsmlXml,
  Application_Node: () => Application_Node,
  Application_Nss: () => Application_Nss,
  Application_ODA: () => Application_ODA,
  Application_ODX: () => Application_ODX,
  Application_Ocsp_Request: () => Application_Ocsp_Request,
  Application_Ocsp_Response: () => Application_Ocsp_Response,
  Application_Octet_Stream: () => Application_Octet_Stream,
  Application_OdmXml: () => Application_OdmXml,
  Application_Oebps_PackageXml: () => Application_Oebps_PackageXml,
  Application_Ogg: () => Application_Ogg,
  Application_OmdocXml: () => Application_OmdocXml,
  Application_Onenote: () => Application_Onenote,
  Application_Oscore: () => Application_Oscore,
  Application_Oxps: () => Application_Oxps,
  Application_P2p_OverlayXml: () => Application_P2p_OverlayXml,
  Application_PDX: () => Application_PDX,
  Application_Parityfec: () => Application_Parityfec,
  Application_Passport: () => Application_Passport,
  Application_Patch_Ops_ErrorXml: () => Application_Patch_Ops_ErrorXml,
  Application_Pdf: () => Application_Pdf,
  Application_Pem_Certificate_Chain: () => Application_Pem_Certificate_Chain,
  Application_Pgp_Encrypted: () => Application_Pgp_Encrypted,
  Application_Pgp_Keys: () => Application_Pgp_Keys,
  Application_Pgp_Signature: () => Application_Pgp_Signature,
  Application_Pics_Rules: () => Application_Pics_Rules,
  Application_PidfXml: () => Application_PidfXml,
  Application_Pidf_DiffXml: () => Application_Pidf_DiffXml,
  Application_Pkcs10: () => Application_Pkcs10,
  Application_Pkcs12: () => Application_Pkcs12,
  Application_Pkcs7_Mime: () => Application_Pkcs7_Mime,
  Application_Pkcs7_Signature: () => Application_Pkcs7_Signature,
  Application_Pkcs8: () => Application_Pkcs8,
  Application_Pkcs8_Encrypted: () => Application_Pkcs8_Encrypted,
  Application_Pkix_Attr_Cert: () => Application_Pkix_Attr_Cert,
  Application_Pkix_Cert: () => Application_Pkix_Cert,
  Application_Pkix_Crl: () => Application_Pkix_Crl,
  Application_Pkix_Pkipath: () => Application_Pkix_Pkipath,
  Application_Pkixcmp: () => Application_Pkixcmp,
  Application_PlsXml: () => Application_PlsXml,
  Application_Poc_SettingsXml: () => Application_Poc_SettingsXml,
  Application_Postscript: () => Application_Postscript,
  Application_Ppsp_TrackerJson: () => Application_Ppsp_TrackerJson,
  Application_ProblemJson: () => Application_ProblemJson,
  Application_ProblemXml: () => Application_ProblemXml,
  Application_ProvenanceXml: () => Application_ProvenanceXml,
  Application_PrsAlvestrandTitrax_Sheet: () => Application_PrsAlvestrandTitrax_Sheet,
  Application_PrsCww: () => Application_PrsCww,
  Application_PrsHpubZip: () => Application_PrsHpubZip,
  Application_PrsNprend: () => Application_PrsNprend,
  Application_PrsPlucker: () => Application_PrsPlucker,
  Application_PrsRdf_Xml_Crypt: () => Application_PrsRdf_Xml_Crypt,
  Application_PrsXsfXml: () => Application_PrsXsfXml,
  Application_PskcXml: () => Application_PskcXml,
  Application_QSIG: () => Application_QSIG,
  Application_RamlYaml: () => Application_RamlYaml,
  Application_Raptorfec: () => Application_Raptorfec,
  Application_RdapJson: () => Application_RdapJson,
  Application_RdfXml: () => Application_RdfXml,
  Application_ReginfoXml: () => Application_ReginfoXml,
  Application_Relax_Ng_Compact_Syntax: () => Application_Relax_Ng_Compact_Syntax,
  Application_Remote_Printing: () => Application_Remote_Printing,
  Application_ReputonJson: () => Application_ReputonJson,
  Application_Resource_ListsXml: () => Application_Resource_ListsXml,
  Application_Resource_Lists_DiffXml: () => Application_Resource_Lists_DiffXml,
  Application_RfcXml: () => Application_RfcXml,
  Application_Riscos: () => Application_Riscos,
  Application_RlmiXml: () => Application_RlmiXml,
  Application_Rls_ServicesXml: () => Application_Rls_ServicesXml,
  Application_Route_ApdXml: () => Application_Route_ApdXml,
  Application_Route_S_TsidXml: () => Application_Route_S_TsidXml,
  Application_Route_UsdXml: () => Application_Route_UsdXml,
  Application_Rpki_Ghostbusters: () => Application_Rpki_Ghostbusters,
  Application_Rpki_Manifest: () => Application_Rpki_Manifest,
  Application_Rpki_Publication: () => Application_Rpki_Publication,
  Application_Rpki_Roa: () => Application_Rpki_Roa,
  Application_Rpki_Updown: () => Application_Rpki_Updown,
  Application_RsdXml: () => Application_RsdXml,
  Application_RssXml: () => Application_RssXml,
  Application_Rtf: () => Application_Rtf,
  Application_Rtploopback: () => Application_Rtploopback,
  Application_Rtx: () => Application_Rtx,
  Application_SGML: () => Application_SGML,
  Application_SamlassertionXml: () => Application_SamlassertionXml,
  Application_SamlmetadataXml: () => Application_SamlmetadataXml,
  Application_SbmlXml: () => Application_SbmlXml,
  Application_ScaipXml: () => Application_ScaipXml,
  Application_ScenarioJson: () => Application_ScenarioJson,
  Application_ScimJson: () => Application_ScimJson,
  Application_Scvp_Cv_Request: () => Application_Scvp_Cv_Request,
  Application_Scvp_Cv_Response: () => Application_Scvp_Cv_Response,
  Application_Scvp_Vp_Request: () => Application_Scvp_Vp_Request,
  Application_Scvp_Vp_Response: () => Application_Scvp_Vp_Response,
  Application_Sdp: () => Application_Sdp,
  Application_SeceventJwt: () => Application_SeceventJwt,
  Application_SenmlCbor: () => Application_SenmlCbor,
  Application_SenmlJson: () => Application_SenmlJson,
  Application_SenmlXml: () => Application_SenmlXml,
  Application_Senml_Exi: () => Application_Senml_Exi,
  Application_SensmlCbor: () => Application_SensmlCbor,
  Application_SensmlJson: () => Application_SensmlJson,
  Application_SensmlXml: () => Application_SensmlXml,
  Application_Sensml_Exi: () => Application_Sensml_Exi,
  Application_SepXml: () => Application_SepXml,
  Application_Sep_Exi: () => Application_Sep_Exi,
  Application_Session_Info: () => Application_Session_Info,
  Application_Set_Payment: () => Application_Set_Payment,
  Application_Set_Payment_Initiation: () => Application_Set_Payment_Initiation,
  Application_Set_Registration: () => Application_Set_Registration,
  Application_Set_Registration_Initiation: () => Application_Set_Registration_Initiation,
  Application_Sgml_Open_Catalog: () => Application_Sgml_Open_Catalog,
  Application_ShfXml: () => Application_ShfXml,
  Application_Sieve: () => Application_Sieve,
  Application_SimpleSymbolContainer: () => Application_SimpleSymbolContainer,
  Application_Simple_FilterXml: () => Application_Simple_FilterXml,
  Application_Simple_Message_Summary: () => Application_Simple_Message_Summary,
  Application_Sipc: () => Application_Sipc,
  Application_Slate: () => Application_Slate,
  Application_Smil: () => Application_Smil,
  Application_SmilXml: () => Application_SmilXml,
  Application_Smpte336m: () => Application_Smpte336m,
  Application_SoapFastinfoset: () => Application_SoapFastinfoset,
  Application_SoapXml: () => Application_SoapXml,
  Application_Sparql_Query: () => Application_Sparql_Query,
  Application_Sparql_ResultsXml: () => Application_Sparql_ResultsXml,
  Application_Spirits_EventXml: () => Application_Spirits_EventXml,
  Application_Sql: () => Application_Sql,
  Application_Srgs: () => Application_Srgs,
  Application_SrgsXml: () => Application_SrgsXml,
  Application_SruXml: () => Application_SruXml,
  Application_SsdlXml: () => Application_SsdlXml,
  Application_SsmlXml: () => Application_SsmlXml,
  Application_StixJson: () => Application_StixJson,
  Application_SwidXml: () => Application_SwidXml,
  Application_TETRA_ISI: () => Application_TETRA_ISI,
  Application_Tamp_Apex_Update: () => Application_Tamp_Apex_Update,
  Application_Tamp_Apex_Update_Confirm: () => Application_Tamp_Apex_Update_Confirm,
  Application_Tamp_Community_Update: () => Application_Tamp_Community_Update,
  Application_Tamp_Community_Update_Confirm: () => Application_Tamp_Community_Update_Confirm,
  Application_Tamp_Error: () => Application_Tamp_Error,
  Application_Tamp_Sequence_Adjust: () => Application_Tamp_Sequence_Adjust,
  Application_Tamp_Sequence_Adjust_Confirm: () => Application_Tamp_Sequence_Adjust_Confirm,
  Application_Tamp_Status_Query: () => Application_Tamp_Status_Query,
  Application_Tamp_Status_Response: () => Application_Tamp_Status_Response,
  Application_Tamp_Update: () => Application_Tamp_Update,
  Application_Tamp_Update_Confirm: () => Application_Tamp_Update_Confirm,
  Application_Tar: () => Application_Tar,
  Application_TaxiiJson: () => Application_TaxiiJson,
  Application_TeiXml: () => Application_TeiXml,
  Application_ThraudXml: () => Application_ThraudXml,
  Application_Timestamp_Query: () => Application_Timestamp_Query,
  Application_Timestamp_Reply: () => Application_Timestamp_Reply,
  Application_Timestamped_Data: () => Application_Timestamped_Data,
  Application_TlsrptGzip: () => Application_TlsrptGzip,
  Application_TlsrptJson: () => Application_TlsrptJson,
  Application_Tnauthlist: () => Application_Tnauthlist,
  Application_Toml: () => Application_Toml,
  Application_Trickle_Ice_Sdpfrag: () => Application_Trickle_Ice_Sdpfrag,
  Application_Trig: () => Application_Trig,
  Application_TtmlXml: () => Application_TtmlXml,
  Application_Tve_Trigger: () => Application_Tve_Trigger,
  Application_Tzif: () => Application_Tzif,
  Application_Tzif_Leap: () => Application_Tzif_Leap,
  Application_Ubjson: () => Application_Ubjson,
  Application_Ulpfec: () => Application_Ulpfec,
  Application_Urc_GrpsheetXml: () => Application_Urc_GrpsheetXml,
  Application_Urc_RessheetXml: () => Application_Urc_RessheetXml,
  Application_Urc_TargetdescXml: () => Application_Urc_TargetdescXml,
  Application_Urc_UisocketdescXml: () => Application_Urc_UisocketdescXml,
  Application_VcardJson: () => Application_VcardJson,
  Application_VcardXml: () => Application_VcardXml,
  Application_Vemmi: () => Application_Vemmi,
  Application_Vendor_1000mindsDecision_ModelXml: () => Application_Vendor_1000mindsDecision_ModelXml,
  Application_Vendor_1d_Interleaved_Parityfec: () => Application_Vendor_1d_Interleaved_Parityfec,
  Application_Vendor_3MPost_It_Notes: () => Application_Vendor_3MPost_It_Notes,
  Application_Vendor_3gpdash_Qoe_ReportXml: () => Application_Vendor_3gpdash_Qoe_ReportXml,
  Application_Vendor_3gpp2BcmcsinfoXml: () => Application_Vendor_3gpp2BcmcsinfoXml,
  Application_Vendor_3gpp2Sms: () => Application_Vendor_3gpp2Sms,
  Application_Vendor_3gpp2Tcap: () => Application_Vendor_3gpp2Tcap,
  Application_Vendor_3gppAccess_Transfer_EventsXml: () => Application_Vendor_3gppAccess_Transfer_EventsXml,
  Application_Vendor_3gppBsfXml: () => Application_Vendor_3gppBsfXml,
  Application_Vendor_3gppGMOPXml: () => Application_Vendor_3gppGMOPXml,
  Application_Vendor_3gppMc_Signalling_Ear: () => Application_Vendor_3gppMc_Signalling_Ear,
  Application_Vendor_3gppMcdata_Affiliation_CommandXml: () => Application_Vendor_3gppMcdata_Affiliation_CommandXml,
  Application_Vendor_3gppMcdata_InfoXml: () => Application_Vendor_3gppMcdata_InfoXml,
  Application_Vendor_3gppMcdata_Payload: () => Application_Vendor_3gppMcdata_Payload,
  Application_Vendor_3gppMcdata_Service_ConfigXml: () => Application_Vendor_3gppMcdata_Service_ConfigXml,
  Application_Vendor_3gppMcdata_Signalling: () => Application_Vendor_3gppMcdata_Signalling,
  Application_Vendor_3gppMcdata_Ue_ConfigXml: () => Application_Vendor_3gppMcdata_Ue_ConfigXml,
  Application_Vendor_3gppMcdata_User_ProfileXml: () => Application_Vendor_3gppMcdata_User_ProfileXml,
  Application_Vendor_3gppMcptt_Affiliation_CommandXml: () => Application_Vendor_3gppMcptt_Affiliation_CommandXml,
  Application_Vendor_3gppMcptt_Floor_RequestXml: () => Application_Vendor_3gppMcptt_Floor_RequestXml,
  Application_Vendor_3gppMcptt_InfoXml: () => Application_Vendor_3gppMcptt_InfoXml,
  Application_Vendor_3gppMcptt_Location_InfoXml: () => Application_Vendor_3gppMcptt_Location_InfoXml,
  Application_Vendor_3gppMcptt_Mbms_Usage_InfoXml: () => Application_Vendor_3gppMcptt_Mbms_Usage_InfoXml,
  Application_Vendor_3gppMcptt_Service_ConfigXml: () => Application_Vendor_3gppMcptt_Service_ConfigXml,
  Application_Vendor_3gppMcptt_SignedXml: () => Application_Vendor_3gppMcptt_SignedXml,
  Application_Vendor_3gppMcptt_Ue_ConfigXml: () => Application_Vendor_3gppMcptt_Ue_ConfigXml,
  Application_Vendor_3gppMcptt_Ue_Init_ConfigXml: () => Application_Vendor_3gppMcptt_Ue_Init_ConfigXml,
  Application_Vendor_3gppMcptt_User_ProfileXml: () => Application_Vendor_3gppMcptt_User_ProfileXml,
  Application_Vendor_3gppMcvideo_Affiliation_CommandXml: () => Application_Vendor_3gppMcvideo_Affiliation_CommandXml,
  Application_Vendor_3gppMcvideo_Affiliation_InfoXml: () => Application_Vendor_3gppMcvideo_Affiliation_InfoXml,
  Application_Vendor_3gppMcvideo_InfoXml: () => Application_Vendor_3gppMcvideo_InfoXml,
  Application_Vendor_3gppMcvideo_Location_InfoXml: () => Application_Vendor_3gppMcvideo_Location_InfoXml,
  Application_Vendor_3gppMcvideo_Mbms_Usage_InfoXml: () => Application_Vendor_3gppMcvideo_Mbms_Usage_InfoXml,
  Application_Vendor_3gppMcvideo_Service_ConfigXml: () => Application_Vendor_3gppMcvideo_Service_ConfigXml,
  Application_Vendor_3gppMcvideo_Transmission_RequestXml: () => Application_Vendor_3gppMcvideo_Transmission_RequestXml,
  Application_Vendor_3gppMcvideo_Ue_ConfigXml: () => Application_Vendor_3gppMcvideo_Ue_ConfigXml,
  Application_Vendor_3gppMcvideo_User_ProfileXml: () => Application_Vendor_3gppMcvideo_User_ProfileXml,
  Application_Vendor_3gppMid_CallXml: () => Application_Vendor_3gppMid_CallXml,
  Application_Vendor_3gppPic_Bw_Large: () => Application_Vendor_3gppPic_Bw_Large,
  Application_Vendor_3gppPic_Bw_Small: () => Application_Vendor_3gppPic_Bw_Small,
  Application_Vendor_3gppPic_Bw_Var: () => Application_Vendor_3gppPic_Bw_Var,
  Application_Vendor_3gppSRVCC_InfoXml: () => Application_Vendor_3gppSRVCC_InfoXml,
  Application_Vendor_3gppSms: () => Application_Vendor_3gppSms,
  Application_Vendor_3gppSmsXml: () => Application_Vendor_3gppSmsXml,
  Application_Vendor_3gppSrvcc_ExtXml: () => Application_Vendor_3gppSrvcc_ExtXml,
  Application_Vendor_3gppState_And_Event_InfoXml: () => Application_Vendor_3gppState_And_Event_InfoXml,
  Application_Vendor_3gppUssdXml: () => Application_Vendor_3gppUssdXml,
  Application_Vendor_3gpp_ImsXml: () => Application_Vendor_3gpp_ImsXml,
  Application_Vendor_3gpp_ProseXml: () => Application_Vendor_3gpp_ProseXml,
  Application_Vendor_3gpp_Prose_Pc3chXml: () => Application_Vendor_3gpp_Prose_Pc3chXml,
  Application_Vendor_3gpp_V2x_Local_Service_Information: () => Application_Vendor_3gpp_V2x_Local_Service_Information,
  Application_Vendor_3lightssoftwareImagescal: () => Application_Vendor_3lightssoftwareImagescal,
  Application_Vendor_AccpacSimplyAso: () => Application_Vendor_AccpacSimplyAso,
  Application_Vendor_AccpacSimplyImp: () => Application_Vendor_AccpacSimplyImp,
  Application_Vendor_Acucobol: () => Application_Vendor_Acucobol,
  Application_Vendor_Acucorp: () => Application_Vendor_Acucorp,
  Application_Vendor_AdobeAir_Application_Installer_PackageZip: () => Application_Vendor_AdobeAir_Application_Installer_PackageZip,
  Application_Vendor_AdobeFlashMovie: () => Application_Vendor_AdobeFlashMovie,
  Application_Vendor_AdobeFormscentralFcdt: () => Application_Vendor_AdobeFormscentralFcdt,
  Application_Vendor_AdobeFxp: () => Application_Vendor_AdobeFxp,
  Application_Vendor_AdobePartial_Upload: () => Application_Vendor_AdobePartial_Upload,
  Application_Vendor_AdobeXdpXml: () => Application_Vendor_AdobeXdpXml,
  Application_Vendor_AdobeXfdf: () => Application_Vendor_AdobeXfdf,
  Application_Vendor_AetherImp: () => Application_Vendor_AetherImp,
  Application_Vendor_AfpcAfplinedata: () => Application_Vendor_AfpcAfplinedata,
  Application_Vendor_AfpcAfplinedata_Pagedef: () => Application_Vendor_AfpcAfplinedata_Pagedef,
  Application_Vendor_AfpcFoca_Charset: () => Application_Vendor_AfpcFoca_Charset,
  Application_Vendor_AfpcFoca_Codedfont: () => Application_Vendor_AfpcFoca_Codedfont,
  Application_Vendor_AfpcFoca_Codepage: () => Application_Vendor_AfpcFoca_Codepage,
  Application_Vendor_AfpcModca: () => Application_Vendor_AfpcModca,
  Application_Vendor_AfpcModca_Formdef: () => Application_Vendor_AfpcModca_Formdef,
  Application_Vendor_AfpcModca_Mediummap: () => Application_Vendor_AfpcModca_Mediummap,
  Application_Vendor_AfpcModca_Objectcontainer: () => Application_Vendor_AfpcModca_Objectcontainer,
  Application_Vendor_AfpcModca_Overlay: () => Application_Vendor_AfpcModca_Overlay,
  Application_Vendor_AfpcModca_Pagesegment: () => Application_Vendor_AfpcModca_Pagesegment,
  Application_Vendor_Ah_Barcode: () => Application_Vendor_Ah_Barcode,
  Application_Vendor_AheadSpace: () => Application_Vendor_AheadSpace,
  Application_Vendor_AirzipFilesecureAzf: () => Application_Vendor_AirzipFilesecureAzf,
  Application_Vendor_AirzipFilesecureAzs: () => Application_Vendor_AirzipFilesecureAzs,
  Application_Vendor_AmadeusJson: () => Application_Vendor_AmadeusJson,
  Application_Vendor_AmazonEbook: () => Application_Vendor_AmazonEbook,
  Application_Vendor_AmazonMobi8_Ebook: () => Application_Vendor_AmazonMobi8_Ebook,
  Application_Vendor_AmericandynamicsAcc: () => Application_Vendor_AmericandynamicsAcc,
  Application_Vendor_AmigaAmi: () => Application_Vendor_AmigaAmi,
  Application_Vendor_AmundsenMazeXml: () => Application_Vendor_AmundsenMazeXml,
  Application_Vendor_AndroidOta: () => Application_Vendor_AndroidOta,
  Application_Vendor_AndroidPackage_Archive: () => Application_Vendor_AndroidPackage_Archive,
  Application_Vendor_Anki: () => Application_Vendor_Anki,
  Application_Vendor_Anser_Web_Certificate_Issue_Initiation: () => Application_Vendor_Anser_Web_Certificate_Issue_Initiation,
  Application_Vendor_Anser_Web_Funds_Transfer_Initiation: () => Application_Vendor_Anser_Web_Funds_Transfer_Initiation,
  Application_Vendor_AntixGame_Component: () => Application_Vendor_AntixGame_Component,
  Application_Vendor_ApacheThriftBinary: () => Application_Vendor_ApacheThriftBinary,
  Application_Vendor_ApacheThriftCompact: () => Application_Vendor_ApacheThriftCompact,
  Application_Vendor_ApacheThriftJson: () => Application_Vendor_ApacheThriftJson,
  Application_Vendor_ApiJson: () => Application_Vendor_ApiJson,
  Application_Vendor_AplextorWarrpJson: () => Application_Vendor_AplextorWarrpJson,
  Application_Vendor_ApothekendeReservationJson: () => Application_Vendor_ApothekendeReservationJson,
  Application_Vendor_AppleInstallerXml: () => Application_Vendor_AppleInstallerXml,
  Application_Vendor_AppleKeynote: () => Application_Vendor_AppleKeynote,
  Application_Vendor_AppleMpegurl: () => Application_Vendor_AppleMpegurl,
  Application_Vendor_AppleNumbers: () => Application_Vendor_AppleNumbers,
  Application_Vendor_ApplePages: () => Application_Vendor_ApplePages,
  Application_Vendor_ApplePkpass: () => Application_Vendor_ApplePkpass,
  Application_Vendor_ArastraSwi: () => Application_Vendor_ArastraSwi,
  Application_Vendor_AristanetworksSwi: () => Application_Vendor_AristanetworksSwi,
  Application_Vendor_ArtisanJson: () => Application_Vendor_ArtisanJson,
  Application_Vendor_Artsquare: () => Application_Vendor_Artsquare,
  Application_Vendor_Astraea_SoftwareIota: () => Application_Vendor_Astraea_SoftwareIota,
  Application_Vendor_Audiograph: () => Application_Vendor_Audiograph,
  Application_Vendor_Autopackage: () => Application_Vendor_Autopackage,
  Application_Vendor_AvalonJson: () => Application_Vendor_AvalonJson,
  Application_Vendor_AvistarXml: () => Application_Vendor_AvistarXml,
  Application_Vendor_BalsamiqBmmlXml: () => Application_Vendor_BalsamiqBmmlXml,
  Application_Vendor_BalsamiqBmpr: () => Application_Vendor_BalsamiqBmpr,
  Application_Vendor_Banana_Accounting: () => Application_Vendor_Banana_Accounting,
  Application_Vendor_BbfUspError: () => Application_Vendor_BbfUspError,
  Application_Vendor_BbfUspMsg: () => Application_Vendor_BbfUspMsg,
  Application_Vendor_BbfUspMsgJson: () => Application_Vendor_BbfUspMsgJson,
  Application_Vendor_Bekitzur_StechJson: () => Application_Vendor_Bekitzur_StechJson,
  Application_Vendor_BintMed_Content: () => Application_Vendor_BintMed_Content,
  Application_Vendor_BiopaxRdfXml: () => Application_Vendor_BiopaxRdfXml,
  Application_Vendor_Blink_Idb_Value_Wrapper: () => Application_Vendor_Blink_Idb_Value_Wrapper,
  Application_Vendor_BlueiceMultipass: () => Application_Vendor_BlueiceMultipass,
  Application_Vendor_BluetoothEpOob: () => Application_Vendor_BluetoothEpOob,
  Application_Vendor_BluetoothLeOob: () => Application_Vendor_BluetoothLeOob,
  Application_Vendor_Bmi: () => Application_Vendor_Bmi,
  Application_Vendor_Bpf: () => Application_Vendor_Bpf,
  Application_Vendor_Bpf3: () => Application_Vendor_Bpf3,
  Application_Vendor_Businessobjects: () => Application_Vendor_Businessobjects,
  Application_Vendor_ByuUapiJson: () => Application_Vendor_ByuUapiJson,
  Application_Vendor_Cab_Jscript: () => Application_Vendor_Cab_Jscript,
  Application_Vendor_Canon_Cpdl: () => Application_Vendor_Canon_Cpdl,
  Application_Vendor_Canon_Lips: () => Application_Vendor_Canon_Lips,
  Application_Vendor_Capasystems_PgJson: () => Application_Vendor_Capasystems_PgJson,
  Application_Vendor_CendioThinlincClientconf: () => Application_Vendor_CendioThinlincClientconf,
  Application_Vendor_Century_SystemsTcp_stream: () => Application_Vendor_Century_SystemsTcp_stream,
  Application_Vendor_ChemdrawXml: () => Application_Vendor_ChemdrawXml,
  Application_Vendor_Chess_Pgn: () => Application_Vendor_Chess_Pgn,
  Application_Vendor_ChipnutsKaraoke_Mmd: () => Application_Vendor_ChipnutsKaraoke_Mmd,
  Application_Vendor_Ciedi: () => Application_Vendor_Ciedi,
  Application_Vendor_Cinderella: () => Application_Vendor_Cinderella,
  Application_Vendor_CirpackIsdn_Ext: () => Application_Vendor_CirpackIsdn_Ext,
  Application_Vendor_CitationstylesStyleXml: () => Application_Vendor_CitationstylesStyleXml,
  Application_Vendor_Claymore: () => Application_Vendor_Claymore,
  Application_Vendor_CloantoRp9: () => Application_Vendor_CloantoRp9,
  Application_Vendor_ClonkC4group: () => Application_Vendor_ClonkC4group,
  Application_Vendor_CluetrustCartomobile_Config: () => Application_Vendor_CluetrustCartomobile_Config,
  Application_Vendor_CluetrustCartomobile_Config_Pkg: () => Application_Vendor_CluetrustCartomobile_Config_Pkg,
  Application_Vendor_Coffeescript: () => Application_Vendor_Coffeescript,
  Application_Vendor_CollabioXodocumentsDocument: () => Application_Vendor_CollabioXodocumentsDocument,
  Application_Vendor_CollabioXodocumentsDocument_Template: () => Application_Vendor_CollabioXodocumentsDocument_Template,
  Application_Vendor_CollabioXodocumentsPresentation: () => Application_Vendor_CollabioXodocumentsPresentation,
  Application_Vendor_CollabioXodocumentsPresentation_Template: () => Application_Vendor_CollabioXodocumentsPresentation_Template,
  Application_Vendor_CollabioXodocumentsSpreadsheet: () => Application_Vendor_CollabioXodocumentsSpreadsheet,
  Application_Vendor_CollabioXodocumentsSpreadsheet_Template: () => Application_Vendor_CollabioXodocumentsSpreadsheet_Template,
  Application_Vendor_CollectionDocJson: () => Application_Vendor_CollectionDocJson,
  Application_Vendor_CollectionJson: () => Application_Vendor_CollectionJson,
  Application_Vendor_CollectionNextJson: () => Application_Vendor_CollectionNextJson,
  Application_Vendor_ComicbookZip: () => Application_Vendor_ComicbookZip,
  Application_Vendor_Comicbook_Rar: () => Application_Vendor_Comicbook_Rar,
  Application_Vendor_Commerce_Battelle: () => Application_Vendor_Commerce_Battelle,
  Application_Vendor_Commonspace: () => Application_Vendor_Commonspace,
  Application_Vendor_ContactCmsg: () => Application_Vendor_ContactCmsg,
  Application_Vendor_CoreosIgnitionJson: () => Application_Vendor_CoreosIgnitionJson,
  Application_Vendor_Cosmocaller: () => Application_Vendor_Cosmocaller,
  Application_Vendor_CrickClicker: () => Application_Vendor_CrickClicker,
  Application_Vendor_CrickClickerKeyboard: () => Application_Vendor_CrickClickerKeyboard,
  Application_Vendor_CrickClickerPalette: () => Application_Vendor_CrickClickerPalette,
  Application_Vendor_CrickClickerTemplate: () => Application_Vendor_CrickClickerTemplate,
  Application_Vendor_CrickClickerWordbank: () => Application_Vendor_CrickClickerWordbank,
  Application_Vendor_CriticaltoolsWbsXml: () => Application_Vendor_CriticaltoolsWbsXml,
  Application_Vendor_CryptiiPipeJson: () => Application_Vendor_CryptiiPipeJson,
  Application_Vendor_Crypto_Shade_File: () => Application_Vendor_Crypto_Shade_File,
  Application_Vendor_Ctc_Posml: () => Application_Vendor_Ctc_Posml,
  Application_Vendor_CtctWsXml: () => Application_Vendor_CtctWsXml,
  Application_Vendor_Cups_Pdf: () => Application_Vendor_Cups_Pdf,
  Application_Vendor_Cups_Postscript: () => Application_Vendor_Cups_Postscript,
  Application_Vendor_Cups_Ppd: () => Application_Vendor_Cups_Ppd,
  Application_Vendor_Cups_Raster: () => Application_Vendor_Cups_Raster,
  Application_Vendor_Cups_Raw: () => Application_Vendor_Cups_Raw,
  Application_Vendor_Curl: () => Application_Vendor_Curl,
  Application_Vendor_CurlCar: () => Application_Vendor_CurlCar,
  Application_Vendor_CurlPcurl: () => Application_Vendor_CurlPcurl,
  Application_Vendor_CyanDeanRootXml: () => Application_Vendor_CyanDeanRootXml,
  Application_Vendor_Cybank: () => Application_Vendor_Cybank,
  Application_Vendor_D2lCoursepackage1p0Zip: () => Application_Vendor_D2lCoursepackage1p0Zip,
  Application_Vendor_Dart: () => Application_Vendor_Dart,
  Application_Vendor_Data_VisionRdz: () => Application_Vendor_Data_VisionRdz,
  Application_Vendor_DatapackageJson: () => Application_Vendor_DatapackageJson,
  Application_Vendor_DataresourceJson: () => Application_Vendor_DataresourceJson,
  Application_Vendor_DebianBinary_Package: () => Application_Vendor_DebianBinary_Package,
  Application_Vendor_DeceData: () => Application_Vendor_DeceData,
  Application_Vendor_DeceTtmlXml: () => Application_Vendor_DeceTtmlXml,
  Application_Vendor_DeceUnspecified: () => Application_Vendor_DeceUnspecified,
  Application_Vendor_DeceZip: () => Application_Vendor_DeceZip,
  Application_Vendor_DenovoFcselayout_Link: () => Application_Vendor_DenovoFcselayout_Link,
  Application_Vendor_DesmumeMovie: () => Application_Vendor_DesmumeMovie,
  Application_Vendor_Dir_BiPlate_Dl_Nosuffix: () => Application_Vendor_Dir_BiPlate_Dl_Nosuffix,
  Application_Vendor_DmDelegationXml: () => Application_Vendor_DmDelegationXml,
  Application_Vendor_Dna: () => Application_Vendor_Dna,
  Application_Vendor_DocumentJson: () => Application_Vendor_DocumentJson,
  Application_Vendor_DolbyMlp: () => Application_Vendor_DolbyMlp,
  Application_Vendor_DolbyMobile1: () => Application_Vendor_DolbyMobile1,
  Application_Vendor_DolbyMobile2: () => Application_Vendor_DolbyMobile2,
  Application_Vendor_DoremirScorecloud_Binary_Document: () => Application_Vendor_DoremirScorecloud_Binary_Document,
  Application_Vendor_Dpgraph: () => Application_Vendor_Dpgraph,
  Application_Vendor_Dreamfactory: () => Application_Vendor_Dreamfactory,
  Application_Vendor_DriveJson: () => Application_Vendor_DriveJson,
  Application_Vendor_Ds_Keypoint: () => Application_Vendor_Ds_Keypoint,
  Application_Vendor_DtgLocal: () => Application_Vendor_DtgLocal,
  Application_Vendor_DtgLocalFlash: () => Application_Vendor_DtgLocalFlash,
  Application_Vendor_DtgLocalHtml: () => Application_Vendor_DtgLocalHtml,
  Application_Vendor_DvbAit: () => Application_Vendor_DvbAit,
  Application_Vendor_DvbDvbj: () => Application_Vendor_DvbDvbj,
  Application_Vendor_DvbEsgcontainer: () => Application_Vendor_DvbEsgcontainer,
  Application_Vendor_DvbIpdcdftnotifaccess: () => Application_Vendor_DvbIpdcdftnotifaccess,
  Application_Vendor_DvbIpdcesgaccess: () => Application_Vendor_DvbIpdcesgaccess,
  Application_Vendor_DvbIpdcesgaccess2: () => Application_Vendor_DvbIpdcesgaccess2,
  Application_Vendor_DvbIpdcesgpdd: () => Application_Vendor_DvbIpdcesgpdd,
  Application_Vendor_DvbIpdcroaming: () => Application_Vendor_DvbIpdcroaming,
  Application_Vendor_DvbIptvAlfec_Base: () => Application_Vendor_DvbIptvAlfec_Base,
  Application_Vendor_DvbIptvAlfec_Enhancement: () => Application_Vendor_DvbIptvAlfec_Enhancement,
  Application_Vendor_DvbNotif_Aggregate_RootXml: () => Application_Vendor_DvbNotif_Aggregate_RootXml,
  Application_Vendor_DvbNotif_ContainerXml: () => Application_Vendor_DvbNotif_ContainerXml,
  Application_Vendor_DvbNotif_GenericXml: () => Application_Vendor_DvbNotif_GenericXml,
  Application_Vendor_DvbNotif_Ia_MsglistXml: () => Application_Vendor_DvbNotif_Ia_MsglistXml,
  Application_Vendor_DvbNotif_Ia_Registration_RequestXml: () => Application_Vendor_DvbNotif_Ia_Registration_RequestXml,
  Application_Vendor_DvbNotif_Ia_Registration_ResponseXml: () => Application_Vendor_DvbNotif_Ia_Registration_ResponseXml,
  Application_Vendor_DvbNotif_InitXml: () => Application_Vendor_DvbNotif_InitXml,
  Application_Vendor_DvbPfr: () => Application_Vendor_DvbPfr,
  Application_Vendor_DvbService: () => Application_Vendor_DvbService,
  Application_Vendor_Dxr: () => Application_Vendor_Dxr,
  Application_Vendor_Dynageo: () => Application_Vendor_Dynageo,
  Application_Vendor_Dzr: () => Application_Vendor_Dzr,
  Application_Vendor_EasykaraokeCdgdownload: () => Application_Vendor_EasykaraokeCdgdownload,
  Application_Vendor_Ecdis_Update: () => Application_Vendor_Ecdis_Update,
  Application_Vendor_EcipRlp: () => Application_Vendor_EcipRlp,
  Application_Vendor_EcowinChart: () => Application_Vendor_EcowinChart,
  Application_Vendor_EcowinFilerequest: () => Application_Vendor_EcowinFilerequest,
  Application_Vendor_EcowinFileupdate: () => Application_Vendor_EcowinFileupdate,
  Application_Vendor_EcowinSeries: () => Application_Vendor_EcowinSeries,
  Application_Vendor_EcowinSeriesrequest: () => Application_Vendor_EcowinSeriesrequest,
  Application_Vendor_EcowinSeriesupdate: () => Application_Vendor_EcowinSeriesupdate,
  Application_Vendor_EfiImg: () => Application_Vendor_EfiImg,
  Application_Vendor_EfiIso: () => Application_Vendor_EfiIso,
  Application_Vendor_EmclientAccessrequestXml: () => Application_Vendor_EmclientAccessrequestXml,
  Application_Vendor_Enliven: () => Application_Vendor_Enliven,
  Application_Vendor_EnphaseEnvoy: () => Application_Vendor_EnphaseEnvoy,
  Application_Vendor_EprintsDataXml: () => Application_Vendor_EprintsDataXml,
  Application_Vendor_EpsonEsf: () => Application_Vendor_EpsonEsf,
  Application_Vendor_EpsonMsf: () => Application_Vendor_EpsonMsf,
  Application_Vendor_EpsonQuickanime: () => Application_Vendor_EpsonQuickanime,
  Application_Vendor_EpsonSalt: () => Application_Vendor_EpsonSalt,
  Application_Vendor_EpsonSsf: () => Application_Vendor_EpsonSsf,
  Application_Vendor_EricssonQuickcall: () => Application_Vendor_EricssonQuickcall,
  Application_Vendor_Espass_EspassZip: () => Application_Vendor_Espass_EspassZip,
  Application_Vendor_Eszigno3Xml: () => Application_Vendor_Eszigno3Xml,
  Application_Vendor_EtsiAocXml: () => Application_Vendor_EtsiAocXml,
  Application_Vendor_EtsiAsic_EZip: () => Application_Vendor_EtsiAsic_EZip,
  Application_Vendor_EtsiAsic_SZip: () => Application_Vendor_EtsiAsic_SZip,
  Application_Vendor_EtsiCugXml: () => Application_Vendor_EtsiCugXml,
  Application_Vendor_EtsiIptvcommandXml: () => Application_Vendor_EtsiIptvcommandXml,
  Application_Vendor_EtsiIptvdiscoveryXml: () => Application_Vendor_EtsiIptvdiscoveryXml,
  Application_Vendor_EtsiIptvprofileXml: () => Application_Vendor_EtsiIptvprofileXml,
  Application_Vendor_EtsiIptvsad_BcXml: () => Application_Vendor_EtsiIptvsad_BcXml,
  Application_Vendor_EtsiIptvsad_CodXml: () => Application_Vendor_EtsiIptvsad_CodXml,
  Application_Vendor_EtsiIptvsad_NpvrXml: () => Application_Vendor_EtsiIptvsad_NpvrXml,
  Application_Vendor_EtsiIptvserviceXml: () => Application_Vendor_EtsiIptvserviceXml,
  Application_Vendor_EtsiIptvsyncXml: () => Application_Vendor_EtsiIptvsyncXml,
  Application_Vendor_EtsiIptvueprofileXml: () => Application_Vendor_EtsiIptvueprofileXml,
  Application_Vendor_EtsiMcidXml: () => Application_Vendor_EtsiMcidXml,
  Application_Vendor_EtsiMheg5: () => Application_Vendor_EtsiMheg5,
  Application_Vendor_EtsiOverload_Control_Policy_DatasetXml: () => Application_Vendor_EtsiOverload_Control_Policy_DatasetXml,
  Application_Vendor_EtsiPstnXml: () => Application_Vendor_EtsiPstnXml,
  Application_Vendor_EtsiSciXml: () => Application_Vendor_EtsiSciXml,
  Application_Vendor_EtsiSimservsXml: () => Application_Vendor_EtsiSimservsXml,
  Application_Vendor_EtsiTimestamp_Token: () => Application_Vendor_EtsiTimestamp_Token,
  Application_Vendor_EtsiTslDer: () => Application_Vendor_EtsiTslDer,
  Application_Vendor_EtsiTslXml: () => Application_Vendor_EtsiTslXml,
  Application_Vendor_EudoraData: () => Application_Vendor_EudoraData,
  Application_Vendor_EvolvEcigProfile: () => Application_Vendor_EvolvEcigProfile,
  Application_Vendor_EvolvEcigSettings: () => Application_Vendor_EvolvEcigSettings,
  Application_Vendor_EvolvEcigTheme: () => Application_Vendor_EvolvEcigTheme,
  Application_Vendor_Exstream_EmpowerZip: () => Application_Vendor_Exstream_EmpowerZip,
  Application_Vendor_Exstream_Package: () => Application_Vendor_Exstream_Package,
  Application_Vendor_Ezpix_Album: () => Application_Vendor_Ezpix_Album,
  Application_Vendor_Ezpix_Package: () => Application_Vendor_Ezpix_Package,
  Application_Vendor_F_SecureMobile: () => Application_Vendor_F_SecureMobile,
  Application_Vendor_Fastcopy_Disk_Image: () => Application_Vendor_Fastcopy_Disk_Image,
  Application_Vendor_Fdf: () => Application_Vendor_Fdf,
  Application_Vendor_FdsnMseed: () => Application_Vendor_FdsnMseed,
  Application_Vendor_FdsnSeed: () => Application_Vendor_FdsnSeed,
  Application_Vendor_Ffsns: () => Application_Vendor_Ffsns,
  Application_Vendor_FiclabFlbZip: () => Application_Vendor_FiclabFlbZip,
  Application_Vendor_FilmitZfc: () => Application_Vendor_FilmitZfc,
  Application_Vendor_Fints: () => Application_Vendor_Fints,
  Application_Vendor_FiremonkeysCloudcell: () => Application_Vendor_FiremonkeysCloudcell,
  Application_Vendor_FloGraphIt: () => Application_Vendor_FloGraphIt,
  Application_Vendor_FluxtimeClip: () => Application_Vendor_FluxtimeClip,
  Application_Vendor_Font_Fontforge_Sfd: () => Application_Vendor_Font_Fontforge_Sfd,
  Application_Vendor_Framemaker: () => Application_Vendor_Framemaker,
  Application_Vendor_FrogansFnc: () => Application_Vendor_FrogansFnc,
  Application_Vendor_FrogansLtf: () => Application_Vendor_FrogansLtf,
  Application_Vendor_FscWeblaunch: () => Application_Vendor_FscWeblaunch,
  Application_Vendor_FujitsuOasys: () => Application_Vendor_FujitsuOasys,
  Application_Vendor_FujitsuOasys2: () => Application_Vendor_FujitsuOasys2,
  Application_Vendor_FujitsuOasys3: () => Application_Vendor_FujitsuOasys3,
  Application_Vendor_FujitsuOasysgp: () => Application_Vendor_FujitsuOasysgp,
  Application_Vendor_FujitsuOasysprs: () => Application_Vendor_FujitsuOasysprs,
  Application_Vendor_FujixeroxART4: () => Application_Vendor_FujixeroxART4,
  Application_Vendor_FujixeroxART_EX: () => Application_Vendor_FujixeroxART_EX,
  Application_Vendor_FujixeroxDdd: () => Application_Vendor_FujixeroxDdd,
  Application_Vendor_FujixeroxDocuworks: () => Application_Vendor_FujixeroxDocuworks,
  Application_Vendor_FujixeroxDocuworksBinder: () => Application_Vendor_FujixeroxDocuworksBinder,
  Application_Vendor_FujixeroxDocuworksContainer: () => Application_Vendor_FujixeroxDocuworksContainer,
  Application_Vendor_FujixeroxHBPL: () => Application_Vendor_FujixeroxHBPL,
  Application_Vendor_Fut_Misnet: () => Application_Vendor_Fut_Misnet,
  Application_Vendor_FutoinCbor: () => Application_Vendor_FutoinCbor,
  Application_Vendor_FutoinJson: () => Application_Vendor_FutoinJson,
  Application_Vendor_Fuzzysheet: () => Application_Vendor_Fuzzysheet,
  Application_Vendor_GenomatixTuxedo: () => Application_Vendor_GenomatixTuxedo,
  Application_Vendor_GenticsGrdJson: () => Application_Vendor_GenticsGrdJson,
  Application_Vendor_GeoJson: () => Application_Vendor_GeoJson,
  Application_Vendor_GeocubeXml: () => Application_Vendor_GeocubeXml,
  Application_Vendor_GeogebraFile: () => Application_Vendor_GeogebraFile,
  Application_Vendor_GeogebraTool: () => Application_Vendor_GeogebraTool,
  Application_Vendor_Geometry_Explorer: () => Application_Vendor_Geometry_Explorer,
  Application_Vendor_Geonext: () => Application_Vendor_Geonext,
  Application_Vendor_Geoplan: () => Application_Vendor_Geoplan,
  Application_Vendor_Geospace: () => Application_Vendor_Geospace,
  Application_Vendor_Gerber: () => Application_Vendor_Gerber,
  Application_Vendor_GlobalplatformCard_Content_Mgt: () => Application_Vendor_GlobalplatformCard_Content_Mgt,
  Application_Vendor_GlobalplatformCard_Content_Mgt_Response: () => Application_Vendor_GlobalplatformCard_Content_Mgt_Response,
  Application_Vendor_Gmx: () => Application_Vendor_Gmx,
  Application_Vendor_Google_Apps_Document: () => Application_Vendor_Google_Apps_Document,
  Application_Vendor_Google_Apps_Presentation: () => Application_Vendor_Google_Apps_Presentation,
  Application_Vendor_Google_Apps_Spreadsheet: () => Application_Vendor_Google_Apps_Spreadsheet,
  Application_Vendor_Google_EarthKmlXml: () => Application_Vendor_Google_EarthKmlXml,
  Application_Vendor_Google_EarthKmz: () => Application_Vendor_Google_EarthKmz,
  Application_Vendor_GovSkE_FormXml: () => Application_Vendor_GovSkE_FormXml,
  Application_Vendor_GovSkE_FormZip: () => Application_Vendor_GovSkE_FormZip,
  Application_Vendor_GovSkXmldatacontainerXml: () => Application_Vendor_GovSkXmldatacontainerXml,
  Application_Vendor_Grafeq: () => Application_Vendor_Grafeq,
  Application_Vendor_Gridmp: () => Application_Vendor_Gridmp,
  Application_Vendor_Groove_Account: () => Application_Vendor_Groove_Account,
  Application_Vendor_Groove_Help: () => Application_Vendor_Groove_Help,
  Application_Vendor_Groove_Identity_Message: () => Application_Vendor_Groove_Identity_Message,
  Application_Vendor_Groove_Injector: () => Application_Vendor_Groove_Injector,
  Application_Vendor_Groove_Tool_Message: () => Application_Vendor_Groove_Tool_Message,
  Application_Vendor_Groove_Tool_Template: () => Application_Vendor_Groove_Tool_Template,
  Application_Vendor_Groove_Vcard: () => Application_Vendor_Groove_Vcard,
  Application_Vendor_HalJson: () => Application_Vendor_HalJson,
  Application_Vendor_HalXml: () => Application_Vendor_HalXml,
  Application_Vendor_HandHeld_EntertainmentXml: () => Application_Vendor_HandHeld_EntertainmentXml,
  Application_Vendor_Hbci: () => Application_Vendor_Hbci,
  Application_Vendor_HcJson: () => Application_Vendor_HcJson,
  Application_Vendor_Hcl_Bireports: () => Application_Vendor_Hcl_Bireports,
  Application_Vendor_Hdt: () => Application_Vendor_Hdt,
  Application_Vendor_HerokuJson: () => Application_Vendor_HerokuJson,
  Application_Vendor_HheLesson_Player: () => Application_Vendor_HheLesson_Player,
  Application_Vendor_Hp_HPGL: () => Application_Vendor_Hp_HPGL,
  Application_Vendor_Hp_Hpid: () => Application_Vendor_Hp_Hpid,
  Application_Vendor_Hp_Hps: () => Application_Vendor_Hp_Hps,
  Application_Vendor_Hp_Jlyt: () => Application_Vendor_Hp_Jlyt,
  Application_Vendor_Hp_PCL: () => Application_Vendor_Hp_PCL,
  Application_Vendor_Hp_PCLXL: () => Application_Vendor_Hp_PCLXL,
  Application_Vendor_Httphone: () => Application_Vendor_Httphone,
  Application_Vendor_HydrostatixSof_Data: () => Application_Vendor_HydrostatixSof_Data,
  Application_Vendor_HyperJson: () => Application_Vendor_HyperJson,
  Application_Vendor_Hyper_ItemJson: () => Application_Vendor_Hyper_ItemJson,
  Application_Vendor_HyperdriveJson: () => Application_Vendor_HyperdriveJson,
  Application_Vendor_Hzn_3d_Crossword: () => Application_Vendor_Hzn_3d_Crossword,
  Application_Vendor_IbmAfplinedata: () => Application_Vendor_IbmAfplinedata,
  Application_Vendor_IbmElectronic_Media: () => Application_Vendor_IbmElectronic_Media,
  Application_Vendor_IbmMiniPay: () => Application_Vendor_IbmMiniPay,
  Application_Vendor_IbmModcap: () => Application_Vendor_IbmModcap,
  Application_Vendor_IbmRights_Management: () => Application_Vendor_IbmRights_Management,
  Application_Vendor_IbmSecure_Container: () => Application_Vendor_IbmSecure_Container,
  Application_Vendor_Iccprofile: () => Application_Vendor_Iccprofile,
  Application_Vendor_Ieee1905: () => Application_Vendor_Ieee1905,
  Application_Vendor_Igloader: () => Application_Vendor_Igloader,
  Application_Vendor_ImagemeterFolderZip: () => Application_Vendor_ImagemeterFolderZip,
  Application_Vendor_ImagemeterImageZip: () => Application_Vendor_ImagemeterImageZip,
  Application_Vendor_Immervision_Ivp: () => Application_Vendor_Immervision_Ivp,
  Application_Vendor_Immervision_Ivu: () => Application_Vendor_Immervision_Ivu,
  Application_Vendor_ImsImsccv1p1: () => Application_Vendor_ImsImsccv1p1,
  Application_Vendor_ImsImsccv1p2: () => Application_Vendor_ImsImsccv1p2,
  Application_Vendor_ImsImsccv1p3: () => Application_Vendor_ImsImsccv1p3,
  Application_Vendor_ImsLisV2ResultJson: () => Application_Vendor_ImsLisV2ResultJson,
  Application_Vendor_ImsLtiV2ToolconsumerprofileJson: () => Application_Vendor_ImsLtiV2ToolconsumerprofileJson,
  Application_Vendor_ImsLtiV2ToolproxyIdJson: () => Application_Vendor_ImsLtiV2ToolproxyIdJson,
  Application_Vendor_ImsLtiV2ToolproxyJson: () => Application_Vendor_ImsLtiV2ToolproxyJson,
  Application_Vendor_ImsLtiV2ToolsettingsJson: () => Application_Vendor_ImsLtiV2ToolsettingsJson,
  Application_Vendor_ImsLtiV2ToolsettingsSimpleJson: () => Application_Vendor_ImsLtiV2ToolsettingsSimpleJson,
  Application_Vendor_InformedcontrolRmsXml: () => Application_Vendor_InformedcontrolRmsXml,
  Application_Vendor_Informix_Visionary: () => Application_Vendor_Informix_Visionary,
  Application_Vendor_InfotechProject: () => Application_Vendor_InfotechProject,
  Application_Vendor_InfotechProjectXml: () => Application_Vendor_InfotechProjectXml,
  Application_Vendor_InnopathWampNotification: () => Application_Vendor_InnopathWampNotification,
  Application_Vendor_InsorsIgm: () => Application_Vendor_InsorsIgm,
  Application_Vendor_InterconFormnet: () => Application_Vendor_InterconFormnet,
  Application_Vendor_Intergeo: () => Application_Vendor_Intergeo,
  Application_Vendor_IntertrustDigibox: () => Application_Vendor_IntertrustDigibox,
  Application_Vendor_IntertrustNncp: () => Application_Vendor_IntertrustNncp,
  Application_Vendor_IntuQbo: () => Application_Vendor_IntuQbo,
  Application_Vendor_IntuQfx: () => Application_Vendor_IntuQfx,
  Application_Vendor_IptcG2CatalogitemXml: () => Application_Vendor_IptcG2CatalogitemXml,
  Application_Vendor_IptcG2ConceptitemXml: () => Application_Vendor_IptcG2ConceptitemXml,
  Application_Vendor_IptcG2KnowledgeitemXml: () => Application_Vendor_IptcG2KnowledgeitemXml,
  Application_Vendor_IptcG2NewsitemXml: () => Application_Vendor_IptcG2NewsitemXml,
  Application_Vendor_IptcG2NewsmessageXml: () => Application_Vendor_IptcG2NewsmessageXml,
  Application_Vendor_IptcG2PackageitemXml: () => Application_Vendor_IptcG2PackageitemXml,
  Application_Vendor_IptcG2PlanningitemXml: () => Application_Vendor_IptcG2PlanningitemXml,
  Application_Vendor_IpunpluggedRcprofile: () => Application_Vendor_IpunpluggedRcprofile,
  Application_Vendor_IrepositoryPackageXml: () => Application_Vendor_IrepositoryPackageXml,
  Application_Vendor_Is_Xpr: () => Application_Vendor_Is_Xpr,
  Application_Vendor_IsacFcs: () => Application_Vendor_IsacFcs,
  Application_Vendor_Iso11783_10Zip: () => Application_Vendor_Iso11783_10Zip,
  Application_Vendor_Jam: () => Application_Vendor_Jam,
  Application_Vendor_Japannet_Directory_Service: () => Application_Vendor_Japannet_Directory_Service,
  Application_Vendor_Japannet_Jpnstore_Wakeup: () => Application_Vendor_Japannet_Jpnstore_Wakeup,
  Application_Vendor_Japannet_Payment_Wakeup: () => Application_Vendor_Japannet_Payment_Wakeup,
  Application_Vendor_Japannet_Registration: () => Application_Vendor_Japannet_Registration,
  Application_Vendor_Japannet_Registration_Wakeup: () => Application_Vendor_Japannet_Registration_Wakeup,
  Application_Vendor_Japannet_Setstore_Wakeup: () => Application_Vendor_Japannet_Setstore_Wakeup,
  Application_Vendor_Japannet_Verification: () => Application_Vendor_Japannet_Verification,
  Application_Vendor_Japannet_Verification_Wakeup: () => Application_Vendor_Japannet_Verification_Wakeup,
  Application_Vendor_JcpJavameMidlet_Rms: () => Application_Vendor_JcpJavameMidlet_Rms,
  Application_Vendor_Jisp: () => Application_Vendor_Jisp,
  Application_Vendor_JoostJoda_Archive: () => Application_Vendor_JoostJoda_Archive,
  Application_Vendor_JskIsdn_Ngn: () => Application_Vendor_JskIsdn_Ngn,
  Application_Vendor_Kahootz: () => Application_Vendor_Kahootz,
  Application_Vendor_KdeKarbon: () => Application_Vendor_KdeKarbon,
  Application_Vendor_KdeKchart: () => Application_Vendor_KdeKchart,
  Application_Vendor_KdeKformula: () => Application_Vendor_KdeKformula,
  Application_Vendor_KdeKivio: () => Application_Vendor_KdeKivio,
  Application_Vendor_KdeKontour: () => Application_Vendor_KdeKontour,
  Application_Vendor_KdeKpresenter: () => Application_Vendor_KdeKpresenter,
  Application_Vendor_KdeKspread: () => Application_Vendor_KdeKspread,
  Application_Vendor_KdeKword: () => Application_Vendor_KdeKword,
  Application_Vendor_Kenameaapp: () => Application_Vendor_Kenameaapp,
  Application_Vendor_Kidspiration: () => Application_Vendor_Kidspiration,
  Application_Vendor_Kinar: () => Application_Vendor_Kinar,
  Application_Vendor_Koan: () => Application_Vendor_Koan,
  Application_Vendor_Kodak_Descriptor: () => Application_Vendor_Kodak_Descriptor,
  Application_Vendor_Las: () => Application_Vendor_Las,
  Application_Vendor_LasLasJson: () => Application_Vendor_LasLasJson,
  Application_Vendor_LasLasXml: () => Application_Vendor_LasLasXml,
  Application_Vendor_Laszip: () => Application_Vendor_Laszip,
  Application_Vendor_LeapJson: () => Application_Vendor_LeapJson,
  Application_Vendor_Liberty_RequestXml: () => Application_Vendor_Liberty_RequestXml,
  Application_Vendor_LlamagraphicsLife_BalanceDesktop: () => Application_Vendor_LlamagraphicsLife_BalanceDesktop,
  Application_Vendor_LlamagraphicsLife_BalanceExchangeXml: () => Application_Vendor_LlamagraphicsLife_BalanceExchangeXml,
  Application_Vendor_LogipipeCircuitZip: () => Application_Vendor_LogipipeCircuitZip,
  Application_Vendor_Loom: () => Application_Vendor_Loom,
  Application_Vendor_Lotus_1_2_3: () => Application_Vendor_Lotus_1_2_3,
  Application_Vendor_Lotus_Approach: () => Application_Vendor_Lotus_Approach,
  Application_Vendor_Lotus_Freelance: () => Application_Vendor_Lotus_Freelance,
  Application_Vendor_Lotus_Notes: () => Application_Vendor_Lotus_Notes,
  Application_Vendor_Lotus_Organizer: () => Application_Vendor_Lotus_Organizer,
  Application_Vendor_Lotus_Screencam: () => Application_Vendor_Lotus_Screencam,
  Application_Vendor_Lotus_Wordpro: () => Application_Vendor_Lotus_Wordpro,
  Application_Vendor_MFER: () => Application_Vendor_MFER,
  Application_Vendor_MacportsPortpkg: () => Application_Vendor_MacportsPortpkg,
  Application_Vendor_Mapbox_Vector_Tile: () => Application_Vendor_Mapbox_Vector_Tile,
  Application_Vendor_MarlinDrmActiontokenXml: () => Application_Vendor_MarlinDrmActiontokenXml,
  Application_Vendor_MarlinDrmConftokenXml: () => Application_Vendor_MarlinDrmConftokenXml,
  Application_Vendor_MarlinDrmLicenseXml: () => Application_Vendor_MarlinDrmLicenseXml,
  Application_Vendor_MarlinDrmMdcf: () => Application_Vendor_MarlinDrmMdcf,
  Application_Vendor_MasonJson: () => Application_Vendor_MasonJson,
  Application_Vendor_MaxmindMaxmind_Db: () => Application_Vendor_MaxmindMaxmind_Db,
  Application_Vendor_Mcd: () => Application_Vendor_Mcd,
  Application_Vendor_Medcalcdata: () => Application_Vendor_Medcalcdata,
  Application_Vendor_MediastationCdkey: () => Application_Vendor_MediastationCdkey,
  Application_Vendor_Meridian_Slingshot: () => Application_Vendor_Meridian_Slingshot,
  Application_Vendor_Mfmp: () => Application_Vendor_Mfmp,
  Application_Vendor_MicroJson: () => Application_Vendor_MicroJson,
  Application_Vendor_MicrografxFlo: () => Application_Vendor_MicrografxFlo,
  Application_Vendor_MicrografxIgx: () => Application_Vendor_MicrografxIgx,
  Application_Vendor_MicrosoftPortable_Executable: () => Application_Vendor_MicrosoftPortable_Executable,
  Application_Vendor_MicrosoftWindowsThumbnail_Cache: () => Application_Vendor_MicrosoftWindowsThumbnail_Cache,
  Application_Vendor_MieleJson: () => Application_Vendor_MieleJson,
  Application_Vendor_Mif: () => Application_Vendor_Mif,
  Application_Vendor_Minisoft_Hp3000_Save: () => Application_Vendor_Minisoft_Hp3000_Save,
  Application_Vendor_MitsubishiMisty_GuardTrustweb: () => Application_Vendor_MitsubishiMisty_GuardTrustweb,
  Application_Vendor_MobiusDAF: () => Application_Vendor_MobiusDAF,
  Application_Vendor_MobiusDIS: () => Application_Vendor_MobiusDIS,
  Application_Vendor_MobiusMBK: () => Application_Vendor_MobiusMBK,
  Application_Vendor_MobiusMQY: () => Application_Vendor_MobiusMQY,
  Application_Vendor_MobiusMSL: () => Application_Vendor_MobiusMSL,
  Application_Vendor_MobiusPLC: () => Application_Vendor_MobiusPLC,
  Application_Vendor_MobiusTXF: () => Application_Vendor_MobiusTXF,
  Application_Vendor_MophunApplication: () => Application_Vendor_MophunApplication,
  Application_Vendor_MophunCertificate: () => Application_Vendor_MophunCertificate,
  Application_Vendor_MotorolaFlexsuite: () => Application_Vendor_MotorolaFlexsuite,
  Application_Vendor_MotorolaFlexsuiteAdsi: () => Application_Vendor_MotorolaFlexsuiteAdsi,
  Application_Vendor_MotorolaFlexsuiteFis: () => Application_Vendor_MotorolaFlexsuiteFis,
  Application_Vendor_MotorolaFlexsuiteGotap: () => Application_Vendor_MotorolaFlexsuiteGotap,
  Application_Vendor_MotorolaFlexsuiteKmr: () => Application_Vendor_MotorolaFlexsuiteKmr,
  Application_Vendor_MotorolaFlexsuiteTtc: () => Application_Vendor_MotorolaFlexsuiteTtc,
  Application_Vendor_MotorolaFlexsuiteWem: () => Application_Vendor_MotorolaFlexsuiteWem,
  Application_Vendor_MotorolaIprm: () => Application_Vendor_MotorolaIprm,
  Application_Vendor_MozillaXulXml: () => Application_Vendor_MozillaXulXml,
  Application_Vendor_Ms_3mfdocument: () => Application_Vendor_Ms_3mfdocument,
  Application_Vendor_Ms_Artgalry: () => Application_Vendor_Ms_Artgalry,
  Application_Vendor_Ms_Asf: () => Application_Vendor_Ms_Asf,
  Application_Vendor_Ms_Cab_Compressed: () => Application_Vendor_Ms_Cab_Compressed,
  Application_Vendor_Ms_ColorIccprofile: () => Application_Vendor_Ms_ColorIccprofile,
  Application_Vendor_Ms_Excel: () => Application_Vendor_Ms_Excel,
  Application_Vendor_Ms_ExcelAddinMacroEnabled12: () => Application_Vendor_Ms_ExcelAddinMacroEnabled12,
  Application_Vendor_Ms_ExcelSheetBinaryMacroEnabled12: () => Application_Vendor_Ms_ExcelSheetBinaryMacroEnabled12,
  Application_Vendor_Ms_ExcelSheetMacroEnabled12: () => Application_Vendor_Ms_ExcelSheetMacroEnabled12,
  Application_Vendor_Ms_ExcelTemplateMacroEnabled12: () => Application_Vendor_Ms_ExcelTemplateMacroEnabled12,
  Application_Vendor_Ms_Fontobject: () => Application_Vendor_Ms_Fontobject,
  Application_Vendor_Ms_Htmlhelp: () => Application_Vendor_Ms_Htmlhelp,
  Application_Vendor_Ms_Ims: () => Application_Vendor_Ms_Ims,
  Application_Vendor_Ms_Lrm: () => Application_Vendor_Ms_Lrm,
  Application_Vendor_Ms_OfficeActiveXXml: () => Application_Vendor_Ms_OfficeActiveXXml,
  Application_Vendor_Ms_Officetheme: () => Application_Vendor_Ms_Officetheme,
  Application_Vendor_Ms_Opentype: () => Application_Vendor_Ms_Opentype,
  Application_Vendor_Ms_Outlook: () => Application_Vendor_Ms_Outlook,
  Application_Vendor_Ms_PackageObfuscated_Opentype: () => Application_Vendor_Ms_PackageObfuscated_Opentype,
  Application_Vendor_Ms_PkiSeccat: () => Application_Vendor_Ms_PkiSeccat,
  Application_Vendor_Ms_PkiStl: () => Application_Vendor_Ms_PkiStl,
  Application_Vendor_Ms_PlayreadyInitiatorXml: () => Application_Vendor_Ms_PlayreadyInitiatorXml,
  Application_Vendor_Ms_Powerpoint: () => Application_Vendor_Ms_Powerpoint,
  Application_Vendor_Ms_PowerpointAddinMacroEnabled12: () => Application_Vendor_Ms_PowerpointAddinMacroEnabled12,
  Application_Vendor_Ms_PowerpointPresentationMacroEnabled12: () => Application_Vendor_Ms_PowerpointPresentationMacroEnabled12,
  Application_Vendor_Ms_PowerpointSlideMacroEnabled12: () => Application_Vendor_Ms_PowerpointSlideMacroEnabled12,
  Application_Vendor_Ms_PowerpointSlideshowMacroEnabled12: () => Application_Vendor_Ms_PowerpointSlideshowMacroEnabled12,
  Application_Vendor_Ms_PowerpointTemplateMacroEnabled12: () => Application_Vendor_Ms_PowerpointTemplateMacroEnabled12,
  Application_Vendor_Ms_PrintDeviceCapabilitiesXml: () => Application_Vendor_Ms_PrintDeviceCapabilitiesXml,
  Application_Vendor_Ms_PrintSchemaTicketXml: () => Application_Vendor_Ms_PrintSchemaTicketXml,
  Application_Vendor_Ms_PrintingPrintticketXml: () => Application_Vendor_Ms_PrintingPrintticketXml,
  Application_Vendor_Ms_Project: () => Application_Vendor_Ms_Project,
  Application_Vendor_Ms_Tnef: () => Application_Vendor_Ms_Tnef,
  Application_Vendor_Ms_WindowsDevicepairing: () => Application_Vendor_Ms_WindowsDevicepairing,
  Application_Vendor_Ms_WindowsNwprintingOob: () => Application_Vendor_Ms_WindowsNwprintingOob,
  Application_Vendor_Ms_WindowsPrinterpairing: () => Application_Vendor_Ms_WindowsPrinterpairing,
  Application_Vendor_Ms_WindowsWsdOob: () => Application_Vendor_Ms_WindowsWsdOob,
  Application_Vendor_Ms_WmdrmLic_Chlg_Req: () => Application_Vendor_Ms_WmdrmLic_Chlg_Req,
  Application_Vendor_Ms_WmdrmLic_Resp: () => Application_Vendor_Ms_WmdrmLic_Resp,
  Application_Vendor_Ms_WmdrmMeter_Chlg_Req: () => Application_Vendor_Ms_WmdrmMeter_Chlg_Req,
  Application_Vendor_Ms_WmdrmMeter_Resp: () => Application_Vendor_Ms_WmdrmMeter_Resp,
  Application_Vendor_Ms_WordDocumentMacroEnabled12: () => Application_Vendor_Ms_WordDocumentMacroEnabled12,
  Application_Vendor_Ms_WordTemplateMacroEnabled12: () => Application_Vendor_Ms_WordTemplateMacroEnabled12,
  Application_Vendor_Ms_Works: () => Application_Vendor_Ms_Works,
  Application_Vendor_Ms_Wpl: () => Application_Vendor_Ms_Wpl,
  Application_Vendor_Ms_Xpsdocument: () => Application_Vendor_Ms_Xpsdocument,
  Application_Vendor_Msa_Disk_Image: () => Application_Vendor_Msa_Disk_Image,
  Application_Vendor_Mseq: () => Application_Vendor_Mseq,
  Application_Vendor_Msign: () => Application_Vendor_Msign,
  Application_Vendor_MultiadCreator: () => Application_Vendor_MultiadCreator,
  Application_Vendor_MultiadCreatorCif: () => Application_Vendor_MultiadCreatorCif,
  Application_Vendor_Music_Niff: () => Application_Vendor_Music_Niff,
  Application_Vendor_Musician: () => Application_Vendor_Musician,
  Application_Vendor_MuveeStyle: () => Application_Vendor_MuveeStyle,
  Application_Vendor_Mynfc: () => Application_Vendor_Mynfc,
  Application_Vendor_NcdControl: () => Application_Vendor_NcdControl,
  Application_Vendor_NcdReference: () => Application_Vendor_NcdReference,
  Application_Vendor_NearstInvJson: () => Application_Vendor_NearstInvJson,
  Application_Vendor_Nervana: () => Application_Vendor_Nervana,
  Application_Vendor_Netfpx: () => Application_Vendor_Netfpx,
  Application_Vendor_NeurolanguageNlu: () => Application_Vendor_NeurolanguageNlu,
  Application_Vendor_Nimn: () => Application_Vendor_Nimn,
  Application_Vendor_NintendoNitroRom: () => Application_Vendor_NintendoNitroRom,
  Application_Vendor_NintendoSnesRom: () => Application_Vendor_NintendoSnesRom,
  Application_Vendor_Nitf: () => Application_Vendor_Nitf,
  Application_Vendor_Noblenet_Directory: () => Application_Vendor_Noblenet_Directory,
  Application_Vendor_Noblenet_Sealer: () => Application_Vendor_Noblenet_Sealer,
  Application_Vendor_Noblenet_Web: () => Application_Vendor_Noblenet_Web,
  Application_Vendor_NokiaCatalogs: () => Application_Vendor_NokiaCatalogs,
  Application_Vendor_NokiaConmlWbxml: () => Application_Vendor_NokiaConmlWbxml,
  Application_Vendor_NokiaConmlXml: () => Application_Vendor_NokiaConmlXml,
  Application_Vendor_NokiaISDS_Radio_Presets: () => Application_Vendor_NokiaISDS_Radio_Presets,
  Application_Vendor_NokiaIptvConfigXml: () => Application_Vendor_NokiaIptvConfigXml,
  Application_Vendor_NokiaLandmarkWbxml: () => Application_Vendor_NokiaLandmarkWbxml,
  Application_Vendor_NokiaLandmarkXml: () => Application_Vendor_NokiaLandmarkXml,
  Application_Vendor_NokiaLandmarkcollectionXml: () => Application_Vendor_NokiaLandmarkcollectionXml,
  Application_Vendor_NokiaN_GageAcXml: () => Application_Vendor_NokiaN_GageAcXml,
  Application_Vendor_NokiaN_GageData: () => Application_Vendor_NokiaN_GageData,
  Application_Vendor_NokiaN_GageSymbianInstall: () => Application_Vendor_NokiaN_GageSymbianInstall,
  Application_Vendor_NokiaNcd: () => Application_Vendor_NokiaNcd,
  Application_Vendor_NokiaPcdWbxml: () => Application_Vendor_NokiaPcdWbxml,
  Application_Vendor_NokiaPcdXml: () => Application_Vendor_NokiaPcdXml,
  Application_Vendor_NokiaRadio_Preset: () => Application_Vendor_NokiaRadio_Preset,
  Application_Vendor_NokiaRadio_Presets: () => Application_Vendor_NokiaRadio_Presets,
  Application_Vendor_NovadigmEDM: () => Application_Vendor_NovadigmEDM,
  Application_Vendor_NovadigmEDX: () => Application_Vendor_NovadigmEDX,
  Application_Vendor_NovadigmEXT: () => Application_Vendor_NovadigmEXT,
  Application_Vendor_Ntt_LocalContent_Share: () => Application_Vendor_Ntt_LocalContent_Share,
  Application_Vendor_Ntt_LocalFile_Transfer: () => Application_Vendor_Ntt_LocalFile_Transfer,
  Application_Vendor_Ntt_LocalOgw_remote_Access: () => Application_Vendor_Ntt_LocalOgw_remote_Access,
  Application_Vendor_Ntt_LocalSip_Ta_remote: () => Application_Vendor_Ntt_LocalSip_Ta_remote,
  Application_Vendor_Ntt_LocalSip_Ta_tcp_stream: () => Application_Vendor_Ntt_LocalSip_Ta_tcp_stream,
  Application_Vendor_OasisOpendocumentChart: () => Application_Vendor_OasisOpendocumentChart,
  Application_Vendor_OasisOpendocumentChart_Template: () => Application_Vendor_OasisOpendocumentChart_Template,
  Application_Vendor_OasisOpendocumentDatabase: () => Application_Vendor_OasisOpendocumentDatabase,
  Application_Vendor_OasisOpendocumentFormula: () => Application_Vendor_OasisOpendocumentFormula,
  Application_Vendor_OasisOpendocumentFormula_Template: () => Application_Vendor_OasisOpendocumentFormula_Template,
  Application_Vendor_OasisOpendocumentGraphics: () => Application_Vendor_OasisOpendocumentGraphics,
  Application_Vendor_OasisOpendocumentGraphics_Template: () => Application_Vendor_OasisOpendocumentGraphics_Template,
  Application_Vendor_OasisOpendocumentImage: () => Application_Vendor_OasisOpendocumentImage,
  Application_Vendor_OasisOpendocumentImage_Template: () => Application_Vendor_OasisOpendocumentImage_Template,
  Application_Vendor_OasisOpendocumentPresentation: () => Application_Vendor_OasisOpendocumentPresentation,
  Application_Vendor_OasisOpendocumentPresentation_Template: () => Application_Vendor_OasisOpendocumentPresentation_Template,
  Application_Vendor_OasisOpendocumentSpreadsheet: () => Application_Vendor_OasisOpendocumentSpreadsheet,
  Application_Vendor_OasisOpendocumentSpreadsheet_Template: () => Application_Vendor_OasisOpendocumentSpreadsheet_Template,
  Application_Vendor_OasisOpendocumentText: () => Application_Vendor_OasisOpendocumentText,
  Application_Vendor_OasisOpendocumentText_Master: () => Application_Vendor_OasisOpendocumentText_Master,
  Application_Vendor_OasisOpendocumentText_Template: () => Application_Vendor_OasisOpendocumentText_Template,
  Application_Vendor_OasisOpendocumentText_Web: () => Application_Vendor_OasisOpendocumentText_Web,
  Application_Vendor_Obn: () => Application_Vendor_Obn,
  Application_Vendor_OcfCbor: () => Application_Vendor_OcfCbor,
  Application_Vendor_OftnL10nJson: () => Application_Vendor_OftnL10nJson,
  Application_Vendor_OipfContentaccessdownloadXml: () => Application_Vendor_OipfContentaccessdownloadXml,
  Application_Vendor_OipfContentaccessstreamingXml: () => Application_Vendor_OipfContentaccessstreamingXml,
  Application_Vendor_OipfCspg_Hexbinary: () => Application_Vendor_OipfCspg_Hexbinary,
  Application_Vendor_OipfDaeSvgXml: () => Application_Vendor_OipfDaeSvgXml,
  Application_Vendor_OipfDaeXhtmlXml: () => Application_Vendor_OipfDaeXhtmlXml,
  Application_Vendor_OipfMippvcontrolmessageXml: () => Application_Vendor_OipfMippvcontrolmessageXml,
  Application_Vendor_OipfPaeGem: () => Application_Vendor_OipfPaeGem,
  Application_Vendor_OipfSpdiscoveryXml: () => Application_Vendor_OipfSpdiscoveryXml,
  Application_Vendor_OipfSpdlistXml: () => Application_Vendor_OipfSpdlistXml,
  Application_Vendor_OipfUeprofileXml: () => Application_Vendor_OipfUeprofileXml,
  Application_Vendor_OipfUserprofileXml: () => Application_Vendor_OipfUserprofileXml,
  Application_Vendor_Olpc_Sugar: () => Application_Vendor_Olpc_Sugar,
  Application_Vendor_OmaBcastAssociated_Procedure_ParameterXml: () => Application_Vendor_OmaBcastAssociated_Procedure_ParameterXml,
  Application_Vendor_OmaBcastDrm_TriggerXml: () => Application_Vendor_OmaBcastDrm_TriggerXml,
  Application_Vendor_OmaBcastImdXml: () => Application_Vendor_OmaBcastImdXml,
  Application_Vendor_OmaBcastLtkm: () => Application_Vendor_OmaBcastLtkm,
  Application_Vendor_OmaBcastNotificationXml: () => Application_Vendor_OmaBcastNotificationXml,
  Application_Vendor_OmaBcastProvisioningtrigger: () => Application_Vendor_OmaBcastProvisioningtrigger,
  Application_Vendor_OmaBcastSgboot: () => Application_Vendor_OmaBcastSgboot,
  Application_Vendor_OmaBcastSgddXml: () => Application_Vendor_OmaBcastSgddXml,
  Application_Vendor_OmaBcastSgdu: () => Application_Vendor_OmaBcastSgdu,
  Application_Vendor_OmaBcastSimple_Symbol_Container: () => Application_Vendor_OmaBcastSimple_Symbol_Container,
  Application_Vendor_OmaBcastSmartcard_TriggerXml: () => Application_Vendor_OmaBcastSmartcard_TriggerXml,
  Application_Vendor_OmaBcastSprovXml: () => Application_Vendor_OmaBcastSprovXml,
  Application_Vendor_OmaBcastStkm: () => Application_Vendor_OmaBcastStkm,
  Application_Vendor_OmaCab_Address_BookXml: () => Application_Vendor_OmaCab_Address_BookXml,
  Application_Vendor_OmaCab_Feature_HandlerXml: () => Application_Vendor_OmaCab_Feature_HandlerXml,
  Application_Vendor_OmaCab_PccXml: () => Application_Vendor_OmaCab_PccXml,
  Application_Vendor_OmaCab_Subs_InviteXml: () => Application_Vendor_OmaCab_Subs_InviteXml,
  Application_Vendor_OmaCab_User_PrefsXml: () => Application_Vendor_OmaCab_User_PrefsXml,
  Application_Vendor_OmaDcd: () => Application_Vendor_OmaDcd,
  Application_Vendor_OmaDcdc: () => Application_Vendor_OmaDcdc,
  Application_Vendor_OmaDd2Xml: () => Application_Vendor_OmaDd2Xml,
  Application_Vendor_OmaDrmRisdXml: () => Application_Vendor_OmaDrmRisdXml,
  Application_Vendor_OmaGroup_Usage_ListXml: () => Application_Vendor_OmaGroup_Usage_ListXml,
  Application_Vendor_OmaLwm2mJson: () => Application_Vendor_OmaLwm2mJson,
  Application_Vendor_OmaLwm2mTlv: () => Application_Vendor_OmaLwm2mTlv,
  Application_Vendor_OmaPalXml: () => Application_Vendor_OmaPalXml,
  Application_Vendor_OmaPocDetailed_Progress_ReportXml: () => Application_Vendor_OmaPocDetailed_Progress_ReportXml,
  Application_Vendor_OmaPocFinal_ReportXml: () => Application_Vendor_OmaPocFinal_ReportXml,
  Application_Vendor_OmaPocGroupsXml: () => Application_Vendor_OmaPocGroupsXml,
  Application_Vendor_OmaPocInvocation_DescriptorXml: () => Application_Vendor_OmaPocInvocation_DescriptorXml,
  Application_Vendor_OmaPocOptimized_Progress_ReportXml: () => Application_Vendor_OmaPocOptimized_Progress_ReportXml,
  Application_Vendor_OmaPush: () => Application_Vendor_OmaPush,
  Application_Vendor_OmaScidmMessagesXml: () => Application_Vendor_OmaScidmMessagesXml,
  Application_Vendor_OmaXcap_DirectoryXml: () => Application_Vendor_OmaXcap_DirectoryXml,
  Application_Vendor_Oma_Scws_Config: () => Application_Vendor_Oma_Scws_Config,
  Application_Vendor_Oma_Scws_Http_Request: () => Application_Vendor_Oma_Scws_Http_Request,
  Application_Vendor_Oma_Scws_Http_Response: () => Application_Vendor_Oma_Scws_Http_Response,
  Application_Vendor_Omads_EmailXml: () => Application_Vendor_Omads_EmailXml,
  Application_Vendor_Omads_FileXml: () => Application_Vendor_Omads_FileXml,
  Application_Vendor_Omads_FolderXml: () => Application_Vendor_Omads_FolderXml,
  Application_Vendor_Omaloc_Supl_Init: () => Application_Vendor_Omaloc_Supl_Init,
  Application_Vendor_Onepager: () => Application_Vendor_Onepager,
  Application_Vendor_Onepagertamp: () => Application_Vendor_Onepagertamp,
  Application_Vendor_Onepagertamx: () => Application_Vendor_Onepagertamx,
  Application_Vendor_Onepagertat: () => Application_Vendor_Onepagertat,
  Application_Vendor_Onepagertatp: () => Application_Vendor_Onepagertatp,
  Application_Vendor_Onepagertatx: () => Application_Vendor_Onepagertatx,
  Application_Vendor_OpenbloxGameXml: () => Application_Vendor_OpenbloxGameXml,
  Application_Vendor_OpenbloxGame_Binary: () => Application_Vendor_OpenbloxGame_Binary,
  Application_Vendor_OpeneyeOeb: () => Application_Vendor_OpeneyeOeb,
  Application_Vendor_OpenofficeorgExtension: () => Application_Vendor_OpenofficeorgExtension,
  Application_Vendor_OpenstreetmapDataXml: () => Application_Vendor_OpenstreetmapDataXml,
  Application_Vendor_Openxmlformats_OfficedocumentCustomXmlPropertiesXml: () => Application_Vendor_Openxmlformats_OfficedocumentCustomXmlPropertiesXml,
  Application_Vendor_Openxmlformats_OfficedocumentCustom_PropertiesXml: () => Application_Vendor_Openxmlformats_OfficedocumentCustom_PropertiesXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartshapesXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartshapesXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramColorsXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramColorsXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramDataXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramDataXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramLayoutXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramLayoutXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramStyleXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramStyleXml,
  Application_Vendor_Openxmlformats_OfficedocumentExtended_PropertiesXml: () => Application_Vendor_Openxmlformats_OfficedocumentExtended_PropertiesXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentAuthorsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentAuthorsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlHandoutMasterXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlHandoutMasterXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesMasterXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesMasterXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesSlideXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesSlideXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresPropsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresPropsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentation: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentation,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentationMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentationMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlide: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlide,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideLayoutXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideLayoutXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideMasterXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideMasterXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideUpdateInfoXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideUpdateInfoXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshow: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshow,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshowMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshowMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTableStylesXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTableStylesXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTagsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTagsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplate: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplate,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplateMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplateMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlViewPropsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlViewPropsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCalcChainXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCalcChainXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlChartsheetXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlChartsheetXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCommentsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCommentsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlConnectionsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlConnectionsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlDialogsheetXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlDialogsheetXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlExternalLinkXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlExternalLinkXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheDefinitionXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheDefinitionXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheRecordsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheRecordsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlQueryTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlQueryTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionHeadersXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionHeadersXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionLogXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionLogXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSharedStringsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSharedStringsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheet: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheet,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMetadataXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMetadataXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlStylesXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlStylesXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableSingleCellsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableSingleCellsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplate: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplate,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplateMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplateMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlUserNamesXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlUserNamesXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlVolatileDependenciesXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlVolatileDependenciesXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlWorksheetXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlWorksheetXml,
  Application_Vendor_Openxmlformats_OfficedocumentThemeOverrideXml: () => Application_Vendor_Openxmlformats_OfficedocumentThemeOverrideXml,
  Application_Vendor_Openxmlformats_OfficedocumentThemeXml: () => Application_Vendor_Openxmlformats_OfficedocumentThemeXml,
  Application_Vendor_Openxmlformats_OfficedocumentVmlDrawing: () => Application_Vendor_Openxmlformats_OfficedocumentVmlDrawing,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlCommentsXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlCommentsXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocument: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocument,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentGlossaryXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentGlossaryXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlEndnotesXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlEndnotesXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFontTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFontTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFooterXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFooterXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFootnotesXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFootnotesXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlNumberingXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlNumberingXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlSettingsXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlSettingsXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlStylesXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlStylesXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplate: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplate,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplateMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplateMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlWebSettingsXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlWebSettingsXml,
  Application_Vendor_Openxmlformats_PackageCore_PropertiesXml: () => Application_Vendor_Openxmlformats_PackageCore_PropertiesXml,
  Application_Vendor_Openxmlformats_PackageDigital_Signature_XmlsignatureXml: () => Application_Vendor_Openxmlformats_PackageDigital_Signature_XmlsignatureXml,
  Application_Vendor_Openxmlformats_PackageRelationshipsXml: () => Application_Vendor_Openxmlformats_PackageRelationshipsXml,
  Application_Vendor_OracleResourceJson: () => Application_Vendor_OracleResourceJson,
  Application_Vendor_OrangeIndata: () => Application_Vendor_OrangeIndata,
  Application_Vendor_OsaNetdeploy: () => Application_Vendor_OsaNetdeploy,
  Application_Vendor_OsgeoMapguidePackage: () => Application_Vendor_OsgeoMapguidePackage,
  Application_Vendor_OsgiBundle: () => Application_Vendor_OsgiBundle,
  Application_Vendor_OsgiDp: () => Application_Vendor_OsgiDp,
  Application_Vendor_OsgiSubsystem: () => Application_Vendor_OsgiSubsystem,
  Application_Vendor_OtpsCt_KipXml: () => Application_Vendor_OtpsCt_KipXml,
  Application_Vendor_OxliCountgraph: () => Application_Vendor_OxliCountgraph,
  Application_Vendor_PagerdutyJson: () => Application_Vendor_PagerdutyJson,
  Application_Vendor_Palm: () => Application_Vendor_Palm,
  Application_Vendor_Panoply: () => Application_Vendor_Panoply,
  Application_Vendor_PaosXml: () => Application_Vendor_PaosXml,
  Application_Vendor_Patentdive: () => Application_Vendor_Patentdive,
  Application_Vendor_Patientecommsdoc: () => Application_Vendor_Patientecommsdoc,
  Application_Vendor_Pawaafile: () => Application_Vendor_Pawaafile,
  Application_Vendor_Pcos: () => Application_Vendor_Pcos,
  Application_Vendor_PgFormat: () => Application_Vendor_PgFormat,
  Application_Vendor_PgOsasli: () => Application_Vendor_PgOsasli,
  Application_Vendor_PiaccessApplication_Licence: () => Application_Vendor_PiaccessApplication_Licence,
  Application_Vendor_Picsel: () => Application_Vendor_Picsel,
  Application_Vendor_PmiWidget: () => Application_Vendor_PmiWidget,
  Application_Vendor_PocGroup_AdvertisementXml: () => Application_Vendor_PocGroup_AdvertisementXml,
  Application_Vendor_Pocketlearn: () => Application_Vendor_Pocketlearn,
  Application_Vendor_Powerbuilder6: () => Application_Vendor_Powerbuilder6,
  Application_Vendor_Powerbuilder6_S: () => Application_Vendor_Powerbuilder6_S,
  Application_Vendor_Powerbuilder7: () => Application_Vendor_Powerbuilder7,
  Application_Vendor_Powerbuilder75: () => Application_Vendor_Powerbuilder75,
  Application_Vendor_Powerbuilder75_S: () => Application_Vendor_Powerbuilder75_S,
  Application_Vendor_Powerbuilder7_S: () => Application_Vendor_Powerbuilder7_S,
  Application_Vendor_Preminet: () => Application_Vendor_Preminet,
  Application_Vendor_PreviewsystemsBox: () => Application_Vendor_PreviewsystemsBox,
  Application_Vendor_ProteusMagazine: () => Application_Vendor_ProteusMagazine,
  Application_Vendor_Psfs: () => Application_Vendor_Psfs,
  Application_Vendor_Publishare_Delta_Tree: () => Application_Vendor_Publishare_Delta_Tree,
  Application_Vendor_PviPtid1: () => Application_Vendor_PviPtid1,
  Application_Vendor_Pwg_Multiplexed: () => Application_Vendor_Pwg_Multiplexed,
  Application_Vendor_Pwg_Xhtml_PrintXml: () => Application_Vendor_Pwg_Xhtml_PrintXml,
  Application_Vendor_QualcommBrew_App_Res: () => Application_Vendor_QualcommBrew_App_Res,
  Application_Vendor_Quarantainenet: () => Application_Vendor_Quarantainenet,
  Application_Vendor_QuarkQuarkXPress: () => Application_Vendor_QuarkQuarkXPress,
  Application_Vendor_Quobject_Quoxdocument: () => Application_Vendor_Quobject_Quoxdocument,
  Application_Vendor_RadisysMomlXml: () => Application_Vendor_RadisysMomlXml,
  Application_Vendor_RadisysMsmlXml: () => Application_Vendor_RadisysMsmlXml,
  Application_Vendor_RadisysMsml_AuditXml: () => Application_Vendor_RadisysMsml_AuditXml,
  Application_Vendor_RadisysMsml_Audit_ConfXml: () => Application_Vendor_RadisysMsml_Audit_ConfXml,
  Application_Vendor_RadisysMsml_Audit_ConnXml: () => Application_Vendor_RadisysMsml_Audit_ConnXml,
  Application_Vendor_RadisysMsml_Audit_DialogXml: () => Application_Vendor_RadisysMsml_Audit_DialogXml,
  Application_Vendor_RadisysMsml_Audit_StreamXml: () => Application_Vendor_RadisysMsml_Audit_StreamXml,
  Application_Vendor_RadisysMsml_ConfXml: () => Application_Vendor_RadisysMsml_ConfXml,
  Application_Vendor_RadisysMsml_DialogXml: () => Application_Vendor_RadisysMsml_DialogXml,
  Application_Vendor_RadisysMsml_Dialog_BaseXml: () => Application_Vendor_RadisysMsml_Dialog_BaseXml,
  Application_Vendor_RadisysMsml_Dialog_Fax_DetectXml: () => Application_Vendor_RadisysMsml_Dialog_Fax_DetectXml,
  Application_Vendor_RadisysMsml_Dialog_Fax_SendrecvXml: () => Application_Vendor_RadisysMsml_Dialog_Fax_SendrecvXml,
  Application_Vendor_RadisysMsml_Dialog_GroupXml: () => Application_Vendor_RadisysMsml_Dialog_GroupXml,
  Application_Vendor_RadisysMsml_Dialog_SpeechXml: () => Application_Vendor_RadisysMsml_Dialog_SpeechXml,
  Application_Vendor_RadisysMsml_Dialog_TransformXml: () => Application_Vendor_RadisysMsml_Dialog_TransformXml,
  Application_Vendor_RainstorData: () => Application_Vendor_RainstorData,
  Application_Vendor_Rapid: () => Application_Vendor_Rapid,
  Application_Vendor_Rar: () => Application_Vendor_Rar,
  Application_Vendor_RealvncBed: () => Application_Vendor_RealvncBed,
  Application_Vendor_RecordareMusicxml: () => Application_Vendor_RecordareMusicxml,
  Application_Vendor_RecordareMusicxmlXml: () => Application_Vendor_RecordareMusicxmlXml,
  Application_Vendor_RenLearnRlprint: () => Application_Vendor_RenLearnRlprint,
  Application_Vendor_RestfulJson: () => Application_Vendor_RestfulJson,
  Application_Vendor_RigCryptonote: () => Application_Vendor_RigCryptonote,
  Application_Vendor_RimCod: () => Application_Vendor_RimCod,
  Application_Vendor_Rn_Realmedia: () => Application_Vendor_Rn_Realmedia,
  Application_Vendor_Rn_Realmedia_Vbr: () => Application_Vendor_Rn_Realmedia_Vbr,
  Application_Vendor_Route66Link66Xml: () => Application_Vendor_Route66Link66Xml,
  Application_Vendor_Rs_274x: () => Application_Vendor_Rs_274x,
  Application_Vendor_RuckusDownload: () => Application_Vendor_RuckusDownload,
  Application_Vendor_S3sms: () => Application_Vendor_S3sms,
  Application_Vendor_SailingtrackerTrack: () => Application_Vendor_SailingtrackerTrack,
  Application_Vendor_Sar: () => Application_Vendor_Sar,
  Application_Vendor_SbmCid: () => Application_Vendor_SbmCid,
  Application_Vendor_SbmMid2: () => Application_Vendor_SbmMid2,
  Application_Vendor_Scribus: () => Application_Vendor_Scribus,
  Application_Vendor_Sealed3df: () => Application_Vendor_Sealed3df,
  Application_Vendor_SealedCsf: () => Application_Vendor_SealedCsf,
  Application_Vendor_SealedDoc: () => Application_Vendor_SealedDoc,
  Application_Vendor_SealedEml: () => Application_Vendor_SealedEml,
  Application_Vendor_SealedMht: () => Application_Vendor_SealedMht,
  Application_Vendor_SealedNet: () => Application_Vendor_SealedNet,
  Application_Vendor_SealedPpt: () => Application_Vendor_SealedPpt,
  Application_Vendor_SealedTiff: () => Application_Vendor_SealedTiff,
  Application_Vendor_SealedXls: () => Application_Vendor_SealedXls,
  Application_Vendor_SealedmediaSoftsealHtml: () => Application_Vendor_SealedmediaSoftsealHtml,
  Application_Vendor_SealedmediaSoftsealPdf: () => Application_Vendor_SealedmediaSoftsealPdf,
  Application_Vendor_Seemail: () => Application_Vendor_Seemail,
  Application_Vendor_Sema: () => Application_Vendor_Sema,
  Application_Vendor_Semd: () => Application_Vendor_Semd,
  Application_Vendor_Semf: () => Application_Vendor_Semf,
  Application_Vendor_Shade_Save_File: () => Application_Vendor_Shade_Save_File,
  Application_Vendor_ShanaInformedFormdata: () => Application_Vendor_ShanaInformedFormdata,
  Application_Vendor_ShanaInformedFormtemplate: () => Application_Vendor_ShanaInformedFormtemplate,
  Application_Vendor_ShanaInformedInterchange: () => Application_Vendor_ShanaInformedInterchange,
  Application_Vendor_ShanaInformedPackage: () => Application_Vendor_ShanaInformedPackage,
  Application_Vendor_ShootproofJson: () => Application_Vendor_ShootproofJson,
  Application_Vendor_ShopkickJson: () => Application_Vendor_ShopkickJson,
  Application_Vendor_SigrokSession: () => Application_Vendor_SigrokSession,
  Application_Vendor_SimTech_MindMapper: () => Application_Vendor_SimTech_MindMapper,
  Application_Vendor_SirenJson: () => Application_Vendor_SirenJson,
  Application_Vendor_Smaf: () => Application_Vendor_Smaf,
  Application_Vendor_SmartNotebook: () => Application_Vendor_SmartNotebook,
  Application_Vendor_SmartTeacher: () => Application_Vendor_SmartTeacher,
  Application_Vendor_Software602FillerFormXml: () => Application_Vendor_Software602FillerFormXml,
  Application_Vendor_Software602FillerForm_Xml_Zip: () => Application_Vendor_Software602FillerForm_Xml_Zip,
  Application_Vendor_SolentSdkmXml: () => Application_Vendor_SolentSdkmXml,
  Application_Vendor_SpotfireDxp: () => Application_Vendor_SpotfireDxp,
  Application_Vendor_SpotfireSfs: () => Application_Vendor_SpotfireSfs,
  Application_Vendor_Sqlite3: () => Application_Vendor_Sqlite3,
  Application_Vendor_Sss_Cod: () => Application_Vendor_Sss_Cod,
  Application_Vendor_Sss_Dtf: () => Application_Vendor_Sss_Dtf,
  Application_Vendor_Sss_Ntf: () => Application_Vendor_Sss_Ntf,
  Application_Vendor_StardivisionCalc: () => Application_Vendor_StardivisionCalc,
  Application_Vendor_StardivisionDraw: () => Application_Vendor_StardivisionDraw,
  Application_Vendor_StardivisionImpress: () => Application_Vendor_StardivisionImpress,
  Application_Vendor_StardivisionMath: () => Application_Vendor_StardivisionMath,
  Application_Vendor_StardivisionWriter: () => Application_Vendor_StardivisionWriter,
  Application_Vendor_StardivisionWriter_Global: () => Application_Vendor_StardivisionWriter_Global,
  Application_Vendor_StepmaniaPackage: () => Application_Vendor_StepmaniaPackage,
  Application_Vendor_StepmaniaStepchart: () => Application_Vendor_StepmaniaStepchart,
  Application_Vendor_Street_Stream: () => Application_Vendor_Street_Stream,
  Application_Vendor_SunWadlXml: () => Application_Vendor_SunWadlXml,
  Application_Vendor_SunXmlCalc: () => Application_Vendor_SunXmlCalc,
  Application_Vendor_SunXmlCalcTemplate: () => Application_Vendor_SunXmlCalcTemplate,
  Application_Vendor_SunXmlDraw: () => Application_Vendor_SunXmlDraw,
  Application_Vendor_SunXmlDrawTemplate: () => Application_Vendor_SunXmlDrawTemplate,
  Application_Vendor_SunXmlImpress: () => Application_Vendor_SunXmlImpress,
  Application_Vendor_SunXmlImpressTemplate: () => Application_Vendor_SunXmlImpressTemplate,
  Application_Vendor_SunXmlMath: () => Application_Vendor_SunXmlMath,
  Application_Vendor_SunXmlWriter: () => Application_Vendor_SunXmlWriter,
  Application_Vendor_SunXmlWriterGlobal: () => Application_Vendor_SunXmlWriterGlobal,
  Application_Vendor_SunXmlWriterTemplate: () => Application_Vendor_SunXmlWriterTemplate,
  Application_Vendor_Sus_Calendar: () => Application_Vendor_Sus_Calendar,
  Application_Vendor_Svd: () => Application_Vendor_Svd,
  Application_Vendor_Swiftview_Ics: () => Application_Vendor_Swiftview_Ics,
  Application_Vendor_SymbianInstall: () => Application_Vendor_SymbianInstall,
  Application_Vendor_SyncmlDmNotification: () => Application_Vendor_SyncmlDmNotification,
  Application_Vendor_SyncmlDmWbxml: () => Application_Vendor_SyncmlDmWbxml,
  Application_Vendor_SyncmlDmXml: () => Application_Vendor_SyncmlDmXml,
  Application_Vendor_SyncmlDmddfWbxml: () => Application_Vendor_SyncmlDmddfWbxml,
  Application_Vendor_SyncmlDmddfXml: () => Application_Vendor_SyncmlDmddfXml,
  Application_Vendor_SyncmlDmtndsWbxml: () => Application_Vendor_SyncmlDmtndsWbxml,
  Application_Vendor_SyncmlDmtndsXml: () => Application_Vendor_SyncmlDmtndsXml,
  Application_Vendor_SyncmlDsNotification: () => Application_Vendor_SyncmlDsNotification,
  Application_Vendor_SyncmlXml: () => Application_Vendor_SyncmlXml,
  Application_Vendor_TableschemaJson: () => Application_Vendor_TableschemaJson,
  Application_Vendor_TaoIntent_Module_Archive: () => Application_Vendor_TaoIntent_Module_Archive,
  Application_Vendor_TcpdumpPcap: () => Application_Vendor_TcpdumpPcap,
  Application_Vendor_Think_CellPpttcJson: () => Application_Vendor_Think_CellPpttcJson,
  Application_Vendor_TmdMediaflexApiXml: () => Application_Vendor_TmdMediaflexApiXml,
  Application_Vendor_Tml: () => Application_Vendor_Tml,
  Application_Vendor_Tmobile_Livetv: () => Application_Vendor_Tmobile_Livetv,
  Application_Vendor_TriOnesource: () => Application_Vendor_TriOnesource,
  Application_Vendor_TridTpt: () => Application_Vendor_TridTpt,
  Application_Vendor_TriscapeMxs: () => Application_Vendor_TriscapeMxs,
  Application_Vendor_Trueapp: () => Application_Vendor_Trueapp,
  Application_Vendor_Truedoc: () => Application_Vendor_Truedoc,
  Application_Vendor_UbisoftWebplayer: () => Application_Vendor_UbisoftWebplayer,
  Application_Vendor_Ufdl: () => Application_Vendor_Ufdl,
  Application_Vendor_UiqTheme: () => Application_Vendor_UiqTheme,
  Application_Vendor_Umajin: () => Application_Vendor_Umajin,
  Application_Vendor_Unity: () => Application_Vendor_Unity,
  Application_Vendor_UomlXml: () => Application_Vendor_UomlXml,
  Application_Vendor_UplanetAlert: () => Application_Vendor_UplanetAlert,
  Application_Vendor_UplanetAlert_Wbxml: () => Application_Vendor_UplanetAlert_Wbxml,
  Application_Vendor_UplanetBearer_Choice: () => Application_Vendor_UplanetBearer_Choice,
  Application_Vendor_UplanetBearer_Choice_Wbxml: () => Application_Vendor_UplanetBearer_Choice_Wbxml,
  Application_Vendor_UplanetCacheop: () => Application_Vendor_UplanetCacheop,
  Application_Vendor_UplanetCacheop_Wbxml: () => Application_Vendor_UplanetCacheop_Wbxml,
  Application_Vendor_UplanetChannel: () => Application_Vendor_UplanetChannel,
  Application_Vendor_UplanetChannel_Wbxml: () => Application_Vendor_UplanetChannel_Wbxml,
  Application_Vendor_UplanetList: () => Application_Vendor_UplanetList,
  Application_Vendor_UplanetList_Wbxml: () => Application_Vendor_UplanetList_Wbxml,
  Application_Vendor_UplanetListcmd: () => Application_Vendor_UplanetListcmd,
  Application_Vendor_UplanetListcmd_Wbxml: () => Application_Vendor_UplanetListcmd_Wbxml,
  Application_Vendor_UplanetSignal: () => Application_Vendor_UplanetSignal,
  Application_Vendor_Uri_Map: () => Application_Vendor_Uri_Map,
  Application_Vendor_ValveSourceMaterial: () => Application_Vendor_ValveSourceMaterial,
  Application_Vendor_Vcx: () => Application_Vendor_Vcx,
  Application_Vendor_Vd_Study: () => Application_Vendor_Vd_Study,
  Application_Vendor_Vectorworks: () => Application_Vendor_Vectorworks,
  Application_Vendor_VelJson: () => Application_Vendor_VelJson,
  Application_Vendor_VerimatrixVcas: () => Application_Vendor_VerimatrixVcas,
  Application_Vendor_VeryantThin: () => Application_Vendor_VeryantThin,
  Application_Vendor_VesEncrypted: () => Application_Vendor_VesEncrypted,
  Application_Vendor_VidsoftVidconference: () => Application_Vendor_VidsoftVidconference,
  Application_Vendor_Visio: () => Application_Vendor_Visio,
  Application_Vendor_Visionary: () => Application_Vendor_Visionary,
  Application_Vendor_VividenceScriptfile: () => Application_Vendor_VividenceScriptfile,
  Application_Vendor_Vsf: () => Application_Vendor_Vsf,
  Application_Vendor_WapSic: () => Application_Vendor_WapSic,
  Application_Vendor_WapSlc: () => Application_Vendor_WapSlc,
  Application_Vendor_WapWbxml: () => Application_Vendor_WapWbxml,
  Application_Vendor_WapWmlc: () => Application_Vendor_WapWmlc,
  Application_Vendor_WapWmlscriptc: () => Application_Vendor_WapWmlscriptc,
  Application_Vendor_Webturbo: () => Application_Vendor_Webturbo,
  Application_Vendor_WfaP2p: () => Application_Vendor_WfaP2p,
  Application_Vendor_WfaWsc: () => Application_Vendor_WfaWsc,
  Application_Vendor_WindowsDevicepairing: () => Application_Vendor_WindowsDevicepairing,
  Application_Vendor_Wmc: () => Application_Vendor_Wmc,
  Application_Vendor_WmfBootstrap: () => Application_Vendor_WmfBootstrap,
  Application_Vendor_WolframMathematica: () => Application_Vendor_WolframMathematica,
  Application_Vendor_WolframMathematicaPackage: () => Application_Vendor_WolframMathematicaPackage,
  Application_Vendor_WolframPlayer: () => Application_Vendor_WolframPlayer,
  Application_Vendor_Wordperfect: () => Application_Vendor_Wordperfect,
  Application_Vendor_Wqd: () => Application_Vendor_Wqd,
  Application_Vendor_Wrq_Hp3000_Labelled: () => Application_Vendor_Wrq_Hp3000_Labelled,
  Application_Vendor_WtStf: () => Application_Vendor_WtStf,
  Application_Vendor_WvCspWbxml: () => Application_Vendor_WvCspWbxml,
  Application_Vendor_WvCspXml: () => Application_Vendor_WvCspXml,
  Application_Vendor_WvSspXml: () => Application_Vendor_WvSspXml,
  Application_Vendor_XacmlJson: () => Application_Vendor_XacmlJson,
  Application_Vendor_Xara: () => Application_Vendor_Xara,
  Application_Vendor_Xfdl: () => Application_Vendor_Xfdl,
  Application_Vendor_XfdlWebform: () => Application_Vendor_XfdlWebform,
  Application_Vendor_XmiXml: () => Application_Vendor_XmiXml,
  Application_Vendor_XmpieCpkg: () => Application_Vendor_XmpieCpkg,
  Application_Vendor_XmpieDpkg: () => Application_Vendor_XmpieDpkg,
  Application_Vendor_XmpiePlan: () => Application_Vendor_XmpiePlan,
  Application_Vendor_XmpiePpkg: () => Application_Vendor_XmpiePpkg,
  Application_Vendor_XmpieXlim: () => Application_Vendor_XmpieXlim,
  Application_Vendor_YamahaHv_Dic: () => Application_Vendor_YamahaHv_Dic,
  Application_Vendor_YamahaHv_Script: () => Application_Vendor_YamahaHv_Script,
  Application_Vendor_YamahaHv_Voice: () => Application_Vendor_YamahaHv_Voice,
  Application_Vendor_YamahaOpenscoreformat: () => Application_Vendor_YamahaOpenscoreformat,
  Application_Vendor_YamahaOpenscoreformatOsfpvgXml: () => Application_Vendor_YamahaOpenscoreformatOsfpvgXml,
  Application_Vendor_YamahaRemote_Setup: () => Application_Vendor_YamahaRemote_Setup,
  Application_Vendor_YamahaSmaf_Audio: () => Application_Vendor_YamahaSmaf_Audio,
  Application_Vendor_YamahaSmaf_Phrase: () => Application_Vendor_YamahaSmaf_Phrase,
  Application_Vendor_YamahaThrough_Ngn: () => Application_Vendor_YamahaThrough_Ngn,
  Application_Vendor_YamahaTunnel_Udpencap: () => Application_Vendor_YamahaTunnel_Udpencap,
  Application_Vendor_Yaoweme: () => Application_Vendor_Yaoweme,
  Application_Vendor_Yellowriver_Custom_Menu: () => Application_Vendor_Yellowriver_Custom_Menu,
  Application_Vendor_YoutubeYt: () => Application_Vendor_YoutubeYt,
  Application_Vendor_Zul: () => Application_Vendor_Zul,
  Application_Vendor_ZzazzDeckXml: () => Application_Vendor_ZzazzDeckXml,
  Application_VividenceScriptfile: () => Application_VividenceScriptfile,
  Application_VoicexmlXml: () => Application_VoicexmlXml,
  Application_Voucher_CmsJson: () => Application_Voucher_CmsJson,
  Application_Vq_Rtcpxr: () => Application_Vq_Rtcpxr,
  Application_Wasm: () => Application_Wasm,
  Application_WatcherinfoXml: () => Application_WatcherinfoXml,
  Application_Webpush_OptionsJson: () => Application_Webpush_OptionsJson,
  Application_Whoispp_Query: () => Application_Whoispp_Query,
  Application_Whoispp_Response: () => Application_Whoispp_Response,
  Application_Widget: () => Application_Widget,
  Application_Winhlp: () => Application_Winhlp,
  Application_Wita: () => Application_Wita,
  Application_Wordperfect51: () => Application_Wordperfect51,
  Application_WsdlXml: () => Application_WsdlXml,
  Application_WspolicyXml: () => Application_WspolicyXml,
  Application_X400_Bp: () => Application_X400_Bp,
  Application_X_7z_Compressed: () => Application_X_7z_Compressed,
  Application_X_Abiword: () => Application_X_Abiword,
  Application_X_Ace_Compressed: () => Application_X_Ace_Compressed,
  Application_X_Amf: () => Application_X_Amf,
  Application_X_Apple_Diskimage: () => Application_X_Apple_Diskimage,
  Application_X_Arj: () => Application_X_Arj,
  Application_X_Authorware_Bin: () => Application_X_Authorware_Bin,
  Application_X_Authorware_Map: () => Application_X_Authorware_Map,
  Application_X_Authorware_Seg: () => Application_X_Authorware_Seg,
  Application_X_Bcpio: () => Application_X_Bcpio,
  Application_X_Bdoc: () => Application_X_Bdoc,
  Application_X_Bittorrent: () => Application_X_Bittorrent,
  Application_X_Blorb: () => Application_X_Blorb,
  Application_X_Bzip: () => Application_X_Bzip,
  Application_X_Bzip2: () => Application_X_Bzip2,
  Application_X_Cbr: () => Application_X_Cbr,
  Application_X_Cdlink: () => Application_X_Cdlink,
  Application_X_Cfs_Compressed: () => Application_X_Cfs_Compressed,
  Application_X_Chat: () => Application_X_Chat,
  Application_X_Chess_Pgn: () => Application_X_Chess_Pgn,
  Application_X_Chrome_Extension: () => Application_X_Chrome_Extension,
  Application_X_Compress: () => Application_X_Compress,
  Application_X_Conference: () => Application_X_Conference,
  Application_X_Cpio: () => Application_X_Cpio,
  Application_X_Csh: () => Application_X_Csh,
  Application_X_Deb: () => Application_X_Deb,
  Application_X_Debian_Package: () => Application_X_Debian_Package,
  Application_X_Dgc_Compressed: () => Application_X_Dgc_Compressed,
  Application_X_Director: () => Application_X_Director,
  Application_X_Doom: () => Application_X_Doom,
  Application_X_DtbncxXml: () => Application_X_DtbncxXml,
  Application_X_DtbookXml: () => Application_X_DtbookXml,
  Application_X_DtbresourceXml: () => Application_X_DtbresourceXml,
  Application_X_Dvi: () => Application_X_Dvi,
  Application_X_Envoy: () => Application_X_Envoy,
  Application_X_Eva: () => Application_X_Eva,
  Application_X_Font_Bdf: () => Application_X_Font_Bdf,
  Application_X_Font_Dos: () => Application_X_Font_Dos,
  Application_X_Font_Framemaker: () => Application_X_Font_Framemaker,
  Application_X_Font_Ghostscript: () => Application_X_Font_Ghostscript,
  Application_X_Font_Libgrx: () => Application_X_Font_Libgrx,
  Application_X_Font_Linux_Psf: () => Application_X_Font_Linux_Psf,
  Application_X_Font_Pcf: () => Application_X_Font_Pcf,
  Application_X_Font_Snf: () => Application_X_Font_Snf,
  Application_X_Font_Speedo: () => Application_X_Font_Speedo,
  Application_X_Font_Sunos_News: () => Application_X_Font_Sunos_News,
  Application_X_Font_Type1: () => Application_X_Font_Type1,
  Application_X_Font_Vfont: () => Application_X_Font_Vfont,
  Application_X_Freearc: () => Application_X_Freearc,
  Application_X_Futuresplash: () => Application_X_Futuresplash,
  Application_X_Gca_Compressed: () => Application_X_Gca_Compressed,
  Application_X_Glulx: () => Application_X_Glulx,
  Application_X_Gnumeric: () => Application_X_Gnumeric,
  Application_X_Gramps_Xml: () => Application_X_Gramps_Xml,
  Application_X_Gtar: () => Application_X_Gtar,
  Application_X_Gzip: () => Application_X_Gzip,
  Application_X_Hdf: () => Application_X_Hdf,
  Application_X_Httpd_Php: () => Application_X_Httpd_Php,
  Application_X_Install_Instructions: () => Application_X_Install_Instructions,
  Application_X_Iso9660_Image: () => Application_X_Iso9660_Image,
  Application_X_Iwork_Keynote_Sffkey: () => Application_X_Iwork_Keynote_Sffkey,
  Application_X_Iwork_Numbers_Sffnumbers: () => Application_X_Iwork_Numbers_Sffnumbers,
  Application_X_Iwork_Pages_Sffpages: () => Application_X_Iwork_Pages_Sffpages,
  Application_X_Java_Jnlp_File: () => Application_X_Java_Jnlp_File,
  Application_X_Javascript: () => Application_X_Javascript,
  Application_X_Keepass2: () => Application_X_Keepass2,
  Application_X_Latex: () => Application_X_Latex,
  Application_X_Lua_Bytecode: () => Application_X_Lua_Bytecode,
  Application_X_Lzh_Compressed: () => Application_X_Lzh_Compressed,
  Application_X_Mie: () => Application_X_Mie,
  Application_X_Mobipocket_Ebook: () => Application_X_Mobipocket_Ebook,
  Application_X_Mpegurl: () => Application_X_Mpegurl,
  Application_X_Ms_Application: () => Application_X_Ms_Application,
  Application_X_Ms_Shortcut: () => Application_X_Ms_Shortcut,
  Application_X_Ms_Wmd: () => Application_X_Ms_Wmd,
  Application_X_Ms_Wmz: () => Application_X_Ms_Wmz,
  Application_X_Ms_Xbap: () => Application_X_Ms_Xbap,
  Application_X_Msaccess: () => Application_X_Msaccess,
  Application_X_Msbinder: () => Application_X_Msbinder,
  Application_X_Mscardfile: () => Application_X_Mscardfile,
  Application_X_Msclip: () => Application_X_Msclip,
  Application_X_Msdos_Program: () => Application_X_Msdos_Program,
  Application_X_Msdownload: () => Application_X_Msdownload,
  Application_X_Msmediaview: () => Application_X_Msmediaview,
  Application_X_Msmetafile: () => Application_X_Msmetafile,
  Application_X_Msmoney: () => Application_X_Msmoney,
  Application_X_Mspublisher: () => Application_X_Mspublisher,
  Application_X_Msschedule: () => Application_X_Msschedule,
  Application_X_Msterminal: () => Application_X_Msterminal,
  Application_X_Mswrite: () => Application_X_Mswrite,
  Application_X_Netcdf: () => Application_X_Netcdf,
  Application_X_Ns_Proxy_Autoconfig: () => Application_X_Ns_Proxy_Autoconfig,
  Application_X_Nzb: () => Application_X_Nzb,
  Application_X_Pkcs12: () => Application_X_Pkcs12,
  Application_X_Pkcs7_Certificates: () => Application_X_Pkcs7_Certificates,
  Application_X_Pkcs7_Certreqresp: () => Application_X_Pkcs7_Certreqresp,
  Application_X_Rar_Compressed: () => Application_X_Rar_Compressed,
  Application_X_Research_Info_Systems: () => Application_X_Research_Info_Systems,
  Application_X_Sh: () => Application_X_Sh,
  Application_X_Shar: () => Application_X_Shar,
  Application_X_Shockwave_Flash: () => Application_X_Shockwave_Flash,
  Application_X_Silverlight_App: () => Application_X_Silverlight_App,
  Application_X_Sql: () => Application_X_Sql,
  Application_X_Stuffit: () => Application_X_Stuffit,
  Application_X_Stuffitx: () => Application_X_Stuffitx,
  Application_X_Subrip: () => Application_X_Subrip,
  Application_X_Sv4cpio: () => Application_X_Sv4cpio,
  Application_X_Sv4crc: () => Application_X_Sv4crc,
  Application_X_T3vm_Image: () => Application_X_T3vm_Image,
  Application_X_Tads: () => Application_X_Tads,
  Application_X_Tar: () => Application_X_Tar,
  Application_X_Tcl: () => Application_X_Tcl,
  Application_X_Tex: () => Application_X_Tex,
  Application_X_Tex_Tfm: () => Application_X_Tex_Tfm,
  Application_X_Texinfo: () => Application_X_Texinfo,
  Application_X_Tgif: () => Application_X_Tgif,
  Application_X_Url: () => Application_X_Url,
  Application_X_Ustar: () => Application_X_Ustar,
  Application_X_Virtualbox_Hdd: () => Application_X_Virtualbox_Hdd,
  Application_X_Virtualbox_Ova: () => Application_X_Virtualbox_Ova,
  Application_X_Virtualbox_Ovf: () => Application_X_Virtualbox_Ovf,
  Application_X_Virtualbox_Vbox: () => Application_X_Virtualbox_Vbox,
  Application_X_Virtualbox_Vbox_Extpack: () => Application_X_Virtualbox_Vbox_Extpack,
  Application_X_Virtualbox_Vdi: () => Application_X_Virtualbox_Vdi,
  Application_X_Virtualbox_Vhd: () => Application_X_Virtualbox_Vhd,
  Application_X_Virtualbox_Vmdk: () => Application_X_Virtualbox_Vmdk,
  Application_X_Wais_Source: () => Application_X_Wais_Source,
  Application_X_Web_App_ManifestJson: () => Application_X_Web_App_ManifestJson,
  Application_X_Www_Form_Urlencoded: () => Application_X_Www_Form_Urlencoded,
  Application_X_X509_Ca_Cert: () => Application_X_X509_Ca_Cert,
  Application_X_Xfig: () => Application_X_Xfig,
  Application_X_XliffXml: () => Application_X_XliffXml,
  Application_X_Xpinstall: () => Application_X_Xpinstall,
  Application_X_Xz: () => Application_X_Xz,
  Application_X_Zip_Compressed: () => Application_X_Zip_Compressed,
  Application_X_Zmachine: () => Application_X_Zmachine,
  Application_XacmlXml: () => Application_XacmlXml,
  Application_XamlXml: () => Application_XamlXml,
  Application_Xcap_AttXml: () => Application_Xcap_AttXml,
  Application_Xcap_CapsXml: () => Application_Xcap_CapsXml,
  Application_Xcap_DiffXml: () => Application_Xcap_DiffXml,
  Application_Xcap_ElXml: () => Application_Xcap_ElXml,
  Application_Xcap_ErrorXml: () => Application_Xcap_ErrorXml,
  Application_Xcap_NsXml: () => Application_Xcap_NsXml,
  Application_Xcon_Conference_InfoXml: () => Application_Xcon_Conference_InfoXml,
  Application_Xcon_Conference_Info_DiffXml: () => Application_Xcon_Conference_Info_DiffXml,
  Application_XencXml: () => Application_XencXml,
  Application_XhtmlXml: () => Application_XhtmlXml,
  Application_Xhtml_VoiceXml: () => Application_Xhtml_VoiceXml,
  Application_XliffXml: () => Application_XliffXml,
  Application_Xml: () => Application_Xml,
  Application_Xml_Dtd: () => Application_Xml_Dtd,
  Application_Xml_External_Parsed_Entity: () => Application_Xml_External_Parsed_Entity,
  Application_Xml_PatchXml: () => Application_Xml_PatchXml,
  Application_XmppXml: () => Application_XmppXml,
  Application_XopXml: () => Application_XopXml,
  Application_XprocXml: () => Application_XprocXml,
  Application_XsltXml: () => Application_XsltXml,
  Application_XspfXml: () => Application_XspfXml,
  Application_XvXml: () => Application_XvXml,
  Application_Yang: () => Application_Yang,
  Application_Yang_DataJson: () => Application_Yang_DataJson,
  Application_Yang_DataXml: () => Application_Yang_DataXml,
  Application_Yang_PatchJson: () => Application_Yang_PatchJson,
  Application_Yang_PatchXml: () => Application_Yang_PatchXml,
  Application_YinXml: () => Application_YinXml,
  Application_Zip: () => Application_Zip,
  Application_Zlib: () => Application_Zlib,
  Application_Zstd: () => Application_Zstd
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/util.ts
var typePattern = /([^\/]+)\/(.+)/;
var subTypePattern = /(?:([^\.]+)\.)?([^\+;]+)(?:\+([^;]+))?((?:; *([^=]+)=([^;]+))*)/;
function mediaTypesToAcceptValue(types) {
  return types.flatMap((type2) => type2.extensions.map((ext) => "." + ext)).sort().join(", ");
}
var MediaType = class {
  constructor(_type, _fullSubType, extensions) {
    this._type = _type;
    this._fullSubType = _fullSubType;
    this._primaryExtension = null;
    this.depMessage = null;
    const parameters = /* @__PURE__ */ new Map();
    this._parameters = parameters;
    const subTypeParts = this._fullSubType.match(subTypePattern);
    this._tree = subTypeParts[1];
    this._subType = subTypeParts[2];
    this._suffix = subTypeParts[3];
    const paramStr = subTypeParts[4];
    this._value = this._fullValue = this._type + "/";
    if (isDefined(this._tree)) {
      this._value = this._fullValue += this._tree + ".";
    }
    this._value = this._fullValue += this._subType;
    if (isDefined(this._suffix)) {
      this._value = this._fullValue += "+" + this._suffix;
    }
    if (isDefined(paramStr)) {
      const pairs = paramStr.split(";").map((p) => p.trim()).filter((p) => p.length > 0).map((p) => p.split("="));
      for (const [key, ...values] of pairs) {
        const value2 = values.join("=");
        parameters.set(key, value2);
        const slug = `; ${key}=${value2}`;
        this._fullValue += slug;
        if (key !== "q") {
          this._value += slug;
        }
      }
    }
    this._extensions = extensions || [];
    this._primaryExtension = this._extensions[0] || null;
  }
  static parse(value2) {
    if (!value2) {
      return null;
    }
    const match = value2.match(typePattern);
    if (!match) {
      return null;
    }
    const type2 = match[1];
    const subType = match[2];
    return new MediaType(type2, subType);
  }
  deprecate(message2) {
    this.depMessage = message2;
    return this;
  }
  check() {
    if (isDefined(this.depMessage)) {
      console.warn(`${this._value} is deprecated ${this.depMessage}`);
    }
  }
  matches(value2) {
    if (isNullOrUndefined(value2)) {
      return false;
    }
    if (this.typeName === "*" && this.subTypeName === "*") {
      return true;
    }
    let typeName = null;
    let subTypeName = null;
    if (isString(value2)) {
      const match = value2.match(typePattern);
      if (!match) {
        return false;
      }
      typeName = match[1];
      subTypeName = match[2];
    } else {
      typeName = value2.typeName;
      subTypeName = value2._fullSubType;
    }
    return this.typeName === typeName && (this._fullSubType === "*" || this._fullSubType === subTypeName);
  }
  withParameter(key, value2) {
    const newSubType = `${this._fullSubType}; ${key}=${value2}`;
    return new MediaType(this.typeName, newSubType, this.extensions);
  }
  get typeName() {
    this.check();
    return this._type;
  }
  get tree() {
    this.check();
    return this._tree;
  }
  get suffix() {
    return this._suffix;
  }
  get subTypeName() {
    this.check();
    return this._subType;
  }
  get value() {
    this.check();
    return this._value;
  }
  __getValueUnsafe() {
    return this._value;
  }
  get fullValue() {
    this.check();
    return this._fullValue;
  }
  get parameters() {
    this.check();
    return this._parameters;
  }
  get extensions() {
    this.check();
    return this._extensions;
  }
  __getExtensionsUnsafe() {
    return this._extensions;
  }
  get primaryExtension() {
    this.check();
    return this._primaryExtension;
  }
  toString() {
    if (this.parameters.get("q") === "1") {
      return this.value;
    } else {
      return this.fullValue;
    }
  }
  addExtension(fileName) {
    if (!fileName) {
      throw new Error("File name is not defined");
    }
    if (this.primaryExtension) {
      const idx = fileName.lastIndexOf(".");
      if (idx > -1) {
        const currentExtension = fileName.substring(idx + 1);
        ;
        if (this.extensions.indexOf(currentExtension) > -1) {
          fileName = fileName.substring(0, idx);
        }
      }
      fileName = `${fileName}.${this.primaryExtension}`;
    }
    return fileName;
  }
};
function create(group, value2, ...extensions) {
  return new MediaType(group, value2, extensions);
}
function specialize(group) {
  return create.bind(null, group);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/application.ts
var application = /* @__PURE__ */ specialize("application");
var Application_A2L = /* @__PURE__ */ application("a2l");
var Application_Activemessage = /* @__PURE__ */ application("activemessage");
var Application_ScenarioJson = /* @__PURE__ */ application("activity+json", "json");
var Application_Alto_CostmapfilterJson = /* @__PURE__ */ application("alto-costmapfilter+json", "json");
var Application_Alto_CostmapJson = /* @__PURE__ */ application("alto-costmap+json", "json");
var Application_Alto_DirectoryJson = /* @__PURE__ */ application("alto-directory+json", "json");
var Application_Alto_EndpointcostJson = /* @__PURE__ */ application("alto-endpointcost+json", "json");
var Application_Alto_EndpointcostparamsJson = /* @__PURE__ */ application("alto-endpointcostparams+json", "json");
var Application_Alto_EndpointpropJson = /* @__PURE__ */ application("alto-endpointprop+json", "json");
var Application_Alto_EndpointpropparamsJson = /* @__PURE__ */ application("alto-endpointpropparams+json", "json");
var Application_Alto_ErrorJson = /* @__PURE__ */ application("alto-error+json", "json");
var Application_Alto_NetworkmapfilterJson = /* @__PURE__ */ application("alto-networkmapfilter+json", "json");
var Application_Alto_NetworkmapJson = /* @__PURE__ */ application("alto-networkmap+json", "json");
var Application_AML = /* @__PURE__ */ application("aml");
var Application_Andrew_Inset = /* @__PURE__ */ application("andrew-inset", "ez");
var Application_Applefile = /* @__PURE__ */ application("applefile");
var Application_Applixware = /* @__PURE__ */ application("applixware", "aw");
var Application_ATF = /* @__PURE__ */ application("atf");
var Application_ATFX = /* @__PURE__ */ application("atfx");
var Application_AtomcatXml = /* @__PURE__ */ application("atomcat+xml", "atomcat");
var Application_AtomdeletedXml = /* @__PURE__ */ application("atomdeleted+xml", "xml");
var Application_Atomicmail = /* @__PURE__ */ application("atomicmail");
var Application_AtomsvcXml = /* @__PURE__ */ application("atomsvc+xml", "atomsvc");
var Application_AtomXml = /* @__PURE__ */ application("atom+xml", "atom");
var Application_Atsc_DwdXml = /* @__PURE__ */ application("atsc-dwd+xml", "xml");
var Application_Atsc_HeldXml = /* @__PURE__ */ application("atsc-held+xml", "xml");
var Application_Atsc_RdtJson = /* @__PURE__ */ application("atsc-rdt+json", "json");
var Application_Atsc_RsatXml = /* @__PURE__ */ application("atsc-rsat+xml", "xml");
var Application_ATXML = /* @__PURE__ */ application("atxml");
var Application_Auth_PolicyXml = /* @__PURE__ */ application("auth-policy+xml", "xml");
var Application_Bacnet_XddZip = /* @__PURE__ */ application("bacnet-xdd+zip", "zip");
var Application_Batch_SMTP = /* @__PURE__ */ application("batch-smtp");
var Application_Bdoc = /* @__PURE__ */ application("bdoc", "bdoc");
var Application_BeepXml = /* @__PURE__ */ application("beep+xml", "xml");
var Application_CalendarJson = /* @__PURE__ */ application("calendar+json", "json");
var Application_CalendarXml = /* @__PURE__ */ application("calendar+xml", "xml");
var Application_Call_Completion = /* @__PURE__ */ application("call-completion");
var Application_CALS_1840 = /* @__PURE__ */ application("cals-1840");
var Application_Cbor = /* @__PURE__ */ application("cbor");
var Application_Cbor_Seq = /* @__PURE__ */ application("cbor-seq");
var Application_Cccex = /* @__PURE__ */ application("cccex");
var Application_CcmpXml = /* @__PURE__ */ application("ccmp+xml", "xml");
var Application_CcxmlXml = /* @__PURE__ */ application("ccxml+xml", "ccxml");
var Application_CDFXXML = /* @__PURE__ */ application("cdfx+xml", "xml");
var Application_Cdmi_Capability = /* @__PURE__ */ application("cdmi-capability", "cdmia");
var Application_Cdmi_Container = /* @__PURE__ */ application("cdmi-container", "cdmic");
var Application_Cdmi_Domain = /* @__PURE__ */ application("cdmi-domain", "cdmid");
var Application_Cdmi_Object = /* @__PURE__ */ application("cdmi-object", "cdmio");
var Application_Cdmi_Queue = /* @__PURE__ */ application("cdmi-queue", "cdmiq");
var Application_Cdni = /* @__PURE__ */ application("cdni");
var Application_CEA = /* @__PURE__ */ application("cea");
var Application_Cea_2018Xml = /* @__PURE__ */ application("cea-2018+xml", "xml");
var Application_CellmlXml = /* @__PURE__ */ application("cellml+xml", "xml");
var Application_Cfw = /* @__PURE__ */ application("cfw");
var Application_Clue_infoXml = /* @__PURE__ */ application("clue_info+xml", "xml");
var Application_ClueXml = /* @__PURE__ */ application("clue+xml", "xml");
var Application_Cms = /* @__PURE__ */ application("cms");
var Application_CnrpXml = /* @__PURE__ */ application("cnrp+xml", "xml");
var Application_Coap_GroupJson = /* @__PURE__ */ application("coap-group+json", "json");
var Application_Coap_Payload = /* @__PURE__ */ application("coap-payload");
var Application_Commonground = /* @__PURE__ */ application("commonground");
var Application_Conference_InfoXml = /* @__PURE__ */ application("conference-info+xml", "xml");
var Application_Cose = /* @__PURE__ */ application("cose");
var Application_Cose_Key = /* @__PURE__ */ application("cose-key");
var Application_Cose_Key_Set = /* @__PURE__ */ application("cose-key-set");
var Application_CplXml = /* @__PURE__ */ application("cpl+xml", "xml");
var Application_Csrattrs = /* @__PURE__ */ application("csrattrs");
var Application_CSTAdataXml = /* @__PURE__ */ application("cstadata+xml", "xml");
var Application_CstaXml = /* @__PURE__ */ application("csta+xml", "xml");
var Application_CsvmJson = /* @__PURE__ */ application("csvm+json", "json");
var Application_Cu_Seeme = /* @__PURE__ */ application("cu-seeme", "cu");
var Application_Cwt = /* @__PURE__ */ application("cwt");
var Application_Cybercash = /* @__PURE__ */ application("cybercash");
var Application_Dart = /* @__PURE__ */ application("dart");
var Application_Dashdelta = /* @__PURE__ */ application("dashdelta");
var Application_DashXml = /* @__PURE__ */ application("dash+xml", "xml");
var Application_DavmountXml = /* @__PURE__ */ application("davmount+xml", "davmount");
var Application_Dca_Rft = /* @__PURE__ */ application("dca-rft");
var Application_DCD = /* @__PURE__ */ application("dcd");
var Application_Dec_Dx = /* @__PURE__ */ application("dec-dx");
var Application_Dialog_InfoXml = /* @__PURE__ */ application("dialog-info+xml", "xml");
var Application_Dicom = /* @__PURE__ */ application("dicom");
var Application_DicomJson = /* @__PURE__ */ application("dicom+json", "json");
var Application_DicomXml = /* @__PURE__ */ application("dicom+xml", "xml");
var Application_DII = /* @__PURE__ */ application("dii");
var Application_DIT = /* @__PURE__ */ application("dit");
var Application_Dns = /* @__PURE__ */ application("dns");
var Application_Dns_Message = /* @__PURE__ */ application("dns-message");
var Application_DnsJson = /* @__PURE__ */ application("dns+json", "json");
var Application_DocbookXml = /* @__PURE__ */ application("docbook+xml", "dbk");
var Application_DotsCbor = /* @__PURE__ */ application("dots+cbor", "cbor");
var Application_DskppXml = /* @__PURE__ */ application("dskpp+xml", "xml");
var Application_DsscDer = /* @__PURE__ */ application("dssc+der", "dssc");
var Application_DsscXml = /* @__PURE__ */ application("dssc+xml", "xdssc");
var Application_Dvcs = /* @__PURE__ */ application("dvcs");
var Application_Ecmascript = /* @__PURE__ */ application("ecmascript", "ecma");
var Application_EDI_Consent = /* @__PURE__ */ application("edi-consent");
var Application_EDI_X12 = /* @__PURE__ */ application("edi-x12");
var Application_EDIFACT = /* @__PURE__ */ application("edifact");
var Application_Efi = /* @__PURE__ */ application("efi");
var Application_EmergencyCallDataCommentXml = /* @__PURE__ */ application("emergencycalldata.comment+xml", "xml");
var Application_EmergencyCallDataControlXml = /* @__PURE__ */ application("emergencycalldata.control+xml", "xml");
var Application_EmergencyCallDataDeviceInfoXml = /* @__PURE__ */ application("emergencycalldata.deviceinfo+xml", "xml");
var Application_EmergencyCallDataECallMSD = /* @__PURE__ */ application("emergencycalldata.ecall.msd");
var Application_EmergencyCallDataProviderInfoXml = /* @__PURE__ */ application("emergencycalldata.providerinfo+xml", "xml");
var Application_EmergencyCallDataServiceInfoXml = /* @__PURE__ */ application("emergencycalldata.serviceinfo+xml", "xml");
var Application_EmergencyCallDataSubscriberInfoXml = /* @__PURE__ */ application("emergencycalldata.subscriberinfo+xml", "xml");
var Application_EmergencyCallDataVEDSXml = /* @__PURE__ */ application("emergencycalldata.veds+xml", "xml");
var Application_EmmaXml = /* @__PURE__ */ application("emma+xml", "emma");
var Application_EmotionmlXml = /* @__PURE__ */ application("emotionml+xml", "xml");
var Application_Encaprtp = /* @__PURE__ */ application("encaprtp");
var Application_EppXml = /* @__PURE__ */ application("epp+xml", "xml");
var Application_EpubZip = /* @__PURE__ */ application("epub+zip", "epub");
var Application_Eshop = /* @__PURE__ */ application("eshop");
var Application_Example = /* @__PURE__ */ application("example");
var Application_Exi = /* @__PURE__ */ application("exi", "exi");
var Application_Expect_Ct_ReportJson = /* @__PURE__ */ application("expect-ct-report+json", "json");
var Application_Fastinfoset = /* @__PURE__ */ application("fastinfoset");
var Application_Fastsoap = /* @__PURE__ */ application("fastsoap");
var Application_FdtXml = /* @__PURE__ */ application("fdt+xml", "xml");
var Application_FhirJson = /* @__PURE__ */ application("fhir+json", "json");
var Application_FhirXml = /* @__PURE__ */ application("fhir+xml", "xml");
var Application_Fido_TrustedAppsJson = /* @__PURE__ */ application("fido.trusted-apps+json");
var Application_Fits = /* @__PURE__ */ application("fits");
var Application_Flexfec = /* @__PURE__ */ application("flexfec");
var Application_Font_Sfnt = /* @__PURE__ */ application("font-sfnt").deprecate("in favor of font/sfnt");
var Application_Font_Tdpfr = /* @__PURE__ */ application("font-tdpfr", "pfr");
var Application_Font_Woff = /* @__PURE__ */ application("font-woff").deprecate("in favor of font/woff");
var Application_Framework_AttributesXml = /* @__PURE__ */ application("framework-attributes+xml", "xml");
var Application_GeoJson = /* @__PURE__ */ application("geo+json", "json");
var Application_GeoJson_Seq = /* @__PURE__ */ application("geo+json-seq", "json-seq");
var Application_GeopackageSqlite3 = /* @__PURE__ */ application("geopackage+sqlite3", "sqlite3");
var Application_GeoxacmlXml = /* @__PURE__ */ application("geoxacml+xml", "xml");
var Application_Gltf_Buffer = /* @__PURE__ */ application("gltf-buffer");
var Application_GmlXml = /* @__PURE__ */ application("gml+xml", "gml");
var Application_GpxXml = /* @__PURE__ */ application("gpx+xml", "gpx");
var Application_Gxf = /* @__PURE__ */ application("gxf", "gxf");
var Application_Gzip = /* @__PURE__ */ application("gzip");
var Application_H224 = /* @__PURE__ */ application("h224");
var Application_HeldXml = /* @__PURE__ */ application("held+xml", "xml");
var Application_Hjson = /* @__PURE__ */ application("hjson", "hjson");
var Application_Http = /* @__PURE__ */ application("http");
var Application_Hyperstudio = /* @__PURE__ */ application("hyperstudio", "stk");
var Application_Ibe_Key_RequestXml = /* @__PURE__ */ application("ibe-key-request+xml", "xml");
var Application_Ibe_Pkg_ReplyXml = /* @__PURE__ */ application("ibe-pkg-reply+xml", "xml");
var Application_Ibe_Pp_Data = /* @__PURE__ */ application("ibe-pp-data");
var Application_Iges = /* @__PURE__ */ application("iges");
var Application_Im_IscomposingXml = /* @__PURE__ */ application("im-iscomposing+xml", "xml");
var Application_Index = /* @__PURE__ */ application("index");
var Application_IndexCmd = /* @__PURE__ */ application("index.cmd");
var Application_IndexObj = /* @__PURE__ */ application("index.obj");
var Application_IndexResponse = /* @__PURE__ */ application("index.response");
var Application_IndexVnd = /* @__PURE__ */ application("index.vnd");
var Application_InkmlXml = /* @__PURE__ */ application("inkml+xml", "ink", "inkml");
var Application_IOTP = /* @__PURE__ */ application("iotp");
var Application_Ipfix = /* @__PURE__ */ application("ipfix", "ipfix");
var Application_Ipp = /* @__PURE__ */ application("ipp");
var Application_ISUP = /* @__PURE__ */ application("isup");
var Application_ItsXml = /* @__PURE__ */ application("its+xml", "xml");
var Application_Java_Archive = /* @__PURE__ */ application("java-archive", "jar");
var Application_Java_Serialized_Object = /* @__PURE__ */ application("java-serialized-object", "ser");
var Application_Java_Vm = /* @__PURE__ */ application("java-vm", "class");
var Application_Javascript = /* @__PURE__ */ application("javascript", "js");
var Application_Jf2feedJson = /* @__PURE__ */ application("jf2feed+json", "json");
var Application_Jose = /* @__PURE__ */ application("jose");
var Application_JoseJson = /* @__PURE__ */ application("jose+json", "json");
var Application_JrdJson = /* @__PURE__ */ application("jrd+json", "json");
var Application_Json = /* @__PURE__ */ application("json", "json");
var Application_Json5 = /* @__PURE__ */ application("json5", "json5");
var Application_JsonUTF8 = /* @__PURE__ */ application("json; charset=UTF-8", "json");
var Application_Json_PatchJson = /* @__PURE__ */ application("json-patch+json", "json");
var Application_Json_Seq = /* @__PURE__ */ application("json-seq");
var Application_JsonmlJson = /* @__PURE__ */ application("jsonml+json", "jsonml");
var Application_Jwk_SetJson = /* @__PURE__ */ application("jwk-set+json", "json");
var Application_JwkJson = /* @__PURE__ */ application("jwk+json", "json");
var Application_Jwt = /* @__PURE__ */ application("jwt");
var Application_Kpml_RequestXml = /* @__PURE__ */ application("kpml-request+xml", "xml");
var Application_Kpml_ResponseXml = /* @__PURE__ */ application("kpml-response+xml", "xml");
var Application_LdJson = /* @__PURE__ */ application("ld+json", "json");
var Application_LgrXml = /* @__PURE__ */ application("lgr+xml", "xml");
var Application_Link_Format = /* @__PURE__ */ application("link-format");
var Application_Load_ControlXml = /* @__PURE__ */ application("load-control+xml", "xml");
var Application_LostsyncXml = /* @__PURE__ */ application("lostsync+xml", "xml");
var Application_LostXml = /* @__PURE__ */ application("lost+xml", "lostxml");
var Application_LXF = /* @__PURE__ */ application("lxf");
var Application_Mac_Binhex40 = /* @__PURE__ */ application("mac-binhex40", "hqx");
var Application_Mac_Compactpro = /* @__PURE__ */ application("mac-compactpro", "cpt");
var Application_Macwriteii = /* @__PURE__ */ application("macwriteii");
var Application_MadsXml = /* @__PURE__ */ application("mads+xml", "mads");
var Application_ManifestJson = /* @__PURE__ */ application("manifest+json", "webmanifest");
var Application_Marc = /* @__PURE__ */ application("marc", "mrc");
var Application_MarcxmlXml = /* @__PURE__ */ application("marcxml+xml", "mrcx");
var Application_Mathematica = /* @__PURE__ */ application("mathematica", "ma", "nb", "mb");
var Application_Mathml_ContentXml = /* @__PURE__ */ application("mathml-content+xml", "xml");
var Application_Mathml_PresentationXml = /* @__PURE__ */ application("mathml-presentation+xml", "xml");
var Application_MathmlXml = /* @__PURE__ */ application("mathml+xml", "mathml");
var Application_Mbms_Associated_Procedure_DescriptionXml = /* @__PURE__ */ application("mbms-associated-procedure-description+xml", "xml");
var Application_Mbms_DeregisterXml = /* @__PURE__ */ application("mbms-deregister+xml", "xml");
var Application_Mbms_EnvelopeXml = /* @__PURE__ */ application("mbms-envelope+xml", "xml");
var Application_Mbms_Msk_ResponseXml = /* @__PURE__ */ application("mbms-msk-response+xml", "xml");
var Application_Mbms_MskXml = /* @__PURE__ */ application("mbms-msk+xml", "xml");
var Application_Mbms_Protection_DescriptionXml = /* @__PURE__ */ application("mbms-protection-description+xml", "xml");
var Application_Mbms_Reception_ReportXml = /* @__PURE__ */ application("mbms-reception-report+xml", "xml");
var Application_Mbms_Register_ResponseXml = /* @__PURE__ */ application("mbms-register-response+xml", "xml");
var Application_Mbms_RegisterXml = /* @__PURE__ */ application("mbms-register+xml", "xml");
var Application_Mbms_ScheduleXml = /* @__PURE__ */ application("mbms-schedule+xml", "xml");
var Application_Mbms_User_Service_DescriptionXml = /* @__PURE__ */ application("mbms-user-service-description+xml", "xml");
var Application_Mbox = /* @__PURE__ */ application("mbox", "mbox");
var Application_Media_controlXml = /* @__PURE__ */ application("media_control+xml", "xml");
var Application_Media_Policy_DatasetXml = /* @__PURE__ */ application("media-policy-dataset+xml", "xml");
var Application_MediaservercontrolXml = /* @__PURE__ */ application("mediaservercontrol+xml", "mscml");
var Application_Merge_PatchJson = /* @__PURE__ */ application("merge-patch+json", "json");
var Application_Metalink4Xml = /* @__PURE__ */ application("metalink4+xml", "meta4");
var Application_MetalinkXml = /* @__PURE__ */ application("metalink+xml", "metalink");
var Application_MetsXml = /* @__PURE__ */ application("mets+xml", "mets");
var Application_MF4 = /* @__PURE__ */ application("mf4");
var Application_Mikey = /* @__PURE__ */ application("mikey");
var Application_Mipc = /* @__PURE__ */ application("mipc");
var Application_Mmt_AeiXml = /* @__PURE__ */ application("mmt-aei+xml", "xml");
var Application_Mmt_UsdXml = /* @__PURE__ */ application("mmt-usd+xml", "xml");
var Application_ModsXml = /* @__PURE__ */ application("mods+xml", "mods");
var Application_Moss_Keys = /* @__PURE__ */ application("moss-keys");
var Application_Moss_Signature = /* @__PURE__ */ application("moss-signature");
var Application_Mosskey_Data = /* @__PURE__ */ application("mosskey-data");
var Application_Mosskey_Request = /* @__PURE__ */ application("mosskey-request");
var Application_Mp21 = /* @__PURE__ */ application("mp21", "m21", "mp21");
var Application_Mp4 = /* @__PURE__ */ application("mp4", "mp4s");
var Application_Mpeg4_Generic = /* @__PURE__ */ application("mpeg4-generic");
var Application_Mpeg4_Iod = /* @__PURE__ */ application("mpeg4-iod");
var Application_Mpeg4_Iod_Xmt = /* @__PURE__ */ application("mpeg4-iod-xmt");
var Application_Mrb_ConsumerXml = /* @__PURE__ */ application("mrb-consumer+xml", "xml");
var Application_Mrb_PublishXml = /* @__PURE__ */ application("mrb-publish+xml", "xml");
var Application_Msc_IvrXml = /* @__PURE__ */ application("msc-ivr+xml", "xml");
var Application_Msc_MixerXml = /* @__PURE__ */ application("msc-mixer+xml", "xml");
var Application_Msword = /* @__PURE__ */ application("msword", "doc", "dot");
var Application_MudJson = /* @__PURE__ */ application("mud+json", "json");
var Application_Multipart_Core = /* @__PURE__ */ application("multipart-core");
var Application_Mxf = /* @__PURE__ */ application("mxf", "mxf");
var Application_N_Quads = /* @__PURE__ */ application("n-quads");
var Application_N_Triples = /* @__PURE__ */ application("n-triples");
var Application_Nasdata = /* @__PURE__ */ application("nasdata");
var Application_News_Checkgroups = /* @__PURE__ */ application("news-checkgroups");
var Application_News_Groupinfo = /* @__PURE__ */ application("news-groupinfo");
var Application_News_Transmission = /* @__PURE__ */ application("news-transmission");
var Application_NlsmlXml = /* @__PURE__ */ application("nlsml+xml", "xml");
var Application_Node = /* @__PURE__ */ application("node");
var Application_Nss = /* @__PURE__ */ application("nss");
var Application_Ocsp_Request = /* @__PURE__ */ application("ocsp-request");
var Application_Ocsp_Response = /* @__PURE__ */ application("ocsp-response");
var Application_Octet_Stream = /* @__PURE__ */ application("octet-stream", "bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy");
var Application_ODA = /* @__PURE__ */ application("oda", "oda");
var Application_OdmXml = /* @__PURE__ */ application("odm+xml", "xml");
var Application_ODX = /* @__PURE__ */ application("odx");
var Application_Oebps_PackageXml = /* @__PURE__ */ application("oebps-package+xml", "opf");
var Application_Ogg = /* @__PURE__ */ application("ogg", "ogx");
var Application_OmdocXml = /* @__PURE__ */ application("omdoc+xml", "omdoc");
var Application_Onenote = /* @__PURE__ */ application("onenote", "onetoc", "onetoc2", "onetmp", "onepkg");
var Application_Oscore = /* @__PURE__ */ application("oscore");
var Application_Oxps = /* @__PURE__ */ application("oxps", "oxps");
var Application_P2p_OverlayXml = /* @__PURE__ */ application("p2p-overlay+xml", "xml");
var Application_Parityfec = /* @__PURE__ */ application("parityfec");
var Application_Passport = /* @__PURE__ */ application("passport");
var Application_Patch_Ops_ErrorXml = /* @__PURE__ */ application("patch-ops-error+xml", "xer");
var Application_Pdf = /* @__PURE__ */ application("pdf", "pdf");
var Application_PDX = /* @__PURE__ */ application("pdx");
var Application_Pem_Certificate_Chain = /* @__PURE__ */ application("pem-certificate-chain");
var Application_Pgp_Encrypted = /* @__PURE__ */ application("pgp-encrypted", "pgp");
var Application_Pgp_Keys = /* @__PURE__ */ application("pgp-keys");
var Application_Pgp_Signature = /* @__PURE__ */ application("pgp-signature", "asc", "sig");
var Application_Pics_Rules = /* @__PURE__ */ application("pics-rules", "prf");
var Application_Pidf_DiffXml = /* @__PURE__ */ application("pidf-diff+xml", "xml");
var Application_PidfXml = /* @__PURE__ */ application("pidf+xml", "xml");
var Application_Pkcs10 = /* @__PURE__ */ application("pkcs10", "p10");
var Application_Pkcs12 = /* @__PURE__ */ application("pkcs12");
var Application_Pkcs7_Mime = /* @__PURE__ */ application("pkcs7-mime", "p7m", "p7c");
var Application_Pkcs7_Signature = /* @__PURE__ */ application("pkcs7-signature", "p7s");
var Application_Pkcs8 = /* @__PURE__ */ application("pkcs8", "p8");
var Application_Pkcs8_Encrypted = /* @__PURE__ */ application("pkcs8-encrypted");
var Application_Pkix_Attr_Cert = /* @__PURE__ */ application("pkix-attr-cert", "ac");
var Application_Pkix_Cert = /* @__PURE__ */ application("pkix-cert", "cer");
var Application_Pkix_Crl = /* @__PURE__ */ application("pkix-crl", "crl");
var Application_Pkix_Pkipath = /* @__PURE__ */ application("pkix-pkipath", "pkipath");
var Application_Pkixcmp = /* @__PURE__ */ application("pkixcmp", "pki");
var Application_PlsXml = /* @__PURE__ */ application("pls+xml", "pls");
var Application_Poc_SettingsXml = /* @__PURE__ */ application("poc-settings+xml", "xml");
var Application_Postscript = /* @__PURE__ */ application("postscript", "ai", "eps", "ps");
var Application_Ppsp_TrackerJson = /* @__PURE__ */ application("ppsp-tracker+json", "json");
var Application_ProblemJson = /* @__PURE__ */ application("problem+json", "json");
var Application_ProblemXml = /* @__PURE__ */ application("problem+xml", "xml");
var Application_ProvenanceXml = /* @__PURE__ */ application("provenance+xml", "xml");
var Application_PrsAlvestrandTitrax_Sheet = /* @__PURE__ */ application("prs.alvestrand.titrax-sheet");
var Application_PrsCww = /* @__PURE__ */ application("prs.cww", "cww");
var Application_PrsHpubZip = /* @__PURE__ */ application("prs.hpub+zip", "zip");
var Application_PrsNprend = /* @__PURE__ */ application("prs.nprend");
var Application_PrsPlucker = /* @__PURE__ */ application("prs.plucker");
var Application_PrsRdf_Xml_Crypt = /* @__PURE__ */ application("prs.rdf-xml-crypt");
var Application_PrsXsfXml = /* @__PURE__ */ application("prs.xsf+xml", "xml");
var Application_PskcXml = /* @__PURE__ */ application("pskc+xml", "pskcxml");
var Application_QSIG = /* @__PURE__ */ application("qsig");
var Application_RamlYaml = /* @__PURE__ */ application("raml+yaml", "raml");
var Application_Raptorfec = /* @__PURE__ */ application("raptorfec");
var Application_RdapJson = /* @__PURE__ */ application("rdap+json", "json");
var Application_RdfXml = /* @__PURE__ */ application("rdf+xml", "rdf");
var Application_ReginfoXml = /* @__PURE__ */ application("reginfo+xml", "rif");
var Application_Relax_Ng_Compact_Syntax = /* @__PURE__ */ application("relax-ng-compact-syntax", "rnc");
var Application_Remote_Printing = /* @__PURE__ */ application("remote-printing");
var Application_ReputonJson = /* @__PURE__ */ application("reputon+json", "json");
var Application_Resource_Lists_DiffXml = /* @__PURE__ */ application("resource-lists-diff+xml", "rld");
var Application_Resource_ListsXml = /* @__PURE__ */ application("resource-lists+xml", "rl");
var Application_RfcXml = /* @__PURE__ */ application("rfc+xml", "xml");
var Application_Riscos = /* @__PURE__ */ application("riscos");
var Application_RlmiXml = /* @__PURE__ */ application("rlmi+xml", "xml");
var Application_Rls_ServicesXml = /* @__PURE__ */ application("rls-services+xml", "rs");
var Application_Route_ApdXml = /* @__PURE__ */ application("route-apd+xml", "xml");
var Application_Route_S_TsidXml = /* @__PURE__ */ application("route-s-tsid+xml", "xml");
var Application_Route_UsdXml = /* @__PURE__ */ application("route-usd+xml", "xml");
var Application_Rpki_Ghostbusters = /* @__PURE__ */ application("rpki-ghostbusters", "gbr");
var Application_Rpki_Manifest = /* @__PURE__ */ application("rpki-manifest", "mft");
var Application_Rpki_Publication = /* @__PURE__ */ application("rpki-publication");
var Application_Rpki_Roa = /* @__PURE__ */ application("rpki-roa", "roa");
var Application_Rpki_Updown = /* @__PURE__ */ application("rpki-updown");
var Application_RsdXml = /* @__PURE__ */ application("rsd+xml", "rsd");
var Application_RssXml = /* @__PURE__ */ application("rss+xml", "rss");
var Application_Rtf = /* @__PURE__ */ application("rtf", "rtf");
var Application_Rtploopback = /* @__PURE__ */ application("rtploopback");
var Application_Rtx = /* @__PURE__ */ application("rtx");
var Application_SamlassertionXml = /* @__PURE__ */ application("samlassertion+xml", "xml");
var Application_SamlmetadataXml = /* @__PURE__ */ application("samlmetadata+xml", "xml");
var Application_SbmlXml = /* @__PURE__ */ application("sbml+xml", "sbml");
var Application_ScaipXml = /* @__PURE__ */ application("scaip+xml", "xml");
var Application_ScimJson = /* @__PURE__ */ application("scim+json", "json");
var Application_Scvp_Cv_Request = /* @__PURE__ */ application("scvp-cv-request", "scq");
var Application_Scvp_Cv_Response = /* @__PURE__ */ application("scvp-cv-response", "scs");
var Application_Scvp_Vp_Request = /* @__PURE__ */ application("scvp-vp-request", "spq");
var Application_Scvp_Vp_Response = /* @__PURE__ */ application("scvp-vp-response", "spp");
var Application_Sdp = /* @__PURE__ */ application("sdp", "sdp");
var Application_SeceventJwt = /* @__PURE__ */ application("secevent+jwt", "jwt");
var Application_Senml_Exi = /* @__PURE__ */ application("senml-exi");
var Application_SenmlCbor = /* @__PURE__ */ application("senml+cbor", "cbor");
var Application_SenmlJson = /* @__PURE__ */ application("senml+json", "json");
var Application_SenmlXml = /* @__PURE__ */ application("senml+xml", "xml");
var Application_Sensml_Exi = /* @__PURE__ */ application("sensml-exi");
var Application_SensmlCbor = /* @__PURE__ */ application("sensml+cbor", "cbor");
var Application_SensmlJson = /* @__PURE__ */ application("sensml+json", "json");
var Application_SensmlXml = /* @__PURE__ */ application("sensml+xml", "xml");
var Application_Sep_Exi = /* @__PURE__ */ application("sep-exi");
var Application_SepXml = /* @__PURE__ */ application("sep+xml", "xml");
var Application_Session_Info = /* @__PURE__ */ application("session-info");
var Application_Set_Payment = /* @__PURE__ */ application("set-payment");
var Application_Set_Payment_Initiation = /* @__PURE__ */ application("set-payment-initiation", "setpay");
var Application_Set_Registration = /* @__PURE__ */ application("set-registration");
var Application_Set_Registration_Initiation = /* @__PURE__ */ application("set-registration-initiation", "setreg");
var Application_SGML = /* @__PURE__ */ application("sgml");
var Application_Sgml_Open_Catalog = /* @__PURE__ */ application("sgml-open-catalog");
var Application_ShfXml = /* @__PURE__ */ application("shf+xml", "shf");
var Application_Sieve = /* @__PURE__ */ application("sieve");
var Application_Simple_FilterXml = /* @__PURE__ */ application("simple-filter+xml", "xml");
var Application_Simple_Message_Summary = /* @__PURE__ */ application("simple-message-summary");
var Application_SimpleSymbolContainer = /* @__PURE__ */ application("simplesymbolcontainer");
var Application_Sipc = /* @__PURE__ */ application("sipc");
var Application_Slate = /* @__PURE__ */ application("slate");
var Application_Smil = /* @__PURE__ */ application("smil").deprecate("in favor of application/smil+xml");
var Application_SmilXml = /* @__PURE__ */ application("smil+xml", "smi", "smil");
var Application_Smpte336m = /* @__PURE__ */ application("smpte336m");
var Application_SoapFastinfoset = /* @__PURE__ */ application("soap+fastinfoset", "fastinfoset");
var Application_SoapXml = /* @__PURE__ */ application("soap+xml", "xml");
var Application_Sparql_Query = /* @__PURE__ */ application("sparql-query", "rq");
var Application_Sparql_ResultsXml = /* @__PURE__ */ application("sparql-results+xml", "srx");
var Application_Spirits_EventXml = /* @__PURE__ */ application("spirits-event+xml", "xml");
var Application_Sql = /* @__PURE__ */ application("sql");
var Application_Srgs = /* @__PURE__ */ application("srgs", "gram");
var Application_SrgsXml = /* @__PURE__ */ application("srgs+xml", "grxml");
var Application_SruXml = /* @__PURE__ */ application("sru+xml", "sru");
var Application_SsdlXml = /* @__PURE__ */ application("ssdl+xml", "ssdl");
var Application_SsmlXml = /* @__PURE__ */ application("ssml+xml", "ssml");
var Application_StixJson = /* @__PURE__ */ application("stix+json", "json");
var Application_SwidXml = /* @__PURE__ */ application("swid+xml", "xml");
var Application_Tamp_Apex_Update = /* @__PURE__ */ application("tamp-apex-update");
var Application_Tamp_Apex_Update_Confirm = /* @__PURE__ */ application("tamp-apex-update-confirm");
var Application_Tamp_Community_Update = /* @__PURE__ */ application("tamp-community-update");
var Application_Tamp_Community_Update_Confirm = /* @__PURE__ */ application("tamp-community-update-confirm");
var Application_Tamp_Error = /* @__PURE__ */ application("tamp-error");
var Application_Tamp_Sequence_Adjust = /* @__PURE__ */ application("tamp-sequence-adjust");
var Application_Tamp_Sequence_Adjust_Confirm = /* @__PURE__ */ application("tamp-sequence-adjust-confirm");
var Application_Tamp_Status_Query = /* @__PURE__ */ application("tamp-status-query");
var Application_Tamp_Status_Response = /* @__PURE__ */ application("tamp-status-response");
var Application_Tamp_Update = /* @__PURE__ */ application("tamp-update");
var Application_Tamp_Update_Confirm = /* @__PURE__ */ application("tamp-update-confirm");
var Application_Tar = /* @__PURE__ */ application("tar");
var Application_TaxiiJson = /* @__PURE__ */ application("taxii+json", "json");
var Application_TeiXml = /* @__PURE__ */ application("tei+xml", "tei", "teicorpus");
var Application_TETRA_ISI = /* @__PURE__ */ application("tetra_isi");
var Application_ThraudXml = /* @__PURE__ */ application("thraud+xml", "tfi");
var Application_Timestamp_Query = /* @__PURE__ */ application("timestamp-query");
var Application_Timestamp_Reply = /* @__PURE__ */ application("timestamp-reply");
var Application_Timestamped_Data = /* @__PURE__ */ application("timestamped-data", "tsd");
var Application_TlsrptGzip = /* @__PURE__ */ application("tlsrpt+gzip", "gzip");
var Application_TlsrptJson = /* @__PURE__ */ application("tlsrpt+json", "json");
var Application_Tnauthlist = /* @__PURE__ */ application("tnauthlist");
var Application_Toml = /* @__PURE__ */ application("toml", "toml");
var Application_Trickle_Ice_Sdpfrag = /* @__PURE__ */ application("trickle-ice-sdpfrag");
var Application_Trig = /* @__PURE__ */ application("trig");
var Application_TtmlXml = /* @__PURE__ */ application("ttml+xml", "xml");
var Application_Tve_Trigger = /* @__PURE__ */ application("tve-trigger");
var Application_Tzif = /* @__PURE__ */ application("tzif");
var Application_Tzif_Leap = /* @__PURE__ */ application("tzif-leap");
var Application_Ubjson = /* @__PURE__ */ application("ubjson", "ubj");
var Application_Ulpfec = /* @__PURE__ */ application("ulpfec");
var Application_Urc_GrpsheetXml = /* @__PURE__ */ application("urc-grpsheet+xml", "xml");
var Application_Urc_RessheetXml = /* @__PURE__ */ application("urc-ressheet+xml", "xml");
var Application_Urc_TargetdescXml = /* @__PURE__ */ application("urc-targetdesc+xml", "xml");
var Application_Urc_UisocketdescXml = /* @__PURE__ */ application("urc-uisocketdesc+xml", "xml");
var Application_VcardJson = /* @__PURE__ */ application("vcard+json", "json");
var Application_VcardXml = /* @__PURE__ */ application("vcard+xml", "xml");
var Application_Vemmi = /* @__PURE__ */ application("vemmi");
var Application_Vendor_1000mindsDecision_ModelXml = /* @__PURE__ */ application("vnd.1000minds.decision-model+xml", "xml");
var Application_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ application("1d-interleaved-parityfec");
var Application_Vendor_3gpdash_Qoe_ReportXml = /* @__PURE__ */ application("3gpdash-qoe-report+xml", "xml");
var Application_Vendor_3gpp_ImsXml = /* @__PURE__ */ application("3gpp-ims+xml", "xml");
var Application_Vendor_3gpp_Prose_Pc3chXml = /* @__PURE__ */ application("vnd.3gpp-prose-pc3ch+xml", "xml");
var Application_Vendor_3gpp_ProseXml = /* @__PURE__ */ application("vnd.3gpp-prose+xml", "xml");
var Application_Vendor_3gpp_V2x_Local_Service_Information = /* @__PURE__ */ application("vnd.3gpp-v2x-local-service-information");
var Application_Vendor_3gpp2BcmcsinfoXml = /* @__PURE__ */ application("vnd.3gpp2.bcmcsinfo+xml", "xml");
var Application_Vendor_3gpp2Sms = /* @__PURE__ */ application("vnd.3gpp2.sms");
var Application_Vendor_3gpp2Tcap = /* @__PURE__ */ application("vnd.3gpp2.tcap", "tcap");
var Application_Vendor_3gppAccess_Transfer_EventsXml = /* @__PURE__ */ application("vnd.3gpp.access-transfer-events+xml", "xml");
var Application_Vendor_3gppBsfXml = /* @__PURE__ */ application("vnd.3gpp.bsf+xml", "xml");
var Application_Vendor_3gppGMOPXml = /* @__PURE__ */ application("vnd.3gpp.gmop+xml", "xml");
var Application_Vendor_3gppMc_Signalling_Ear = /* @__PURE__ */ application("vnd.3gpp.mc-signalling-ear");
var Application_Vendor_3gppMcdata_Affiliation_CommandXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-affiliation-command+xml", "xml");
var Application_Vendor_3gppMcdata_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-info+xml", "xml");
var Application_Vendor_3gppMcdata_Payload = /* @__PURE__ */ application("vnd.3gpp.mcdata-payload");
var Application_Vendor_3gppMcdata_Service_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-service-config+xml", "xml");
var Application_Vendor_3gppMcdata_Signalling = /* @__PURE__ */ application("vnd.3gpp.mcdata-signalling");
var Application_Vendor_3gppMcdata_Ue_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-ue-config+xml", "xml");
var Application_Vendor_3gppMcdata_User_ProfileXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-user-profile+xml", "xml");
var Application_Vendor_3gppMcptt_Affiliation_CommandXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-affiliation-command+xml", "xml");
var Application_Vendor_3gppMcptt_Floor_RequestXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-floor-request+xml", "xml");
var Application_Vendor_3gppMcptt_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-info+xml", "xml");
var Application_Vendor_3gppMcptt_Location_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-location-info+xml", "xml");
var Application_Vendor_3gppMcptt_Mbms_Usage_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-mbms-usage-info+xml", "xml");
var Application_Vendor_3gppMcptt_Service_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-service-config+xml", "xml");
var Application_Vendor_3gppMcptt_SignedXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-signed+xml", "xml");
var Application_Vendor_3gppMcptt_Ue_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-ue-config+xml", "xml");
var Application_Vendor_3gppMcptt_Ue_Init_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-ue-init-config+xml", "xml");
var Application_Vendor_3gppMcptt_User_ProfileXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-user-profile+xml", "xml");
var Application_Vendor_3gppMcvideo_Affiliation_CommandXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-affiliation-command+xml", "xml");
var Application_Vendor_3gppMcvideo_Affiliation_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-affiliation-info+xml", "xml").deprecate("in favor of application/vnd.3gpp.mcvideo-info+xml");
var Application_Vendor_3gppMcvideo_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-info+xml", "xml");
var Application_Vendor_3gppMcvideo_Location_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-location-info+xml", "xml");
var Application_Vendor_3gppMcvideo_Mbms_Usage_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-mbms-usage-info+xml", "xml");
var Application_Vendor_3gppMcvideo_Service_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-service-config+xml", "xml");
var Application_Vendor_3gppMcvideo_Transmission_RequestXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-transmission-request+xml", "xml");
var Application_Vendor_3gppMcvideo_Ue_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-ue-config+xml", "xml");
var Application_Vendor_3gppMcvideo_User_ProfileXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-user-profile+xml", "xml");
var Application_Vendor_3gppMid_CallXml = /* @__PURE__ */ application("vnd.3gpp.mid-call+xml", "xml");
var Application_Vendor_3gppPic_Bw_Large = /* @__PURE__ */ application("vnd.3gpp.pic-bw-large", "plb");
var Application_Vendor_3gppPic_Bw_Small = /* @__PURE__ */ application("vnd.3gpp.pic-bw-small", "psb");
var Application_Vendor_3gppPic_Bw_Var = /* @__PURE__ */ application("vnd.3gpp.pic-bw-var", "pvb");
var Application_Vendor_3gppSms = /* @__PURE__ */ application("vnd.3gpp.sms");
var Application_Vendor_3gppSmsXml = /* @__PURE__ */ application("vnd.3gpp.sms+xml", "xml");
var Application_Vendor_3gppSrvcc_ExtXml = /* @__PURE__ */ application("vnd.3gpp.srvcc-ext+xml", "xml");
var Application_Vendor_3gppSRVCC_InfoXml = /* @__PURE__ */ application("vnd.3gpp.srvcc-info+xml", "xml");
var Application_Vendor_3gppState_And_Event_InfoXml = /* @__PURE__ */ application("vnd.3gpp.state-and-event-info+xml", "xml");
var Application_Vendor_3gppUssdXml = /* @__PURE__ */ application("vnd.3gpp.ussd+xml", "xml");
var Application_Vendor_3lightssoftwareImagescal = /* @__PURE__ */ application("vnd.3lightssoftware.imagescal");
var Application_Vendor_3MPost_It_Notes = /* @__PURE__ */ application("vnd.3m.post-it-notes", "pwn");
var Application_Vendor_AccpacSimplyAso = /* @__PURE__ */ application("vnd.accpac.simply.aso", "aso");
var Application_Vendor_AccpacSimplyImp = /* @__PURE__ */ application("vnd.accpac.simply.imp", "imp");
var Application_Vendor_Acucobol = /* @__PURE__ */ application("vnd.acucobol", "acu");
var Application_Vendor_Acucorp = /* @__PURE__ */ application("vnd.acucorp", "atc", "acutc");
var Application_Vendor_AdobeAir_Application_Installer_PackageZip = /* @__PURE__ */ application("vnd.adobe.air-application-installer-package+zip", "air");
var Application_Vendor_AdobeFlashMovie = /* @__PURE__ */ application("vnd.adobe.flash.movie");
var Application_Vendor_AdobeFormscentralFcdt = /* @__PURE__ */ application("vnd.adobe.formscentral.fcdt", "fcdt");
var Application_Vendor_AdobeFxp = /* @__PURE__ */ application("vnd.adobe.fxp", "fxp", "fxpl");
var Application_Vendor_AdobePartial_Upload = /* @__PURE__ */ application("vnd.adobe.partial-upload");
var Application_Vendor_AdobeXdpXml = /* @__PURE__ */ application("vnd.adobe.xdp+xml", "xdp");
var Application_Vendor_AdobeXfdf = /* @__PURE__ */ application("vnd.adobe.xfdf", "xfdf");
var Application_Vendor_AetherImp = /* @__PURE__ */ application("vnd.aether.imp");
var Application_Vendor_AfpcAfplinedata = /* @__PURE__ */ application("vnd.afpc.afplinedata");
var Application_Vendor_AfpcAfplinedata_Pagedef = /* @__PURE__ */ application("vnd.afpc.afplinedata-pagedef");
var Application_Vendor_AfpcFoca_Charset = /* @__PURE__ */ application("vnd.afpc.foca-charset");
var Application_Vendor_AfpcFoca_Codedfont = /* @__PURE__ */ application("vnd.afpc.foca-codedfont");
var Application_Vendor_AfpcFoca_Codepage = /* @__PURE__ */ application("vnd.afpc.foca-codepage");
var Application_Vendor_AfpcModca = /* @__PURE__ */ application("vnd.afpc.modca");
var Application_Vendor_AfpcModca_Formdef = /* @__PURE__ */ application("vnd.afpc.modca-formdef");
var Application_Vendor_AfpcModca_Mediummap = /* @__PURE__ */ application("vnd.afpc.modca-mediummap");
var Application_Vendor_AfpcModca_Objectcontainer = /* @__PURE__ */ application("vnd.afpc.modca-objectcontainer");
var Application_Vendor_AfpcModca_Overlay = /* @__PURE__ */ application("vnd.afpc.modca-overlay");
var Application_Vendor_AfpcModca_Pagesegment = /* @__PURE__ */ application("vnd.afpc.modca-pagesegment");
var Application_Vendor_Ah_Barcode = /* @__PURE__ */ application("vnd.ah-barcode");
var Application_Vendor_AheadSpace = /* @__PURE__ */ application("vnd.ahead.space", "ahead");
var Application_Vendor_AirzipFilesecureAzf = /* @__PURE__ */ application("vnd.airzip.filesecure.azf", "azf");
var Application_Vendor_AirzipFilesecureAzs = /* @__PURE__ */ application("vnd.airzip.filesecure.azs", "azs");
var Application_Vendor_AmadeusJson = /* @__PURE__ */ application("vnd.amadeus+json", "json");
var Application_Vendor_AmazonEbook = /* @__PURE__ */ application("vnd.amazon.ebook", "azw");
var Application_Vendor_AmazonMobi8_Ebook = /* @__PURE__ */ application("vnd.amazon.mobi8-ebook");
var Application_Vendor_AmericandynamicsAcc = /* @__PURE__ */ application("vnd.americandynamics.acc", "acc");
var Application_Vendor_AmigaAmi = /* @__PURE__ */ application("vnd.amiga.ami", "ami");
var Application_Vendor_AmundsenMazeXml = /* @__PURE__ */ application("vnd.amundsen.maze+xml", "xml");
var Application_Vendor_AndroidOta = /* @__PURE__ */ application("vnd.android.ota");
var Application_Vendor_AndroidPackage_Archive = /* @__PURE__ */ application("vnd.android.package-archive", "apk");
var Application_Vendor_Anki = /* @__PURE__ */ application("vnd.anki");
var Application_Vendor_Anser_Web_Certificate_Issue_Initiation = /* @__PURE__ */ application("vnd.anser-web-certificate-issue-initiation", "cii");
var Application_Vendor_Anser_Web_Funds_Transfer_Initiation = /* @__PURE__ */ application("vnd.anser-web-funds-transfer-initiation", "fti");
var Application_Vendor_AntixGame_Component = /* @__PURE__ */ application("vnd.antix.game-component", "atx");
var Application_Vendor_ApacheThriftBinary = /* @__PURE__ */ application("vnd.apache.thrift.binary");
var Application_Vendor_ApacheThriftCompact = /* @__PURE__ */ application("vnd.apache.thrift.compact");
var Application_Vendor_ApacheThriftJson = /* @__PURE__ */ application("vnd.apache.thrift.json");
var Application_Vendor_ApiJson = /* @__PURE__ */ application("vnd.api+json", "json");
var Application_Vendor_AplextorWarrpJson = /* @__PURE__ */ application("vnd.aplextor.warrp+json", "json");
var Application_Vendor_ApothekendeReservationJson = /* @__PURE__ */ application("vnd.apothekende.reservation+json", "json");
var Application_Vendor_AppleInstallerXml = /* @__PURE__ */ application("vnd.apple.installer+xml", "mpkg");
var Application_Vendor_AppleKeynote = /* @__PURE__ */ application("vnd.apple.keynote");
var Application_Vendor_AppleMpegurl = /* @__PURE__ */ application("vnd.apple.mpegurl", "m3u8");
var Application_Vendor_AppleNumbers = /* @__PURE__ */ application("vnd.apple.numbers");
var Application_Vendor_ApplePages = /* @__PURE__ */ application("vnd.apple.pages");
var Application_Vendor_ApplePkpass = /* @__PURE__ */ application("vnd.apple.pkpass", "pkpass");
var Application_Vendor_ArastraSwi = /* @__PURE__ */ application("vnd.arastra.swi").deprecate("in favor of application/vnd.aristanetworks.swi");
var Application_Vendor_AristanetworksSwi = /* @__PURE__ */ application("vnd.aristanetworks.swi", "swi");
var Application_Vendor_ArtisanJson = /* @__PURE__ */ application("vnd.artisan+json", "json");
var Application_Vendor_Artsquare = /* @__PURE__ */ application("vnd.artsquare");
var Application_Vendor_Astraea_SoftwareIota = /* @__PURE__ */ application("vnd.astraea-software.iota", "iota");
var Application_Vendor_Audiograph = /* @__PURE__ */ application("vnd.audiograph", "aep");
var Application_Vendor_Autopackage = /* @__PURE__ */ application("vnd.autopackage");
var Application_Vendor_AvalonJson = /* @__PURE__ */ application("vnd.avalon+json", "json");
var Application_Vendor_AvistarXml = /* @__PURE__ */ application("vnd.avistar+xml", "xml");
var Application_Vendor_BalsamiqBmmlXml = /* @__PURE__ */ application("vnd.balsamiq.bmml+xml", "xml");
var Application_Vendor_BalsamiqBmpr = /* @__PURE__ */ application("vnd.balsamiq.bmpr");
var Application_Vendor_Banana_Accounting = /* @__PURE__ */ application("vnd.banana-accounting");
var Application_Vendor_BbfUspError = /* @__PURE__ */ application("vnd.bbf.usp.error");
var Application_Vendor_BbfUspMsg = /* @__PURE__ */ application("vnd.bbf.usp.msg");
var Application_Vendor_BbfUspMsgJson = /* @__PURE__ */ application("vnd.bbf.usp.msg+json", "json");
var Application_Vendor_Bekitzur_StechJson = /* @__PURE__ */ application("vnd.bekitzur-stech+json", "json");
var Application_Vendor_BintMed_Content = /* @__PURE__ */ application("vnd.bint.med-content");
var Application_Vendor_BiopaxRdfXml = /* @__PURE__ */ application("vnd.biopax.rdf+xml", "xml");
var Application_Vendor_Blink_Idb_Value_Wrapper = /* @__PURE__ */ application("vnd.blink-idb-value-wrapper");
var Application_Vendor_BlueiceMultipass = /* @__PURE__ */ application("vnd.blueice.multipass", "mpm");
var Application_Vendor_BluetoothEpOob = /* @__PURE__ */ application("vnd.bluetooth.ep.oob");
var Application_Vendor_BluetoothLeOob = /* @__PURE__ */ application("vnd.bluetooth.le.oob");
var Application_Vendor_Bmi = /* @__PURE__ */ application("vnd.bmi", "bmi");
var Application_Vendor_Bpf = /* @__PURE__ */ application("vnd.bpf");
var Application_Vendor_Bpf3 = /* @__PURE__ */ application("vnd.bpf3");
var Application_Vendor_Businessobjects = /* @__PURE__ */ application("vnd.businessobjects", "rep");
var Application_Vendor_ByuUapiJson = /* @__PURE__ */ application("vnd.byu.uapi+json", "json");
var Application_Vendor_Cab_Jscript = /* @__PURE__ */ application("vnd.cab-jscript");
var Application_Vendor_Canon_Cpdl = /* @__PURE__ */ application("vnd.canon-cpdl");
var Application_Vendor_Canon_Lips = /* @__PURE__ */ application("vnd.canon-lips");
var Application_Vendor_Capasystems_PgJson = /* @__PURE__ */ application("vnd.capasystems-pg+json", "json");
var Application_Vendor_CendioThinlincClientconf = /* @__PURE__ */ application("vnd.cendio.thinlinc.clientconf");
var Application_Vendor_Century_SystemsTcp_stream = /* @__PURE__ */ application("vnd.century-systems.tcp_stream");
var Application_Vendor_ChemdrawXml = /* @__PURE__ */ application("vnd.chemdraw+xml", "cdxml");
var Application_Vendor_Chess_Pgn = /* @__PURE__ */ application("vnd.chess-pgn");
var Application_Vendor_ChipnutsKaraoke_Mmd = /* @__PURE__ */ application("vnd.chipnuts.karaoke-mmd", "mmd");
var Application_Vendor_Ciedi = /* @__PURE__ */ application("vnd.ciedi");
var Application_Vendor_Cinderella = /* @__PURE__ */ application("vnd.cinderella", "cdy");
var Application_Vendor_CirpackIsdn_Ext = /* @__PURE__ */ application("vnd.cirpack.isdn-ext");
var Application_Vendor_CitationstylesStyleXml = /* @__PURE__ */ application("vnd.citationstyles.style+xml", "xml");
var Application_Vendor_Claymore = /* @__PURE__ */ application("vnd.claymore", "cla");
var Application_Vendor_CloantoRp9 = /* @__PURE__ */ application("vnd.cloanto.rp9", "rp9");
var Application_Vendor_ClonkC4group = /* @__PURE__ */ application("vnd.clonk.c4group", "c4g", "c4d", "c4f", "c4p", "c4u");
var Application_Vendor_CluetrustCartomobile_Config = /* @__PURE__ */ application("vnd.cluetrust.cartomobile-config", "c11amc");
var Application_Vendor_CluetrustCartomobile_Config_Pkg = /* @__PURE__ */ application("vnd.cluetrust.cartomobile-config-pkg", "c11amz");
var Application_Vendor_Coffeescript = /* @__PURE__ */ application("vnd.coffeescript");
var Application_Vendor_CollabioXodocumentsDocument = /* @__PURE__ */ application("vnd.collabio.xodocuments.document");
var Application_Vendor_CollabioXodocumentsDocument_Template = /* @__PURE__ */ application("vnd.collabio.xodocuments.document-template");
var Application_Vendor_CollabioXodocumentsPresentation = /* @__PURE__ */ application("vnd.collabio.xodocuments.presentation");
var Application_Vendor_CollabioXodocumentsPresentation_Template = /* @__PURE__ */ application("vnd.collabio.xodocuments.presentation-template");
var Application_Vendor_CollabioXodocumentsSpreadsheet = /* @__PURE__ */ application("vnd.collabio.xodocuments.spreadsheet");
var Application_Vendor_CollabioXodocumentsSpreadsheet_Template = /* @__PURE__ */ application("vnd.collabio.xodocuments.spreadsheet-template");
var Application_Vendor_CollectionDocJson = /* @__PURE__ */ application("vnd.collection.doc+json", "json");
var Application_Vendor_CollectionJson = /* @__PURE__ */ application("vnd.collection+json", "json");
var Application_Vendor_CollectionNextJson = /* @__PURE__ */ application("vnd.collection.next+json", "json");
var Application_Vendor_Comicbook_Rar = /* @__PURE__ */ application("vnd.comicbook-rar");
var Application_Vendor_ComicbookZip = /* @__PURE__ */ application("vnd.comicbook+zip", "zip");
var Application_Vendor_Commerce_Battelle = /* @__PURE__ */ application("vnd.commerce-battelle");
var Application_Vendor_Commonspace = /* @__PURE__ */ application("vnd.commonspace", "csp");
var Application_Vendor_ContactCmsg = /* @__PURE__ */ application("vnd.contact.cmsg", "cdbcmsg");
var Application_Vendor_CoreosIgnitionJson = /* @__PURE__ */ application("vnd.coreos.ignition+json", "json");
var Application_Vendor_Cosmocaller = /* @__PURE__ */ application("vnd.cosmocaller", "cmc");
var Application_Vendor_CrickClicker = /* @__PURE__ */ application("vnd.crick.clicker", "clkx");
var Application_Vendor_CrickClickerKeyboard = /* @__PURE__ */ application("vnd.crick.clicker.keyboard", "clkk");
var Application_Vendor_CrickClickerPalette = /* @__PURE__ */ application("vnd.crick.clicker.palette", "clkp");
var Application_Vendor_CrickClickerTemplate = /* @__PURE__ */ application("vnd.crick.clicker.template", "clkt");
var Application_Vendor_CrickClickerWordbank = /* @__PURE__ */ application("vnd.crick.clicker.wordbank", "clkw");
var Application_Vendor_CriticaltoolsWbsXml = /* @__PURE__ */ application("vnd.criticaltools.wbs+xml", "wbs");
var Application_Vendor_CryptiiPipeJson = /* @__PURE__ */ application("vnd.cryptii.pipe+json", "json");
var Application_Vendor_Crypto_Shade_File = /* @__PURE__ */ application("vnd.crypto-shade-file");
var Application_Vendor_Ctc_Posml = /* @__PURE__ */ application("vnd.ctc-posml", "pml");
var Application_Vendor_CtctWsXml = /* @__PURE__ */ application("vnd.ctct.ws+xml", "xml");
var Application_Vendor_Cups_Pdf = /* @__PURE__ */ application("vnd.cups-pdf");
var Application_Vendor_Cups_Postscript = /* @__PURE__ */ application("vnd.cups-postscript");
var Application_Vendor_Cups_Ppd = /* @__PURE__ */ application("vnd.cups-ppd", "ppd");
var Application_Vendor_Cups_Raster = /* @__PURE__ */ application("vnd.cups-raster");
var Application_Vendor_Cups_Raw = /* @__PURE__ */ application("vnd.cups-raw");
var Application_Vendor_Curl = /* @__PURE__ */ application("vnd.curl");
var Application_Vendor_CurlCar = /* @__PURE__ */ application("vnd.curl.car", "car");
var Application_Vendor_CurlPcurl = /* @__PURE__ */ application("vnd.curl.pcurl", "pcurl");
var Application_Vendor_CyanDeanRootXml = /* @__PURE__ */ application("vnd.cyan.dean.root+xml", "xml");
var Application_Vendor_Cybank = /* @__PURE__ */ application("vnd.cybank");
var Application_Vendor_D2lCoursepackage1p0Zip = /* @__PURE__ */ application("vnd.d2l.coursepackage1p0+zip", "zip");
var Application_Vendor_Dart = /* @__PURE__ */ application("vnd.dart", "dart");
var Application_Vendor_Data_VisionRdz = /* @__PURE__ */ application("vnd.data-vision.rdz", "rdz");
var Application_Vendor_DatapackageJson = /* @__PURE__ */ application("vnd.datapackage+json", "json");
var Application_Vendor_DataresourceJson = /* @__PURE__ */ application("vnd.dataresource+json", "json");
var Application_Vendor_DebianBinary_Package = /* @__PURE__ */ application("vnd.debian.binary-package");
var Application_Vendor_DeceData = /* @__PURE__ */ application("vnd.dece.data", "uvf", "uvvf", "uvd", "uvvd");
var Application_Vendor_DeceTtmlXml = /* @__PURE__ */ application("vnd.dece.ttml+xml", "uvt", "uvvt");
var Application_Vendor_DeceUnspecified = /* @__PURE__ */ application("vnd.dece.unspecified", "uvx", "uvvx");
var Application_Vendor_DeceZip = /* @__PURE__ */ application("vnd.dece.zip", "uvz", "uvvz");
var Application_Vendor_DenovoFcselayout_Link = /* @__PURE__ */ application("vnd.denovo.fcselayout-link", "fe_launch");
var Application_Vendor_DesmumeMovie = /* @__PURE__ */ application("vnd.desmume.movie");
var Application_Vendor_Dir_BiPlate_Dl_Nosuffix = /* @__PURE__ */ application("vnd.dir-bi.plate-dl-nosuffix");
var Application_Vendor_DmDelegationXml = /* @__PURE__ */ application("vnd.dm.delegation+xml", "xml");
var Application_Vendor_Dna = /* @__PURE__ */ application("vnd.dna", "dna");
var Application_Vendor_DocumentJson = /* @__PURE__ */ application("vnd.document+json", "json");
var Application_Vendor_DolbyMlp = /* @__PURE__ */ application("vnd.dolby.mlp", "mlp");
var Application_Vendor_DolbyMobile1 = /* @__PURE__ */ application("vnd.dolby.mobile.1");
var Application_Vendor_DolbyMobile2 = /* @__PURE__ */ application("vnd.dolby.mobile.2");
var Application_Vendor_DoremirScorecloud_Binary_Document = /* @__PURE__ */ application("vnd.doremir.scorecloud-binary-document");
var Application_Vendor_Dpgraph = /* @__PURE__ */ application("vnd.dpgraph", "dpg");
var Application_Vendor_Dreamfactory = /* @__PURE__ */ application("vnd.dreamfactory", "dfac");
var Application_Vendor_DriveJson = /* @__PURE__ */ application("vnd.drive+json", "json");
var Application_Vendor_Ds_Keypoint = /* @__PURE__ */ application("vnd.ds-keypoint", "kpxx");
var Application_Vendor_DtgLocal = /* @__PURE__ */ application("vnd.dtg.local");
var Application_Vendor_DtgLocalFlash = /* @__PURE__ */ application("vnd.dtg.local.flash");
var Application_Vendor_DtgLocalHtml = /* @__PURE__ */ application("vnd.dtg.local.html");
var Application_Vendor_DvbAit = /* @__PURE__ */ application("vnd.dvb.ait", "ait");
var Application_Vendor_DvbDvbj = /* @__PURE__ */ application("vnd.dvb.dvbj");
var Application_Vendor_DvbEsgcontainer = /* @__PURE__ */ application("vnd.dvb.esgcontainer");
var Application_Vendor_DvbIpdcdftnotifaccess = /* @__PURE__ */ application("vnd.dvb.ipdcdftnotifaccess");
var Application_Vendor_DvbIpdcesgaccess = /* @__PURE__ */ application("vnd.dvb.ipdcesgaccess");
var Application_Vendor_DvbIpdcesgaccess2 = /* @__PURE__ */ application("vnd.dvb.ipdcesgaccess2");
var Application_Vendor_DvbIpdcesgpdd = /* @__PURE__ */ application("vnd.dvb.ipdcesgpdd");
var Application_Vendor_DvbIpdcroaming = /* @__PURE__ */ application("vnd.dvb.ipdcroaming");
var Application_Vendor_DvbIptvAlfec_Base = /* @__PURE__ */ application("vnd.dvb.iptv.alfec-base");
var Application_Vendor_DvbIptvAlfec_Enhancement = /* @__PURE__ */ application("vnd.dvb.iptv.alfec-enhancement");
var Application_Vendor_DvbNotif_Aggregate_RootXml = /* @__PURE__ */ application("vnd.dvb.notif-aggregate-root+xml", "xml");
var Application_Vendor_DvbNotif_ContainerXml = /* @__PURE__ */ application("vnd.dvb.notif-container+xml", "xml");
var Application_Vendor_DvbNotif_GenericXml = /* @__PURE__ */ application("vnd.dvb.notif-generic+xml", "xml");
var Application_Vendor_DvbNotif_Ia_MsglistXml = /* @__PURE__ */ application("vnd.dvb.notif-ia-msglist+xml", "xml");
var Application_Vendor_DvbNotif_Ia_Registration_RequestXml = /* @__PURE__ */ application("vnd.dvb.notif-ia-registration-request+xml", "xml");
var Application_Vendor_DvbNotif_Ia_Registration_ResponseXml = /* @__PURE__ */ application("vnd.dvb.notif-ia-registration-response+xml", "xml");
var Application_Vendor_DvbNotif_InitXml = /* @__PURE__ */ application("vnd.dvb.notif-init+xml", "xml");
var Application_Vendor_DvbPfr = /* @__PURE__ */ application("vnd.dvb.pfr");
var Application_Vendor_DvbService = /* @__PURE__ */ application("vnd.dvb.service", "svc");
var Application_Vendor_Dxr = /* @__PURE__ */ application("vnd.dxr");
var Application_Vendor_Dynageo = /* @__PURE__ */ application("vnd.dynageo", "geo");
var Application_Vendor_Dzr = /* @__PURE__ */ application("vnd.dzr");
var Application_Vendor_EasykaraokeCdgdownload = /* @__PURE__ */ application("vnd.easykaraoke.cdgdownload");
var Application_Vendor_Ecdis_Update = /* @__PURE__ */ application("vnd.ecdis-update");
var Application_Vendor_EcipRlp = /* @__PURE__ */ application("vnd.ecip.rlp");
var Application_Vendor_EcowinChart = /* @__PURE__ */ application("vnd.ecowin.chart", "mag");
var Application_Vendor_EcowinFilerequest = /* @__PURE__ */ application("vnd.ecowin.filerequest");
var Application_Vendor_EcowinFileupdate = /* @__PURE__ */ application("vnd.ecowin.fileupdate");
var Application_Vendor_EcowinSeries = /* @__PURE__ */ application("vnd.ecowin.series");
var Application_Vendor_EcowinSeriesrequest = /* @__PURE__ */ application("vnd.ecowin.seriesrequest");
var Application_Vendor_EcowinSeriesupdate = /* @__PURE__ */ application("vnd.ecowin.seriesupdate");
var Application_Vendor_EfiImg = /* @__PURE__ */ application("vnd.efi.img");
var Application_Vendor_EfiIso = /* @__PURE__ */ application("vnd.efi.iso");
var Application_Vendor_EmclientAccessrequestXml = /* @__PURE__ */ application("vnd.emclient.accessrequest+xml", "xml");
var Application_Vendor_Enliven = /* @__PURE__ */ application("vnd.enliven", "nml");
var Application_Vendor_EnphaseEnvoy = /* @__PURE__ */ application("vnd.enphase.envoy");
var Application_Vendor_EprintsDataXml = /* @__PURE__ */ application("vnd.eprints.data+xml", "xml");
var Application_Vendor_EpsonEsf = /* @__PURE__ */ application("vnd.epson.esf", "esf");
var Application_Vendor_EpsonMsf = /* @__PURE__ */ application("vnd.epson.msf", "msf");
var Application_Vendor_EpsonQuickanime = /* @__PURE__ */ application("vnd.epson.quickanime", "qam");
var Application_Vendor_EpsonSalt = /* @__PURE__ */ application("vnd.epson.salt", "slt");
var Application_Vendor_EpsonSsf = /* @__PURE__ */ application("vnd.epson.ssf", "ssf");
var Application_Vendor_EricssonQuickcall = /* @__PURE__ */ application("vnd.ericsson.quickcall");
var Application_Vendor_Espass_EspassZip = /* @__PURE__ */ application("vnd.espass-espass+zip", "zip");
var Application_Vendor_Eszigno3Xml = /* @__PURE__ */ application("vnd.eszigno3+xml", "es3", "et3");
var Application_Vendor_EtsiAocXml = /* @__PURE__ */ application("vnd.etsi.aoc+xml", "xml");
var Application_Vendor_EtsiAsic_EZip = /* @__PURE__ */ application("vnd.etsi.asic-e+zip", "zip");
var Application_Vendor_EtsiAsic_SZip = /* @__PURE__ */ application("vnd.etsi.asic-s+zip", "zip");
var Application_Vendor_EtsiCugXml = /* @__PURE__ */ application("vnd.etsi.cug+xml", "xml");
var Application_Vendor_EtsiIptvcommandXml = /* @__PURE__ */ application("vnd.etsi.iptvcommand+xml", "xml");
var Application_Vendor_EtsiIptvdiscoveryXml = /* @__PURE__ */ application("vnd.etsi.iptvdiscovery+xml", "xml");
var Application_Vendor_EtsiIptvprofileXml = /* @__PURE__ */ application("vnd.etsi.iptvprofile+xml", "xml");
var Application_Vendor_EtsiIptvsad_BcXml = /* @__PURE__ */ application("vnd.etsi.iptvsad-bc+xml", "xml");
var Application_Vendor_EtsiIptvsad_CodXml = /* @__PURE__ */ application("vnd.etsi.iptvsad-cod+xml", "xml");
var Application_Vendor_EtsiIptvsad_NpvrXml = /* @__PURE__ */ application("vnd.etsi.iptvsad-npvr+xml", "xml");
var Application_Vendor_EtsiIptvserviceXml = /* @__PURE__ */ application("vnd.etsi.iptvservice+xml", "xml");
var Application_Vendor_EtsiIptvsyncXml = /* @__PURE__ */ application("vnd.etsi.iptvsync+xml", "xml");
var Application_Vendor_EtsiIptvueprofileXml = /* @__PURE__ */ application("vnd.etsi.iptvueprofile+xml", "xml");
var Application_Vendor_EtsiMcidXml = /* @__PURE__ */ application("vnd.etsi.mcid+xml", "xml");
var Application_Vendor_EtsiMheg5 = /* @__PURE__ */ application("vnd.etsi.mheg5");
var Application_Vendor_EtsiOverload_Control_Policy_DatasetXml = /* @__PURE__ */ application("vnd.etsi.overload-control-policy-dataset+xml", "xml");
var Application_Vendor_EtsiPstnXml = /* @__PURE__ */ application("vnd.etsi.pstn+xml", "xml");
var Application_Vendor_EtsiSciXml = /* @__PURE__ */ application("vnd.etsi.sci+xml", "xml");
var Application_Vendor_EtsiSimservsXml = /* @__PURE__ */ application("vnd.etsi.simservs+xml", "xml");
var Application_Vendor_EtsiTimestamp_Token = /* @__PURE__ */ application("vnd.etsi.timestamp-token");
var Application_Vendor_EtsiTslDer = /* @__PURE__ */ application("vnd.etsi.tsl.der");
var Application_Vendor_EtsiTslXml = /* @__PURE__ */ application("vnd.etsi.tsl+xml", "xml");
var Application_Vendor_EudoraData = /* @__PURE__ */ application("vnd.eudora.data");
var Application_Vendor_EvolvEcigProfile = /* @__PURE__ */ application("vnd.evolv.ecig.profile");
var Application_Vendor_EvolvEcigSettings = /* @__PURE__ */ application("vnd.evolv.ecig.settings");
var Application_Vendor_EvolvEcigTheme = /* @__PURE__ */ application("vnd.evolv.ecig.theme");
var Application_Vendor_Exstream_EmpowerZip = /* @__PURE__ */ application("vnd.exstream-empower+zip", "zip");
var Application_Vendor_Exstream_Package = /* @__PURE__ */ application("vnd.exstream-package");
var Application_Vendor_Ezpix_Album = /* @__PURE__ */ application("vnd.ezpix-album", "ez2");
var Application_Vendor_Ezpix_Package = /* @__PURE__ */ application("vnd.ezpix-package", "ez3");
var Application_Vendor_F_SecureMobile = /* @__PURE__ */ application("vnd.f-secure.mobile");
var Application_Vendor_Fastcopy_Disk_Image = /* @__PURE__ */ application("vnd.fastcopy-disk-image");
var Application_Vendor_Fdf = /* @__PURE__ */ application("vnd.fdf", "fdf");
var Application_Vendor_FdsnMseed = /* @__PURE__ */ application("vnd.fdsn.mseed", "mseed");
var Application_Vendor_FdsnSeed = /* @__PURE__ */ application("vnd.fdsn.seed", "seed", "dataless");
var Application_Vendor_Ffsns = /* @__PURE__ */ application("vnd.ffsns");
var Application_Vendor_FiclabFlbZip = /* @__PURE__ */ application("vnd.ficlab.flb+zip", "zip");
var Application_Vendor_FilmitZfc = /* @__PURE__ */ application("vnd.filmit.zfc");
var Application_Vendor_Fints = /* @__PURE__ */ application("vnd.fints");
var Application_Vendor_FiremonkeysCloudcell = /* @__PURE__ */ application("vnd.firemonkeys.cloudcell");
var Application_Vendor_FloGraphIt = /* @__PURE__ */ application("vnd.flographit", "gph");
var Application_Vendor_FluxtimeClip = /* @__PURE__ */ application("vnd.fluxtime.clip", "ftc");
var Application_Vendor_Font_Fontforge_Sfd = /* @__PURE__ */ application("vnd.font-fontforge-sfd");
var Application_Vendor_Framemaker = /* @__PURE__ */ application("vnd.framemaker", "fm", "frame", "maker", "book");
var Application_Vendor_FrogansFnc = /* @__PURE__ */ application("vnd.frogans.fnc", "fnc");
var Application_Vendor_FrogansLtf = /* @__PURE__ */ application("vnd.frogans.ltf", "ltf");
var Application_Vendor_FscWeblaunch = /* @__PURE__ */ application("vnd.fsc.weblaunch", "fsc");
var Application_Vendor_FujitsuOasys = /* @__PURE__ */ application("vnd.fujitsu.oasys", "oas");
var Application_Vendor_FujitsuOasys2 = /* @__PURE__ */ application("vnd.fujitsu.oasys2", "oa2");
var Application_Vendor_FujitsuOasys3 = /* @__PURE__ */ application("vnd.fujitsu.oasys3", "oa3");
var Application_Vendor_FujitsuOasysgp = /* @__PURE__ */ application("vnd.fujitsu.oasysgp", "fg5");
var Application_Vendor_FujitsuOasysprs = /* @__PURE__ */ application("vnd.fujitsu.oasysprs", "bh2");
var Application_Vendor_FujixeroxART_EX = /* @__PURE__ */ application("vnd.fujixerox.art-ex");
var Application_Vendor_FujixeroxART4 = /* @__PURE__ */ application("vnd.fujixerox.art4");
var Application_Vendor_FujixeroxDdd = /* @__PURE__ */ application("vnd.fujixerox.ddd", "ddd");
var Application_Vendor_FujixeroxDocuworks = /* @__PURE__ */ application("vnd.fujixerox.docuworks", "xdw");
var Application_Vendor_FujixeroxDocuworksBinder = /* @__PURE__ */ application("vnd.fujixerox.docuworks.binder", "xbd");
var Application_Vendor_FujixeroxDocuworksContainer = /* @__PURE__ */ application("vnd.fujixerox.docuworks.container");
var Application_Vendor_FujixeroxHBPL = /* @__PURE__ */ application("vnd.fujixerox.hbpl");
var Application_Vendor_Fut_Misnet = /* @__PURE__ */ application("vnd.fut-misnet");
var Application_Vendor_FutoinCbor = /* @__PURE__ */ application("vnd.futoin+cbor", "cbor");
var Application_Vendor_FutoinJson = /* @__PURE__ */ application("vnd.futoin+json", "json");
var Application_Vendor_Fuzzysheet = /* @__PURE__ */ application("vnd.fuzzysheet", "fzs");
var Application_Vendor_GenomatixTuxedo = /* @__PURE__ */ application("vnd.genomatix.tuxedo", "txd");
var Application_Vendor_GenticsGrdJson = /* @__PURE__ */ application("vnd.gentics.grd+json", "json");
var Application_Vendor_GeocubeXml = /* @__PURE__ */ application("vnd.geocube+xml", "xml").deprecate("by request");
var Application_Vendor_GeogebraFile = /* @__PURE__ */ application("vnd.geogebra.file", "ggb");
var Application_Vendor_GeogebraTool = /* @__PURE__ */ application("vnd.geogebra.tool", "ggt");
var Application_Vendor_GeoJson = /* @__PURE__ */ application("vnd.geo+json", "json").deprecate("in favor of application/geo+json");
var Application_Vendor_Geometry_Explorer = /* @__PURE__ */ application("vnd.geometry-explorer", "gex", "gre");
var Application_Vendor_Geonext = /* @__PURE__ */ application("vnd.geonext", "gxt");
var Application_Vendor_Geoplan = /* @__PURE__ */ application("vnd.geoplan", "g2w");
var Application_Vendor_Geospace = /* @__PURE__ */ application("vnd.geospace", "g3w");
var Application_Vendor_Gerber = /* @__PURE__ */ application("vnd.gerber");
var Application_Vendor_GlobalplatformCard_Content_Mgt = /* @__PURE__ */ application("vnd.globalplatform.card-content-mgt");
var Application_Vendor_GlobalplatformCard_Content_Mgt_Response = /* @__PURE__ */ application("vnd.globalplatform.card-content-mgt-response");
var Application_Vendor_Gmx = /* @__PURE__ */ application("vnd.gmx", "gmx").deprecate("with no reason given");
var Application_Vendor_Google_Apps_Document = /* @__PURE__ */ application("vnd.google-apps.document", "gdoc");
var Application_Vendor_Google_Apps_Presentation = /* @__PURE__ */ application("vnd.google-apps.presentation", "gslides");
var Application_Vendor_Google_Apps_Spreadsheet = /* @__PURE__ */ application("vnd.google-apps.spreadsheet", "gsheet");
var Application_Vendor_Google_EarthKmlXml = /* @__PURE__ */ application("vnd.google-earth.kml+xml", "kml");
var Application_Vendor_Google_EarthKmz = /* @__PURE__ */ application("vnd.google-earth.kmz", "kmz");
var Application_Vendor_GovSkE_FormXml = /* @__PURE__ */ application("vnd.gov.sk.e-form+xml", "xml");
var Application_Vendor_GovSkE_FormZip = /* @__PURE__ */ application("vnd.gov.sk.e-form+zip", "zip");
var Application_Vendor_GovSkXmldatacontainerXml = /* @__PURE__ */ application("vnd.gov.sk.xmldatacontainer+xml", "xml");
var Application_Vendor_Grafeq = /* @__PURE__ */ application("vnd.grafeq", "gqf", "gqs");
var Application_Vendor_Gridmp = /* @__PURE__ */ application("vnd.gridmp");
var Application_Vendor_Groove_Account = /* @__PURE__ */ application("vnd.groove-account", "gac");
var Application_Vendor_Groove_Help = /* @__PURE__ */ application("vnd.groove-help", "ghf");
var Application_Vendor_Groove_Identity_Message = /* @__PURE__ */ application("vnd.groove-identity-message", "gim");
var Application_Vendor_Groove_Injector = /* @__PURE__ */ application("vnd.groove-injector", "grv");
var Application_Vendor_Groove_Tool_Message = /* @__PURE__ */ application("vnd.groove-tool-message", "gtm");
var Application_Vendor_Groove_Tool_Template = /* @__PURE__ */ application("vnd.groove-tool-template", "tpl");
var Application_Vendor_Groove_Vcard = /* @__PURE__ */ application("vnd.groove-vcard", "vcg");
var Application_Vendor_HalJson = /* @__PURE__ */ application("vnd.hal+json", "json");
var Application_Vendor_HalXml = /* @__PURE__ */ application("vnd.hal+xml", "hal");
var Application_Vendor_HandHeld_EntertainmentXml = /* @__PURE__ */ application("vnd.handheld-entertainment+xml", "zmm");
var Application_Vendor_Hbci = /* @__PURE__ */ application("vnd.hbci", "hbci");
var Application_Vendor_HcJson = /* @__PURE__ */ application("vnd.hc+json", "json");
var Application_Vendor_Hcl_Bireports = /* @__PURE__ */ application("vnd.hcl-bireports");
var Application_Vendor_Hdt = /* @__PURE__ */ application("vnd.hdt");
var Application_Vendor_HerokuJson = /* @__PURE__ */ application("vnd.heroku+json", "json");
var Application_Vendor_HheLesson_Player = /* @__PURE__ */ application("vnd.hhe.lesson-player", "les");
var Application_Vendor_Hp_HPGL = /* @__PURE__ */ application("vnd.hp-hpgl", "hpgl");
var Application_Vendor_Hp_Hpid = /* @__PURE__ */ application("vnd.hp-hpid", "hpid");
var Application_Vendor_Hp_Hps = /* @__PURE__ */ application("vnd.hp-hps", "hps");
var Application_Vendor_Hp_Jlyt = /* @__PURE__ */ application("vnd.hp-jlyt", "jlt");
var Application_Vendor_Hp_PCL = /* @__PURE__ */ application("vnd.hp-pcl", "pcl");
var Application_Vendor_Hp_PCLXL = /* @__PURE__ */ application("vnd.hp-pclxl", "pclxl");
var Application_Vendor_Httphone = /* @__PURE__ */ application("vnd.httphone");
var Application_Vendor_HydrostatixSof_Data = /* @__PURE__ */ application("vnd.hydrostatix.sof-data", "sfd-hdstx");
var Application_Vendor_Hyper_ItemJson = /* @__PURE__ */ application("vnd.hyper-item+json", "json");
var Application_Vendor_HyperdriveJson = /* @__PURE__ */ application("vnd.hyperdrive+json", "json");
var Application_Vendor_HyperJson = /* @__PURE__ */ application("vnd.hyper+json", "json");
var Application_Vendor_Hzn_3d_Crossword = /* @__PURE__ */ application("vnd.hzn-3d-crossword");
var Application_Vendor_IbmAfplinedata = /* @__PURE__ */ application("vnd.ibm.afplinedata").deprecate("in favor of vnd.afpc.afplinedata");
var Application_Vendor_IbmElectronic_Media = /* @__PURE__ */ application("vnd.ibm.electronic-media");
var Application_Vendor_IbmMiniPay = /* @__PURE__ */ application("vnd.ibm.minipay", "mpy");
var Application_Vendor_IbmModcap = /* @__PURE__ */ application("vnd.ibm.modcap", "afp", "listafp", "list3820").deprecate("in favor of application/vnd.afpc.modca");
var Application_Vendor_IbmRights_Management = /* @__PURE__ */ application("vnd.ibm.rights-management", "irm");
var Application_Vendor_IbmSecure_Container = /* @__PURE__ */ application("vnd.ibm.secure-container", "sc");
var Application_Vendor_Iccprofile = /* @__PURE__ */ application("vnd.iccprofile", "icc", "icm");
var Application_Vendor_Ieee1905 = /* @__PURE__ */ application("vnd.ieee.1905");
var Application_Vendor_Igloader = /* @__PURE__ */ application("vnd.igloader", "igl");
var Application_Vendor_ImagemeterFolderZip = /* @__PURE__ */ application("vnd.imagemeter.folder+zip", "zip");
var Application_Vendor_ImagemeterImageZip = /* @__PURE__ */ application("vnd.imagemeter.image+zip", "zip");
var Application_Vendor_Immervision_Ivp = /* @__PURE__ */ application("vnd.immervision-ivp", "ivp");
var Application_Vendor_Immervision_Ivu = /* @__PURE__ */ application("vnd.immervision-ivu", "ivu");
var Application_Vendor_ImsImsccv1p1 = /* @__PURE__ */ application("vnd.ims.imsccv1p1");
var Application_Vendor_ImsImsccv1p2 = /* @__PURE__ */ application("vnd.ims.imsccv1p2");
var Application_Vendor_ImsImsccv1p3 = /* @__PURE__ */ application("vnd.ims.imsccv1p3");
var Application_Vendor_ImsLisV2ResultJson = /* @__PURE__ */ application("vnd.ims.lis.v2.result+json", "json");
var Application_Vendor_ImsLtiV2ToolconsumerprofileJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolconsumerprofile+json", "json");
var Application_Vendor_ImsLtiV2ToolproxyIdJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolproxy.id+json", "json");
var Application_Vendor_ImsLtiV2ToolproxyJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolproxy+json", "json");
var Application_Vendor_ImsLtiV2ToolsettingsJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolsettings+json", "json");
var Application_Vendor_ImsLtiV2ToolsettingsSimpleJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolsettings.simple+json", "json");
var Application_Vendor_InformedcontrolRmsXml = /* @__PURE__ */ application("vnd.informedcontrol.rms+xml", "xml");
var Application_Vendor_Informix_Visionary = /* @__PURE__ */ application("vnd.informix-visionary").deprecate("in favor of application/vnd.visionary");
var Application_Vendor_InfotechProject = /* @__PURE__ */ application("vnd.infotech.project");
var Application_Vendor_InfotechProjectXml = /* @__PURE__ */ application("vnd.infotech.project+xml", "xml");
var Application_Vendor_InnopathWampNotification = /* @__PURE__ */ application("vnd.innopath.wamp.notification");
var Application_Vendor_InsorsIgm = /* @__PURE__ */ application("vnd.insors.igm", "igm");
var Application_Vendor_InterconFormnet = /* @__PURE__ */ application("vnd.intercon.formnet", "xpw", "xpx");
var Application_Vendor_Intergeo = /* @__PURE__ */ application("vnd.intergeo", "i2g");
var Application_Vendor_IntertrustDigibox = /* @__PURE__ */ application("vnd.intertrust.digibox");
var Application_Vendor_IntertrustNncp = /* @__PURE__ */ application("vnd.intertrust.nncp");
var Application_Vendor_IntuQbo = /* @__PURE__ */ application("vnd.intu.qbo", "qbo");
var Application_Vendor_IntuQfx = /* @__PURE__ */ application("vnd.intu.qfx", "qfx");
var Application_Vendor_IptcG2CatalogitemXml = /* @__PURE__ */ application("vnd.iptc.g2.catalogitem+xml", "xml");
var Application_Vendor_IptcG2ConceptitemXml = /* @__PURE__ */ application("vnd.iptc.g2.conceptitem+xml", "xml");
var Application_Vendor_IptcG2KnowledgeitemXml = /* @__PURE__ */ application("vnd.iptc.g2.knowledgeitem+xml", "xml");
var Application_Vendor_IptcG2NewsitemXml = /* @__PURE__ */ application("vnd.iptc.g2.newsitem+xml", "xml");
var Application_Vendor_IptcG2NewsmessageXml = /* @__PURE__ */ application("vnd.iptc.g2.newsmessage+xml", "xml");
var Application_Vendor_IptcG2PackageitemXml = /* @__PURE__ */ application("vnd.iptc.g2.packageitem+xml", "xml");
var Application_Vendor_IptcG2PlanningitemXml = /* @__PURE__ */ application("vnd.iptc.g2.planningitem+xml", "xml");
var Application_Vendor_IpunpluggedRcprofile = /* @__PURE__ */ application("vnd.ipunplugged.rcprofile", "rcprofile");
var Application_Vendor_IrepositoryPackageXml = /* @__PURE__ */ application("vnd.irepository.package+xml", "irp");
var Application_Vendor_Is_Xpr = /* @__PURE__ */ application("vnd.is-xpr", "xpr");
var Application_Vendor_IsacFcs = /* @__PURE__ */ application("vnd.isac.fcs", "fcs");
var Application_Vendor_Iso11783_10Zip = /* @__PURE__ */ application("vnd.iso11783-10+zip", "zip");
var Application_Vendor_Jam = /* @__PURE__ */ application("vnd.jam", "jam");
var Application_Vendor_Japannet_Directory_Service = /* @__PURE__ */ application("vnd.japannet-directory-service");
var Application_Vendor_Japannet_Jpnstore_Wakeup = /* @__PURE__ */ application("vnd.japannet-jpnstore-wakeup");
var Application_Vendor_Japannet_Payment_Wakeup = /* @__PURE__ */ application("vnd.japannet-payment-wakeup");
var Application_Vendor_Japannet_Registration = /* @__PURE__ */ application("vnd.japannet-registration");
var Application_Vendor_Japannet_Registration_Wakeup = /* @__PURE__ */ application("vnd.japannet-registration-wakeup");
var Application_Vendor_Japannet_Setstore_Wakeup = /* @__PURE__ */ application("vnd.japannet-setstore-wakeup");
var Application_Vendor_Japannet_Verification = /* @__PURE__ */ application("vnd.japannet-verification");
var Application_Vendor_Japannet_Verification_Wakeup = /* @__PURE__ */ application("vnd.japannet-verification-wakeup");
var Application_Vendor_JcpJavameMidlet_Rms = /* @__PURE__ */ application("vnd.jcp.javame.midlet-rms", "rms");
var Application_Vendor_Jisp = /* @__PURE__ */ application("vnd.jisp", "jisp");
var Application_Vendor_JoostJoda_Archive = /* @__PURE__ */ application("vnd.joost.joda-archive", "joda");
var Application_Vendor_JskIsdn_Ngn = /* @__PURE__ */ application("vnd.jsk.isdn-ngn");
var Application_Vendor_Kahootz = /* @__PURE__ */ application("vnd.kahootz", "ktz", "ktr");
var Application_Vendor_KdeKarbon = /* @__PURE__ */ application("vnd.kde.karbon", "karbon");
var Application_Vendor_KdeKchart = /* @__PURE__ */ application("vnd.kde.kchart", "chrt");
var Application_Vendor_KdeKformula = /* @__PURE__ */ application("vnd.kde.kformula", "kfo");
var Application_Vendor_KdeKivio = /* @__PURE__ */ application("vnd.kde.kivio", "flw");
var Application_Vendor_KdeKontour = /* @__PURE__ */ application("vnd.kde.kontour", "kon");
var Application_Vendor_KdeKpresenter = /* @__PURE__ */ application("vnd.kde.kpresenter", "kpr", "kpt");
var Application_Vendor_KdeKspread = /* @__PURE__ */ application("vnd.kde.kspread", "ksp");
var Application_Vendor_KdeKword = /* @__PURE__ */ application("vnd.kde.kword", "kwd", "kwt");
var Application_Vendor_Kenameaapp = /* @__PURE__ */ application("vnd.kenameaapp", "htke");
var Application_Vendor_Kidspiration = /* @__PURE__ */ application("vnd.kidspiration", "kia");
var Application_Vendor_Kinar = /* @__PURE__ */ application("vnd.kinar", "kne", "knp");
var Application_Vendor_Koan = /* @__PURE__ */ application("vnd.koan", "skp", "skd", "skt", "skm");
var Application_Vendor_Kodak_Descriptor = /* @__PURE__ */ application("vnd.kodak-descriptor", "sse");
var Application_Vendor_Las = /* @__PURE__ */ application("vnd.las");
var Application_Vendor_LasLasJson = /* @__PURE__ */ application("vnd.las.las+json", "json");
var Application_Vendor_LasLasXml = /* @__PURE__ */ application("vnd.las.las+xml", "lasxml");
var Application_Vendor_Laszip = /* @__PURE__ */ application("vnd.laszip");
var Application_Vendor_LeapJson = /* @__PURE__ */ application("vnd.leap+json", "json");
var Application_Vendor_Liberty_RequestXml = /* @__PURE__ */ application("vnd.liberty-request+xml", "xml");
var Application_Vendor_LlamagraphicsLife_BalanceDesktop = /* @__PURE__ */ application("vnd.llamagraphics.life-balance.desktop", "lbd");
var Application_Vendor_LlamagraphicsLife_BalanceExchangeXml = /* @__PURE__ */ application("vnd.llamagraphics.life-balance.exchange+xml", "lbe");
var Application_Vendor_LogipipeCircuitZip = /* @__PURE__ */ application("vnd.logipipe.circuit+zip", "zip");
var Application_Vendor_Loom = /* @__PURE__ */ application("vnd.loom");
var Application_Vendor_Lotus_1_2_3 = /* @__PURE__ */ application("vnd.lotus-1-2-3", "123");
var Application_Vendor_Lotus_Approach = /* @__PURE__ */ application("vnd.lotus-approach", "apr");
var Application_Vendor_Lotus_Freelance = /* @__PURE__ */ application("vnd.lotus-freelance", "pre");
var Application_Vendor_Lotus_Notes = /* @__PURE__ */ application("vnd.lotus-notes", "nsf");
var Application_Vendor_Lotus_Organizer = /* @__PURE__ */ application("vnd.lotus-organizer", "org");
var Application_Vendor_Lotus_Screencam = /* @__PURE__ */ application("vnd.lotus-screencam", "scm");
var Application_Vendor_Lotus_Wordpro = /* @__PURE__ */ application("vnd.lotus-wordpro", "lwp");
var Application_Vendor_MacportsPortpkg = /* @__PURE__ */ application("vnd.macports.portpkg", "portpkg");
var Application_Vendor_Mapbox_Vector_Tile = /* @__PURE__ */ application("vnd.mapbox-vector-tile");
var Application_Vendor_MarlinDrmActiontokenXml = /* @__PURE__ */ application("vnd.marlin.drm.actiontoken+xml", "xml");
var Application_Vendor_MarlinDrmConftokenXml = /* @__PURE__ */ application("vnd.marlin.drm.conftoken+xml", "xml");
var Application_Vendor_MarlinDrmLicenseXml = /* @__PURE__ */ application("vnd.marlin.drm.license+xml", "xml");
var Application_Vendor_MarlinDrmMdcf = /* @__PURE__ */ application("vnd.marlin.drm.mdcf");
var Application_Vendor_MasonJson = /* @__PURE__ */ application("vnd.mason+json", "json");
var Application_Vendor_MaxmindMaxmind_Db = /* @__PURE__ */ application("vnd.maxmind.maxmind-db");
var Application_Vendor_Mcd = /* @__PURE__ */ application("vnd.mcd", "mcd");
var Application_Vendor_Medcalcdata = /* @__PURE__ */ application("vnd.medcalcdata", "mc1");
var Application_Vendor_MediastationCdkey = /* @__PURE__ */ application("vnd.mediastation.cdkey", "cdkey");
var Application_Vendor_Meridian_Slingshot = /* @__PURE__ */ application("vnd.meridian-slingshot");
var Application_Vendor_MFER = /* @__PURE__ */ application("vnd.mfer", "mwf");
var Application_Vendor_Mfmp = /* @__PURE__ */ application("vnd.mfmp", "mfm");
var Application_Vendor_MicrografxFlo = /* @__PURE__ */ application("vnd.micrografx.flo", "flo");
var Application_Vendor_MicrografxIgx = /* @__PURE__ */ application("vnd.micrografx.igx", "igx");
var Application_Vendor_MicroJson = /* @__PURE__ */ application("vnd.micro+json", "json");
var Application_Vendor_MicrosoftPortable_Executable = /* @__PURE__ */ application("vnd.microsoft.portable-executable");
var Application_Vendor_MicrosoftWindowsThumbnail_Cache = /* @__PURE__ */ application("vnd.microsoft.windows.thumbnail-cache");
var Application_Vendor_MieleJson = /* @__PURE__ */ application("vnd.miele+json", "json");
var Application_Vendor_Mif = /* @__PURE__ */ application("vnd.mif", "mif");
var Application_Vendor_Minisoft_Hp3000_Save = /* @__PURE__ */ application("vnd.minisoft-hp3000-save");
var Application_Vendor_MitsubishiMisty_GuardTrustweb = /* @__PURE__ */ application("vnd.mitsubishi.misty-guard.trustweb");
var Application_Vendor_MobiusDAF = /* @__PURE__ */ application("vnd.mobius.daf", "daf");
var Application_Vendor_MobiusDIS = /* @__PURE__ */ application("vnd.mobius.dis", "dis");
var Application_Vendor_MobiusMBK = /* @__PURE__ */ application("vnd.mobius.mbk", "mbk");
var Application_Vendor_MobiusMQY = /* @__PURE__ */ application("vnd.mobius.mqy", "mqy");
var Application_Vendor_MobiusMSL = /* @__PURE__ */ application("vnd.mobius.msl", "msl");
var Application_Vendor_MobiusPLC = /* @__PURE__ */ application("vnd.mobius.plc", "plc");
var Application_Vendor_MobiusTXF = /* @__PURE__ */ application("vnd.mobius.txf", "txf");
var Application_Vendor_MophunApplication = /* @__PURE__ */ application("vnd.mophun.application", "mpn");
var Application_Vendor_MophunCertificate = /* @__PURE__ */ application("vnd.mophun.certificate", "mpc");
var Application_Vendor_MotorolaFlexsuite = /* @__PURE__ */ application("vnd.motorola.flexsuite");
var Application_Vendor_MotorolaFlexsuiteAdsi = /* @__PURE__ */ application("vnd.motorola.flexsuite.adsi");
var Application_Vendor_MotorolaFlexsuiteFis = /* @__PURE__ */ application("vnd.motorola.flexsuite.fis");
var Application_Vendor_MotorolaFlexsuiteGotap = /* @__PURE__ */ application("vnd.motorola.flexsuite.gotap");
var Application_Vendor_MotorolaFlexsuiteKmr = /* @__PURE__ */ application("vnd.motorola.flexsuite.kmr");
var Application_Vendor_MotorolaFlexsuiteTtc = /* @__PURE__ */ application("vnd.motorola.flexsuite.ttc");
var Application_Vendor_MotorolaFlexsuiteWem = /* @__PURE__ */ application("vnd.motorola.flexsuite.wem");
var Application_Vendor_MotorolaIprm = /* @__PURE__ */ application("vnd.motorola.iprm");
var Application_Vendor_MozillaXulXml = /* @__PURE__ */ application("vnd.mozilla.xul+xml", "xul");
var Application_Vendor_Ms_3mfdocument = /* @__PURE__ */ application("vnd.ms-3mfdocument");
var Application_Vendor_Ms_Artgalry = /* @__PURE__ */ application("vnd.ms-artgalry", "cil");
var Application_Vendor_Ms_Asf = /* @__PURE__ */ application("vnd.ms-asf");
var Application_Vendor_Ms_Cab_Compressed = /* @__PURE__ */ application("vnd.ms-cab-compressed", "cab");
var Application_Vendor_Ms_ColorIccprofile = /* @__PURE__ */ application("vnd.ms-color.iccprofile");
var Application_Vendor_Ms_Excel = /* @__PURE__ */ application("vnd.ms-excel", "xls", "xlm", "xla", "xlc", "xlt", "xlw");
var Application_Vendor_Ms_ExcelAddinMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.addin.macroenabled.12", "xlam");
var Application_Vendor_Ms_ExcelSheetBinaryMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb");
var Application_Vendor_Ms_ExcelSheetMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.sheet.macroenabled.12", "xlsm");
var Application_Vendor_Ms_ExcelTemplateMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.template.macroenabled.12", "xltm");
var Application_Vendor_Ms_Fontobject = /* @__PURE__ */ application("vnd.ms-fontobject", "eot");
var Application_Vendor_Ms_Htmlhelp = /* @__PURE__ */ application("vnd.ms-htmlhelp", "chm");
var Application_Vendor_Ms_Ims = /* @__PURE__ */ application("vnd.ms-ims", "ims");
var Application_Vendor_Ms_Lrm = /* @__PURE__ */ application("vnd.ms-lrm", "lrm");
var Application_Vendor_Ms_OfficeActiveXXml = /* @__PURE__ */ application("vnd.ms-office.activex+xml", "xml");
var Application_Vendor_Ms_Officetheme = /* @__PURE__ */ application("vnd.ms-officetheme", "thmx");
var Application_Vendor_Ms_Opentype = /* @__PURE__ */ application("vnd.ms-opentype");
var Application_Vendor_Ms_Outlook = /* @__PURE__ */ application("vnd.ms-outlook", "msg");
var Application_Vendor_Ms_PackageObfuscated_Opentype = /* @__PURE__ */ application("vnd.ms-package.obfuscated-opentype");
var Application_Vendor_Ms_PkiSeccat = /* @__PURE__ */ application("vnd.ms-pki.seccat", "cat");
var Application_Vendor_Ms_PkiStl = /* @__PURE__ */ application("vnd.ms-pki.stl", "stl");
var Application_Vendor_Ms_PlayreadyInitiatorXml = /* @__PURE__ */ application("vnd.ms-playready.initiator+xml", "xml");
var Application_Vendor_Ms_Powerpoint = /* @__PURE__ */ application("vnd.ms-powerpoint", "ppt", "pps", "pot");
var Application_Vendor_Ms_PowerpointAddinMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.addin.macroenabled.12", "ppam");
var Application_Vendor_Ms_PowerpointPresentationMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.presentation.macroenabled.12", "pptm");
var Application_Vendor_Ms_PowerpointSlideMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.slide.macroenabled.12", "sldm");
var Application_Vendor_Ms_PowerpointSlideshowMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm");
var Application_Vendor_Ms_PowerpointTemplateMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.template.macroenabled.12", "potm");
var Application_Vendor_Ms_PrintDeviceCapabilitiesXml = /* @__PURE__ */ application("vnd.ms-printdevicecapabilities+xml", "xml");
var Application_Vendor_Ms_PrintingPrintticketXml = /* @__PURE__ */ application("vnd.ms-printing.printticket+xml", "xml");
var Application_Vendor_Ms_PrintSchemaTicketXml = /* @__PURE__ */ application("vnd.ms-printschematicket+xml", "xml");
var Application_Vendor_Ms_Project = /* @__PURE__ */ application("vnd.ms-project", "mpp", "mpt");
var Application_Vendor_Ms_Tnef = /* @__PURE__ */ application("vnd.ms-tnef");
var Application_Vendor_Ms_WindowsDevicepairing = /* @__PURE__ */ application("vnd.ms-windows.devicepairing");
var Application_Vendor_Ms_WindowsNwprintingOob = /* @__PURE__ */ application("vnd.ms-windows.nwprinting.oob");
var Application_Vendor_Ms_WindowsPrinterpairing = /* @__PURE__ */ application("vnd.ms-windows.printerpairing");
var Application_Vendor_Ms_WindowsWsdOob = /* @__PURE__ */ application("vnd.ms-windows.wsd.oob");
var Application_Vendor_Ms_WmdrmLic_Chlg_Req = /* @__PURE__ */ application("vnd.ms-wmdrm.lic-chlg-req");
var Application_Vendor_Ms_WmdrmLic_Resp = /* @__PURE__ */ application("vnd.ms-wmdrm.lic-resp");
var Application_Vendor_Ms_WmdrmMeter_Chlg_Req = /* @__PURE__ */ application("vnd.ms-wmdrm.meter-chlg-req");
var Application_Vendor_Ms_WmdrmMeter_Resp = /* @__PURE__ */ application("vnd.ms-wmdrm.meter-resp");
var Application_Vendor_Ms_WordDocumentMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-word.document.macroenabled.12", "docm");
var Application_Vendor_Ms_WordTemplateMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-word.template.macroenabled.12", "dotm");
var Application_Vendor_Ms_Works = /* @__PURE__ */ application("vnd.ms-works", "wps", "wks", "wcm", "wdb");
var Application_Vendor_Ms_Wpl = /* @__PURE__ */ application("vnd.ms-wpl", "wpl");
var Application_Vendor_Ms_Xpsdocument = /* @__PURE__ */ application("vnd.ms-xpsdocument", "xps");
var Application_Vendor_Msa_Disk_Image = /* @__PURE__ */ application("vnd.msa-disk-image");
var Application_Vendor_Mseq = /* @__PURE__ */ application("vnd.mseq", "mseq");
var Application_Vendor_Msign = /* @__PURE__ */ application("vnd.msign");
var Application_Vendor_MultiadCreator = /* @__PURE__ */ application("vnd.multiad.creator");
var Application_Vendor_MultiadCreatorCif = /* @__PURE__ */ application("vnd.multiad.creator.cif");
var Application_Vendor_Music_Niff = /* @__PURE__ */ application("vnd.music-niff");
var Application_Vendor_Musician = /* @__PURE__ */ application("vnd.musician", "mus");
var Application_Vendor_MuveeStyle = /* @__PURE__ */ application("vnd.muvee.style", "msty");
var Application_Vendor_Mynfc = /* @__PURE__ */ application("vnd.mynfc", "taglet");
var Application_Vendor_NcdControl = /* @__PURE__ */ application("vnd.ncd.control");
var Application_Vendor_NcdReference = /* @__PURE__ */ application("vnd.ncd.reference");
var Application_Vendor_NearstInvJson = /* @__PURE__ */ application("vnd.nearst.inv+json", "json");
var Application_Vendor_Nervana = /* @__PURE__ */ application("vnd.nervana");
var Application_Vendor_Netfpx = /* @__PURE__ */ application("vnd.netfpx");
var Application_Vendor_NeurolanguageNlu = /* @__PURE__ */ application("vnd.neurolanguage.nlu", "nlu");
var Application_Vendor_Nimn = /* @__PURE__ */ application("vnd.nimn");
var Application_Vendor_NintendoNitroRom = /* @__PURE__ */ application("vnd.nintendo.nitro.rom");
var Application_Vendor_NintendoSnesRom = /* @__PURE__ */ application("vnd.nintendo.snes.rom");
var Application_Vendor_Nitf = /* @__PURE__ */ application("vnd.nitf", "ntf", "nitf");
var Application_Vendor_Noblenet_Directory = /* @__PURE__ */ application("vnd.noblenet-directory", "nnd");
var Application_Vendor_Noblenet_Sealer = /* @__PURE__ */ application("vnd.noblenet-sealer", "nns");
var Application_Vendor_Noblenet_Web = /* @__PURE__ */ application("vnd.noblenet-web", "nnw");
var Application_Vendor_NokiaCatalogs = /* @__PURE__ */ application("vnd.nokia.catalogs");
var Application_Vendor_NokiaConmlWbxml = /* @__PURE__ */ application("vnd.nokia.conml+wbxml", "wbxml");
var Application_Vendor_NokiaConmlXml = /* @__PURE__ */ application("vnd.nokia.conml+xml", "xml");
var Application_Vendor_NokiaIptvConfigXml = /* @__PURE__ */ application("vnd.nokia.iptv.config+xml", "xml");
var Application_Vendor_NokiaISDS_Radio_Presets = /* @__PURE__ */ application("vnd.nokia.isds-radio-presets");
var Application_Vendor_NokiaLandmarkcollectionXml = /* @__PURE__ */ application("vnd.nokia.landmarkcollection+xml", "xml");
var Application_Vendor_NokiaLandmarkWbxml = /* @__PURE__ */ application("vnd.nokia.landmark+wbxml", "wbxml");
var Application_Vendor_NokiaLandmarkXml = /* @__PURE__ */ application("vnd.nokia.landmark+xml", "xml");
var Application_Vendor_NokiaN_GageAcXml = /* @__PURE__ */ application("vnd.nokia.n-gage.ac+xml", "xml");
var Application_Vendor_NokiaN_GageData = /* @__PURE__ */ application("vnd.nokia.n-gage.data", "ngdat");
var Application_Vendor_NokiaN_GageSymbianInstall = /* @__PURE__ */ application("vnd.nokia.n-gage.symbian.install", "n-gage").deprecate("as obsolete with no replacement given");
var Application_Vendor_NokiaNcd = /* @__PURE__ */ application("vnd.nokia.ncd");
var Application_Vendor_NokiaPcdWbxml = /* @__PURE__ */ application("vnd.nokia.pcd+wbxml", "wbxml");
var Application_Vendor_NokiaPcdXml = /* @__PURE__ */ application("vnd.nokia.pcd+xml", "xml");
var Application_Vendor_NokiaRadio_Preset = /* @__PURE__ */ application("vnd.nokia.radio-preset", "rpst");
var Application_Vendor_NokiaRadio_Presets = /* @__PURE__ */ application("vnd.nokia.radio-presets", "rpss");
var Application_Vendor_NovadigmEDM = /* @__PURE__ */ application("vnd.novadigm.edm", "edm");
var Application_Vendor_NovadigmEDX = /* @__PURE__ */ application("vnd.novadigm.edx", "edx");
var Application_Vendor_NovadigmEXT = /* @__PURE__ */ application("vnd.novadigm.ext", "ext");
var Application_Vendor_Ntt_LocalContent_Share = /* @__PURE__ */ application("vnd.ntt-local.content-share");
var Application_Vendor_Ntt_LocalFile_Transfer = /* @__PURE__ */ application("vnd.ntt-local.file-transfer");
var Application_Vendor_Ntt_LocalOgw_remote_Access = /* @__PURE__ */ application("vnd.ntt-local.ogw_remote-access");
var Application_Vendor_Ntt_LocalSip_Ta_remote = /* @__PURE__ */ application("vnd.ntt-local.sip-ta_remote");
var Application_Vendor_Ntt_LocalSip_Ta_tcp_stream = /* @__PURE__ */ application("vnd.ntt-local.sip-ta_tcp_stream");
var Application_Vendor_OasisOpendocumentChart = /* @__PURE__ */ application("vnd.oasis.opendocument.chart", "odc");
var Application_Vendor_OasisOpendocumentChart_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.chart-template", "otc");
var Application_Vendor_OasisOpendocumentDatabase = /* @__PURE__ */ application("vnd.oasis.opendocument.database", "odb");
var Application_Vendor_OasisOpendocumentFormula = /* @__PURE__ */ application("vnd.oasis.opendocument.formula", "odf");
var Application_Vendor_OasisOpendocumentFormula_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.formula-template", "odft");
var Application_Vendor_OasisOpendocumentGraphics = /* @__PURE__ */ application("vnd.oasis.opendocument.graphics", "odg");
var Application_Vendor_OasisOpendocumentGraphics_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.graphics-template", "otg");
var Application_Vendor_OasisOpendocumentImage = /* @__PURE__ */ application("vnd.oasis.opendocument.image", "odi");
var Application_Vendor_OasisOpendocumentImage_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.image-template", "oti");
var Application_Vendor_OasisOpendocumentPresentation = /* @__PURE__ */ application("vnd.oasis.opendocument.presentation", "odp");
var Application_Vendor_OasisOpendocumentPresentation_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.presentation-template", "otp");
var Application_Vendor_OasisOpendocumentSpreadsheet = /* @__PURE__ */ application("vnd.oasis.opendocument.spreadsheet", "ods");
var Application_Vendor_OasisOpendocumentSpreadsheet_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.spreadsheet-template", "ots");
var Application_Vendor_OasisOpendocumentText = /* @__PURE__ */ application("vnd.oasis.opendocument.text", "odt");
var Application_Vendor_OasisOpendocumentText_Master = /* @__PURE__ */ application("vnd.oasis.opendocument.text-master", "odm");
var Application_Vendor_OasisOpendocumentText_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.text-template", "ott");
var Application_Vendor_OasisOpendocumentText_Web = /* @__PURE__ */ application("vnd.oasis.opendocument.text-web", "oth");
var Application_Vendor_Obn = /* @__PURE__ */ application("vnd.obn");
var Application_Vendor_OcfCbor = /* @__PURE__ */ application("vnd.ocf+cbor", "cbor");
var Application_Vendor_OftnL10nJson = /* @__PURE__ */ application("vnd.oftn.l10n+json", "json");
var Application_Vendor_OipfContentaccessdownloadXml = /* @__PURE__ */ application("vnd.oipf.contentaccessdownload+xml", "xml");
var Application_Vendor_OipfContentaccessstreamingXml = /* @__PURE__ */ application("vnd.oipf.contentaccessstreaming+xml", "xml");
var Application_Vendor_OipfCspg_Hexbinary = /* @__PURE__ */ application("vnd.oipf.cspg-hexbinary");
var Application_Vendor_OipfDaeSvgXml = /* @__PURE__ */ application("vnd.oipf.dae.svg+xml", "xml");
var Application_Vendor_OipfDaeXhtmlXml = /* @__PURE__ */ application("vnd.oipf.dae.xhtml+xml", "xml");
var Application_Vendor_OipfMippvcontrolmessageXml = /* @__PURE__ */ application("vnd.oipf.mippvcontrolmessage+xml", "xml");
var Application_Vendor_OipfPaeGem = /* @__PURE__ */ application("vnd.oipf.pae.gem");
var Application_Vendor_OipfSpdiscoveryXml = /* @__PURE__ */ application("vnd.oipf.spdiscovery+xml", "xml");
var Application_Vendor_OipfSpdlistXml = /* @__PURE__ */ application("vnd.oipf.spdlist+xml", "xml");
var Application_Vendor_OipfUeprofileXml = /* @__PURE__ */ application("vnd.oipf.ueprofile+xml", "xml");
var Application_Vendor_OipfUserprofileXml = /* @__PURE__ */ application("vnd.oipf.userprofile+xml", "xml");
var Application_Vendor_Olpc_Sugar = /* @__PURE__ */ application("vnd.olpc-sugar", "xo");
var Application_Vendor_Oma_Scws_Config = /* @__PURE__ */ application("vnd.oma-scws-config");
var Application_Vendor_Oma_Scws_Http_Request = /* @__PURE__ */ application("vnd.oma-scws-http-request");
var Application_Vendor_Oma_Scws_Http_Response = /* @__PURE__ */ application("vnd.oma-scws-http-response");
var Application_Vendor_OmaBcastAssociated_Procedure_ParameterXml = /* @__PURE__ */ application("vnd.oma.bcast.associated-procedure-parameter+xml", "xml");
var Application_Vendor_OmaBcastDrm_TriggerXml = /* @__PURE__ */ application("vnd.oma.bcast.drm-trigger+xml", "xml");
var Application_Vendor_OmaBcastImdXml = /* @__PURE__ */ application("vnd.oma.bcast.imd+xml", "xml");
var Application_Vendor_OmaBcastLtkm = /* @__PURE__ */ application("vnd.oma.bcast.ltkm");
var Application_Vendor_OmaBcastNotificationXml = /* @__PURE__ */ application("vnd.oma.bcast.notification+xml", "xml");
var Application_Vendor_OmaBcastProvisioningtrigger = /* @__PURE__ */ application("vnd.oma.bcast.provisioningtrigger");
var Application_Vendor_OmaBcastSgboot = /* @__PURE__ */ application("vnd.oma.bcast.sgboot");
var Application_Vendor_OmaBcastSgddXml = /* @__PURE__ */ application("vnd.oma.bcast.sgdd+xml", "xml");
var Application_Vendor_OmaBcastSgdu = /* @__PURE__ */ application("vnd.oma.bcast.sgdu");
var Application_Vendor_OmaBcastSimple_Symbol_Container = /* @__PURE__ */ application("vnd.oma.bcast.simple-symbol-container");
var Application_Vendor_OmaBcastSmartcard_TriggerXml = /* @__PURE__ */ application("vnd.oma.bcast.smartcard-trigger+xml", "xml");
var Application_Vendor_OmaBcastSprovXml = /* @__PURE__ */ application("vnd.oma.bcast.sprov+xml", "xml");
var Application_Vendor_OmaBcastStkm = /* @__PURE__ */ application("vnd.oma.bcast.stkm");
var Application_Vendor_OmaCab_Address_BookXml = /* @__PURE__ */ application("vnd.oma.cab-address-book+xml", "xml");
var Application_Vendor_OmaCab_Feature_HandlerXml = /* @__PURE__ */ application("vnd.oma.cab-feature-handler+xml", "xml");
var Application_Vendor_OmaCab_PccXml = /* @__PURE__ */ application("vnd.oma.cab-pcc+xml", "xml");
var Application_Vendor_OmaCab_Subs_InviteXml = /* @__PURE__ */ application("vnd.oma.cab-subs-invite+xml", "xml");
var Application_Vendor_OmaCab_User_PrefsXml = /* @__PURE__ */ application("vnd.oma.cab-user-prefs+xml", "xml");
var Application_Vendor_OmaDcd = /* @__PURE__ */ application("vnd.oma.dcd");
var Application_Vendor_OmaDcdc = /* @__PURE__ */ application("vnd.oma.dcdc");
var Application_Vendor_OmaDd2Xml = /* @__PURE__ */ application("vnd.oma.dd2+xml", "dd2");
var Application_Vendor_OmaDrmRisdXml = /* @__PURE__ */ application("vnd.oma.drm.risd+xml", "xml");
var Application_Vendor_Omads_EmailXml = /* @__PURE__ */ application("vnd.omads-email+xml", "xml");
var Application_Vendor_Omads_FileXml = /* @__PURE__ */ application("vnd.omads-file+xml", "xml");
var Application_Vendor_Omads_FolderXml = /* @__PURE__ */ application("vnd.omads-folder+xml", "xml");
var Application_Vendor_OmaGroup_Usage_ListXml = /* @__PURE__ */ application("vnd.oma.group-usage-list+xml", "xml");
var Application_Vendor_Omaloc_Supl_Init = /* @__PURE__ */ application("vnd.omaloc-supl-init");
var Application_Vendor_OmaLwm2mJson = /* @__PURE__ */ application("vnd.oma.lwm2m+json", "json");
var Application_Vendor_OmaLwm2mTlv = /* @__PURE__ */ application("vnd.oma.lwm2m+tlv", "tlv");
var Application_Vendor_OmaPalXml = /* @__PURE__ */ application("vnd.oma.pal+xml", "xml");
var Application_Vendor_OmaPocDetailed_Progress_ReportXml = /* @__PURE__ */ application("vnd.oma.poc.detailed-progress-report+xml", "xml");
var Application_Vendor_OmaPocFinal_ReportXml = /* @__PURE__ */ application("vnd.oma.poc.final-report+xml", "xml");
var Application_Vendor_OmaPocGroupsXml = /* @__PURE__ */ application("vnd.oma.poc.groups+xml", "xml");
var Application_Vendor_OmaPocInvocation_DescriptorXml = /* @__PURE__ */ application("vnd.oma.poc.invocation-descriptor+xml", "xml");
var Application_Vendor_OmaPocOptimized_Progress_ReportXml = /* @__PURE__ */ application("vnd.oma.poc.optimized-progress-report+xml", "xml");
var Application_Vendor_OmaPush = /* @__PURE__ */ application("vnd.oma.push");
var Application_Vendor_OmaScidmMessagesXml = /* @__PURE__ */ application("vnd.oma.scidm.messages+xml", "xml");
var Application_Vendor_OmaXcap_DirectoryXml = /* @__PURE__ */ application("vnd.oma.xcap-directory+xml", "xml");
var Application_Vendor_Onepager = /* @__PURE__ */ application("vnd.onepager");
var Application_Vendor_Onepagertamp = /* @__PURE__ */ application("vnd.onepagertamp");
var Application_Vendor_Onepagertamx = /* @__PURE__ */ application("vnd.onepagertamx");
var Application_Vendor_Onepagertat = /* @__PURE__ */ application("vnd.onepagertat");
var Application_Vendor_Onepagertatp = /* @__PURE__ */ application("vnd.onepagertatp");
var Application_Vendor_Onepagertatx = /* @__PURE__ */ application("vnd.onepagertatx");
var Application_Vendor_OpenbloxGame_Binary = /* @__PURE__ */ application("vnd.openblox.game-binary");
var Application_Vendor_OpenbloxGameXml = /* @__PURE__ */ application("vnd.openblox.game+xml", "xml");
var Application_Vendor_OpeneyeOeb = /* @__PURE__ */ application("vnd.openeye.oeb");
var Application_Vendor_OpenofficeorgExtension = /* @__PURE__ */ application("vnd.openofficeorg.extension", "oxt");
var Application_Vendor_OpenstreetmapDataXml = /* @__PURE__ */ application("vnd.openstreetmap.data+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentCustom_PropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.custom-properties+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentCustomXmlPropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.customxmlproperties+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartshapesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.chartshapes+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.chart+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramColorsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramDataXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramdata+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramLayoutXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramStyleXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawing+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentExtended_PropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.extended-properties+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentAuthorsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.commentauthors+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.comments+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlHandoutMasterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesMasterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.notesmaster+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesSlideXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.notesslide+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentation = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.presentation", "pptx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentationMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.presentation.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresPropsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.presprops+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlide = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slide", "sldx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideLayoutXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slidelayout+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideMasterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slidemaster+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshow = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshowMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideUpdateInfoXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slide+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTableStylesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.tablestyles+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTagsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.tags+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplate = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.template", "potx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplateMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.template.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlViewPropsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.viewprops+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCalcChainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlChartsheetXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCommentsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.comments+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlConnectionsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.connections+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlDialogsheetXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlExternalLinkXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheDefinitionXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheRecordsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlQueryTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionHeadersXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionLogXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSharedStringsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheet = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMetadataXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlStylesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.styles+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableSingleCellsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.table+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplate = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplateMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlUserNamesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlVolatileDependenciesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlWorksheetXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentThemeOverrideXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.themeoverride+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentThemeXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.theme+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentVmlDrawing = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.vmldrawing");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlCommentsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocument = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.document", "docx");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentGlossaryXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlEndnotesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFontTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFooterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFootnotesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlNumberingXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlSettingsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlStylesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplate = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplateMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlWebSettingsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml", "xml");
var Application_Vendor_Openxmlformats_PackageCore_PropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-package.core-properties+xml", "xml");
var Application_Vendor_Openxmlformats_PackageDigital_Signature_XmlsignatureXml = /* @__PURE__ */ application("vnd.openxmlformats-package.digital-signature-xmlsignature+xml", "xml");
var Application_Vendor_Openxmlformats_PackageRelationshipsXml = /* @__PURE__ */ application("vnd.openxmlformats-package.relationships+xml", "xml");
var Application_Vendor_OracleResourceJson = /* @__PURE__ */ application("vnd.oracle.resource+json", "json");
var Application_Vendor_OrangeIndata = /* @__PURE__ */ application("vnd.orange.indata");
var Application_Vendor_OsaNetdeploy = /* @__PURE__ */ application("vnd.osa.netdeploy");
var Application_Vendor_OsgeoMapguidePackage = /* @__PURE__ */ application("vnd.osgeo.mapguide.package", "mgp");
var Application_Vendor_OsgiBundle = /* @__PURE__ */ application("vnd.osgi.bundle");
var Application_Vendor_OsgiDp = /* @__PURE__ */ application("vnd.osgi.dp", "dp");
var Application_Vendor_OsgiSubsystem = /* @__PURE__ */ application("vnd.osgi.subsystem", "esa");
var Application_Vendor_OtpsCt_KipXml = /* @__PURE__ */ application("vnd.otps.ct-kip+xml", "xml");
var Application_Vendor_OxliCountgraph = /* @__PURE__ */ application("vnd.oxli.countgraph");
var Application_Vendor_PagerdutyJson = /* @__PURE__ */ application("vnd.pagerduty+json", "json");
var Application_Vendor_Palm = /* @__PURE__ */ application("vnd.palm", "pdb", "pqa", "oprc");
var Application_Vendor_Panoply = /* @__PURE__ */ application("vnd.panoply");
var Application_Vendor_PaosXml = /* @__PURE__ */ application("vnd.paos.xml");
var Application_Vendor_Patentdive = /* @__PURE__ */ application("vnd.patentdive");
var Application_Vendor_Patientecommsdoc = /* @__PURE__ */ application("vnd.patientecommsdoc");
var Application_Vendor_Pawaafile = /* @__PURE__ */ application("vnd.pawaafile", "paw");
var Application_Vendor_Pcos = /* @__PURE__ */ application("vnd.pcos");
var Application_Vendor_PgFormat = /* @__PURE__ */ application("vnd.pg.format", "str");
var Application_Vendor_PgOsasli = /* @__PURE__ */ application("vnd.pg.osasli", "ei6");
var Application_Vendor_PiaccessApplication_Licence = /* @__PURE__ */ application("vnd.piaccess.application-licence");
var Application_Vendor_Picsel = /* @__PURE__ */ application("vnd.picsel", "efif");
var Application_Vendor_PmiWidget = /* @__PURE__ */ application("vnd.pmi.widget", "wg");
var Application_Vendor_PocGroup_AdvertisementXml = /* @__PURE__ */ application("vnd.poc.group-advertisement+xml", "xml");
var Application_Vendor_Pocketlearn = /* @__PURE__ */ application("vnd.pocketlearn", "plf");
var Application_Vendor_Powerbuilder6 = /* @__PURE__ */ application("vnd.powerbuilder6", "pbd");
var Application_Vendor_Powerbuilder6_S = /* @__PURE__ */ application("vnd.powerbuilder6-s");
var Application_Vendor_Powerbuilder7 = /* @__PURE__ */ application("vnd.powerbuilder7");
var Application_Vendor_Powerbuilder7_S = /* @__PURE__ */ application("vnd.powerbuilder7-s");
var Application_Vendor_Powerbuilder75 = /* @__PURE__ */ application("vnd.powerbuilder75");
var Application_Vendor_Powerbuilder75_S = /* @__PURE__ */ application("vnd.powerbuilder75-s");
var Application_Vendor_Preminet = /* @__PURE__ */ application("vnd.preminet");
var Application_Vendor_PreviewsystemsBox = /* @__PURE__ */ application("vnd.previewsystems.box", "box");
var Application_Vendor_ProteusMagazine = /* @__PURE__ */ application("vnd.proteus.magazine", "mgz");
var Application_Vendor_Psfs = /* @__PURE__ */ application("vnd.psfs");
var Application_Vendor_Publishare_Delta_Tree = /* @__PURE__ */ application("vnd.publishare-delta-tree", "qps");
var Application_Vendor_PviPtid1 = /* @__PURE__ */ application("vnd.pvi.ptid1", "ptid");
var Application_Vendor_Pwg_Multiplexed = /* @__PURE__ */ application("vnd.pwg-multiplexed");
var Application_Vendor_Pwg_Xhtml_PrintXml = /* @__PURE__ */ application("vnd.pwg-xhtml-print+xml", "xml");
var Application_Vendor_QualcommBrew_App_Res = /* @__PURE__ */ application("vnd.qualcomm.brew-app-res");
var Application_Vendor_Quarantainenet = /* @__PURE__ */ application("vnd.quarantainenet");
var Application_Vendor_QuarkQuarkXPress = /* @__PURE__ */ application("vnd.quark.quarkxpress", "qxd", "qxt", "qwd", "qwt", "qxl", "qxb");
var Application_Vendor_Quobject_Quoxdocument = /* @__PURE__ */ application("vnd.quobject-quoxdocument");
var Application_Vendor_RadisysMomlXml = /* @__PURE__ */ application("vnd.radisys.moml+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_ConfXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-conf+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_ConnXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-conn+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_DialogXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-dialog+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_StreamXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-stream+xml", "xml");
var Application_Vendor_RadisysMsml_AuditXml = /* @__PURE__ */ application("vnd.radisys.msml-audit+xml", "xml");
var Application_Vendor_RadisysMsml_ConfXml = /* @__PURE__ */ application("vnd.radisys.msml-conf+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_BaseXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-base+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_Fax_DetectXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-fax-detect+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_Fax_SendrecvXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-fax-sendrecv+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_GroupXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-group+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_SpeechXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-speech+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_TransformXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-transform+xml", "xml");
var Application_Vendor_RadisysMsml_DialogXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog+xml", "xml");
var Application_Vendor_RadisysMsmlXml = /* @__PURE__ */ application("vnd.radisys.msml+xml", "xml");
var Application_Vendor_RainstorData = /* @__PURE__ */ application("vnd.rainstor.data");
var Application_Vendor_Rapid = /* @__PURE__ */ application("vnd.rapid");
var Application_Vendor_Rar = /* @__PURE__ */ application("vnd.rar");
var Application_Vendor_RealvncBed = /* @__PURE__ */ application("vnd.realvnc.bed", "bed");
var Application_Vendor_RecordareMusicxml = /* @__PURE__ */ application("vnd.recordare.musicxml", "mxl");
var Application_Vendor_RecordareMusicxmlXml = /* @__PURE__ */ application("vnd.recordare.musicxml+xml", "musicxml");
var Application_Vendor_RenLearnRlprint = /* @__PURE__ */ application("vnd.renlearn.rlprint");
var Application_Vendor_RestfulJson = /* @__PURE__ */ application("vnd.restful+json", "json");
var Application_Vendor_RigCryptonote = /* @__PURE__ */ application("vnd.rig.cryptonote", "cryptonote");
var Application_Vendor_RimCod = /* @__PURE__ */ application("vnd.rim.cod", "cod");
var Application_Vendor_Rn_Realmedia = /* @__PURE__ */ application("vnd.rn-realmedia", "rm");
var Application_Vendor_Rn_Realmedia_Vbr = /* @__PURE__ */ application("vnd.rn-realmedia-vbr", "rmvb");
var Application_Vendor_Route66Link66Xml = /* @__PURE__ */ application("vnd.route66.link66+xml", "link66");
var Application_Vendor_Rs_274x = /* @__PURE__ */ application("vnd.rs-274x");
var Application_Vendor_RuckusDownload = /* @__PURE__ */ application("vnd.ruckus.download");
var Application_Vendor_S3sms = /* @__PURE__ */ application("vnd.s3sms");
var Application_Vendor_SailingtrackerTrack = /* @__PURE__ */ application("vnd.sailingtracker.track", "st");
var Application_Vendor_Sar = /* @__PURE__ */ application("vnd.sar");
var Application_Vendor_SbmCid = /* @__PURE__ */ application("vnd.sbm.cid");
var Application_Vendor_SbmMid2 = /* @__PURE__ */ application("vnd.sbm.mid2");
var Application_Vendor_Scribus = /* @__PURE__ */ application("vnd.scribus");
var Application_Vendor_Sealed3df = /* @__PURE__ */ application("vnd.sealed.3df");
var Application_Vendor_SealedCsf = /* @__PURE__ */ application("vnd.sealed.csf");
var Application_Vendor_SealedDoc = /* @__PURE__ */ application("vnd.sealed.doc");
var Application_Vendor_SealedEml = /* @__PURE__ */ application("vnd.sealed.eml");
var Application_Vendor_SealedmediaSoftsealHtml = /* @__PURE__ */ application("vnd.sealedmedia.softseal.html");
var Application_Vendor_SealedmediaSoftsealPdf = /* @__PURE__ */ application("vnd.sealedmedia.softseal.pdf");
var Application_Vendor_SealedMht = /* @__PURE__ */ application("vnd.sealed.mht");
var Application_Vendor_SealedNet = /* @__PURE__ */ application("vnd.sealed.net");
var Application_Vendor_SealedPpt = /* @__PURE__ */ application("vnd.sealed.ppt");
var Application_Vendor_SealedTiff = /* @__PURE__ */ application("vnd.sealed.tiff");
var Application_Vendor_SealedXls = /* @__PURE__ */ application("vnd.sealed.xls");
var Application_Vendor_Seemail = /* @__PURE__ */ application("vnd.seemail", "see");
var Application_Vendor_Sema = /* @__PURE__ */ application("vnd.sema", "sema");
var Application_Vendor_Semd = /* @__PURE__ */ application("vnd.semd", "semd");
var Application_Vendor_Semf = /* @__PURE__ */ application("vnd.semf", "semf");
var Application_Vendor_Shade_Save_File = /* @__PURE__ */ application("vnd.shade-save-file");
var Application_Vendor_ShanaInformedFormdata = /* @__PURE__ */ application("vnd.shana.informed.formdata", "ifm");
var Application_Vendor_ShanaInformedFormtemplate = /* @__PURE__ */ application("vnd.shana.informed.formtemplate", "itp");
var Application_Vendor_ShanaInformedInterchange = /* @__PURE__ */ application("vnd.shana.informed.interchange", "iif");
var Application_Vendor_ShanaInformedPackage = /* @__PURE__ */ application("vnd.shana.informed.package", "ipk");
var Application_Vendor_ShootproofJson = /* @__PURE__ */ application("vnd.shootproof+json", "json");
var Application_Vendor_ShopkickJson = /* @__PURE__ */ application("vnd.shopkick+json", "json");
var Application_Vendor_SigrokSession = /* @__PURE__ */ application("vnd.sigrok.session");
var Application_Vendor_SimTech_MindMapper = /* @__PURE__ */ application("vnd.simtech-mindmapper", "twd", "twds");
var Application_Vendor_SirenJson = /* @__PURE__ */ application("vnd.siren+json", "json");
var Application_Vendor_Smaf = /* @__PURE__ */ application("vnd.smaf", "mmf");
var Application_Vendor_SmartNotebook = /* @__PURE__ */ application("vnd.smart.notebook");
var Application_Vendor_SmartTeacher = /* @__PURE__ */ application("vnd.smart.teacher", "teacher");
var Application_Vendor_Software602FillerForm_Xml_Zip = /* @__PURE__ */ application("vnd.software602.filler.form-xml-zip");
var Application_Vendor_Software602FillerFormXml = /* @__PURE__ */ application("vnd.software602.filler.form+xml", "xml");
var Application_Vendor_SolentSdkmXml = /* @__PURE__ */ application("vnd.solent.sdkm+xml", "sdkm", "sdkd");
var Application_Vendor_SpotfireDxp = /* @__PURE__ */ application("vnd.spotfire.dxp", "dxp");
var Application_Vendor_SpotfireSfs = /* @__PURE__ */ application("vnd.spotfire.sfs", "sfs");
var Application_Vendor_Sqlite3 = /* @__PURE__ */ application("vnd.sqlite3");
var Application_Vendor_Sss_Cod = /* @__PURE__ */ application("vnd.sss-cod");
var Application_Vendor_Sss_Dtf = /* @__PURE__ */ application("vnd.sss-dtf");
var Application_Vendor_Sss_Ntf = /* @__PURE__ */ application("vnd.sss-ntf");
var Application_Vendor_StardivisionCalc = /* @__PURE__ */ application("vnd.stardivision.calc", "sdc");
var Application_Vendor_StardivisionDraw = /* @__PURE__ */ application("vnd.stardivision.draw", "sda");
var Application_Vendor_StardivisionImpress = /* @__PURE__ */ application("vnd.stardivision.impress", "sdd");
var Application_Vendor_StardivisionMath = /* @__PURE__ */ application("vnd.stardivision.math", "smf");
var Application_Vendor_StardivisionWriter = /* @__PURE__ */ application("vnd.stardivision.writer", "sdw", "vor");
var Application_Vendor_StardivisionWriter_Global = /* @__PURE__ */ application("vnd.stardivision.writer-global", "sgl");
var Application_Vendor_StepmaniaPackage = /* @__PURE__ */ application("vnd.stepmania.package", "smzip");
var Application_Vendor_StepmaniaStepchart = /* @__PURE__ */ application("vnd.stepmania.stepchart", "sm");
var Application_Vendor_Street_Stream = /* @__PURE__ */ application("vnd.street-stream");
var Application_Vendor_SunWadlXml = /* @__PURE__ */ application("vnd.sun.wadl+xml", "xml");
var Application_Vendor_SunXmlCalc = /* @__PURE__ */ application("vnd.sun.xml.calc", "sxc");
var Application_Vendor_SunXmlCalcTemplate = /* @__PURE__ */ application("vnd.sun.xml.calc.template", "stc");
var Application_Vendor_SunXmlDraw = /* @__PURE__ */ application("vnd.sun.xml.draw", "sxd");
var Application_Vendor_SunXmlDrawTemplate = /* @__PURE__ */ application("vnd.sun.xml.draw.template", "std");
var Application_Vendor_SunXmlImpress = /* @__PURE__ */ application("vnd.sun.xml.impress", "sxi");
var Application_Vendor_SunXmlImpressTemplate = /* @__PURE__ */ application("vnd.sun.xml.impress.template", "sti");
var Application_Vendor_SunXmlMath = /* @__PURE__ */ application("vnd.sun.xml.math", "sxm");
var Application_Vendor_SunXmlWriter = /* @__PURE__ */ application("vnd.sun.xml.writer", "sxw");
var Application_Vendor_SunXmlWriterGlobal = /* @__PURE__ */ application("vnd.sun.xml.writer.global", "sxg");
var Application_Vendor_SunXmlWriterTemplate = /* @__PURE__ */ application("vnd.sun.xml.writer.template", "stw");
var Application_Vendor_Sus_Calendar = /* @__PURE__ */ application("vnd.sus-calendar", "sus", "susp");
var Application_Vendor_Svd = /* @__PURE__ */ application("vnd.svd", "svd");
var Application_Vendor_Swiftview_Ics = /* @__PURE__ */ application("vnd.swiftview-ics");
var Application_Vendor_SymbianInstall = /* @__PURE__ */ application("vnd.symbian.install", "sis", "sisx");
var Application_Vendor_SyncmlDmddfWbxml = /* @__PURE__ */ application("vnd.syncml.dmddf+wbxml", "wbxml");
var Application_Vendor_SyncmlDmddfXml = /* @__PURE__ */ application("vnd.syncml.dmddf+xml", "xml");
var Application_Vendor_SyncmlDmNotification = /* @__PURE__ */ application("vnd.syncml.dm.notification");
var Application_Vendor_SyncmlDmtndsWbxml = /* @__PURE__ */ application("vnd.syncml.dmtnds+wbxml", "wbxml");
var Application_Vendor_SyncmlDmtndsXml = /* @__PURE__ */ application("vnd.syncml.dmtnds+xml", "xml");
var Application_Vendor_SyncmlDmWbxml = /* @__PURE__ */ application("vnd.syncml.dm+wbxml", "bdm");
var Application_Vendor_SyncmlDmXml = /* @__PURE__ */ application("vnd.syncml.dm+xml", "xdm");
var Application_Vendor_SyncmlDsNotification = /* @__PURE__ */ application("vnd.syncml.ds.notification");
var Application_Vendor_SyncmlXml = /* @__PURE__ */ application("vnd.syncml+xml", "xsm");
var Application_Vendor_TableschemaJson = /* @__PURE__ */ application("vnd.tableschema+json", "json");
var Application_Vendor_TaoIntent_Module_Archive = /* @__PURE__ */ application("vnd.tao.intent-module-archive", "tao");
var Application_Vendor_TcpdumpPcap = /* @__PURE__ */ application("vnd.tcpdump.pcap", "pcap", "cap", "dmp");
var Application_Vendor_Think_CellPpttcJson = /* @__PURE__ */ application("vnd.think-cell.ppttc+json", "json");
var Application_Vendor_TmdMediaflexApiXml = /* @__PURE__ */ application("vnd.tmd.mediaflex.api+xml", "xml");
var Application_Vendor_Tml = /* @__PURE__ */ application("vnd.tml");
var Application_Vendor_Tmobile_Livetv = /* @__PURE__ */ application("vnd.tmobile-livetv", "tmo");
var Application_Vendor_TridTpt = /* @__PURE__ */ application("vnd.trid.tpt", "tpt");
var Application_Vendor_TriOnesource = /* @__PURE__ */ application("vnd.tri.onesource");
var Application_Vendor_TriscapeMxs = /* @__PURE__ */ application("vnd.triscape.mxs", "mxs");
var Application_Vendor_Trueapp = /* @__PURE__ */ application("vnd.trueapp", "tra");
var Application_Vendor_Truedoc = /* @__PURE__ */ application("vnd.truedoc");
var Application_Vendor_UbisoftWebplayer = /* @__PURE__ */ application("vnd.ubisoft.webplayer");
var Application_Vendor_Ufdl = /* @__PURE__ */ application("vnd.ufdl", "ufd", "ufdl");
var Application_Vendor_UiqTheme = /* @__PURE__ */ application("vnd.uiq.theme", "utz");
var Application_Vendor_Umajin = /* @__PURE__ */ application("vnd.umajin", "umj");
var Application_Vendor_Unity = /* @__PURE__ */ application("vnd.unity", "unityweb");
var Application_Vendor_UomlXml = /* @__PURE__ */ application("vnd.uoml+xml", "uoml");
var Application_Vendor_UplanetAlert = /* @__PURE__ */ application("vnd.uplanet.alert");
var Application_Vendor_UplanetAlert_Wbxml = /* @__PURE__ */ application("vnd.uplanet.alert-wbxml");
var Application_Vendor_UplanetBearer_Choice = /* @__PURE__ */ application("vnd.uplanet.bearer-choice");
var Application_Vendor_UplanetBearer_Choice_Wbxml = /* @__PURE__ */ application("vnd.uplanet.bearer-choice-wbxml");
var Application_Vendor_UplanetCacheop = /* @__PURE__ */ application("vnd.uplanet.cacheop");
var Application_Vendor_UplanetCacheop_Wbxml = /* @__PURE__ */ application("vnd.uplanet.cacheop-wbxml");
var Application_Vendor_UplanetChannel = /* @__PURE__ */ application("vnd.uplanet.channel");
var Application_Vendor_UplanetChannel_Wbxml = /* @__PURE__ */ application("vnd.uplanet.channel-wbxml");
var Application_Vendor_UplanetList = /* @__PURE__ */ application("vnd.uplanet.list");
var Application_Vendor_UplanetList_Wbxml = /* @__PURE__ */ application("vnd.uplanet.list-wbxml");
var Application_Vendor_UplanetListcmd = /* @__PURE__ */ application("vnd.uplanet.listcmd");
var Application_Vendor_UplanetListcmd_Wbxml = /* @__PURE__ */ application("vnd.uplanet.listcmd-wbxml");
var Application_Vendor_UplanetSignal = /* @__PURE__ */ application("vnd.uplanet.signal");
var Application_Vendor_Uri_Map = /* @__PURE__ */ application("vnd.uri-map");
var Application_Vendor_ValveSourceMaterial = /* @__PURE__ */ application("vnd.valve.source.material");
var Application_Vendor_Vcx = /* @__PURE__ */ application("vnd.vcx", "vcx");
var Application_Vendor_Vd_Study = /* @__PURE__ */ application("vnd.vd-study");
var Application_Vendor_Vectorworks = /* @__PURE__ */ application("vnd.vectorworks");
var Application_Vendor_VelJson = /* @__PURE__ */ application("vnd.vel+json", "json");
var Application_Vendor_VerimatrixVcas = /* @__PURE__ */ application("vnd.verimatrix.vcas");
var Application_Vendor_VeryantThin = /* @__PURE__ */ application("vnd.veryant.thin");
var Application_Vendor_VesEncrypted = /* @__PURE__ */ application("vnd.ves.encrypted");
var Application_Vendor_VidsoftVidconference = /* @__PURE__ */ application("vnd.vidsoft.vidconference");
var Application_Vendor_Visio = /* @__PURE__ */ application("vnd.visio", "vsd", "vst", "vss", "vsw");
var Application_Vendor_Visionary = /* @__PURE__ */ application("vnd.visionary", "vis");
var Application_Vendor_VividenceScriptfile = /* @__PURE__ */ application("vnd.vividence.scriptfile");
var Application_Vendor_Vsf = /* @__PURE__ */ application("vnd.vsf", "vsf");
var Application_Vendor_WapSic = /* @__PURE__ */ application("vnd.wap.sic");
var Application_Vendor_WapSlc = /* @__PURE__ */ application("vnd.wap.slc");
var Application_Vendor_WapWbxml = /* @__PURE__ */ application("vnd.wap.wbxml", "wbxml");
var Application_Vendor_WapWmlc = /* @__PURE__ */ application("vnd.wap.wmlc", "wmlc");
var Application_Vendor_WapWmlscriptc = /* @__PURE__ */ application("vnd.wap.wmlscriptc", "wmlsc");
var Application_Vendor_Webturbo = /* @__PURE__ */ application("vnd.webturbo", "wtb");
var Application_Vendor_WfaP2p = /* @__PURE__ */ application("vnd.wfa.p2p");
var Application_Vendor_WfaWsc = /* @__PURE__ */ application("vnd.wfa.wsc");
var Application_Vendor_WindowsDevicepairing = /* @__PURE__ */ application("vnd.windows.devicepairing");
var Application_Vendor_Wmc = /* @__PURE__ */ application("vnd.wmc");
var Application_Vendor_WmfBootstrap = /* @__PURE__ */ application("vnd.wmf.bootstrap");
var Application_Vendor_WolframMathematica = /* @__PURE__ */ application("vnd.wolfram.mathematica");
var Application_Vendor_WolframMathematicaPackage = /* @__PURE__ */ application("vnd.wolfram.mathematica.package");
var Application_Vendor_WolframPlayer = /* @__PURE__ */ application("vnd.wolfram.player", "nbp");
var Application_Vendor_Wordperfect = /* @__PURE__ */ application("vnd.wordperfect", "wpd");
var Application_Vendor_Wqd = /* @__PURE__ */ application("vnd.wqd", "wqd");
var Application_Vendor_Wrq_Hp3000_Labelled = /* @__PURE__ */ application("vnd.wrq-hp3000-labelled");
var Application_Vendor_WtStf = /* @__PURE__ */ application("vnd.wt.stf", "stf");
var Application_Vendor_WvCspWbxml = /* @__PURE__ */ application("vnd.wv.csp+wbxml", "wbxml");
var Application_Vendor_WvCspXml = /* @__PURE__ */ application("vnd.wv.csp+xml", "xml");
var Application_Vendor_WvSspXml = /* @__PURE__ */ application("vnd.wv.ssp+xml", "xml");
var Application_Vendor_XacmlJson = /* @__PURE__ */ application("vnd.xacml+json", "json");
var Application_Vendor_Xara = /* @__PURE__ */ application("vnd.xara", "xar");
var Application_Vendor_Xfdl = /* @__PURE__ */ application("vnd.xfdl", "xfdl");
var Application_Vendor_XfdlWebform = /* @__PURE__ */ application("vnd.xfdl.webform");
var Application_Vendor_XmiXml = /* @__PURE__ */ application("vnd.xmi+xml", "xml");
var Application_Vendor_XmpieCpkg = /* @__PURE__ */ application("vnd.xmpie.cpkg");
var Application_Vendor_XmpieDpkg = /* @__PURE__ */ application("vnd.xmpie.dpkg");
var Application_Vendor_XmpiePlan = /* @__PURE__ */ application("vnd.xmpie.plan");
var Application_Vendor_XmpiePpkg = /* @__PURE__ */ application("vnd.xmpie.ppkg");
var Application_Vendor_XmpieXlim = /* @__PURE__ */ application("vnd.xmpie.xlim");
var Application_Vendor_YamahaHv_Dic = /* @__PURE__ */ application("vnd.yamaha.hv-dic", "hvd");
var Application_Vendor_YamahaHv_Script = /* @__PURE__ */ application("vnd.yamaha.hv-script", "hvs");
var Application_Vendor_YamahaHv_Voice = /* @__PURE__ */ application("vnd.yamaha.hv-voice", "hvp");
var Application_Vendor_YamahaOpenscoreformat = /* @__PURE__ */ application("vnd.yamaha.openscoreformat", "osf");
var Application_Vendor_YamahaOpenscoreformatOsfpvgXml = /* @__PURE__ */ application("vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg");
var Application_Vendor_YamahaRemote_Setup = /* @__PURE__ */ application("vnd.yamaha.remote-setup");
var Application_Vendor_YamahaSmaf_Audio = /* @__PURE__ */ application("vnd.yamaha.smaf-audio", "saf");
var Application_Vendor_YamahaSmaf_Phrase = /* @__PURE__ */ application("vnd.yamaha.smaf-phrase", "spf");
var Application_Vendor_YamahaThrough_Ngn = /* @__PURE__ */ application("vnd.yamaha.through-ngn");
var Application_Vendor_YamahaTunnel_Udpencap = /* @__PURE__ */ application("vnd.yamaha.tunnel-udpencap");
var Application_Vendor_Yaoweme = /* @__PURE__ */ application("vnd.yaoweme");
var Application_Vendor_Yellowriver_Custom_Menu = /* @__PURE__ */ application("vnd.yellowriver-custom-menu", "cmp");
var Application_Vendor_YoutubeYt = /* @__PURE__ */ application("vnd.youtube.yt").deprecate("in favor of video/vnd.youtube.yt");
var Application_Vendor_Zul = /* @__PURE__ */ application("vnd.zul", "zir", "zirz");
var Application_Vendor_ZzazzDeckXml = /* @__PURE__ */ application("vnd.zzazz.deck+xml", "zaz");
var Application_VividenceScriptfile = /* @__PURE__ */ application("vividence.scriptfile");
var Application_VoicexmlXml = /* @__PURE__ */ application("voicexml+xml", "vxml");
var Application_Voucher_CmsJson = /* @__PURE__ */ application("voucher-cms+json", "json");
var Application_Vq_Rtcpxr = /* @__PURE__ */ application("vq-rtcpxr");
var Application_Wasm = /* @__PURE__ */ application("wasm", "wasm");
var Application_WatcherinfoXml = /* @__PURE__ */ application("watcherinfo+xml", "xml");
var Application_Webpush_OptionsJson = /* @__PURE__ */ application("webpush-options+json", "json");
var Application_Whoispp_Query = /* @__PURE__ */ application("whoispp-query");
var Application_Whoispp_Response = /* @__PURE__ */ application("whoispp-response");
var Application_Widget = /* @__PURE__ */ application("widget", "wgt");
var Application_Winhlp = /* @__PURE__ */ application("winhlp", "hlp");
var Application_Wita = /* @__PURE__ */ application("wita");
var Application_Wordperfect51 = /* @__PURE__ */ application("wordperfect5.1");
var Application_WsdlXml = /* @__PURE__ */ application("wsdl+xml", "wsdl");
var Application_WspolicyXml = /* @__PURE__ */ application("wspolicy+xml", "wspolicy");
var Application_X_7z_Compressed = /* @__PURE__ */ application("x-7z-compressed", "7z");
var Application_X_Abiword = /* @__PURE__ */ application("x-abiword", "abw");
var Application_X_Ace_Compressed = /* @__PURE__ */ application("x-ace-compressed", "ace");
var Application_X_Amf = /* @__PURE__ */ application("x-amf");
var Application_X_Apple_Diskimage = /* @__PURE__ */ application("x-apple-diskimage", "dmg");
var Application_X_Arj = /* @__PURE__ */ application("x-arj", "arj");
var Application_X_Authorware_Bin = /* @__PURE__ */ application("x-authorware-bin", "aab", "x32", "u32", "vox");
var Application_X_Authorware_Map = /* @__PURE__ */ application("x-authorware-map", "aam");
var Application_X_Authorware_Seg = /* @__PURE__ */ application("x-authorware-seg", "aas");
var Application_X_Bcpio = /* @__PURE__ */ application("x-bcpio", "bcpio");
var Application_X_Bdoc = /* @__PURE__ */ application("x-bdoc", "bdoc");
var Application_X_Bittorrent = /* @__PURE__ */ application("x-bittorrent", "torrent");
var Application_X_Blorb = /* @__PURE__ */ application("x-blorb", "blb", "blorb");
var Application_X_Bzip = /* @__PURE__ */ application("x-bzip", "bz");
var Application_X_Bzip2 = /* @__PURE__ */ application("x-bzip2", "bz2", "boz");
var Application_X_Cbr = /* @__PURE__ */ application("x-cbr", "cbr", "cba", "cbt", "cbz", "cb7");
var Application_X_Cdlink = /* @__PURE__ */ application("x-cdlink", "vcd");
var Application_X_Cfs_Compressed = /* @__PURE__ */ application("x-cfs-compressed", "cfs");
var Application_X_Chat = /* @__PURE__ */ application("x-chat", "chat");
var Application_X_Chess_Pgn = /* @__PURE__ */ application("x-chess-pgn", "pgn");
var Application_X_Chrome_Extension = /* @__PURE__ */ application("x-chrome-extension", "crx");
var Application_X_Deb = /* @__PURE__ */ application("x-deb");
var Application_X_Compress = /* @__PURE__ */ application("x-compress");
var Application_X_Conference = /* @__PURE__ */ application("x-conference", "nsc");
var Application_X_Cpio = /* @__PURE__ */ application("x-cpio", "cpio");
var Application_X_Csh = /* @__PURE__ */ application("x-csh", "csh");
var Application_X_Debian_Package = /* @__PURE__ */ application("x-debian-package", "deb", "udeb");
var Application_X_Dgc_Compressed = /* @__PURE__ */ application("x-dgc-compressed", "dgc");
var Application_X_Director = /* @__PURE__ */ application("x-director", "dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa");
var Application_X_Doom = /* @__PURE__ */ application("x-doom", "wad");
var Application_X_DtbncxXml = /* @__PURE__ */ application("x-dtbncx+xml", "ncx");
var Application_X_DtbookXml = /* @__PURE__ */ application("x-dtbook+xml", "dtb");
var Application_X_DtbresourceXml = /* @__PURE__ */ application("x-dtbresource+xml", "res");
var Application_X_Dvi = /* @__PURE__ */ application("x-dvi", "dvi");
var Application_X_Envoy = /* @__PURE__ */ application("x-envoy", "evy");
var Application_X_Eva = /* @__PURE__ */ application("x-eva", "eva");
var Application_X_Font_Bdf = /* @__PURE__ */ application("x-font-bdf", "bdf");
var Application_X_Font_Dos = /* @__PURE__ */ application("x-font-dos");
var Application_X_Font_Framemaker = /* @__PURE__ */ application("x-font-framemaker");
var Application_X_Font_Ghostscript = /* @__PURE__ */ application("x-font-ghostscript", "gsf");
var Application_X_Font_Libgrx = /* @__PURE__ */ application("x-font-libgrx");
var Application_X_Font_Linux_Psf = /* @__PURE__ */ application("x-font-linux-psf", "psf");
var Application_X_Font_Pcf = /* @__PURE__ */ application("x-font-pcf", "pcf");
var Application_X_Font_Snf = /* @__PURE__ */ application("x-font-snf", "snf");
var Application_X_Font_Speedo = /* @__PURE__ */ application("x-font-speedo");
var Application_X_Font_Sunos_News = /* @__PURE__ */ application("x-font-sunos-news");
var Application_X_Font_Type1 = /* @__PURE__ */ application("x-font-type1", "pfa", "pfb", "pfm", "afm");
var Application_X_Font_Vfont = /* @__PURE__ */ application("x-font-vfont");
var Application_X_Freearc = /* @__PURE__ */ application("x-freearc", "arc");
var Application_X_Futuresplash = /* @__PURE__ */ application("x-futuresplash", "spl");
var Application_X_Gca_Compressed = /* @__PURE__ */ application("x-gca-compressed", "gca");
var Application_X_Glulx = /* @__PURE__ */ application("x-glulx", "ulx");
var Application_X_Gnumeric = /* @__PURE__ */ application("x-gnumeric", "gnumeric");
var Application_X_Gramps_Xml = /* @__PURE__ */ application("x-gramps-xml", "gramps");
var Application_X_Gtar = /* @__PURE__ */ application("x-gtar", "gtar");
var Application_X_Gzip = /* @__PURE__ */ application("x-gzip");
var Application_X_Hdf = /* @__PURE__ */ application("x-hdf", "hdf");
var Application_X_Httpd_Php = /* @__PURE__ */ application("x-httpd-php", "php");
var Application_X_Install_Instructions = /* @__PURE__ */ application("x-install-instructions", "install");
var Application_X_Iso9660_Image = /* @__PURE__ */ application("x-iso9660-image", "iso");
var Application_X_Iwork_Keynote_Sffkey = /* @__PURE__ */ application("x-iwork-keynote-sffkey", "key").deprecate("alias for iWorks Keynote file");
var Application_X_Iwork_Numbers_Sffnumbers = /* @__PURE__ */ application("x-iwork-numbers-sffnumbers", "numbers").deprecate("alias for iWorks Numbers file");
var Application_X_Iwork_Pages_Sffpages = /* @__PURE__ */ application("x-iwork-pages-sffpages", "pages").deprecate("alias for iWorks Pages file");
var Application_X_Java_Jnlp_File = /* @__PURE__ */ application("x-java-jnlp-file", "jnlp");
var Application_X_Javascript = /* @__PURE__ */ application("x-javascript");
var Application_X_Keepass2 = /* @__PURE__ */ application("x-keepass2", "kdbx");
var Application_X_Latex = /* @__PURE__ */ application("x-latex", "latex");
var Application_X_Lua_Bytecode = /* @__PURE__ */ application("x-lua-bytecode", "luac");
var Application_X_Lzh_Compressed = /* @__PURE__ */ application("x-lzh-compressed", "lzh", "lha");
var Application_X_Mie = /* @__PURE__ */ application("x-mie", "mie");
var Application_X_Mobipocket_Ebook = /* @__PURE__ */ application("x-mobipocket-ebook", "prc", "mobi");
var Application_X_Mpegurl = /* @__PURE__ */ application("x-mpegurl");
var Application_X_Ms_Application = /* @__PURE__ */ application("x-ms-application", "application");
var Application_X_Ms_Shortcut = /* @__PURE__ */ application("x-ms-shortcut", "lnk");
var Application_X_Ms_Wmd = /* @__PURE__ */ application("x-ms-wmd", "wmd");
var Application_X_Ms_Wmz = /* @__PURE__ */ application("x-ms-wmz", "wmz");
var Application_X_Ms_Xbap = /* @__PURE__ */ application("x-ms-xbap", "xbap");
var Application_X_Msdos_Program = /* @__PURE__ */ application("x-msdos-program", "exe");
var Application_X_Msaccess = /* @__PURE__ */ application("x-msaccess", "mdb");
var Application_X_Msbinder = /* @__PURE__ */ application("x-msbinder", "obd");
var Application_X_Mscardfile = /* @__PURE__ */ application("x-mscardfile", "crd");
var Application_X_Msclip = /* @__PURE__ */ application("x-msclip", "clp");
var Application_X_Msdownload = /* @__PURE__ */ application("x-msdownload", "exe", "dll", "com", "bat", "msi");
var Application_X_Msmediaview = /* @__PURE__ */ application("x-msmediaview", "mvb", "m13", "m14");
var Application_X_Msmetafile = /* @__PURE__ */ application("x-msmetafile", "wmf", "wmz", "emf", "emz");
var Application_X_Msmoney = /* @__PURE__ */ application("x-msmoney", "mny");
var Application_X_Mspublisher = /* @__PURE__ */ application("x-mspublisher", "pub");
var Application_X_Msschedule = /* @__PURE__ */ application("x-msschedule", "scd");
var Application_X_Msterminal = /* @__PURE__ */ application("x-msterminal", "trm");
var Application_X_Mswrite = /* @__PURE__ */ application("x-mswrite", "wri");
var Application_X_Netcdf = /* @__PURE__ */ application("x-netcdf", "nc", "cdf");
var Application_X_Ns_Proxy_Autoconfig = /* @__PURE__ */ application("x-ns-proxy-autoconfig", "pac");
var Application_X_Nzb = /* @__PURE__ */ application("x-nzb", "nzb");
var Application_X_Pkcs12 = /* @__PURE__ */ application("x-pkcs12", "p12", "pfx");
var Application_X_Pkcs7_Certificates = /* @__PURE__ */ application("x-pkcs7-certificates", "p7b", "spc");
var Application_X_Pkcs7_Certreqresp = /* @__PURE__ */ application("x-pkcs7-certreqresp", "p7r");
var Application_X_Rar_Compressed = /* @__PURE__ */ application("x-rar-compressed", "rar");
var Application_X_Research_Info_Systems = /* @__PURE__ */ application("x-research-info-systems", "ris");
var Application_X_Sh = /* @__PURE__ */ application("x-sh", "sh");
var Application_X_Shar = /* @__PURE__ */ application("x-shar", "shar");
var Application_X_Shockwave_Flash = /* @__PURE__ */ application("x-shockwave-flash", "swf");
var Application_X_Silverlight_App = /* @__PURE__ */ application("x-silverlight-app", "xap");
var Application_X_Sql = /* @__PURE__ */ application("x-sql", "sql");
var Application_X_Stuffit = /* @__PURE__ */ application("x-stuffit", "sit");
var Application_X_Stuffitx = /* @__PURE__ */ application("x-stuffitx", "sitx");
var Application_X_Subrip = /* @__PURE__ */ application("x-subrip", "srt");
var Application_X_Sv4cpio = /* @__PURE__ */ application("x-sv4cpio", "sv4cpio");
var Application_X_Sv4crc = /* @__PURE__ */ application("x-sv4crc", "sv4crc");
var Application_X_T3vm_Image = /* @__PURE__ */ application("x-t3vm-image", "t3");
var Application_X_Tads = /* @__PURE__ */ application("x-tads", "gam");
var Application_X_Tar = /* @__PURE__ */ application("x-tar", "tar");
var Application_X_Tcl = /* @__PURE__ */ application("x-tcl", "tcl");
var Application_X_Tex = /* @__PURE__ */ application("x-tex", "tex");
var Application_X_Tex_Tfm = /* @__PURE__ */ application("x-tex-tfm", "tfm");
var Application_X_Texinfo = /* @__PURE__ */ application("x-texinfo", "texinfo", "texi");
var Application_X_Tgif = /* @__PURE__ */ application("x-tgif", "obj");
var Application_X_Url = /* @__PURE__ */ application("x-url", "url");
var Application_X_Ustar = /* @__PURE__ */ application("x-ustar", "ustar");
var Application_X_Virtualbox_Hdd = /* @__PURE__ */ application("x-virtualbox-hdd", "hdd");
var Application_X_Virtualbox_Ova = /* @__PURE__ */ application("x-virtualbox-ova", "ova");
var Application_X_Virtualbox_Ovf = /* @__PURE__ */ application("x-virtualbox-ovf", "ovf");
var Application_X_Virtualbox_Vbox = /* @__PURE__ */ application("x-virtualbox-vbox", "vbox");
var Application_X_Virtualbox_Vbox_Extpack = /* @__PURE__ */ application("x-virtualbox-vbox-extpack", "vbox-extpack");
var Application_X_Virtualbox_Vdi = /* @__PURE__ */ application("x-virtualbox-vdi", "vdi");
var Application_X_Virtualbox_Vhd = /* @__PURE__ */ application("x-virtualbox-vhd", "vhd");
var Application_X_Virtualbox_Vmdk = /* @__PURE__ */ application("x-virtualbox-vmdk", "vmdk");
var Application_X_Wais_Source = /* @__PURE__ */ application("x-wais-source", "src");
var Application_X_Web_App_ManifestJson = /* @__PURE__ */ application("x-web-app-manifest+json", "webapp");
var Application_X_Www_Form_Urlencoded = /* @__PURE__ */ application("x-www-form-urlencoded");
var Application_X_X509_Ca_Cert = /* @__PURE__ */ application("x-x509-ca-cert", "der", "crt");
var Application_X_Xfig = /* @__PURE__ */ application("x-xfig", "fig");
var Application_X_XliffXml = /* @__PURE__ */ application("x-xliff+xml", "xlf");
var Application_X_Xpinstall = /* @__PURE__ */ application("x-xpinstall", "xpi");
var Application_X_Xz = /* @__PURE__ */ application("x-xz", "xz");
var Application_X_Zip_Compressed = /* @__PURE__ */ application("x-zip-compressed", "zip");
var Application_X_Zmachine = /* @__PURE__ */ application("x-zmachine", "z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8");
var Application_X400_Bp = /* @__PURE__ */ application("x400-bp");
var Application_XacmlXml = /* @__PURE__ */ application("xacml+xml", "xml");
var Application_XamlXml = /* @__PURE__ */ application("xaml+xml", "xaml");
var Application_Xcap_AttXml = /* @__PURE__ */ application("xcap-att+xml", "xml");
var Application_Xcap_CapsXml = /* @__PURE__ */ application("xcap-caps+xml", "xml");
var Application_Xcap_DiffXml = /* @__PURE__ */ application("xcap-diff+xml", "xdf");
var Application_Xcap_ElXml = /* @__PURE__ */ application("xcap-el+xml", "xml");
var Application_Xcap_ErrorXml = /* @__PURE__ */ application("xcap-error+xml", "xml");
var Application_Xcap_NsXml = /* @__PURE__ */ application("xcap-ns+xml", "xml");
var Application_Xcon_Conference_Info_DiffXml = /* @__PURE__ */ application("xcon-conference-info-diff+xml", "xml");
var Application_Xcon_Conference_InfoXml = /* @__PURE__ */ application("xcon-conference-info+xml", "xml");
var Application_XencXml = /* @__PURE__ */ application("xenc+xml", "xenc");
var Application_Xhtml_VoiceXml = /* @__PURE__ */ application("xhtml-voice+xml", "xml");
var Application_XhtmlXml = /* @__PURE__ */ application("xhtml+xml", "xhtml", "xht");
var Application_XliffXml = /* @__PURE__ */ application("xliff+xml", "xml");
var Application_Xml = /* @__PURE__ */ application("xml", "xml", "xsl");
var Application_Xml_Dtd = /* @__PURE__ */ application("xml-dtd", "dtd");
var Application_Xml_External_Parsed_Entity = /* @__PURE__ */ application("xml-external-parsed-entity");
var Application_Xml_PatchXml = /* @__PURE__ */ application("xml-patch+xml", "xml");
var Application_XmppXml = /* @__PURE__ */ application("xmpp+xml", "xml");
var Application_XopXml = /* @__PURE__ */ application("xop+xml", "xop");
var Application_XprocXml = /* @__PURE__ */ application("xproc+xml", "xpl");
var Application_XsltXml = /* @__PURE__ */ application("xslt+xml", "xslt");
var Application_XspfXml = /* @__PURE__ */ application("xspf+xml", "xspf");
var Application_XvXml = /* @__PURE__ */ application("xv+xml", "mxml", "xhvml", "xvml", "xvm");
var Application_Yang = /* @__PURE__ */ application("yang", "yang");
var Application_Yang_DataJson = /* @__PURE__ */ application("yang-data+json", "json");
var Application_Yang_DataXml = /* @__PURE__ */ application("yang-data+xml", "xml");
var Application_Yang_PatchJson = /* @__PURE__ */ application("yang-patch+json", "json");
var Application_Yang_PatchXml = /* @__PURE__ */ application("yang-patch+xml", "xml");
var Application_YinXml = /* @__PURE__ */ application("yin+xml", "yin");
var Application_Zip = /* @__PURE__ */ application("zip", "zip");
var Application_Zlib = /* @__PURE__ */ application("zlib");
var Application_Zstd = /* @__PURE__ */ application("zstd");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/audio.ts
var audio_exports = {};
__export(audio_exports, {
  Audio_AMR: () => Audio_AMR,
  Audio_AMR_WB: () => Audio_AMR_WB,
  Audio_ATRAC3: () => Audio_ATRAC3,
  Audio_ATRAC_ADVANCED_LOSSLESS: () => Audio_ATRAC_ADVANCED_LOSSLESS,
  Audio_ATRAC_X: () => Audio_ATRAC_X,
  Audio_Aac: () => Audio_Aac,
  Audio_Ac3: () => Audio_Ac3,
  Audio_Adpcm: () => Audio_Adpcm,
  Audio_Amr_WbPlus: () => Audio_Amr_WbPlus,
  Audio_Aptx: () => Audio_Aptx,
  Audio_Asc: () => Audio_Asc,
  Audio_BV16: () => Audio_BV16,
  Audio_BV32: () => Audio_BV32,
  Audio_Basic: () => Audio_Basic,
  Audio_CN: () => Audio_CN,
  Audio_Clearmode: () => Audio_Clearmode,
  Audio_DAT12: () => Audio_DAT12,
  Audio_DV: () => Audio_DV,
  Audio_DVI4: () => Audio_DVI4,
  Audio_Dls: () => Audio_Dls,
  Audio_Dsr_Es201108: () => Audio_Dsr_Es201108,
  Audio_Dsr_Es202050: () => Audio_Dsr_Es202050,
  Audio_Dsr_Es202211: () => Audio_Dsr_Es202211,
  Audio_Dsr_Es202212: () => Audio_Dsr_Es202212,
  Audio_EVRC: () => Audio_EVRC,
  Audio_EVRC0: () => Audio_EVRC0,
  Audio_EVRC1: () => Audio_EVRC1,
  Audio_EVRCB: () => Audio_EVRCB,
  Audio_EVRCB0: () => Audio_EVRCB0,
  Audio_EVRCB1: () => Audio_EVRCB1,
  Audio_EVRCNW: () => Audio_EVRCNW,
  Audio_EVRCNW0: () => Audio_EVRCNW0,
  Audio_EVRCNW1: () => Audio_EVRCNW1,
  Audio_EVRCWB: () => Audio_EVRCWB,
  Audio_EVRCWB0: () => Audio_EVRCWB0,
  Audio_EVRCWB1: () => Audio_EVRCWB1,
  Audio_EVRC_QCP: () => Audio_EVRC_QCP,
  Audio_EVS: () => Audio_EVS,
  Audio_Eac3: () => Audio_Eac3,
  Audio_Encaprtp: () => Audio_Encaprtp,
  Audio_Example: () => Audio_Example,
  Audio_Flexfec: () => Audio_Flexfec,
  Audio_Fwdred: () => Audio_Fwdred,
  Audio_G711_0: () => Audio_G711_0,
  Audio_G719: () => Audio_G719,
  Audio_G722: () => Audio_G722,
  Audio_G7221: () => Audio_G7221,
  Audio_G723: () => Audio_G723,
  Audio_G726_16: () => Audio_G726_16,
  Audio_G726_24: () => Audio_G726_24,
  Audio_G726_32: () => Audio_G726_32,
  Audio_G726_40: () => Audio_G726_40,
  Audio_G728: () => Audio_G728,
  Audio_G729: () => Audio_G729,
  Audio_G7291: () => Audio_G7291,
  Audio_G729D: () => Audio_G729D,
  Audio_G729E: () => Audio_G729E,
  Audio_GSM: () => Audio_GSM,
  Audio_GSM_EFR: () => Audio_GSM_EFR,
  Audio_GSM_HR_08: () => Audio_GSM_HR_08,
  Audio_ILBC: () => Audio_ILBC,
  Audio_Ip_Mr_v25: () => Audio_Ip_Mr_v25,
  Audio_Isac: () => Audio_Isac,
  Audio_L16: () => Audio_L16,
  Audio_L20: () => Audio_L20,
  Audio_L24: () => Audio_L24,
  Audio_L8: () => Audio_L8,
  Audio_LPC: () => Audio_LPC,
  Audio_MELP: () => Audio_MELP,
  Audio_MELP1200: () => Audio_MELP1200,
  Audio_MELP2400: () => Audio_MELP2400,
  Audio_MELP600: () => Audio_MELP600,
  Audio_MP4A_LATM: () => Audio_MP4A_LATM,
  Audio_MPA: () => Audio_MPA,
  Audio_Midi: () => Audio_Midi,
  Audio_Mobile_Xmf: () => Audio_Mobile_Xmf,
  Audio_Mp4: () => Audio_Mp4,
  Audio_Mpa_Robust: () => Audio_Mpa_Robust,
  Audio_Mpeg: () => Audio_Mpeg,
  Audio_Mpeg4_Generic: () => Audio_Mpeg4_Generic,
  Audio_Musepack: () => Audio_Musepack,
  Audio_Ogg: () => Audio_Ogg,
  Audio_Opus: () => Audio_Opus,
  Audio_PCMA: () => Audio_PCMA,
  Audio_PCMA_WB: () => Audio_PCMA_WB,
  Audio_PCMU: () => Audio_PCMU,
  Audio_PCMU_WB: () => Audio_PCMU_WB,
  Audio_Parityfec: () => Audio_Parityfec,
  Audio_PrsSid: () => Audio_PrsSid,
  Audio_Qcelp: () => Audio_Qcelp,
  Audio_RED: () => Audio_RED,
  Audio_Raptorfec: () => Audio_Raptorfec,
  Audio_Rtp_Enc_Aescm128: () => Audio_Rtp_Enc_Aescm128,
  Audio_Rtp_Midi: () => Audio_Rtp_Midi,
  Audio_Rtploopback: () => Audio_Rtploopback,
  Audio_Rtx: () => Audio_Rtx,
  Audio_S3m: () => Audio_S3m,
  Audio_SMV: () => Audio_SMV,
  Audio_SMV0: () => Audio_SMV0,
  Audio_SMV_QCP: () => Audio_SMV_QCP,
  Audio_Silk: () => Audio_Silk,
  Audio_Sp_Midi: () => Audio_Sp_Midi,
  Audio_Speex: () => Audio_Speex,
  Audio_T140c: () => Audio_T140c,
  Audio_T38: () => Audio_T38,
  Audio_TETRA_ACELP: () => Audio_TETRA_ACELP,
  Audio_TETRA_ACELP_BB: () => Audio_TETRA_ACELP_BB,
  Audio_Telephone_Event: () => Audio_Telephone_Event,
  Audio_Tone: () => Audio_Tone,
  Audio_UEMCLIP: () => Audio_UEMCLIP,
  Audio_Ulpfec: () => Audio_Ulpfec,
  Audio_Usac: () => Audio_Usac,
  Audio_VDVI: () => Audio_VDVI,
  Audio_VMR_WB: () => Audio_VMR_WB,
  Audio_Vendor_1d_Interleaved_Parityfec: () => Audio_Vendor_1d_Interleaved_Parityfec,
  Audio_Vendor_32kadpcm: () => Audio_Vendor_32kadpcm,
  Audio_Vendor_3gpp: () => Audio_Vendor_3gpp,
  Audio_Vendor_3gpp2: () => Audio_Vendor_3gpp2,
  Audio_Vendor_3gppIufp: () => Audio_Vendor_3gppIufp,
  Audio_Vendor_4SB: () => Audio_Vendor_4SB,
  Audio_Vendor_Audiokoz: () => Audio_Vendor_Audiokoz,
  Audio_Vendor_CELP: () => Audio_Vendor_CELP,
  Audio_Vendor_CiscoNse: () => Audio_Vendor_CiscoNse,
  Audio_Vendor_CmlesRadio_Events: () => Audio_Vendor_CmlesRadio_Events,
  Audio_Vendor_CnsAnp1: () => Audio_Vendor_CnsAnp1,
  Audio_Vendor_CnsInf1: () => Audio_Vendor_CnsInf1,
  Audio_Vendor_DeceAudio: () => Audio_Vendor_DeceAudio,
  Audio_Vendor_Digital_Winds: () => Audio_Vendor_Digital_Winds,
  Audio_Vendor_DlnaAdts: () => Audio_Vendor_DlnaAdts,
  Audio_Vendor_DolbyHeaac1: () => Audio_Vendor_DolbyHeaac1,
  Audio_Vendor_DolbyHeaac2: () => Audio_Vendor_DolbyHeaac2,
  Audio_Vendor_DolbyMlp: () => Audio_Vendor_DolbyMlp,
  Audio_Vendor_DolbyMps: () => Audio_Vendor_DolbyMps,
  Audio_Vendor_DolbyPl2: () => Audio_Vendor_DolbyPl2,
  Audio_Vendor_DolbyPl2x: () => Audio_Vendor_DolbyPl2x,
  Audio_Vendor_DolbyPl2z: () => Audio_Vendor_DolbyPl2z,
  Audio_Vendor_DolbyPulse1: () => Audio_Vendor_DolbyPulse1,
  Audio_Vendor_Dra: () => Audio_Vendor_Dra,
  Audio_Vendor_Dts: () => Audio_Vendor_Dts,
  Audio_Vendor_DtsHd: () => Audio_Vendor_DtsHd,
  Audio_Vendor_DtsUhd: () => Audio_Vendor_DtsUhd,
  Audio_Vendor_DvbFile: () => Audio_Vendor_DvbFile,
  Audio_Vendor_EveradPlj: () => Audio_Vendor_EveradPlj,
  Audio_Vendor_HnsAudio: () => Audio_Vendor_HnsAudio,
  Audio_Vendor_LucentVoice: () => Audio_Vendor_LucentVoice,
  Audio_Vendor_Ms_PlayreadyMediaPya: () => Audio_Vendor_Ms_PlayreadyMediaPya,
  Audio_Vendor_NokiaMobile_Xmf: () => Audio_Vendor_NokiaMobile_Xmf,
  Audio_Vendor_NortelVbk: () => Audio_Vendor_NortelVbk,
  Audio_Vendor_NueraEcelp4800: () => Audio_Vendor_NueraEcelp4800,
  Audio_Vendor_NueraEcelp7470: () => Audio_Vendor_NueraEcelp7470,
  Audio_Vendor_NueraEcelp9600: () => Audio_Vendor_NueraEcelp9600,
  Audio_Vendor_OctelSbc: () => Audio_Vendor_OctelSbc,
  Audio_Vendor_PresonusMultitrack: () => Audio_Vendor_PresonusMultitrack,
  Audio_Vendor_Qcelp: () => Audio_Vendor_Qcelp,
  Audio_Vendor_Rhetorex32kadpcm: () => Audio_Vendor_Rhetorex32kadpcm,
  Audio_Vendor_Rip: () => Audio_Vendor_Rip,
  Audio_Vendor_Rn_Realaudio: () => Audio_Vendor_Rn_Realaudio,
  Audio_Vendor_SealedmediaSoftsealMpeg: () => Audio_Vendor_SealedmediaSoftsealMpeg,
  Audio_Vendor_VmxCvsd: () => Audio_Vendor_VmxCvsd,
  Audio_Vendor_Wave: () => Audio_Vendor_Wave,
  Audio_Vorbis: () => Audio_Vorbis,
  Audio_Vorbis_Config: () => Audio_Vorbis_Config,
  Audio_Wav: () => Audio_Wav,
  Audio_Wave: () => Audio_Wave,
  Audio_WebMOpus: () => Audio_WebMOpus,
  Audio_Webm: () => Audio_Webm,
  Audio_X_Aac: () => Audio_X_Aac,
  Audio_X_Aiff: () => Audio_X_Aiff,
  Audio_X_Caf: () => Audio_X_Caf,
  Audio_X_Flac: () => Audio_X_Flac,
  Audio_X_Matroska: () => Audio_X_Matroska,
  Audio_X_Mpegurl: () => Audio_X_Mpegurl,
  Audio_X_Ms_Wax: () => Audio_X_Ms_Wax,
  Audio_X_Ms_Wma: () => Audio_X_Ms_Wma,
  Audio_X_Pn_Realaudio: () => Audio_X_Pn_Realaudio,
  Audio_X_Pn_Realaudio_Plugin: () => Audio_X_Pn_Realaudio_Plugin,
  Audio_X_Tta: () => Audio_X_Tta,
  Audio_X_Wav: () => Audio_X_Wav,
  Audio_Xm: () => Audio_Xm
});
var audio = /* @__PURE__ */ specialize("audio");
var Audio_Aac = /* @__PURE__ */ audio("aac", "aac");
var Audio_Ac3 = /* @__PURE__ */ audio("ac3", "ac3");
var Audio_Adpcm = /* @__PURE__ */ audio("adpcm", "adp");
var Audio_AMR = /* @__PURE__ */ audio("amr", "amr");
var Audio_AMR_WB = /* @__PURE__ */ audio("amr-wb");
var Audio_Amr_WbPlus = /* @__PURE__ */ audio("amr-wb+");
var Audio_Aptx = /* @__PURE__ */ audio("aptx");
var Audio_Asc = /* @__PURE__ */ audio("asc");
var Audio_ATRAC_ADVANCED_LOSSLESS = /* @__PURE__ */ audio("atrac-advanced-lossless");
var Audio_ATRAC_X = /* @__PURE__ */ audio("atrac-x");
var Audio_ATRAC3 = /* @__PURE__ */ audio("atrac3");
var Audio_Basic = /* @__PURE__ */ audio("basic", "au", "snd");
var Audio_BV16 = /* @__PURE__ */ audio("bv16");
var Audio_BV32 = /* @__PURE__ */ audio("bv32");
var Audio_Clearmode = /* @__PURE__ */ audio("clearmode");
var Audio_CN = /* @__PURE__ */ audio("cn");
var Audio_DAT12 = /* @__PURE__ */ audio("dat12");
var Audio_Dls = /* @__PURE__ */ audio("dls");
var Audio_Dsr_Es201108 = /* @__PURE__ */ audio("dsr-es201108");
var Audio_Dsr_Es202050 = /* @__PURE__ */ audio("dsr-es202050");
var Audio_Dsr_Es202211 = /* @__PURE__ */ audio("dsr-es202211");
var Audio_Dsr_Es202212 = /* @__PURE__ */ audio("dsr-es202212");
var Audio_DV = /* @__PURE__ */ audio("dv");
var Audio_DVI4 = /* @__PURE__ */ audio("dvi4");
var Audio_Eac3 = /* @__PURE__ */ audio("eac3");
var Audio_Encaprtp = /* @__PURE__ */ audio("encaprtp");
var Audio_EVRC = /* @__PURE__ */ audio("evrc");
var Audio_EVRC_QCP = /* @__PURE__ */ audio("evrc-qcp");
var Audio_EVRC0 = /* @__PURE__ */ audio("evrc0");
var Audio_EVRC1 = /* @__PURE__ */ audio("evrc1");
var Audio_EVRCB = /* @__PURE__ */ audio("evrcb");
var Audio_EVRCB0 = /* @__PURE__ */ audio("evrcb0");
var Audio_EVRCB1 = /* @__PURE__ */ audio("evrcb1");
var Audio_EVRCNW = /* @__PURE__ */ audio("evrcnw");
var Audio_EVRCNW0 = /* @__PURE__ */ audio("evrcnw0");
var Audio_EVRCNW1 = /* @__PURE__ */ audio("evrcnw1");
var Audio_EVRCWB = /* @__PURE__ */ audio("evrcwb");
var Audio_EVRCWB0 = /* @__PURE__ */ audio("evrcwb0");
var Audio_EVRCWB1 = /* @__PURE__ */ audio("evrcwb1");
var Audio_EVS = /* @__PURE__ */ audio("evs");
var Audio_Example = /* @__PURE__ */ audio("example");
var Audio_Flexfec = /* @__PURE__ */ audio("flexfec");
var Audio_Fwdred = /* @__PURE__ */ audio("fwdred");
var Audio_G711_0 = /* @__PURE__ */ audio("g711-0");
var Audio_G719 = /* @__PURE__ */ audio("g719");
var Audio_G722 = /* @__PURE__ */ audio("g722");
var Audio_G7221 = /* @__PURE__ */ audio("g7221");
var Audio_G723 = /* @__PURE__ */ audio("g723");
var Audio_G726_16 = /* @__PURE__ */ audio("g726-16");
var Audio_G726_24 = /* @__PURE__ */ audio("g726-24");
var Audio_G726_32 = /* @__PURE__ */ audio("g726-32");
var Audio_G726_40 = /* @__PURE__ */ audio("g726-40");
var Audio_G728 = /* @__PURE__ */ audio("g728");
var Audio_G729 = /* @__PURE__ */ audio("g729");
var Audio_G7291 = /* @__PURE__ */ audio("g7291");
var Audio_G729D = /* @__PURE__ */ audio("g729d");
var Audio_G729E = /* @__PURE__ */ audio("g729e");
var Audio_GSM = /* @__PURE__ */ audio("gsm", "gsm");
var Audio_GSM_EFR = /* @__PURE__ */ audio("gsm-efr");
var Audio_GSM_HR_08 = /* @__PURE__ */ audio("gsm-hr-08");
var Audio_ILBC = /* @__PURE__ */ audio("ilbc");
var Audio_Ip_Mr_v25 = /* @__PURE__ */ audio("ip-mr_v2.5");
var Audio_Isac = /* @__PURE__ */ audio("isac");
var Audio_L16 = /* @__PURE__ */ audio("l16");
var Audio_L20 = /* @__PURE__ */ audio("l20");
var Audio_L24 = /* @__PURE__ */ audio("l24");
var Audio_L8 = /* @__PURE__ */ audio("l8");
var Audio_LPC = /* @__PURE__ */ audio("lpc");
var Audio_MELP = /* @__PURE__ */ audio("melp");
var Audio_MELP1200 = /* @__PURE__ */ audio("melp1200");
var Audio_MELP2400 = /* @__PURE__ */ audio("melp2400");
var Audio_MELP600 = /* @__PURE__ */ audio("melp600");
var Audio_Midi = /* @__PURE__ */ audio("midi", "mid", "midi", "kar", "rmi");
var Audio_Mobile_Xmf = /* @__PURE__ */ audio("mobile-xmf");
var Audio_Mp4 = /* @__PURE__ */ audio("mp4", "m4a", "mp4a");
var Audio_MP4A_LATM = /* @__PURE__ */ audio("mp4a-latm");
var Audio_MPA = /* @__PURE__ */ audio("mpa");
var Audio_Mpa_Robust = /* @__PURE__ */ audio("mpa-robust");
var Audio_Mpeg = /* @__PURE__ */ audio("mpeg", "mp3", "mp2", "mp2a", "mpga", "m2a", "m3a");
var Audio_Mpeg4_Generic = /* @__PURE__ */ audio("mpeg4-generic");
var Audio_Musepack = /* @__PURE__ */ audio("musepack");
var Audio_Ogg = /* @__PURE__ */ audio("ogg", "ogg", "oga", "spx");
var Audio_Opus = /* @__PURE__ */ audio("opus");
var Audio_Parityfec = /* @__PURE__ */ audio("parityfec");
var Audio_PCMA = /* @__PURE__ */ audio("pcma");
var Audio_PCMA_WB = /* @__PURE__ */ audio("pcma-wb");
var Audio_PCMU = /* @__PURE__ */ audio("pcmu");
var Audio_PCMU_WB = /* @__PURE__ */ audio("pcmu-wb");
var Audio_PrsSid = /* @__PURE__ */ audio("prs.sid");
var Audio_Qcelp = /* @__PURE__ */ audio("qcelp");
var Audio_Raptorfec = /* @__PURE__ */ audio("raptorfec");
var Audio_RED = /* @__PURE__ */ audio("red");
var Audio_Rtp_Enc_Aescm128 = /* @__PURE__ */ audio("rtp-enc-aescm128");
var Audio_Rtp_Midi = /* @__PURE__ */ audio("rtp-midi");
var Audio_Rtploopback = /* @__PURE__ */ audio("rtploopback");
var Audio_Rtx = /* @__PURE__ */ audio("rtx");
var Audio_S3m = /* @__PURE__ */ audio("s3m", "s3m");
var Audio_Silk = /* @__PURE__ */ audio("silk", "sil");
var Audio_SMV = /* @__PURE__ */ audio("smv");
var Audio_SMV_QCP = /* @__PURE__ */ audio("smv-qcp");
var Audio_SMV0 = /* @__PURE__ */ audio("smv0");
var Audio_Sp_Midi = /* @__PURE__ */ audio("sp-midi");
var Audio_Speex = /* @__PURE__ */ audio("speex");
var Audio_T140c = /* @__PURE__ */ audio("t140c");
var Audio_T38 = /* @__PURE__ */ audio("t38");
var Audio_Telephone_Event = /* @__PURE__ */ audio("telephone-event");
var Audio_TETRA_ACELP = /* @__PURE__ */ audio("tetra_acelp");
var Audio_TETRA_ACELP_BB = /* @__PURE__ */ audio("tetra_acelp_bb");
var Audio_Tone = /* @__PURE__ */ audio("tone");
var Audio_UEMCLIP = /* @__PURE__ */ audio("uemclip");
var Audio_Ulpfec = /* @__PURE__ */ audio("ulpfec");
var Audio_Usac = /* @__PURE__ */ audio("usac");
var Audio_VDVI = /* @__PURE__ */ audio("vdvi");
var Audio_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ audio("1d-interleaved-parityfec");
var Audio_Vendor_32kadpcm = /* @__PURE__ */ audio("32kadpcm");
var Audio_Vendor_3gpp = /* @__PURE__ */ audio("3gpp");
var Audio_Vendor_3gpp2 = /* @__PURE__ */ audio("3gpp2");
var Audio_Vendor_3gppIufp = /* @__PURE__ */ audio("vnd.3gpp.iufp");
var Audio_Vendor_4SB = /* @__PURE__ */ audio("vnd.4sb");
var Audio_Vendor_Audiokoz = /* @__PURE__ */ audio("vnd.audiokoz");
var Audio_Vendor_CELP = /* @__PURE__ */ audio("vnd.celp");
var Audio_Vendor_CiscoNse = /* @__PURE__ */ audio("vnd.cisco.nse");
var Audio_Vendor_CmlesRadio_Events = /* @__PURE__ */ audio("vnd.cmles.radio-events");
var Audio_Vendor_CnsAnp1 = /* @__PURE__ */ audio("vnd.cns.anp1");
var Audio_Vendor_CnsInf1 = /* @__PURE__ */ audio("vnd.cns.inf1");
var Audio_Vendor_DeceAudio = /* @__PURE__ */ audio("vnd.dece.audio", "uva", "uvva");
var Audio_Vendor_Digital_Winds = /* @__PURE__ */ audio("vnd.digital-winds", "eol");
var Audio_Vendor_DlnaAdts = /* @__PURE__ */ audio("vnd.dlna.adts");
var Audio_Vendor_DolbyHeaac1 = /* @__PURE__ */ audio("vnd.dolby.heaac.1");
var Audio_Vendor_DolbyHeaac2 = /* @__PURE__ */ audio("vnd.dolby.heaac.2");
var Audio_Vendor_DolbyMlp = /* @__PURE__ */ audio("vnd.dolby.mlp");
var Audio_Vendor_DolbyMps = /* @__PURE__ */ audio("vnd.dolby.mps");
var Audio_Vendor_DolbyPl2 = /* @__PURE__ */ audio("vnd.dolby.pl2");
var Audio_Vendor_DolbyPl2x = /* @__PURE__ */ audio("vnd.dolby.pl2x");
var Audio_Vendor_DolbyPl2z = /* @__PURE__ */ audio("vnd.dolby.pl2z");
var Audio_Vendor_DolbyPulse1 = /* @__PURE__ */ audio("vnd.dolby.pulse.1");
var Audio_Vendor_Dra = /* @__PURE__ */ audio("vnd.dra", "dra");
var Audio_Vendor_Dts = /* @__PURE__ */ audio("vnd.dts", "dts");
var Audio_Vendor_DtsHd = /* @__PURE__ */ audio("vnd.dts.hd", "dtshd");
var Audio_Vendor_DtsUhd = /* @__PURE__ */ audio("vnd.dts.uhd");
var Audio_Vendor_DvbFile = /* @__PURE__ */ audio("vnd.dvb.file");
var Audio_Vendor_EveradPlj = /* @__PURE__ */ audio("vnd.everad.plj");
var Audio_Vendor_HnsAudio = /* @__PURE__ */ audio("vnd.hns.audio");
var Audio_Vendor_LucentVoice = /* @__PURE__ */ audio("vnd.lucent.voice", "lvp");
var Audio_Vendor_Ms_PlayreadyMediaPya = /* @__PURE__ */ audio("vnd.ms-playready.media.pya", "pya");
var Audio_Vendor_NokiaMobile_Xmf = /* @__PURE__ */ audio("vnd.nokia.mobile-xmf");
var Audio_Vendor_NortelVbk = /* @__PURE__ */ audio("vnd.nortel.vbk");
var Audio_Vendor_NueraEcelp4800 = /* @__PURE__ */ audio("vnd.nuera.ecelp4800", "ecelp4800");
var Audio_Vendor_NueraEcelp7470 = /* @__PURE__ */ audio("vnd.nuera.ecelp7470", "ecelp7470");
var Audio_Vendor_NueraEcelp9600 = /* @__PURE__ */ audio("vnd.nuera.ecelp9600", "ecelp9600");
var Audio_Vendor_OctelSbc = /* @__PURE__ */ audio("vnd.octel.sbc");
var Audio_Vendor_PresonusMultitrack = /* @__PURE__ */ audio("vnd.presonus.multitrack");
var Audio_Vendor_Qcelp = /* @__PURE__ */ audio("vnd.qcelp").deprecate("in favor of audio/qcelp");
var Audio_Vendor_Rhetorex32kadpcm = /* @__PURE__ */ audio("vnd.rhetorex.32kadpcm");
var Audio_Vendor_Rip = /* @__PURE__ */ audio("vnd.rip", "rip");
var Audio_Vendor_Rn_Realaudio = /* @__PURE__ */ audio("vnd.rn-realaudio");
var Audio_Vendor_SealedmediaSoftsealMpeg = /* @__PURE__ */ audio("vnd.sealedmedia.softseal.mpeg");
var Audio_Vendor_VmxCvsd = /* @__PURE__ */ audio("vnd.vmx.cvsd");
var Audio_Vendor_Wave = /* @__PURE__ */ audio("vnd.wave", "wav");
var Audio_VMR_WB = /* @__PURE__ */ audio("vmr-wb");
var Audio_Vorbis = /* @__PURE__ */ audio("vorbis");
var Audio_Vorbis_Config = /* @__PURE__ */ audio("vorbis-config");
var Audio_Wav = /* @__PURE__ */ audio("wav", "wav");
var Audio_Wave = /* @__PURE__ */ audio("wave", "wav");
var Audio_Webm = /* @__PURE__ */ audio("webm", "weba", "webm");
var Audio_WebMOpus = /* @__PURE__ */ audio("webm; codec=opus", "weba");
var Audio_X_Aac = /* @__PURE__ */ audio("x-aac", "aac");
var Audio_X_Aiff = /* @__PURE__ */ audio("x-aiff", "aif", "aiff", "aifc");
var Audio_X_Caf = /* @__PURE__ */ audio("x-caf", "caf");
var Audio_X_Flac = /* @__PURE__ */ audio("x-flac", "flac");
var Audio_X_Matroska = /* @__PURE__ */ audio("x-matroska", "mka");
var Audio_X_Mpegurl = /* @__PURE__ */ audio("x-mpegurl", "m3u");
var Audio_X_Ms_Wax = /* @__PURE__ */ audio("x-ms-wax", "wax");
var Audio_X_Ms_Wma = /* @__PURE__ */ audio("x-ms-wma", "wma");
var Audio_X_Pn_Realaudio = /* @__PURE__ */ audio("x-pn-realaudio", "ram", "ra");
var Audio_X_Pn_Realaudio_Plugin = /* @__PURE__ */ audio("x-pn-realaudio-plugin", "rmp");
var Audio_X_Tta = /* @__PURE__ */ audio("x-tta");
var Audio_X_Wav = /* @__PURE__ */ audio("x-wav", "wav");
var Audio_Xm = /* @__PURE__ */ audio("xm", "xm");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/chemical.ts
var chemical_exports = {};
__export(chemical_exports, {
  Chemical_X_Cdx: () => Chemical_X_Cdx,
  Chemical_X_Cif: () => Chemical_X_Cif,
  Chemical_X_Cmdf: () => Chemical_X_Cmdf,
  Chemical_X_Cml: () => Chemical_X_Cml,
  Chemical_X_Csml: () => Chemical_X_Csml,
  Chemical_X_Pdb: () => Chemical_X_Pdb,
  Chemical_X_Xyz: () => Chemical_X_Xyz
});
var chemical = /* @__PURE__ */ specialize("chemical");
var Chemical_X_Cdx = /* @__PURE__ */ chemical("x-cdx", "cdx");
var Chemical_X_Cif = /* @__PURE__ */ chemical("x-cif", "cif");
var Chemical_X_Cmdf = /* @__PURE__ */ chemical("x-cmdf", "cmdf");
var Chemical_X_Cml = /* @__PURE__ */ chemical("x-cml", "cml");
var Chemical_X_Csml = /* @__PURE__ */ chemical("x-csml", "csml");
var Chemical_X_Pdb = /* @__PURE__ */ chemical("x-pdb");
var Chemical_X_Xyz = /* @__PURE__ */ chemical("x-xyz", "xyz");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/font.ts
var font_exports = {};
__export(font_exports, {
  Font_Collection: () => Font_Collection,
  Font_Otf: () => Font_Otf,
  Font_Sfnt: () => Font_Sfnt,
  Font_Ttf: () => Font_Ttf,
  Font_Woff: () => Font_Woff,
  Font_Woff2: () => Font_Woff2
});
var font = /* @__PURE__ */ specialize("font");
var Font_Collection = /* @__PURE__ */ font("collection", "ttc");
var Font_Otf = /* @__PURE__ */ font("otf", "otf");
var Font_Sfnt = /* @__PURE__ */ font("sfnt");
var Font_Ttf = /* @__PURE__ */ font("ttf", "ttf");
var Font_Woff = /* @__PURE__ */ font("woff", "woff");
var Font_Woff2 = /* @__PURE__ */ font("woff2", "woff2");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/image.ts
var image_exports = {};
__export(image_exports, {
  Image_Aces: () => Image_Aces,
  Image_Apng: () => Image_Apng,
  Image_Avci: () => Image_Avci,
  Image_Avcs: () => Image_Avcs,
  Image_Avif: () => Image_Avif,
  Image_Bmp: () => Image_Bmp,
  Image_Cgm: () => Image_Cgm,
  Image_Dicom_Rle: () => Image_Dicom_Rle,
  Image_EXR: () => Image_EXR,
  Image_Emf: () => Image_Emf,
  Image_Example: () => Image_Example,
  Image_Fits: () => Image_Fits,
  Image_G3fax: () => Image_G3fax,
  Image_Gif: () => Image_Gif,
  Image_Heic: () => Image_Heic,
  Image_Heic_Sequence: () => Image_Heic_Sequence,
  Image_Heif: () => Image_Heif,
  Image_Heif_Sequence: () => Image_Heif_Sequence,
  Image_Hej2k: () => Image_Hej2k,
  Image_Hsj2: () => Image_Hsj2,
  Image_Ief: () => Image_Ief,
  Image_Jls: () => Image_Jls,
  Image_Jp2: () => Image_Jp2,
  Image_Jpeg: () => Image_Jpeg,
  Image_Jph: () => Image_Jph,
  Image_Jphc: () => Image_Jphc,
  Image_Jpm: () => Image_Jpm,
  Image_Jpx: () => Image_Jpx,
  Image_Jxr: () => Image_Jxr,
  Image_JxrA: () => Image_JxrA,
  Image_JxrS: () => Image_JxrS,
  Image_Jxs: () => Image_Jxs,
  Image_Jxsc: () => Image_Jxsc,
  Image_Jxsi: () => Image_Jxsi,
  Image_Jxss: () => Image_Jxss,
  Image_Ktx: () => Image_Ktx,
  Image_Naplps: () => Image_Naplps,
  Image_Pjpeg: () => Image_Pjpeg,
  Image_Png: () => Image_Png,
  Image_PrsBtif: () => Image_PrsBtif,
  Image_PrsPti: () => Image_PrsPti,
  Image_Pwg_Raster: () => Image_Pwg_Raster,
  Image_Raw: () => Image_Raw,
  Image_Sgi: () => Image_Sgi,
  Image_SvgXml: () => Image_SvgXml,
  Image_T38: () => Image_T38,
  Image_Tiff: () => Image_Tiff,
  Image_Tiff_Fx: () => Image_Tiff_Fx,
  Image_Vendor_AdobePhotoshop: () => Image_Vendor_AdobePhotoshop,
  Image_Vendor_AirzipAcceleratorAzv: () => Image_Vendor_AirzipAcceleratorAzv,
  Image_Vendor_CnsInf2: () => Image_Vendor_CnsInf2,
  Image_Vendor_DeceGraphic: () => Image_Vendor_DeceGraphic,
  Image_Vendor_Djvu: () => Image_Vendor_Djvu,
  Image_Vendor_DvbSubtitle: () => Image_Vendor_DvbSubtitle,
  Image_Vendor_Dwg: () => Image_Vendor_Dwg,
  Image_Vendor_Dxf: () => Image_Vendor_Dxf,
  Image_Vendor_Fastbidsheet: () => Image_Vendor_Fastbidsheet,
  Image_Vendor_Fpx: () => Image_Vendor_Fpx,
  Image_Vendor_Fst: () => Image_Vendor_Fst,
  Image_Vendor_FujixeroxEdmics_Mmr: () => Image_Vendor_FujixeroxEdmics_Mmr,
  Image_Vendor_FujixeroxEdmics_Rlc: () => Image_Vendor_FujixeroxEdmics_Rlc,
  Image_Vendor_GlobalgraphicsPgb: () => Image_Vendor_GlobalgraphicsPgb,
  Image_Vendor_MicrosoftIcon: () => Image_Vendor_MicrosoftIcon,
  Image_Vendor_Mix: () => Image_Vendor_Mix,
  Image_Vendor_MozillaApng: () => Image_Vendor_MozillaApng,
  Image_Vendor_Ms_Dds: () => Image_Vendor_Ms_Dds,
  Image_Vendor_Ms_Modi: () => Image_Vendor_Ms_Modi,
  Image_Vendor_Ms_Photo: () => Image_Vendor_Ms_Photo,
  Image_Vendor_Net_Fpx: () => Image_Vendor_Net_Fpx,
  Image_Vendor_Radiance: () => Image_Vendor_Radiance,
  Image_Vendor_SealedPng: () => Image_Vendor_SealedPng,
  Image_Vendor_SealedmediaSoftsealGif: () => Image_Vendor_SealedmediaSoftsealGif,
  Image_Vendor_SealedmediaSoftsealJpg: () => Image_Vendor_SealedmediaSoftsealJpg,
  Image_Vendor_Svf: () => Image_Vendor_Svf,
  Image_Vendor_TencentTap: () => Image_Vendor_TencentTap,
  Image_Vendor_ValveSourceTexture: () => Image_Vendor_ValveSourceTexture,
  Image_Vendor_WapWbmp: () => Image_Vendor_WapWbmp,
  Image_Vendor_Xiff: () => Image_Vendor_Xiff,
  Image_Vendor_ZbrushPcx: () => Image_Vendor_ZbrushPcx,
  Image_Webp: () => Image_Webp,
  Image_Wmf: () => Image_Wmf,
  Image_X_3ds: () => Image_X_3ds,
  Image_X_Cmu_Raster: () => Image_X_Cmu_Raster,
  Image_X_Cmx: () => Image_X_Cmx,
  Image_X_Emf: () => Image_X_Emf,
  Image_X_Freehand: () => Image_X_Freehand,
  Image_X_Icon: () => Image_X_Icon,
  Image_X_Mrsid_Image: () => Image_X_Mrsid_Image,
  Image_X_Ms_Bmp: () => Image_X_Ms_Bmp,
  Image_X_Pcx: () => Image_X_Pcx,
  Image_X_Pict: () => Image_X_Pict,
  Image_X_Portable_Anymap: () => Image_X_Portable_Anymap,
  Image_X_Portable_Bitmap: () => Image_X_Portable_Bitmap,
  Image_X_Portable_Graymap: () => Image_X_Portable_Graymap,
  Image_X_Portable_Pixmap: () => Image_X_Portable_Pixmap,
  Image_X_Rgb: () => Image_X_Rgb,
  Image_X_Tga: () => Image_X_Tga,
  Image_X_Wmf: () => Image_X_Wmf,
  Image_X_Xbitmap: () => Image_X_Xbitmap,
  Image_X_Xcf: () => Image_X_Xcf,
  Image_X_Xpixmap: () => Image_X_Xpixmap,
  Image_X_Xwindowdump: () => Image_X_Xwindowdump
});
var image = /* @__PURE__ */ specialize("image");
var Image_Aces = /* @__PURE__ */ image("aces");
var Image_Apng = /* @__PURE__ */ image("apng", "apng");
var Image_Avci = /* @__PURE__ */ image("avci");
var Image_Avcs = /* @__PURE__ */ image("avcs");
var Image_Avif = /* @__PURE__ */ image("avif", "avif");
var Image_Bmp = /* @__PURE__ */ image("bmp", "bmp");
var Image_Cgm = /* @__PURE__ */ image("cgm", "cgm");
var Image_Dicom_Rle = /* @__PURE__ */ image("dicom-rle");
var Image_Emf = /* @__PURE__ */ image("emf");
var Image_Example = /* @__PURE__ */ image("example");
var Image_EXR = /* @__PURE__ */ image("x-exr", "exr");
var Image_Fits = /* @__PURE__ */ image("fits");
var Image_G3fax = /* @__PURE__ */ image("g3fax", "g3");
var Image_Gif = /* @__PURE__ */ image("gif", "gif");
var Image_Heic = /* @__PURE__ */ image("heic");
var Image_Heic_Sequence = /* @__PURE__ */ image("heic-sequence");
var Image_Heif = /* @__PURE__ */ image("heif");
var Image_Heif_Sequence = /* @__PURE__ */ image("heif-sequence");
var Image_Hej2k = /* @__PURE__ */ image("hej2k");
var Image_Hsj2 = /* @__PURE__ */ image("hsj2");
var Image_Ief = /* @__PURE__ */ image("ief", "ief");
var Image_Jls = /* @__PURE__ */ image("jls");
var Image_Jp2 = /* @__PURE__ */ image("jp2");
var Image_Jpeg = /* @__PURE__ */ image("jpeg", "jpeg", "jpg", "jpe");
var Image_Jph = /* @__PURE__ */ image("jph");
var Image_Jphc = /* @__PURE__ */ image("jphc");
var Image_Jpm = /* @__PURE__ */ image("jpm");
var Image_Jpx = /* @__PURE__ */ image("jpx");
var Image_Jxr = /* @__PURE__ */ image("jxr");
var Image_JxrA = /* @__PURE__ */ image("jxra");
var Image_JxrS = /* @__PURE__ */ image("jxrs");
var Image_Jxs = /* @__PURE__ */ image("jxs");
var Image_Jxsc = /* @__PURE__ */ image("jxsc");
var Image_Jxsi = /* @__PURE__ */ image("jxsi");
var Image_Jxss = /* @__PURE__ */ image("jxss");
var Image_Ktx = /* @__PURE__ */ image("ktx", "ktx");
var Image_Naplps = /* @__PURE__ */ image("naplps");
var Image_Pjpeg = /* @__PURE__ */ image("pjpeg");
var Image_Png = /* @__PURE__ */ image("png", "png");
var Image_PrsBtif = /* @__PURE__ */ image("prs.btif", "btif");
var Image_PrsPti = /* @__PURE__ */ image("prs.pti");
var Image_Pwg_Raster = /* @__PURE__ */ image("pwg-raster");
var Image_Raw = /* @__PURE__ */ image("x-raw", "raw");
var Image_Sgi = /* @__PURE__ */ image("sgi", "sgi");
var Image_SvgXml = /* @__PURE__ */ image("svg+xml", "svg", "svgz");
var Image_T38 = /* @__PURE__ */ image("t38");
var Image_Tiff = /* @__PURE__ */ image("tiff", "tiff", "tif");
var Image_Tiff_Fx = /* @__PURE__ */ image("tiff-fx");
var Image_Vendor_AdobePhotoshop = /* @__PURE__ */ image("vnd.adobe.photoshop", "psd");
var Image_Vendor_AirzipAcceleratorAzv = /* @__PURE__ */ image("vnd.airzip.accelerator.azv");
var Image_Vendor_CnsInf2 = /* @__PURE__ */ image("vnd.cns.inf2");
var Image_Vendor_DeceGraphic = /* @__PURE__ */ image("vnd.dece.graphic", "uvi", "uvvi", "uvg", "uvvg");
var Image_Vendor_Djvu = /* @__PURE__ */ image("vnd.djvu", "djvu", "djv");
var Image_Vendor_DvbSubtitle = /* @__PURE__ */ image("vnd.dvb.subtitle", "sub");
var Image_Vendor_Dwg = /* @__PURE__ */ image("vnd.dwg", "dwg");
var Image_Vendor_Dxf = /* @__PURE__ */ image("vnd.dxf", "dxf");
var Image_Vendor_Fastbidsheet = /* @__PURE__ */ image("vnd.fastbidsheet", "fbs");
var Image_Vendor_Fpx = /* @__PURE__ */ image("vnd.fpx", "fpx");
var Image_Vendor_Fst = /* @__PURE__ */ image("vnd.fst", "fst");
var Image_Vendor_FujixeroxEdmics_Mmr = /* @__PURE__ */ image("vnd.fujixerox.edmics-mmr", "mmr");
var Image_Vendor_FujixeroxEdmics_Rlc = /* @__PURE__ */ image("vnd.fujixerox.edmics-rlc", "rlc");
var Image_Vendor_GlobalgraphicsPgb = /* @__PURE__ */ image("vnd.globalgraphics.pgb");
var Image_Vendor_MicrosoftIcon = /* @__PURE__ */ image("vnd.microsoft.icon");
var Image_Vendor_Mix = /* @__PURE__ */ image("vnd.mix");
var Image_Vendor_MozillaApng = /* @__PURE__ */ image("vnd.mozilla.apng");
var Image_Vendor_Ms_Dds = /* @__PURE__ */ image("vnd.ms-dds", "dds");
var Image_Vendor_Ms_Modi = /* @__PURE__ */ image("vnd.ms-modi", "mdi");
var Image_Vendor_Ms_Photo = /* @__PURE__ */ image("vnd.ms-photo", "wdp");
var Image_Vendor_Net_Fpx = /* @__PURE__ */ image("vnd.net-fpx", "npx");
var Image_Vendor_Radiance = /* @__PURE__ */ image("vnd.radiance");
var Image_Vendor_SealedmediaSoftsealGif = /* @__PURE__ */ image("vnd.sealedmedia.softseal.gif");
var Image_Vendor_SealedmediaSoftsealJpg = /* @__PURE__ */ image("vnd.sealedmedia.softseal.jpg");
var Image_Vendor_SealedPng = /* @__PURE__ */ image("vnd.sealed.png");
var Image_Vendor_Svf = /* @__PURE__ */ image("vnd.svf");
var Image_Vendor_TencentTap = /* @__PURE__ */ image("vnd.tencent.tap");
var Image_Vendor_ValveSourceTexture = /* @__PURE__ */ image("vnd.valve.source.texture");
var Image_Vendor_WapWbmp = /* @__PURE__ */ image("vnd.wap.wbmp", "wbmp");
var Image_Vendor_Xiff = /* @__PURE__ */ image("vnd.xiff", "xif");
var Image_Vendor_ZbrushPcx = /* @__PURE__ */ image("vnd.zbrush.pcx");
var Image_Webp = /* @__PURE__ */ image("webp", "webp");
var Image_Wmf = /* @__PURE__ */ image("wmf");
var Image_X_3ds = /* @__PURE__ */ image("x-3ds", "3ds");
var Image_X_Cmu_Raster = /* @__PURE__ */ image("x-cmu-raster", "ras");
var Image_X_Cmx = /* @__PURE__ */ image("x-cmx", "cmx");
var Image_X_Emf = /* @__PURE__ */ image("x-emf").deprecate("in favor of image/emf");
var Image_X_Freehand = /* @__PURE__ */ image("x-freehand", "fh", "fhc", "fh4", "fh5", "fh7");
var Image_X_Icon = /* @__PURE__ */ image("x-icon", "ico");
var Image_X_Mrsid_Image = /* @__PURE__ */ image("x-mrsid-image", "sid");
var Image_X_Ms_Bmp = /* @__PURE__ */ image("x-ms-bmp");
var Image_X_Pcx = /* @__PURE__ */ image("x-pcx", "pcx");
var Image_X_Pict = /* @__PURE__ */ image("x-pict", "pic", "pct");
var Image_X_Portable_Anymap = /* @__PURE__ */ image("x-portable-anymap", "pnm");
var Image_X_Portable_Bitmap = /* @__PURE__ */ image("x-portable-bitmap", "pbm");
var Image_X_Portable_Graymap = /* @__PURE__ */ image("x-portable-graymap", "pgm");
var Image_X_Portable_Pixmap = /* @__PURE__ */ image("x-portable-pixmap", "ppm");
var Image_X_Rgb = /* @__PURE__ */ image("x-rgb", "rgb");
var Image_X_Tga = /* @__PURE__ */ image("x-tga", "tga");
var Image_X_Wmf = /* @__PURE__ */ image("x-wmf").deprecate("in favor of image/wmf");
var Image_X_Xbitmap = /* @__PURE__ */ image("x-xbitmap", "xbm");
var Image_X_Xcf = /* @__PURE__ */ image("x-xcf");
var Image_X_Xpixmap = /* @__PURE__ */ image("x-xpixmap", "xpm");
var Image_X_Xwindowdump = /* @__PURE__ */ image("x-xwindowdump", "xwd");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/message.ts
var message_exports = {};
__export(message_exports, {
  Message_CPIM: () => Message_CPIM,
  Message_Delivery_Status: () => Message_Delivery_Status,
  Message_Disposition_Notification: () => Message_Disposition_Notification,
  Message_Example: () => Message_Example,
  Message_External_Body: () => Message_External_Body,
  Message_Feedback_Report: () => Message_Feedback_Report,
  Message_Global: () => Message_Global,
  Message_Global_Delivery_Status: () => Message_Global_Delivery_Status,
  Message_Global_Disposition_Notification: () => Message_Global_Disposition_Notification,
  Message_Global_Headers: () => Message_Global_Headers,
  Message_Http: () => Message_Http,
  Message_ImdnXml: () => Message_ImdnXml,
  Message_News: () => Message_News,
  Message_Partial: () => Message_Partial,
  Message_Rfc822: () => Message_Rfc822,
  Message_S_Http: () => Message_S_Http,
  Message_Sip: () => Message_Sip,
  Message_Sipfrag: () => Message_Sipfrag,
  Message_Tracking_Status: () => Message_Tracking_Status,
  Message_Vendor_SiSimp: () => Message_Vendor_SiSimp,
  Message_Vendor_WfaWsc: () => Message_Vendor_WfaWsc
});
var message = /* @__PURE__ */ specialize("message");
var Message_CPIM = /* @__PURE__ */ message("cpim");
var Message_Delivery_Status = /* @__PURE__ */ message("delivery-status");
var Message_Disposition_Notification = /* @__PURE__ */ message("disposition-notification");
var Message_Example = /* @__PURE__ */ message("example");
var Message_External_Body = /* @__PURE__ */ message("external-body");
var Message_Feedback_Report = /* @__PURE__ */ message("feedback-report");
var Message_Global = /* @__PURE__ */ message("global");
var Message_Global_Delivery_Status = /* @__PURE__ */ message("global-delivery-status");
var Message_Global_Disposition_Notification = /* @__PURE__ */ message("global-disposition-notification");
var Message_Global_Headers = /* @__PURE__ */ message("global-headers");
var Message_Http = /* @__PURE__ */ message("http");
var Message_ImdnXml = /* @__PURE__ */ message("imdn+xml", "xml");
var Message_News = /* @__PURE__ */ message("news").deprecate("by RFC5537");
var Message_Partial = /* @__PURE__ */ message("partial");
var Message_Rfc822 = /* @__PURE__ */ message("rfc822", "eml", "mime");
var Message_S_Http = /* @__PURE__ */ message("s-http");
var Message_Sip = /* @__PURE__ */ message("sip");
var Message_Sipfrag = /* @__PURE__ */ message("sipfrag");
var Message_Tracking_Status = /* @__PURE__ */ message("tracking-status");
var Message_Vendor_SiSimp = /* @__PURE__ */ message("vnd.si.simp").deprecate("by request");
var Message_Vendor_WfaWsc = /* @__PURE__ */ message("vnd.wfa.wsc");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/model.ts
var model_exports = {};
__export(model_exports, {
  Model_Example: () => Model_Example,
  Model_Gltf_Binary: () => Model_Gltf_Binary,
  Model_Gltf_Json: () => Model_Gltf_Json,
  Model_Iges: () => Model_Iges,
  Model_Mesh: () => Model_Mesh,
  Model_Stl: () => Model_Stl,
  Model_Vendor_3mf: () => Model_Vendor_3mf,
  Model_Vendor_ColladaXml: () => Model_Vendor_ColladaXml,
  Model_Vendor_Dwf: () => Model_Vendor_Dwf,
  Model_Vendor_Flatland3dml: () => Model_Vendor_Flatland3dml,
  Model_Vendor_Gdl: () => Model_Vendor_Gdl,
  Model_Vendor_GsGdl: () => Model_Vendor_GsGdl,
  Model_Vendor_Gs_Gdl: () => Model_Vendor_Gs_Gdl,
  Model_Vendor_Gtw: () => Model_Vendor_Gtw,
  Model_Vendor_MomlXml: () => Model_Vendor_MomlXml,
  Model_Vendor_Mts: () => Model_Vendor_Mts,
  Model_Vendor_Opengex: () => Model_Vendor_Opengex,
  Model_Vendor_ParasolidTransmitBinary: () => Model_Vendor_ParasolidTransmitBinary,
  Model_Vendor_ParasolidTransmitText: () => Model_Vendor_ParasolidTransmitText,
  Model_Vendor_RosetteAnnotated_Data_Model: () => Model_Vendor_RosetteAnnotated_Data_Model,
  Model_Vendor_UsdzZip: () => Model_Vendor_UsdzZip,
  Model_Vendor_ValveSourceCompiled_Map: () => Model_Vendor_ValveSourceCompiled_Map,
  Model_Vendor_Vtu: () => Model_Vendor_Vtu,
  Model_Vrml: () => Model_Vrml,
  Model_X3dBinary: () => Model_X3dBinary,
  Model_X3dFastinfoset: () => Model_X3dFastinfoset,
  Model_X3dVrml: () => Model_X3dVrml,
  Model_X3dXml: () => Model_X3dXml,
  Model_X3d_Vrml: () => Model_X3d_Vrml
});
var model = /* @__PURE__ */ specialize("model");
var Model_Example = /* @__PURE__ */ model("example");
var Model_Gltf_Binary = /* @__PURE__ */ model("gltf-binary", "glb");
var Model_Gltf_Json = /* @__PURE__ */ model("gltf+json", "gltf");
var Model_Iges = /* @__PURE__ */ model("iges", "igs", "iges");
var Model_Mesh = /* @__PURE__ */ model("mesh", "msh", "mesh", "silo");
var Model_Stl = /* @__PURE__ */ model("stl");
var Model_Vendor_3mf = /* @__PURE__ */ model("3mf");
var Model_Vendor_ColladaXml = /* @__PURE__ */ model("vnd.collada+xml", "dae");
var Model_Vendor_Dwf = /* @__PURE__ */ model("vnd.dwf", "dwf");
var Model_Vendor_Flatland3dml = /* @__PURE__ */ model("vnd.flatland.3dml");
var Model_Vendor_Gdl = /* @__PURE__ */ model("vnd.gdl", "gdl");
var Model_Vendor_Gs_Gdl = /* @__PURE__ */ model("vnd.gs-gdl");
var Model_Vendor_GsGdl = /* @__PURE__ */ model("vnd.gs.gdl");
var Model_Vendor_Gtw = /* @__PURE__ */ model("vnd.gtw", "gtw");
var Model_Vendor_MomlXml = /* @__PURE__ */ model("vnd.moml+xml", "xml");
var Model_Vendor_Mts = /* @__PURE__ */ model("vnd.mts", "mts");
var Model_Vendor_Opengex = /* @__PURE__ */ model("vnd.opengex");
var Model_Vendor_ParasolidTransmitBinary = /* @__PURE__ */ model("vnd.parasolid.transmit.binary");
var Model_Vendor_ParasolidTransmitText = /* @__PURE__ */ model("vnd.parasolid.transmit.text");
var Model_Vendor_RosetteAnnotated_Data_Model = /* @__PURE__ */ model("vnd.rosette.annotated-data-model");
var Model_Vendor_UsdzZip = /* @__PURE__ */ model("vnd.usdz+zip", "zip");
var Model_Vendor_ValveSourceCompiled_Map = /* @__PURE__ */ model("vnd.valve.source.compiled-map");
var Model_Vendor_Vtu = /* @__PURE__ */ model("vnd.vtu", "vtu");
var Model_Vrml = /* @__PURE__ */ model("vrml", "wrl", "vrml");
var Model_X3d_Vrml = /* @__PURE__ */ model("x3d-vrml");
var Model_X3dBinary = /* @__PURE__ */ model("x3d+binary", "x3db", "x3dbz");
var Model_X3dFastinfoset = /* @__PURE__ */ model("x3d+fastinfoset", "fastinfoset");
var Model_X3dVrml = /* @__PURE__ */ model("x3d+vrml", "x3dv", "x3dvz");
var Model_X3dXml = /* @__PURE__ */ model("x3d+xml", "x3d", "x3dz");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/multipart.ts
var multipart_exports = {};
__export(multipart_exports, {
  MultipartAlternative: () => MultipartAlternative,
  MultipartAppledouble: () => MultipartAppledouble,
  MultipartByteranges: () => MultipartByteranges,
  MultipartDigest: () => MultipartDigest,
  MultipartEncrypted: () => MultipartEncrypted,
  MultipartExample: () => MultipartExample,
  MultipartForm_Data: () => MultipartForm_Data,
  MultipartHeader_Set: () => MultipartHeader_Set,
  MultipartMixed: () => MultipartMixed,
  MultipartMultilingual: () => MultipartMultilingual,
  MultipartParallel: () => MultipartParallel,
  MultipartRelated: () => MultipartRelated,
  MultipartReport: () => MultipartReport,
  MultipartSigned: () => MultipartSigned,
  MultipartVendorBintMed_Plus: () => MultipartVendorBintMed_Plus,
  MultipartVoice_Message: () => MultipartVoice_Message,
  MultipartX_Mixed_Replace: () => MultipartX_Mixed_Replace
});
var multipart = /* @__PURE__ */ specialize("multipart");
var MultipartAlternative = /* @__PURE__ */ multipart("alternative");
var MultipartAppledouble = /* @__PURE__ */ multipart("appledouble");
var MultipartByteranges = /* @__PURE__ */ multipart("byteranges");
var MultipartDigest = /* @__PURE__ */ multipart("digest");
var MultipartEncrypted = /* @__PURE__ */ multipart("encrypted");
var MultipartExample = /* @__PURE__ */ multipart("example");
var MultipartForm_Data = /* @__PURE__ */ multipart("form-data");
var MultipartHeader_Set = /* @__PURE__ */ multipart("header-set");
var MultipartMixed = /* @__PURE__ */ multipart("mixed");
var MultipartMultilingual = /* @__PURE__ */ multipart("multilingual");
var MultipartParallel = /* @__PURE__ */ multipart("parallel");
var MultipartRelated = /* @__PURE__ */ multipart("related");
var MultipartReport = /* @__PURE__ */ multipart("report");
var MultipartSigned = /* @__PURE__ */ multipart("signed");
var MultipartVendorBintMed_Plus = /* @__PURE__ */ multipart("vnd.bint.med-plus");
var MultipartVoice_Message = /* @__PURE__ */ multipart("voice-message");
var MultipartX_Mixed_Replace = /* @__PURE__ */ multipart("x-mixed-replace");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/text.ts
var text_exports = {};
__export(text_exports, {
  Text_Cache_Manifest: () => Text_Cache_Manifest,
  Text_Calendar: () => Text_Calendar,
  Text_Calender: () => Text_Calender,
  Text_Cmd: () => Text_Cmd,
  Text_Coffeescript: () => Text_Coffeescript,
  Text_Css: () => Text_Css,
  Text_Csv: () => Text_Csv,
  Text_Csv_Schema: () => Text_Csv_Schema,
  Text_Directory: () => Text_Directory,
  Text_Dns: () => Text_Dns,
  Text_Ecmascript: () => Text_Ecmascript,
  Text_Encaprtp: () => Text_Encaprtp,
  Text_Enriched: () => Text_Enriched,
  Text_Event_Stream: () => Text_Event_Stream,
  Text_Example: () => Text_Example,
  Text_Flexfec: () => Text_Flexfec,
  Text_Fwdred: () => Text_Fwdred,
  Text_Grammar_Ref_List: () => Text_Grammar_Ref_List,
  Text_Html: () => Text_Html,
  Text_Jade: () => Text_Jade,
  Text_Javascript: () => Text_Javascript,
  Text_Jcr_Cnd: () => Text_Jcr_Cnd,
  Text_Jsx: () => Text_Jsx,
  Text_Less: () => Text_Less,
  Text_Markdown: () => Text_Markdown,
  Text_Mdx: () => Text_Mdx,
  Text_Mizar: () => Text_Mizar,
  Text_N3: () => Text_N3,
  Text_Parameters: () => Text_Parameters,
  Text_Parityfec: () => Text_Parityfec,
  Text_Plain: () => Text_Plain,
  Text_PlainUTF8: () => Text_PlainUTF8,
  Text_Provenance_Notation: () => Text_Provenance_Notation,
  Text_PrsFallensteinRst: () => Text_PrsFallensteinRst,
  Text_PrsLinesTag: () => Text_PrsLinesTag,
  Text_PrsPropLogic: () => Text_PrsPropLogic,
  Text_RED: () => Text_RED,
  Text_Raptorfec: () => Text_Raptorfec,
  Text_Rfc822_Headers: () => Text_Rfc822_Headers,
  Text_Richtext: () => Text_Richtext,
  Text_Rtf: () => Text_Rtf,
  Text_Rtp_Enc_Aescm128: () => Text_Rtp_Enc_Aescm128,
  Text_Rtploopback: () => Text_Rtploopback,
  Text_Rtx: () => Text_Rtx,
  Text_Sgml: () => Text_Sgml,
  Text_Shex: () => Text_Shex,
  Text_Slim: () => Text_Slim,
  Text_Strings: () => Text_Strings,
  Text_Stylus: () => Text_Stylus,
  Text_T140: () => Text_T140,
  Text_Tab_Separated_Values: () => Text_Tab_Separated_Values,
  Text_Troff: () => Text_Troff,
  Text_Turtle: () => Text_Turtle,
  Text_Ulpfec: () => Text_Ulpfec,
  Text_Uri_List: () => Text_Uri_List,
  Text_Vcard: () => Text_Vcard,
  Text_Vendor_1d_Interleaved_Parityfec: () => Text_Vendor_1d_Interleaved_Parityfec,
  Text_Vendor_A: () => Text_Vendor_A,
  Text_Vendor_Abc: () => Text_Vendor_Abc,
  Text_Vendor_Ascii_Art: () => Text_Vendor_Ascii_Art,
  Text_Vendor_Curl: () => Text_Vendor_Curl,
  Text_Vendor_CurlDcurl: () => Text_Vendor_CurlDcurl,
  Text_Vendor_CurlMcurl: () => Text_Vendor_CurlMcurl,
  Text_Vendor_CurlScurl: () => Text_Vendor_CurlScurl,
  Text_Vendor_DMClientScript: () => Text_Vendor_DMClientScript,
  Text_Vendor_DebianCopyright: () => Text_Vendor_DebianCopyright,
  Text_Vendor_DvbSubtitle: () => Text_Vendor_DvbSubtitle,
  Text_Vendor_EsmertecTheme_Descriptor: () => Text_Vendor_EsmertecTheme_Descriptor,
  Text_Vendor_FiclabFlt: () => Text_Vendor_FiclabFlt,
  Text_Vendor_Fly: () => Text_Vendor_Fly,
  Text_Vendor_FmiFlexstor: () => Text_Vendor_FmiFlexstor,
  Text_Vendor_Gml: () => Text_Vendor_Gml,
  Text_Vendor_Graphviz: () => Text_Vendor_Graphviz,
  Text_Vendor_Hgl: () => Text_Vendor_Hgl,
  Text_Vendor_IPTCNITF: () => Text_Vendor_IPTCNITF,
  Text_Vendor_IPTCNewsML: () => Text_Vendor_IPTCNewsML,
  Text_Vendor_In3d3dml: () => Text_Vendor_In3d3dml,
  Text_Vendor_In3dSpot: () => Text_Vendor_In3dSpot,
  Text_Vendor_Latex_Z: () => Text_Vendor_Latex_Z,
  Text_Vendor_MotorolaReflex: () => Text_Vendor_MotorolaReflex,
  Text_Vendor_Ms_Mediapackage: () => Text_Vendor_Ms_Mediapackage,
  Text_Vendor_Net2phoneCommcenterCommand: () => Text_Vendor_Net2phoneCommcenterCommand,
  Text_Vendor_RadisysMsml_Basic_Layout: () => Text_Vendor_RadisysMsml_Basic_Layout,
  Text_Vendor_SenxWarpscript: () => Text_Vendor_SenxWarpscript,
  Text_Vendor_SiUricatalogue: () => Text_Vendor_SiUricatalogue,
  Text_Vendor_Sosi: () => Text_Vendor_Sosi,
  Text_Vendor_SunJ2meApp_Descriptor: () => Text_Vendor_SunJ2meApp_Descriptor,
  Text_Vendor_TrolltechLinguist: () => Text_Vendor_TrolltechLinguist,
  Text_Vendor_WapSi: () => Text_Vendor_WapSi,
  Text_Vendor_WapSl: () => Text_Vendor_WapSl,
  Text_Vendor_WapWml: () => Text_Vendor_WapWml,
  Text_Vendor_WapWmlscript: () => Text_Vendor_WapWmlscript,
  Text_Vtt: () => Text_Vtt,
  Text_X_Asm: () => Text_X_Asm,
  Text_X_C: () => Text_X_C,
  Text_X_Fortran: () => Text_X_Fortran,
  Text_X_Gwt_Rpc: () => Text_X_Gwt_Rpc,
  Text_X_Handlebars_Template: () => Text_X_Handlebars_Template,
  Text_X_Java_Source: () => Text_X_Java_Source,
  Text_X_Jquery_Tmpl: () => Text_X_Jquery_Tmpl,
  Text_X_Lua: () => Text_X_Lua,
  Text_X_Markdown: () => Text_X_Markdown,
  Text_X_Nfo: () => Text_X_Nfo,
  Text_X_Opml: () => Text_X_Opml,
  Text_X_Org: () => Text_X_Org,
  Text_X_Pascal: () => Text_X_Pascal,
  Text_X_Processing: () => Text_X_Processing,
  Text_X_Sass: () => Text_X_Sass,
  Text_X_Scss: () => Text_X_Scss,
  Text_X_Setext: () => Text_X_Setext,
  Text_X_Sfv: () => Text_X_Sfv,
  Text_X_Suse_Ymp: () => Text_X_Suse_Ymp,
  Text_X_Uuencode: () => Text_X_Uuencode,
  Text_X_Vcalendar: () => Text_X_Vcalendar,
  Text_X_Vcard: () => Text_X_Vcard,
  Text_Xml: () => Text_Xml,
  Text_Xml_External_Parsed_Entity: () => Text_Xml_External_Parsed_Entity,
  Text_Yaml: () => Text_Yaml
});
var text = /* @__PURE__ */ specialize("text");
var Text_Cache_Manifest = /* @__PURE__ */ text("cache-manifest", "appcache");
var Text_Calendar = /* @__PURE__ */ text("calendar", "ics", "ifb");
var Text_Calender = /* @__PURE__ */ text("calender");
var Text_Cmd = /* @__PURE__ */ text("cmd");
var Text_Coffeescript = /* @__PURE__ */ text("coffeescript", "coffee", "litcoffee");
var Text_Css = /* @__PURE__ */ text("css", "css");
var Text_Csv = /* @__PURE__ */ text("csv", "csv");
var Text_Csv_Schema = /* @__PURE__ */ text("csv-schema");
var Text_Directory = /* @__PURE__ */ text("directory").deprecate("by RFC6350");
var Text_Dns = /* @__PURE__ */ text("dns");
var Text_Ecmascript = /* @__PURE__ */ text("ecmascript").deprecate("in favor of application/ecmascript");
var Text_Encaprtp = /* @__PURE__ */ text("encaprtp");
var Text_Enriched = /* @__PURE__ */ text("enriched");
var Text_Event_Stream = /* @__PURE__ */ text("event-stream");
var Text_Example = /* @__PURE__ */ text("example");
var Text_Flexfec = /* @__PURE__ */ text("flexfec");
var Text_Fwdred = /* @__PURE__ */ text("fwdred");
var Text_Grammar_Ref_List = /* @__PURE__ */ text("grammar-ref-list");
var Text_Html = /* @__PURE__ */ text("html", "html", "htm");
var Text_Jade = /* @__PURE__ */ text("jade", "jade");
var Text_Javascript = /* @__PURE__ */ text("javascript").deprecate("in favor of application/javascript");
var Text_Jcr_Cnd = /* @__PURE__ */ text("jcr-cnd");
var Text_Jsx = /* @__PURE__ */ text("jsx", "jsx");
var Text_Less = /* @__PURE__ */ text("less", "less");
var Text_Markdown = /* @__PURE__ */ text("markdown");
var Text_Mdx = /* @__PURE__ */ text("mdx", "mdx");
var Text_Mizar = /* @__PURE__ */ text("mizar");
var Text_N3 = /* @__PURE__ */ text("n3", "n3");
var Text_Parameters = /* @__PURE__ */ text("parameters");
var Text_Parityfec = /* @__PURE__ */ text("parityfec");
var Text_Plain = /* @__PURE__ */ text("plain", "txt", "text", "conf", "def", "list", "log", "in");
var Text_PlainUTF8 = /* @__PURE__ */ text("plain; charset=UTF-8", "txt", "text", "conf", "def", "list", "log", "in");
var Text_Provenance_Notation = /* @__PURE__ */ text("provenance-notation");
var Text_PrsFallensteinRst = /* @__PURE__ */ text("prs.fallenstein.rst");
var Text_PrsLinesTag = /* @__PURE__ */ text("prs.lines.tag", "dsc");
var Text_PrsPropLogic = /* @__PURE__ */ text("prs.prop.logic");
var Text_Raptorfec = /* @__PURE__ */ text("raptorfec");
var Text_RED = /* @__PURE__ */ text("red");
var Text_Rfc822_Headers = /* @__PURE__ */ text("rfc822-headers");
var Text_Richtext = /* @__PURE__ */ text("richtext", "rtx");
var Text_Rtf = /* @__PURE__ */ text("rtf");
var Text_Rtp_Enc_Aescm128 = /* @__PURE__ */ text("rtp-enc-aescm128");
var Text_Rtploopback = /* @__PURE__ */ text("rtploopback");
var Text_Rtx = /* @__PURE__ */ text("rtx");
var Text_Sgml = /* @__PURE__ */ text("sgml", "sgml", "sgm");
var Text_Shex = /* @__PURE__ */ text("shex", "shex");
var Text_Slim = /* @__PURE__ */ text("slim", "slim", "slm");
var Text_Strings = /* @__PURE__ */ text("strings");
var Text_Stylus = /* @__PURE__ */ text("stylus", "stylus", "styl");
var Text_T140 = /* @__PURE__ */ text("t140");
var Text_Tab_Separated_Values = /* @__PURE__ */ text("tab-separated-values", "tsv");
var Text_Troff = /* @__PURE__ */ text("troff", "t", "tr", "roff", "man", "me", "ms");
var Text_Turtle = /* @__PURE__ */ text("turtle", "ttl");
var Text_Ulpfec = /* @__PURE__ */ text("ulpfec");
var Text_Uri_List = /* @__PURE__ */ text("uri-list", "uri", "uris", "urls");
var Text_Vcard = /* @__PURE__ */ text("vcard", "vcard");
var Text_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ text("1d-interleaved-parityfec");
var Text_Vendor_A = /* @__PURE__ */ text("vnd.a");
var Text_Vendor_Abc = /* @__PURE__ */ text("vnd.abc");
var Text_Vendor_Ascii_Art = /* @__PURE__ */ text("vnd.ascii-art");
var Text_Vendor_Curl = /* @__PURE__ */ text("vnd.curl", "curl");
var Text_Vendor_CurlDcurl = /* @__PURE__ */ text("vnd.curl.dcurl", "dcurl");
var Text_Vendor_CurlMcurl = /* @__PURE__ */ text("vnd.curl.mcurl", "mcurl");
var Text_Vendor_CurlScurl = /* @__PURE__ */ text("vnd.curl.scurl", "scurl");
var Text_Vendor_DebianCopyright = /* @__PURE__ */ text("vnd.debian.copyright");
var Text_Vendor_DMClientScript = /* @__PURE__ */ text("vnd.dmclientscript");
var Text_Vendor_DvbSubtitle = /* @__PURE__ */ text("vnd.dvb.subtitle", "sub");
var Text_Vendor_EsmertecTheme_Descriptor = /* @__PURE__ */ text("vnd.esmertec.theme-descriptor");
var Text_Vendor_FiclabFlt = /* @__PURE__ */ text("vnd.ficlab.flt");
var Text_Vendor_Fly = /* @__PURE__ */ text("vnd.fly", "fly");
var Text_Vendor_FmiFlexstor = /* @__PURE__ */ text("vnd.fmi.flexstor", "flx");
var Text_Vendor_Gml = /* @__PURE__ */ text("vnd.gml");
var Text_Vendor_Graphviz = /* @__PURE__ */ text("vnd.graphviz", "gv");
var Text_Vendor_Hgl = /* @__PURE__ */ text("vnd.hgl");
var Text_Vendor_In3d3dml = /* @__PURE__ */ text("vnd.in3d.3dml", "3dml");
var Text_Vendor_In3dSpot = /* @__PURE__ */ text("vnd.in3d.spot", "spot");
var Text_Vendor_IPTCNewsML = /* @__PURE__ */ text("vnd.iptc.newsml");
var Text_Vendor_IPTCNITF = /* @__PURE__ */ text("vnd.iptc.nitf");
var Text_Vendor_Latex_Z = /* @__PURE__ */ text("vnd.latex-z");
var Text_Vendor_MotorolaReflex = /* @__PURE__ */ text("vnd.motorola.reflex");
var Text_Vendor_Ms_Mediapackage = /* @__PURE__ */ text("vnd.ms-mediapackage");
var Text_Vendor_Net2phoneCommcenterCommand = /* @__PURE__ */ text("vnd.net2phone.commcenter.command");
var Text_Vendor_RadisysMsml_Basic_Layout = /* @__PURE__ */ text("vnd.radisys.msml-basic-layout");
var Text_Vendor_SenxWarpscript = /* @__PURE__ */ text("vnd.senx.warpscript");
var Text_Vendor_SiUricatalogue = /* @__PURE__ */ text("vnd.si.uricatalogue").deprecate("by request");
var Text_Vendor_Sosi = /* @__PURE__ */ text("vnd.sosi");
var Text_Vendor_SunJ2meApp_Descriptor = /* @__PURE__ */ text("vnd.sun.j2me.app-descriptor", "jad");
var Text_Vendor_TrolltechLinguist = /* @__PURE__ */ text("vnd.trolltech.linguist");
var Text_Vendor_WapSi = /* @__PURE__ */ text("vnd.wap.si");
var Text_Vendor_WapSl = /* @__PURE__ */ text("vnd.wap.sl");
var Text_Vendor_WapWml = /* @__PURE__ */ text("vnd.wap.wml", "wml");
var Text_Vendor_WapWmlscript = /* @__PURE__ */ text("vnd.wap.wmlscript", "wmls");
var Text_Vtt = /* @__PURE__ */ text("vtt");
var Text_X_Asm = /* @__PURE__ */ text("x-asm", "s", "asm");
var Text_X_C = /* @__PURE__ */ text("x-c", "c", "cc", "cxx", "cpp", "h", "hh", "dic");
var Text_X_Fortran = /* @__PURE__ */ text("x-fortran", "f", "for", "f77", "f90");
var Text_X_Gwt_Rpc = /* @__PURE__ */ text("x-gwt-rpc");
var Text_X_Handlebars_Template = /* @__PURE__ */ text("x-handlebars-template", "hbs");
var Text_X_Java_Source = /* @__PURE__ */ text("x-java-source", "java");
var Text_X_Jquery_Tmpl = /* @__PURE__ */ text("x-jquery-tmpl");
var Text_X_Lua = /* @__PURE__ */ text("x-lua", "lua");
var Text_X_Markdown = /* @__PURE__ */ text("x-markdown", "mkd");
var Text_X_Nfo = /* @__PURE__ */ text("x-nfo", "nfo");
var Text_X_Opml = /* @__PURE__ */ text("x-opml", "opml");
var Text_X_Org = /* @__PURE__ */ text("x-org", "org");
var Text_X_Pascal = /* @__PURE__ */ text("x-pascal", "p", "pas");
var Text_X_Processing = /* @__PURE__ */ text("x-processing", "pde");
var Text_X_Sass = /* @__PURE__ */ text("x-sass", "sass");
var Text_X_Scss = /* @__PURE__ */ text("x-scss", "scss");
var Text_X_Setext = /* @__PURE__ */ text("x-setext", "etx");
var Text_X_Sfv = /* @__PURE__ */ text("x-sfv", "sfv");
var Text_X_Suse_Ymp = /* @__PURE__ */ text("x-suse-ymp", "ymp");
var Text_X_Uuencode = /* @__PURE__ */ text("x-uuencode", "uu");
var Text_X_Vcalendar = /* @__PURE__ */ text("x-vcalendar", "vcs");
var Text_X_Vcard = /* @__PURE__ */ text("x-vcard", "vcf");
var Text_Xml = /* @__PURE__ */ text("xml");
var Text_Xml_External_Parsed_Entity = /* @__PURE__ */ text("xml-external-parsed-entity");
var Text_Yaml = /* @__PURE__ */ text("yaml", "yaml", "yml");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/video.ts
var video_exports = {};
__export(video_exports, {
  Video_BMPEG: () => Video_BMPEG,
  Video_BT656: () => Video_BT656,
  Video_CelB: () => Video_CelB,
  Video_DV: () => Video_DV,
  Video_Encaprtp: () => Video_Encaprtp,
  Video_Example: () => Video_Example,
  Video_Flexfec: () => Video_Flexfec,
  Video_H261: () => Video_H261,
  Video_H263: () => Video_H263,
  Video_H263_1998: () => Video_H263_1998,
  Video_H263_2000: () => Video_H263_2000,
  Video_H264: () => Video_H264,
  Video_H264_RCDO: () => Video_H264_RCDO,
  Video_H264_SVC: () => Video_H264_SVC,
  Video_H265: () => Video_H265,
  Video_IsoSegment: () => Video_IsoSegment,
  Video_JPEG: () => Video_JPEG,
  Video_Jpeg2000: () => Video_Jpeg2000,
  Video_Jpm: () => Video_Jpm,
  Video_MP1S: () => Video_MP1S,
  Video_MP2P: () => Video_MP2P,
  Video_MP2T: () => Video_MP2T,
  Video_MP4V_ES: () => Video_MP4V_ES,
  Video_MPV: () => Video_MPV,
  Video_Mj2: () => Video_Mj2,
  Video_Mp4: () => Video_Mp4,
  Video_Mpeg: () => Video_Mpeg,
  Video_Mpeg4_Generic: () => Video_Mpeg4_Generic,
  Video_Nv: () => Video_Nv,
  Video_Ogg: () => Video_Ogg,
  Video_Parityfec: () => Video_Parityfec,
  Video_Pointer: () => Video_Pointer,
  Video_Quicktime: () => Video_Quicktime,
  Video_Raptorfec: () => Video_Raptorfec,
  Video_Raw: () => Video_Raw,
  Video_Rtp_Enc_Aescm128: () => Video_Rtp_Enc_Aescm128,
  Video_Rtploopback: () => Video_Rtploopback,
  Video_Rtx: () => Video_Rtx,
  Video_SMPTE292M: () => Video_SMPTE292M,
  Video_Smpte291: () => Video_Smpte291,
  Video_Ulpfec: () => Video_Ulpfec,
  Video_VP8: () => Video_VP8,
  Video_Vc1: () => Video_Vc1,
  Video_Vc2: () => Video_Vc2,
  Video_Vendor_1d_Interleaved_Parityfec: () => Video_Vendor_1d_Interleaved_Parityfec,
  Video_Vendor_3gpp: () => Video_Vendor_3gpp,
  Video_Vendor_3gpp2: () => Video_Vendor_3gpp2,
  Video_Vendor_3gpp_Tt: () => Video_Vendor_3gpp_Tt,
  Video_Vendor_CCTV: () => Video_Vendor_CCTV,
  Video_Vendor_DeceHd: () => Video_Vendor_DeceHd,
  Video_Vendor_DeceMobile: () => Video_Vendor_DeceMobile,
  Video_Vendor_DeceMp4: () => Video_Vendor_DeceMp4,
  Video_Vendor_DecePd: () => Video_Vendor_DecePd,
  Video_Vendor_DeceSd: () => Video_Vendor_DeceSd,
  Video_Vendor_DeceVideo: () => Video_Vendor_DeceVideo,
  Video_Vendor_DirectvMpeg: () => Video_Vendor_DirectvMpeg,
  Video_Vendor_DirectvMpeg_Tts: () => Video_Vendor_DirectvMpeg_Tts,
  Video_Vendor_DlnaMpeg_Tts: () => Video_Vendor_DlnaMpeg_Tts,
  Video_Vendor_DvbFile: () => Video_Vendor_DvbFile,
  Video_Vendor_Fvt: () => Video_Vendor_Fvt,
  Video_Vendor_HnsVideo: () => Video_Vendor_HnsVideo,
  Video_Vendor_Iptvforum1dparityfec_1010: () => Video_Vendor_Iptvforum1dparityfec_1010,
  Video_Vendor_Iptvforum1dparityfec_2005: () => Video_Vendor_Iptvforum1dparityfec_2005,
  Video_Vendor_Iptvforum2dparityfec_1010: () => Video_Vendor_Iptvforum2dparityfec_1010,
  Video_Vendor_Iptvforum2dparityfec_2005: () => Video_Vendor_Iptvforum2dparityfec_2005,
  Video_Vendor_IptvforumTtsavc: () => Video_Vendor_IptvforumTtsavc,
  Video_Vendor_IptvforumTtsmpeg2: () => Video_Vendor_IptvforumTtsmpeg2,
  Video_Vendor_MotorolaVideo: () => Video_Vendor_MotorolaVideo,
  Video_Vendor_MotorolaVideop: () => Video_Vendor_MotorolaVideop,
  Video_Vendor_Mpeg_Dash_Mpd: () => Video_Vendor_Mpeg_Dash_Mpd,
  Video_Vendor_Mpegurl: () => Video_Vendor_Mpegurl,
  Video_Vendor_Ms_PlayreadyMediaPyv: () => Video_Vendor_Ms_PlayreadyMediaPyv,
  Video_Vendor_NokiaInterleaved_Multimedia: () => Video_Vendor_NokiaInterleaved_Multimedia,
  Video_Vendor_NokiaMp4vr: () => Video_Vendor_NokiaMp4vr,
  Video_Vendor_NokiaVideovoip: () => Video_Vendor_NokiaVideovoip,
  Video_Vendor_Objectvideo: () => Video_Vendor_Objectvideo,
  Video_Vendor_RadgamettoolsBink: () => Video_Vendor_RadgamettoolsBink,
  Video_Vendor_RadgamettoolsSmacker: () => Video_Vendor_RadgamettoolsSmacker,
  Video_Vendor_SealedMpeg1: () => Video_Vendor_SealedMpeg1,
  Video_Vendor_SealedMpeg4: () => Video_Vendor_SealedMpeg4,
  Video_Vendor_SealedSwf: () => Video_Vendor_SealedSwf,
  Video_Vendor_SealedmediaSoftsealMov: () => Video_Vendor_SealedmediaSoftsealMov,
  Video_Vendor_UvvuMp4: () => Video_Vendor_UvvuMp4,
  Video_Vendor_Vivo: () => Video_Vendor_Vivo,
  Video_Vendor_YoutubeYt: () => Video_Vendor_YoutubeYt,
  Video_Webm: () => Video_Webm,
  Video_X_F4v: () => Video_X_F4v,
  Video_X_Fli: () => Video_X_Fli,
  Video_X_Flv: () => Video_X_Flv,
  Video_X_M4v: () => Video_X_M4v,
  Video_X_Matroska: () => Video_X_Matroska,
  Video_X_Mng: () => Video_X_Mng,
  Video_X_Ms_Asf: () => Video_X_Ms_Asf,
  Video_X_Ms_Vob: () => Video_X_Ms_Vob,
  Video_X_Ms_Wm: () => Video_X_Ms_Wm,
  Video_X_Ms_Wmv: () => Video_X_Ms_Wmv,
  Video_X_Ms_Wmx: () => Video_X_Ms_Wmx,
  Video_X_Ms_Wvx: () => Video_X_Ms_Wvx,
  Video_X_Msvideo: () => Video_X_Msvideo,
  Video_X_Sgi_Movie: () => Video_X_Sgi_Movie,
  Video_X_Smv: () => Video_X_Smv
});
var video = /* @__PURE__ */ specialize("video");
var Video_BMPEG = /* @__PURE__ */ video("bmpeg");
var Video_BT656 = /* @__PURE__ */ video("bt656");
var Video_CelB = /* @__PURE__ */ video("celb");
var Video_DV = /* @__PURE__ */ video("dv");
var Video_Encaprtp = /* @__PURE__ */ video("encaprtp");
var Video_Example = /* @__PURE__ */ video("example");
var Video_Flexfec = /* @__PURE__ */ video("flexfec");
var Video_H261 = /* @__PURE__ */ video("h261", "h261");
var Video_H263 = /* @__PURE__ */ video("h263", "h263");
var Video_H263_1998 = /* @__PURE__ */ video("h263-1998");
var Video_H263_2000 = /* @__PURE__ */ video("h263-2000");
var Video_H264 = /* @__PURE__ */ video("h264", "h264");
var Video_H264_RCDO = /* @__PURE__ */ video("h264-rcdo");
var Video_H264_SVC = /* @__PURE__ */ video("h264-svc");
var Video_H265 = /* @__PURE__ */ video("h265");
var Video_IsoSegment = /* @__PURE__ */ video("iso.segment");
var Video_JPEG = /* @__PURE__ */ video("jpeg", "jpgv");
var Video_Jpeg2000 = /* @__PURE__ */ video("jpeg2000");
var Video_Jpm = /* @__PURE__ */ video("jpm", "jpm", "jpgm");
var Video_Mj2 = /* @__PURE__ */ video("mj2", "mj2", "mjp2");
var Video_MP1S = /* @__PURE__ */ video("mp1s");
var Video_MP2P = /* @__PURE__ */ video("mp2p");
var Video_MP2T = /* @__PURE__ */ video("mp2t");
var Video_Mp4 = /* @__PURE__ */ video("mp4", "mp4", "mp4v", "mpg4");
var Video_MP4V_ES = /* @__PURE__ */ video("mp4v-es");
var Video_Mpeg = /* @__PURE__ */ video("mpeg", "mpeg", "mpg", "mpe", "m1v", "m2v");
var Video_Mpeg4_Generic = /* @__PURE__ */ video("mpeg4-generic");
var Video_MPV = /* @__PURE__ */ video("mpv");
var Video_Nv = /* @__PURE__ */ video("nv");
var Video_Ogg = /* @__PURE__ */ video("ogg", "ogv");
var Video_Parityfec = /* @__PURE__ */ video("parityfec");
var Video_Pointer = /* @__PURE__ */ video("pointer");
var Video_Quicktime = /* @__PURE__ */ video("quicktime", "qt", "mov");
var Video_Raptorfec = /* @__PURE__ */ video("raptorfec");
var Video_Raw = /* @__PURE__ */ video("raw");
var Video_Rtp_Enc_Aescm128 = /* @__PURE__ */ video("rtp-enc-aescm128");
var Video_Rtploopback = /* @__PURE__ */ video("rtploopback");
var Video_Rtx = /* @__PURE__ */ video("rtx");
var Video_Smpte291 = /* @__PURE__ */ video("smpte291");
var Video_SMPTE292M = /* @__PURE__ */ video("smpte292m");
var Video_Ulpfec = /* @__PURE__ */ video("ulpfec");
var Video_Vc1 = /* @__PURE__ */ video("vc1");
var Video_Vc2 = /* @__PURE__ */ video("vc2");
var Video_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ video("1d-interleaved-parityfec");
var Video_Vendor_3gpp = /* @__PURE__ */ video("3gpp", "3gp");
var Video_Vendor_3gpp_Tt = /* @__PURE__ */ video("3gpp-tt");
var Video_Vendor_3gpp2 = /* @__PURE__ */ video("3gpp2", "3g2");
var Video_Vendor_CCTV = /* @__PURE__ */ video("vnd.cctv");
var Video_Vendor_DeceHd = /* @__PURE__ */ video("vnd.dece.hd", "uvh", "uvvh");
var Video_Vendor_DeceMobile = /* @__PURE__ */ video("vnd.dece.mobile", "uvm", "uvvm");
var Video_Vendor_DeceMp4 = /* @__PURE__ */ video("vnd.dece.mp4");
var Video_Vendor_DecePd = /* @__PURE__ */ video("vnd.dece.pd", "uvp", "uvvp");
var Video_Vendor_DeceSd = /* @__PURE__ */ video("vnd.dece.sd", "uvs", "uvvs");
var Video_Vendor_DeceVideo = /* @__PURE__ */ video("vnd.dece.video", "uvv", "uvvv");
var Video_Vendor_DirectvMpeg = /* @__PURE__ */ video("vnd.directv.mpeg");
var Video_Vendor_DirectvMpeg_Tts = /* @__PURE__ */ video("vnd.directv.mpeg-tts");
var Video_Vendor_DlnaMpeg_Tts = /* @__PURE__ */ video("vnd.dlna.mpeg-tts");
var Video_Vendor_DvbFile = /* @__PURE__ */ video("vnd.dvb.file", "dvb");
var Video_Vendor_Fvt = /* @__PURE__ */ video("vnd.fvt", "fvt");
var Video_Vendor_HnsVideo = /* @__PURE__ */ video("vnd.hns.video");
var Video_Vendor_Iptvforum1dparityfec_1010 = /* @__PURE__ */ video("vnd.iptvforum.1dparityfec-1010");
var Video_Vendor_Iptvforum1dparityfec_2005 = /* @__PURE__ */ video("vnd.iptvforum.1dparityfec-2005");
var Video_Vendor_Iptvforum2dparityfec_1010 = /* @__PURE__ */ video("vnd.iptvforum.2dparityfec-1010");
var Video_Vendor_Iptvforum2dparityfec_2005 = /* @__PURE__ */ video("vnd.iptvforum.2dparityfec-2005");
var Video_Vendor_IptvforumTtsavc = /* @__PURE__ */ video("vnd.iptvforum.ttsavc");
var Video_Vendor_IptvforumTtsmpeg2 = /* @__PURE__ */ video("vnd.iptvforum.ttsmpeg2");
var Video_Vendor_MotorolaVideo = /* @__PURE__ */ video("vnd.motorola.video");
var Video_Vendor_MotorolaVideop = /* @__PURE__ */ video("vnd.motorola.videop");
var Video_Vendor_Mpegurl = /* @__PURE__ */ video("vnd.mpegurl", "mxu", "m4u");
var Video_Vendor_Ms_PlayreadyMediaPyv = /* @__PURE__ */ video("vnd.ms-playready.media.pyv", "pyv");
var Video_Vendor_NokiaInterleaved_Multimedia = /* @__PURE__ */ video("vnd.nokia.interleaved-multimedia");
var Video_Vendor_NokiaMp4vr = /* @__PURE__ */ video("vnd.nokia.mp4vr");
var Video_Vendor_NokiaVideovoip = /* @__PURE__ */ video("vnd.nokia.videovoip");
var Video_Vendor_Objectvideo = /* @__PURE__ */ video("vnd.objectvideo");
var Video_Vendor_RadgamettoolsBink = /* @__PURE__ */ video("vnd.radgamettools.bink");
var Video_Vendor_RadgamettoolsSmacker = /* @__PURE__ */ video("vnd.radgamettools.smacker");
var Video_Vendor_SealedmediaSoftsealMov = /* @__PURE__ */ video("vnd.sealedmedia.softseal.mov");
var Video_Vendor_SealedMpeg1 = /* @__PURE__ */ video("vnd.sealed.mpeg1");
var Video_Vendor_SealedMpeg4 = /* @__PURE__ */ video("vnd.sealed.mpeg4");
var Video_Vendor_SealedSwf = /* @__PURE__ */ video("vnd.sealed.swf");
var Video_Vendor_UvvuMp4 = /* @__PURE__ */ video("vnd.uvvu.mp4", "uvu", "uvvu");
var Video_Vendor_Vivo = /* @__PURE__ */ video("vnd.vivo", "viv");
var Video_Vendor_YoutubeYt = /* @__PURE__ */ video("vnd.youtube.yt");
var Video_Vendor_Mpeg_Dash_Mpd = /* @__PURE__ */ video("vnd.mpeg.dash.mpd", "mpd");
var Video_VP8 = /* @__PURE__ */ video("vp8");
var Video_Webm = /* @__PURE__ */ video("webm", "webm");
var Video_X_F4v = /* @__PURE__ */ video("x-f4v", "f4v");
var Video_X_Fli = /* @__PURE__ */ video("x-fli", "fli");
var Video_X_Flv = /* @__PURE__ */ video("x-flv", "flv");
var Video_X_M4v = /* @__PURE__ */ video("x-m4v", "m4v");
var Video_X_Matroska = /* @__PURE__ */ video("x-matroska", "mkv", "mk3d", "mks");
var Video_X_Mng = /* @__PURE__ */ video("x-mng", "mng");
var Video_X_Ms_Asf = /* @__PURE__ */ video("x-ms-asf", "asf", "asx");
var Video_X_Ms_Vob = /* @__PURE__ */ video("x-ms-vob", "vob");
var Video_X_Ms_Wm = /* @__PURE__ */ video("x-ms-wm", "wm");
var Video_X_Ms_Wmv = /* @__PURE__ */ video("x-ms-wmv", "wmv");
var Video_X_Ms_Wmx = /* @__PURE__ */ video("x-ms-wmx", "wmx");
var Video_X_Ms_Wvx = /* @__PURE__ */ video("x-ms-wvx", "wvx");
var Video_X_Msvideo = /* @__PURE__ */ video("x-msvideo", "avi");
var Video_X_Sgi_Movie = /* @__PURE__ */ video("x-sgi-movie", "movie");
var Video_X_Smv = /* @__PURE__ */ video("x-smv", "smv");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/xConference.ts
var xConference_exports = {};
__export(xConference_exports, {
  XConference_XCooltalk: () => XConference_XCooltalk
});
var xConference = /* @__PURE__ */ specialize("xconference");
var XConference_XCooltalk = /* @__PURE__ */ xConference("x-cooltalk", "ice");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/xShader.ts
var xShader_exports = {};
__export(xShader_exports, {
  XShader_XFragment: () => XShader_XFragment,
  XShader_XVertex: () => XShader_XVertex
});
var xShader = /* @__PURE__ */ specialize("x-shader");
var XShader_XVertex = /* @__PURE__ */ xShader("x-vertex", "vert", "vs", "glsl");
var XShader_XFragment = /* @__PURE__ */ xShader("x-fragment", "frag", "fs", "glsl");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/BaseProgress.ts
var BaseProgress = class extends TypedEventBase {
  constructor() {
    super(...arguments);
    this.attached = new Array();
    this.soFar = null;
    this.total = null;
    this.msg = null;
    this.est = null;
  }
  get p() {
    return this.total > 0 ? this.soFar / this.total : 0;
  }
  report(soFar, total, msg, est) {
    this.soFar = soFar;
    this.total = total;
    this.msg = msg;
    this.est = est;
    for (const attach of this.attached) {
      attach.report(soFar, total, msg, est);
    }
  }
  attach(prog) {
    this.attached.push(prog);
    prog.report(this.soFar, this.total, this.msg, this.est);
  }
  clear() {
    this.report(0, 0);
    this._clear();
  }
  start(msg) {
    this.report(0, 1, msg || "starting");
  }
  end(msg) {
    this.report(1, 1, msg || "done");
    this._clear();
  }
  _clear() {
    this.soFar = null;
    this.total = null;
    this.msg = null;
    this.est = null;
    arrayClear(this.attached);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/evts.ts
function isModifierless(evt) {
  return !(evt.shiftKey || evt.altKey || evt.ctrlKey || evt.metaKey);
}
function makeEnterKeyEventHandler(callback) {
  return (ev) => {
    const evt = ev;
    if (isModifierless(evt) && evt.key === "Enter") {
      callback(evt);
    }
  };
}
var HtmlEvt = class {
  constructor(name, callback, opts) {
    this.name = name;
    this.callback = callback;
    if (!isFunction(callback)) {
      throw new Error("A function instance is required for this parameter");
    }
    this.opts = opts;
    Object.freeze(this);
  }
  applyToElement(elem) {
    this.add(elem);
  }
  /**
   * Add the encapsulate callback as an event listener to the give HTMLElement
   */
  add(elem) {
    elem.addEventListener(this.name, this.callback, this.opts);
  }
  /**
   * Remove the encapsulate callback as an event listener from the give HTMLElement
   */
  remove(elem) {
    elem.removeEventListener(this.name, this.callback);
  }
};
function onEvent(eventName, callback, opts) {
  return new HtmlEvt(eventName, callback, opts);
}
function onClick(callback, opts) {
  return onEvent("click", callback, opts);
}
function onDragEnd(callback, opts) {
  return onEvent("dragend", callback, opts);
}
function onDragLeave(callback, opts) {
  return onEvent("dragleave", callback, opts);
}
function onDragOver(callback, opts) {
  return onEvent("dragover", callback, opts);
}
function onDrop(callback, opts) {
  return onEvent("drop", callback, opts);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/FileUploadInput.ts
var FileUploadInputEvent = class extends TypedEvent {
  constructor(files) {
    super("input");
    this.files = files;
  }
};
var FileUploadInput = class extends TypedEventBase {
  constructor(buttonText, buttonStyle, file, dragTarget = null) {
    super();
    this.file = file;
    this.typeFilters = new Array();
    this.element = null;
    this._dragTarget = null;
    const getMatchingFiles = (fileList) => Array.from(fileList).filter((f2) => this.typeFilters.length === 0 || this.typeFilters.filter((t2) => t2.matches(f2.type)).length > 0);
    const getMatchingItems = (itemList) => Array.from(itemList).filter((f2) => f2.kind == "file" && (this.typeFilters.length === 0 || this.typeFilters.filter((t2) => t2.matches(f2.type)).length > 0));
    this.onDragOver = (evt) => {
      if (this.enabled) {
        const items = getMatchingItems(evt.dataTransfer.items);
        if (items.length > 0) {
          elementSetText(this.element, "Drop file...");
        } else {
          elementSetText(this.element, "No files matching expected type(s)");
        }
      }
      evt.preventDefault();
    };
    this.onDragEnd = (evt) => {
      if (this.enabled) {
        elementSetText(this.element, buttonText);
      }
      evt.preventDefault();
    };
    this.onDrop = (evt) => {
      if (this.enabled) {
        select(evt.dataTransfer.files);
      }
      this.onDragEnd(evt);
    };
    const select = (fileList) => {
      const files = getMatchingFiles(fileList);
      if (files.length > 0) {
        this.dispatchEvent(new FileUploadInputEvent(files));
      }
    };
    this.file.style.display = "none";
    this.file.insertAdjacentElement(
      "afterend",
      this.element = Button(
        classList("btn", `btn-${buttonStyle}`),
        onClick(() => this.show()),
        buttonText
      )
    );
    this.dragTarget = dragTarget || this.element;
    this.file.addEventListener("input", () => select(this.file.files));
    this.setTypeFilters();
    this.enabled = true;
  }
  get dragTarget() {
    return this._dragTarget;
  }
  set dragTarget(v) {
    if (v !== this.dragTarget) {
      if (this.dragTarget) {
        this.dragTarget.removeEventListener("dragover", this.onDragOver);
        this.dragTarget.removeEventListener("dragend", this.onDragEnd);
        this.dragTarget.removeEventListener("dragleave", this.onDragEnd);
        this.dragTarget.removeEventListener("drop", this.onDrop);
      }
      this._dragTarget = v;
      if (this.dragTarget) {
        elementApply(
          this.dragTarget,
          onDragOver(this.onDragOver),
          onDragLeave(this.onDragEnd),
          onDragEnd(this.onDragEnd),
          onDrop(this.onDrop)
        );
      }
    }
  }
  show() {
    if (this.file.showPicker) {
      this.file.showPicker();
    } else {
      this.file.click();
    }
  }
  setTypeFilters(...types) {
    arrayReplace(this.typeFilters, ...types);
    this.file.accept = mediaTypesToAcceptValue(types);
  }
  isExpectedType(contentType) {
    if (isNullOrUndefined(contentType)) {
      return false;
    }
    if (this.typeFilters.length === 0) {
      return true;
    }
    return this.typeFilters.map((t2) => t2.matches(contentType)).reduce((a, b) => a || b, false);
  }
  get accept() {
    return this.file.accept;
  }
  get enabled() {
    return !this.file.disabled;
  }
  set enabled(v) {
    this.file.disabled = !v;
    this.element.disabled = !v;
  }
  get disabled() {
    return !this.enabled;
  }
  set disabled(v) {
    this.enabled = !v;
  }
  get files() {
    return this.file.files;
  }
  clear() {
    this.file.value = null;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/ChildProgressCallback.ts
var ChildProgressCallback = class extends BaseProgress {
  constructor(i, prog) {
    super();
    this.i = i;
    this.prog = prog;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    this.prog.update(this.i, soFar, total, msg);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/BaseParentProgressCallback.ts
var BaseParentProgressCallback = class {
  constructor(prog) {
    this.prog = prog;
    this.weightTotal = 0;
    this.subProgressCallbacks = new Array();
    this.subProgressWeights = new Array();
    this.subProgressValues = new Array();
    this.start = performance.now();
    for (let i = 0; i < this.subProgressWeights.length; ++i) {
      this.subProgressValues[i] = 0;
      this.subProgressCallbacks[i] = new ChildProgressCallback(i, this);
    }
  }
  addSubProgress(weight) {
    weight = weight || 1;
    this.weightTotal += weight;
    this.subProgressWeights.push(weight);
    this.subProgressValues.push(0);
    const child = new ChildProgressCallback(this.subProgressCallbacks.length, this);
    this.subProgressCallbacks.push(child);
    return child;
  }
  update(i, subSoFar, subTotal, msg) {
    if (this.prog) {
      this.subProgressValues[i] = subSoFar / subTotal;
      let soFar = 0;
      for (let j = 0; j < this.subProgressWeights.length; ++j) {
        soFar += this.subProgressValues[j] * this.subProgressWeights[j];
      }
      const end = performance.now();
      const delta = end - this.start;
      const est = this.start - end + delta * this.weightTotal / soFar;
      this.prog.report(soFar, this.weightTotal, msg, est);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressSplit.ts
function progressSplitWeighted(prog, subProgressWeights) {
  const subProg = new WeightedParentProgressCallback(subProgressWeights, prog);
  return subProg.subProgressCallbacks;
}
function progressSplit(prog, taskCount) {
  const subProgressWeights = new Array(taskCount);
  for (let i = 0; i < taskCount; ++i) {
    subProgressWeights[i] = 1;
  }
  return progressSplitWeighted(prog, subProgressWeights);
}
var WeightedParentProgressCallback = class extends BaseParentProgressCallback {
  constructor(subProgressWeights, prog) {
    super(prog);
    for (const weight of subProgressWeights) {
      this.addSubProgress(weight);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressTasks.ts
async function progressTasksWeighted(prog, taskDefs) {
  const weights = new Array(taskDefs.length);
  const callbacks = new Array(taskDefs.length);
  for (let i = 0; i < taskDefs.length; ++i) {
    const taskDef = taskDefs[i];
    weights[i] = taskDef[0];
    callbacks[i] = taskDef[1];
  }
  const progs = progressSplitWeighted(prog, weights);
  const tasks = new Array(taskDefs.length);
  for (let i = 0; i < taskDefs.length; ++i) {
    tasks[i] = callbacks[i](progs[i]);
  }
  return await Promise.all(tasks);
}
function progressTasks(prog, ...subTaskDef) {
  const taskDefs = subTaskDef.map((t2) => [1, t2]);
  return progressTasksWeighted(prog, taskDefs);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/assertSuccess.ts
function assertSuccess(response) {
  if (response.status >= 400) {
    throw new Error("Resource could not be retrieved: " + response.requestPath);
  }
  return response;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/unwrapResponse.ts
function unwrapResponse(response) {
  const { content } = assertSuccess(response);
  return content;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/Asset.ts
function isAsset(obj) {
  return isDefined(obj) && isFunction(obj.then) && isFunction(obj.catch) && isFunction(obj.finally) && isFunction(obj.fetch) && isFunction(obj.getSize);
}
var BaseAsset = class {
  constructor(path, type2) {
    this.path = path;
    this.type = type2;
    this._result = null;
    this._error = null;
    this._started = false;
    this._finished = false;
    this.resolve = null;
    this.reject = null;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value2) => {
        this._result = value2;
        this._finished = true;
        resolve(value2);
      };
      this.reject = (reason) => {
        this._error = reason;
        this._finished = true;
        reject(reason);
      };
    });
  }
  get result() {
    if (isDefined(this.error)) {
      throw this.error;
    }
    return this._result;
  }
  get error() {
    return this._error;
  }
  get started() {
    return this._started;
  }
  get finished() {
    return this._finished;
  }
  async getSize(fetcher2) {
    try {
      const { contentLength } = await fetcher2.head(this.path).accept(this.type).exec();
      return [this, contentLength || 1];
    } catch (exp2) {
      console.warn(exp2);
      return [this, 1];
    }
    ;
  }
  async fetch(fetcher2, prog) {
    try {
      const result = await this.getResult(fetcher2, prog);
      this.resolve(result);
    } catch (err) {
      this.reject(err);
    }
  }
  get [Symbol.toStringTag]() {
    return this.promise.toString();
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.promise.catch(onrejected);
  }
  finally(onfinally) {
    return this.promise.finally(onfinally);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/using.ts
function interfaceSigCheck(obj, ...funcNames) {
  if (!isObject(obj)) {
    return false;
  }
  obj = obj;
  for (const funcName of funcNames) {
    if (!(funcName in obj)) {
      return false;
    }
    const func = obj[funcName];
    if (!isFunction(func)) {
      return false;
    }
  }
  return true;
}
function isDisposable(obj) {
  return interfaceSigCheck(obj, "dispose");
}
function isDestroyable(obj) {
  return interfaceSigCheck(obj, "destroy");
}
function isClosable(obj) {
  return interfaceSigCheck(obj, "close");
}
function dispose(val) {
  if (isDisposable(val)) {
    val.dispose();
  }
  if (isClosable(val)) {
    val.close();
  }
  if (isDestroyable(val)) {
    val.destroy();
  }
}
function using(val, thunk) {
  try {
    return thunk(val);
  } finally {
    dispose(val);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/canvas.ts
var hasHTMLCanvas = "HTMLCanvasElement" in globalThis;
var hasHTMLImage = "HTMLImageElement" in globalThis;
var disableAdvancedSettings = false;
var hasOffscreenCanvas = !disableAdvancedSettings && "OffscreenCanvas" in globalThis;
var hasImageBitmap = !disableAdvancedSettings && "createImageBitmap" in globalThis;
function isHTMLCanvas(obj) {
  return hasHTMLCanvas && obj instanceof HTMLCanvasElement;
}
function isOffscreenCanvas(obj) {
  return hasOffscreenCanvas && obj instanceof OffscreenCanvas;
}
function testOffscreen2D() {
  try {
    const canv = new OffscreenCanvas(1, 1);
    const g = canv.getContext("2d");
    return g != null;
  } catch (exp2) {
    return false;
  }
}
var hasOffscreenCanvasRenderingContext2D = hasOffscreenCanvas && testOffscreen2D();
var createUtilityCanvas = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvas || hasHTMLCanvas && createCanvas || null;
var createUICanvas = hasHTMLCanvas ? createCanvas : createUtilityCanvas;
function testOffscreen3D() {
  try {
    const canv = new OffscreenCanvas(1, 1);
    const g = canv.getContext("webgl2");
    return g != null;
  } catch (exp2) {
    return false;
  }
}
var hasOffscreenCanvasRenderingContext3D = hasOffscreenCanvas && testOffscreen3D();
function createOffscreenCanvas(width2, height) {
  return new OffscreenCanvas(width2, height);
}
function createCanvas(w, h) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  return Canvas(htmlWidth(w), htmlHeight(h));
}
function drawImageToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.drawImage(img, 0, 0);
}
function setCanvasSize(canv, w, h, superscale = 1) {
  w = Math.floor(w * superscale);
  h = Math.floor(h * superscale);
  if (canv.width != w || canv.height != h) {
    canv.width = w;
    canv.height = h;
    return true;
  }
  return false;
}
function is2DRenderingContext(ctx) {
  return isDefined(ctx.textBaseline);
}
function setCanvas2DContextSize(ctx, w, h, superscale = 1) {
  const oldImageSmoothingEnabled = ctx.imageSmoothingEnabled, oldTextBaseline = ctx.textBaseline, oldTextAlign = ctx.textAlign, oldFont = ctx.font, resized = setCanvasSize(
    ctx.canvas,
    w,
    h,
    superscale
  );
  if (resized) {
    ctx.imageSmoothingEnabled = oldImageSmoothingEnabled;
    ctx.textBaseline = oldTextBaseline;
    ctx.textAlign = oldTextAlign;
    ctx.font = oldFont;
  }
  return resized;
}
function setContextSize(ctx, w, h, superscale = 1) {
  if (is2DRenderingContext(ctx)) {
    return setCanvas2DContextSize(ctx, w, h, superscale);
  } else {
    return setCanvasSize(
      ctx.canvas,
      w,
      h,
      superscale
    );
  }
}
function canvasToBlob(canvas, type2, quality) {
  if (type2 instanceof MediaType) {
    type2 = type2.value;
  }
  if (isOffscreenCanvas(canvas)) {
    return canvas.convertToBlob({ type: type2, quality });
  } else if (isHTMLCanvas(canvas)) {
    const blobCreated = new Task();
    canvas.toBlob(blobCreated.resolve, type2, quality);
    return blobCreated;
  } else {
    throw new Error("Cannot save image from canvas");
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/waitFor.ts
function waitFor(test) {
  const task = new Task();
  const handle = setInterval(() => {
    if (test()) {
      clearInterval(handle);
      task.resolve();
    }
  }, 100);
  return task;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/translateResponse.ts
async function translateResponse(response, translate) {
  const {
    status,
    requestPath,
    responsePath,
    content,
    contentType,
    contentLength,
    fileName,
    headers,
    date
  } = response;
  return {
    status,
    requestPath,
    responsePath,
    content: isDefined(translate) ? await translate(content) : void 0,
    contentType,
    contentLength,
    fileName,
    headers,
    date
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/RequestBuilder.ts
var testAudio = null;
function canPlay(type2) {
  if (testAudio === null) {
    testAudio = new Audio();
  }
  return testAudio.canPlayType(type2) !== "";
}
var RequestBuilder = class {
  constructor(fetcher2, method, path, useBLOBs = false) {
    this.fetcher = fetcher2;
    this.method = method;
    this.path = path;
    this.useBLOBs = useBLOBs;
    this.prog = null;
    this.request = {
      method,
      path: this.path.href,
      body: null,
      headers: null,
      timeout: null,
      withCredentials: false,
      useCache: false,
      retryCount: 3
    };
  }
  retries(count) {
    this.request.retryCount = count;
    return this;
  }
  query(name, value2) {
    this.path.searchParams.set(name, value2);
    this.request.path = this.path.href;
    return this;
  }
  header(name, value2) {
    if (this.request.headers === null) {
      this.request.headers = /* @__PURE__ */ new Map();
    }
    this.request.headers.set(name.toLowerCase(), value2);
    return this;
  }
  headers(headers) {
    for (const [name, value2] of headers.entries()) {
      this.header(name, value2);
    }
    return this;
  }
  timeout(value2) {
    this.request.timeout = value2;
    return this;
  }
  progress(prog) {
    this.prog = prog;
    return this;
  }
  body(body, contentType) {
    if (isDefined(body)) {
      const seen = /* @__PURE__ */ new Set();
      const queue = new Array();
      queue.push(body);
      let isForm = false;
      while (!isForm && queue.length > 0) {
        const here = queue.shift();
        if (here && !seen.has(here)) {
          seen.add(here);
          if (here instanceof Blob) {
            isForm = true;
            break;
          } else if (!isString(here)) {
            queue.push(...Object.values(here));
          }
        }
      }
      if (isForm) {
        const form = new FormData();
        const fileNames = /* @__PURE__ */ new Map();
        const toSkip = /* @__PURE__ */ new Set();
        for (const [key, value2] of Object.entries(body)) {
          if (value2 instanceof Blob) {
            const fileNameKey = key + ".name";
            const fileName = body[fileNameKey];
            if (isString(fileName)) {
              fileNames.set(value2, fileName);
              toSkip.add(fileNameKey);
            }
          }
        }
        for (let [key, value2] of Object.entries(body)) {
          if (toSkip.has(key)) {
            continue;
          }
          if (value2 instanceof Blob) {
            form.append(key, value2, fileNames.get(value2));
          } else if (isString(value2)) {
            form.append(key, value2);
          } else if (isDefined(value2) && isFunction(value2.toString)) {
            form.append(key, value2.toString());
          } else {
            console.warn("Can't serialize value to formdata", key, value2);
          }
        }
        body = form;
        contentType = void 0;
      }
      this.request.body = body;
      this.content(contentType);
    }
    return this;
  }
  withCredentials() {
    this.request.withCredentials = true;
    return this;
  }
  useCache(enabled = true) {
    this.request.useCache = enabled;
    return this;
  }
  media(key, mediaType) {
    if (isDefined(mediaType)) {
      if (!isString(mediaType)) {
        mediaType = mediaType.value;
      }
      this.header(key, mediaType);
    }
  }
  content(contentType) {
    this.media("content-type", contentType);
  }
  accept(acceptType) {
    this.media("accept", acceptType);
    return this;
  }
  blob(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetBlob(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetBlob(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  buffer(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetBuffer(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetBuffer(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  async file(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return await this.fetcher.sendObjectGetFile(this.request, this.prog);
    } else if (this.method === "GET") {
      if (this.useBLOBs) {
        return await this.fetcher.sendNothingGetFile(this.request, this.prog);
      } else {
        const response = await this.fetcher.sendNothingGetNothing(this.request);
        return translateResponse(response, () => this.request.path);
      }
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  text(acceptType) {
    this.accept(acceptType || Text_Plain);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetText(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetText(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  object(acceptType) {
    this.accept(acceptType || Application_Json);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetObject(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetObject(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  xml(acceptType) {
    this.accept(acceptType || Text_Xml);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetXml(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetXml(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  imageBitmap(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetImageBitmap(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetImageBitmap(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  exec() {
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetNothing(this.request, this.prog);
    } else if (this.method === "GET") {
      throw new Exception("GET requests should expect a response type");
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      return this.fetcher.sendNothingGetNothing(this.request);
    } else {
      assertNever(this.method);
    }
  }
  async audioBlob(acceptType) {
    if (isDefined(acceptType)) {
      if (!isString(acceptType)) {
        acceptType = acceptType.value;
      }
      if (!canPlay(acceptType)) {
        throw new Error(`Probably can't play file of type "${acceptType}" at path: ${this.request.path}`);
      }
    }
    const response = await this.blob(acceptType);
    if (canPlay(response.contentType)) {
      return response;
    }
    throw new Error(`Cannot play file of type "${response.contentType}" at path: ${this.request.path}`);
  }
  async audioBuffer(context2, acceptType) {
    return translateResponse(
      await this.audioBlob(acceptType),
      async (blob) => await context2.decodeAudioData(await blob.arrayBuffer())
    );
  }
  async htmlElement(element, resolveEvt, acceptType) {
    const response = await this.file(acceptType);
    const task = once(element, resolveEvt, "error");
    if (element instanceof HTMLLinkElement) {
      element.href = response.content;
    } else {
      element.src = response.content;
    }
    await task;
    return await translateResponse(response, () => element);
  }
  image(acceptType) {
    return this.htmlElement(
      Img(),
      "load",
      acceptType
    );
  }
  async htmlCanvas(acceptType) {
    if (false) {
      throw new Error("HTMLCanvasElement not supported in Workers.");
    }
    const canvas = createCanvas(1, 1);
    if (this.method === "GET") {
      if (hasOffscreenCanvas) {
        this.accept(acceptType);
        const response = await this.fetcher.drawImageToCanvas(this.request, canvas.transferControlToOffscreen(), this.prog);
        return await translateResponse(response, () => canvas);
      } else {
        const response = await (false ? this.imageBitmap(acceptType) : this.image(acceptType));
        return await translateResponse(response, (img) => {
          canvas.width = img.width;
          canvas.height = img.height;
          drawImageToCanvas(canvas, img);
          dispose(img);
          return canvas;
        });
      }
    } else if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE" || this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  canvas(acceptType) {
    if (hasOffscreenCanvas) {
      return this.offscreenCanvas(acceptType);
    } else {
      return this.htmlCanvas(acceptType);
    }
  }
  async offscreenCanvas(acceptType) {
    if (!hasOffscreenCanvas) {
      throw new Error("This system does not support OffscreenCanvas");
    }
    if (this.method === "GET") {
      const response = await (false ? this.imageBitmap(acceptType) : this.image(acceptType));
      return await translateResponse(response, (img) => {
        const canvas = createOffscreenCanvas(img.width, img.height);
        drawImageToCanvas(canvas, img);
        dispose(img);
        return canvas;
      });
    } else if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE" || this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  async style() {
    const tag2 = Link(
      type(Text_Css),
      rel("stylesheet")
    );
    document.head.append(tag2);
    const response = await this.htmlElement(
      tag2,
      "load",
      Text_Css
    );
    return translateResponse(response);
  }
  async getScript() {
    const tag2 = Script(type(Application_Javascript));
    document.head.append(tag2);
    const response = await this.htmlElement(
      tag2,
      "load",
      Application_Javascript
    );
    return translateResponse(response);
  }
  async script(test) {
    let response = null;
    const scriptPath = this.request.path;
    if (!test) {
      response = await this.getScript();
    } else if (!test()) {
      const scriptLoadTask = waitFor(test);
      response = await this.getScript();
      await scriptLoadTask;
    }
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return response;
  }
  async module() {
    const scriptPath = this.request.path;
    const response = await this.file(Application_Javascript);
    const value2 = await import(response.content);
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return translateResponse(response, () => value2);
  }
  async wasm(imports) {
    const response = await this.buffer(Application_Wasm);
    if (!Application_Wasm.matches(response.contentType)) {
      throw new Error(`Server did not respond with WASM file. Was: ${response.contentType}`);
    }
    const module2 = await WebAssembly.compile(response.content);
    const instance = await WebAssembly.instantiate(module2, imports);
    return translateResponse(response, () => instance.exports);
  }
  async worker(type2 = "module") {
    const scriptPath = this.request.path;
    const response = await this.file(Application_Javascript);
    this.prog = null;
    this.request.timeout = null;
    const worker2 = new Worker(response.content, { type: type2 });
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return translateResponse(response, () => worker2);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/Fetcher.ts
var Fetcher = class {
  constructor(service, useBLOBs = false) {
    this.service = service;
    this.useBLOBs = useBLOBs;
    if (true) {
      const antiforgeryToken = getInput("input[name=__RequestVerificationToken]");
      if (antiforgeryToken) {
        this.service.setRequestVerificationToken(antiforgeryToken.value);
      }
    }
  }
  clearCache() {
    return this.service.clearCache();
  }
  evict(path, base) {
    return this.service.evict(new URL(path, base || location.href).href);
  }
  request(method, path, base) {
    return new RequestBuilder(
      this.service,
      method,
      new URL(path, base || location.href),
      this.useBLOBs
    );
  }
  head(path, base) {
    return this.request("HEAD", path, base);
  }
  options(path, base) {
    return this.request("OPTIONS", path, base);
  }
  get(path, base) {
    return this.request("GET", path, base);
  }
  post(path, base) {
    return this.request("POST", path, base);
  }
  put(path, base) {
    return this.request("PUT", path, base);
  }
  patch(path, base) {
    return this.request("PATCH", path, base);
  }
  delete(path, base) {
    return this.request("DELETE", path, base);
  }
  async assets(progressOrAsset, firstAsset, ...assets) {
    if (isNullOrUndefined(assets)) {
      assets = [];
    }
    assets.unshift(firstAsset);
    let progress;
    if (isAsset(progressOrAsset)) {
      assets.unshift(progressOrAsset);
    } else if (isDefined(progressOrAsset)) {
      progress = progressOrAsset;
    }
    assets = assets.filter(isDefined);
    const sizes = await Promise.all(assets.map((asset) => asset.getSize(this)));
    const assetSizes = new Map(sizes);
    await progressTasksWeighted(
      progress,
      assets.map((asset) => [assetSizes.get(asset), (prog) => asset.fetch(this, prog)])
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/FetchingService.ts
var FetchingService = class {
  constructor(impl) {
    this.impl = impl;
    this.defaultPostHeaders = /* @__PURE__ */ new Map();
  }
  setRequestVerificationToken(value2) {
    this.defaultPostHeaders.set("RequestVerificationToken", value2);
  }
  clearCache() {
    return this.impl.clearCache();
  }
  evict(path) {
    return this.impl.evict(path);
  }
  sendNothingGetNothing(request) {
    return this.impl.sendNothingGetNothing(request);
  }
  sendNothingGetBlob(request, progress) {
    return this.impl.sendNothingGetSomething("blob", request, progress);
  }
  sendObjectGetBlob(request, progress) {
    return this.impl.sendSomethingGetSomething("blob", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetBuffer(request, progress) {
    return this.impl.sendNothingGetSomething("arraybuffer", request, progress);
  }
  sendObjectGetBuffer(request, progress) {
    return this.impl.sendSomethingGetSomething("arraybuffer", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetText(request, progress) {
    return this.impl.sendNothingGetSomething("text", request, progress);
  }
  sendObjectGetText(request, progress) {
    return this.impl.sendSomethingGetSomething("text", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetObject(request, progress) {
    return this.impl.sendNothingGetSomething("json", request, progress);
  }
  sendObjectGetObject(request, progress) {
    return this.impl.sendSomethingGetSomething("json", request, this.defaultPostHeaders, progress);
  }
  sendObjectGetNothing(request, progress) {
    return this.impl.sendSomethingGetSomething("", request, this.defaultPostHeaders, progress);
  }
  drawImageToCanvas(request, canvas, progress) {
    return this.impl.drawImageToCanvas(request, canvas, progress);
  }
  async sendNothingGetFile(request, progress) {
    return translateResponse(
      await this.sendNothingGetBlob(request, progress),
      URL.createObjectURL
    );
  }
  async sendObjectGetFile(request, progress) {
    return translateResponse(
      await this.sendObjectGetBlob(request, progress),
      URL.createObjectURL
    );
  }
  async sendNothingGetXml(request, progress) {
    return translateResponse(
      await this.impl.sendNothingGetSomething("document", request, progress),
      (doc) => doc.documentElement
    );
  }
  async sendObjectGetXml(request, progress) {
    return translateResponse(
      await this.impl.sendSomethingGetSomething("document", request, this.defaultPostHeaders, progress),
      (doc) => doc.documentElement
    );
  }
  async sendNothingGetImageBitmap(request, progress) {
    return translateResponse(
      await this.sendNothingGetBlob(request, progress),
      createImageBitmap
    );
  }
  async sendObjectGetImageBitmap(request, progress) {
    return translateResponse(
      await this.sendObjectGetBlob(request, progress),
      createImageBitmap
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapMap.ts
function mapMap(items, makeID, makeValue) {
  return new Map(items.map((item) => [makeID(item), makeValue(item)]));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/makeLookup.ts
function makeLookup(items, makeID) {
  return mapMap(items, makeID, identity);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/PriorityList.ts
var PriorityList = class {
  constructor(init) {
    this.items = /* @__PURE__ */ new Map();
    this.defaultItems = new Array();
    if (isDefined(init)) {
      for (const [key, value2] of init) {
        this.add(key, value2);
      }
    }
  }
  add(key, ...values) {
    for (const value2 of values) {
      if (isNullOrUndefined(key)) {
        this.defaultItems.push(value2);
      } else {
        let list2 = this.items.get(key);
        if (isNullOrUndefined(list2)) {
          this.items.set(key, list2 = []);
        }
        list2.push(value2);
      }
    }
    return this;
  }
  entries() {
    return this.items.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  keys() {
    return this.items.keys();
  }
  *values() {
    for (const item of this.defaultItems) {
      yield item;
    }
    for (const list2 of this.items.values()) {
      for (const item of list2) {
        yield item;
      }
    }
  }
  has(key) {
    if (isDefined(key)) {
      return this.items.has(key);
    } else {
      return this.defaultItems.length > 0;
    }
  }
  get(key) {
    if (isNullOrUndefined(key)) {
      return this.defaultItems;
    }
    return this.items.get(key) || [];
  }
  count(key) {
    if (isNullOrUndefined(key)) {
      return this.defaultItems.length;
    }
    const list2 = this.get(key);
    if (isDefined(list2)) {
      return list2.length;
    }
    return 0;
  }
  get size() {
    let size = this.defaultItems.length;
    for (const list2 of this.items.values()) {
      size += list2.length;
    }
    return size;
  }
  delete(key) {
    if (isNullOrUndefined(key)) {
      return arrayClear(this.defaultItems).length > 0;
    } else {
      return this.items.delete(key);
    }
  }
  remove(key, value2) {
    if (isNullOrUndefined(key)) {
      arrayRemove(this.defaultItems, value2);
    } else {
      const list2 = this.items.get(key);
      if (isDefined(list2)) {
        arrayRemove(list2, value2);
        if (list2.length === 0) {
          this.items.delete(key);
        }
      }
    }
  }
  clear() {
    this.items.clear();
    arrayClear(this.defaultItems);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/PriorityMap.ts
var PriorityMap = class {
  constructor(init) {
    this.items = /* @__PURE__ */ new Map();
    if (isDefined(init)) {
      for (const [key1, key2, value2] of init) {
        this.add(key1, key2, value2);
      }
    }
  }
  add(key1, key2, value2) {
    let level1 = this.items.get(key1);
    if (isNullOrUndefined(level1)) {
      this.items.set(key1, level1 = /* @__PURE__ */ new Map());
    }
    level1.set(key2, value2);
    return this;
  }
  *entries() {
    for (const [key1, level1] of this.items) {
      for (const [key2, value2] of level1) {
        yield [key1, key2, value2];
      }
    }
  }
  keys(key1) {
    if (isNullOrUndefined(key1)) {
      return this.items.keys();
    } else {
      return this.items.get(key1).keys();
    }
  }
  *values() {
    for (const level1 of this.items.values()) {
      for (const value2 of level1.values()) {
        yield value2;
      }
    }
  }
  has(key1, key2) {
    return this.items.has(key1) && (isNullOrUndefined(key2) || this.items.get(key1).has(key2));
  }
  get(key1, key2) {
    if (isNullOrUndefined(key2)) {
      return this.items.get(key1);
    } else if (this.items.has(key1)) {
      return this.items.get(key1).get(key2);
    } else {
      return null;
    }
  }
  count(key1) {
    if (this.items.has(key1)) {
      return this.items.get(key1).size;
    }
    return null;
  }
  get size() {
    let size = 0;
    for (const list2 of this.items.values()) {
      size += list2.size;
    }
    return size;
  }
  delete(key1, key2) {
    if (isNullOrUndefined(key2)) {
      return this.items.delete(key1);
    } else if (this.items.has(key1)) {
      const items = this.items.get(key1);
      const deleted = items.delete(key2);
      if (items.size === 0) {
        this.items.delete(key1);
      }
      return deleted;
    } else {
      return false;
    }
  }
  clear() {
    this.items.clear();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/indexdb/index.ts
var IDexDB = class {
  constructor(db) {
    this.db = db;
  }
  static delete(dbName) {
    const deleteRequest = indexedDB.deleteDatabase(dbName);
    const task = once(deleteRequest, "success", "error", "blocked");
    return success(task);
  }
  static async open(name, ...storeDefs) {
    const storesByName = makeLookup(storeDefs, (v) => v.name);
    const indexesByName = new PriorityMap(
      storeDefs.filter((storeDef) => isDefined(storeDef.indexes)).flatMap((storeDef) => storeDef.indexes.map((indexDef) => [storeDef.name, indexDef.name, indexDef]))
    );
    const storesToAdd = new Array();
    const storesToRemove = new Array();
    const storesToChange = new Array();
    const indexesToAdd = new PriorityList();
    const indexesToRemove = new PriorityList();
    let version5 = null;
    const D = indexedDB.open(name);
    if (await success(once(D, "success", "error", "blocked"))) {
      const db = D.result;
      version5 = db.version;
      const storesToScrutinize = new Array();
      for (const storeName of db.objectStoreNames) {
        if (!storesByName.has(storeName)) {
          storesToRemove.push(storeName);
        }
      }
      for (const storeName of storesByName.keys()) {
        if (!db.objectStoreNames.contains(storeName)) {
          storesToAdd.push(storeName);
        } else {
          storesToScrutinize.push(storeName);
        }
      }
      if (storesToScrutinize.length > 0) {
        const transaction = db.transaction(storesToScrutinize);
        const transacting = once(transaction, "complete", "error", "abort");
        const transacted = success(transacting);
        for (const storeName of storesToScrutinize) {
          const store = transaction.objectStore(storeName);
          const storeDef = storesByName.get(storeName);
          if (isDefined(storeDef.options) && store.keyPath !== storeDef.options.keyPath) {
            storesToRemove.push(storeName);
            storesToAdd.push(storeName);
          }
          for (const indexName of store.indexNames) {
            if (!indexesByName.has(storeName, indexName)) {
              if (storesToChange.indexOf(storeName) === -1) {
                storesToChange.push(storeName);
              }
              indexesToRemove.add(storeName, indexName);
            }
          }
          if (indexesByName.has(storeName)) {
            for (const indexName of indexesByName.get(storeName).keys()) {
              if (!store.indexNames.contains(indexName)) {
                if (storesToChange.indexOf(storeName) === -1) {
                  storesToChange.push(storeName);
                }
                indexesToAdd.add(storeName, indexName);
              } else {
                const indexDef = indexesByName.get(storeName, indexName);
                const index = store.index(indexName);
                if (isString(indexDef.keyPath) !== isString(index.keyPath) || isString(indexDef.keyPath) && isString(index.keyPath) && indexDef.keyPath !== index.keyPath || isArray(indexDef.keyPath) && isArray(index.keyPath) && arrayCompare(indexDef.keyPath, index.keyPath)) {
                  if (storesToChange.indexOf(storeName) === -1) {
                    storesToChange.push(storeName);
                  }
                  indexesToRemove.add(storeName, indexName);
                  indexesToAdd.add(storeName, indexName);
                }
              }
            }
          }
        }
        transaction.commit();
        await transacted;
      }
      dispose(db);
    } else {
      version5 = 0;
      storesToAdd.push(...storesByName.keys());
      for (const storeDef of storeDefs) {
        if (isDefined(storeDef.indexes)) {
          for (const indexDef of storeDef.indexes) {
            indexesToAdd.add(storeDef.name, indexDef.name);
          }
        }
      }
    }
    if (storesToAdd.length > 0 || storesToRemove.length > 0 || indexesToAdd.size > 0 || indexesToRemove.size > 0) {
      ++version5;
    }
    const upgrading = new Task();
    const openRequest = isDefined(version5) ? indexedDB.open(name, version5) : indexedDB.open(name);
    const opening = once(openRequest, "success", "error", "blocked");
    const upgraded = success(upgrading);
    const opened = success(opening);
    const noUpgrade = upgrading.resolver(false);
    openRequest.addEventListener("success", noUpgrade);
    openRequest.addEventListener("upgradeneeded", () => {
      const transacting = once(openRequest.transaction, "complete", "error", "abort");
      const db = openRequest.result;
      for (const storeName of storesToRemove) {
        db.deleteObjectStore(storeName);
      }
      const stores = /* @__PURE__ */ new Map();
      for (const storeName of storesToAdd) {
        const storeDef = storesByName.get(storeName);
        const store = db.createObjectStore(storeName, storeDef.options);
        stores.set(storeName, store);
      }
      for (const storeName of storesToChange) {
        const store = openRequest.transaction.objectStore(storeName);
        stores.set(storeName, store);
      }
      for (const [storeName, store] of stores) {
        for (const indexName of indexesToRemove.get(storeName)) {
          store.deleteIndex(indexName);
        }
        for (const indexName of indexesToAdd.get(storeName)) {
          const indexDef = indexesByName.get(storeName, indexName);
          store.createIndex(indexName, indexDef.keyPath, indexDef.options);
        }
      }
      success(transacting).then(upgrading.resolve).catch(upgrading.reject).finally(() => openRequest.removeEventListener("success", noUpgrade));
    });
    if (!await upgraded) {
      throw upgrading.error;
    }
    if (!await opened) {
      throw opening.error;
    }
    return new IDexDB(openRequest.result);
  }
  dispose() {
    dispose(this.db);
  }
  get name() {
    return this.db.name;
  }
  get version() {
    return this.db.version;
  }
  get storeNames() {
    return Array.from(this.db.objectStoreNames);
  }
  getStore(storeName) {
    return new IDexStore(this.db, storeName);
  }
};
var IDexStore = class {
  constructor(db, storeName) {
    this.db = db;
    this.storeName = storeName;
  }
  async request(makeRequest, mode) {
    const transaction = this.db.transaction(this.storeName, mode);
    const transacting = once(transaction, "complete", "error");
    const store = transaction.objectStore(this.storeName);
    const request = makeRequest(store);
    const requesting = once(request, "success", "error");
    if (!await success(requesting)) {
      transaction.abort();
      throw requesting.error;
    }
    transaction.commit();
    if (!await success(transacting)) {
      throw transacting.error;
    }
    return request.result;
  }
  add(value2, key) {
    return this.request((store) => store.add(value2, key), "readwrite");
  }
  clear() {
    return this.request((store) => store.clear(), "readwrite");
  }
  getCount(query) {
    return this.request((store) => store.count(query), "readonly");
  }
  async has(query) {
    return await this.getCount(query) > 0;
  }
  delete(query) {
    return this.request((store) => store.delete(query), "readwrite");
  }
  get(key) {
    return this.request((store) => store.get(key), "readonly");
  }
  getAll() {
    return this.request((store) => store.getAll(), "readonly");
  }
  getAllKeys() {
    return this.request((store) => store.getAllKeys(), "readonly");
  }
  getKey(query) {
    return this.request((store) => store.getKey(query), "readonly");
  }
  openCursor(query, direction) {
    return this.request((store) => store.openCursor(query, direction), "readonly");
  }
  openKeyCursor(query, direction) {
    return this.request((store) => store.openKeyCursor(query, direction), "readonly");
  }
  put(value2, key) {
    return this.request((store) => store.put(value2, key), "readwrite");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapJoin.ts
function mapJoin(dest, ...sources) {
  for (const source of sources) {
    if (isDefined(source)) {
      for (const [key, value2] of source) {
        dest.set(key, value2);
      }
    }
  }
  return dest;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/sleep.ts
var SleepTask = class extends Task {
  constructor(milliseconds) {
    super(false);
    this.milliseconds = milliseconds;
    this._timer = null;
  }
  start() {
    super.start();
    this._timer = setTimeout(() => {
      this._timer = null;
      this.resolve();
    }, this.milliseconds);
  }
  reset() {
    super.reset();
    if (isDefined(this._timer)) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
};
function sleep(milliseconds) {
  const task = new SleepTask(milliseconds);
  task.start();
  return task;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/withRetry.ts
function withRetry(retryCount, action) {
  return async () => {
    let lastError = null;
    let retryTime = 500;
    for (let retry = 0; retry <= retryCount; ++retry) {
      try {
        if (retry > 0) {
          await sleep(retryTime);
          retryTime *= 2;
        }
        return await action();
      } catch (error) {
        lastError = error;
      }
    }
    throw lastError;
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/FetchingServiceImplXHR.ts
function isXHRBodyInit(obj) {
  return isString(obj) || isArrayBufferView(obj) || obj instanceof Blob || obj instanceof FormData || isArrayBuffer(obj) || "Document" in globalThis && obj instanceof Document;
}
function trackProgress(name, xhr, target, prog, skipLoading, prevTask) {
  let prevDone = !prevTask;
  if (prevTask) {
    prevTask.then(() => prevDone = true);
  }
  let done = false;
  let loaded = skipLoading;
  const requestComplete = new Task();
  target.addEventListener("loadstart", () => {
    if (prevDone && !done && prog) {
      prog.start(name);
    }
  });
  target.addEventListener("progress", (ev) => {
    if (prevDone && !done) {
      const evt = ev;
      if (prog) {
        prog.report(evt.loaded, Math.max(evt.loaded, evt.total), name);
      }
      if (evt.loaded === evt.total) {
        loaded = true;
        if (done) {
          requestComplete.resolve();
        }
      }
    }
  });
  target.addEventListener("load", () => {
    if (prevDone && !done) {
      if (prog) {
        prog.end(name);
      }
      done = true;
      if (loaded) {
        requestComplete.resolve();
      }
    }
  });
  const onError = (msg) => () => {
    if (prevDone) {
      requestComplete.reject(`${msg} (${xhr.status})`);
    }
  };
  target.addEventListener("error", onError("error"));
  target.addEventListener("abort", onError("abort"));
  target.addEventListener("timeout", onError("timeout"));
  return requestComplete;
}
function sendRequest(xhr, method, path, timeout, headers, body) {
  xhr.open(method, path);
  xhr.responseType = "blob";
  xhr.timeout = timeout;
  if (headers) {
    for (const [key, value2] of headers) {
      xhr.setRequestHeader(key, value2);
    }
  }
  if (isDefined(body)) {
    xhr.send(body);
  } else {
    xhr.send();
  }
}
function readResponseHeader(headers, key, translate) {
  if (!headers.has(key)) {
    return null;
  }
  const value2 = headers.get(key);
  try {
    const translated = translate(value2);
    headers.delete(key);
    return translated;
  } catch (exp2) {
    console.warn(key, exp2);
  }
  return null;
}
var FILE_NAME_PATTERN = /filename=\"(.+)\"(;|$)/;
var DB_NAME = "Juniper:Fetcher:Cache";
var FetchingServiceImplXHR = class {
  constructor() {
    this.cache = null;
    this.store = null;
    this.tasks = new PriorityMap();
    this.cacheReady = this.openCache();
  }
  async drawImageToCanvas(request, canvas, progress) {
    const response = await this.sendNothingGetSomething("blob", request, progress);
    const blob = response.content;
    return using(await createImageBitmap(blob, {
      imageOrientation: "from-image"
    }), (img) => {
      canvas.width = img.width;
      canvas.height = img.height;
      const g = canvas.getContext("2d");
      g.drawImage(img, 0, 0);
      return translateResponse(response);
    });
  }
  async openCache() {
    const options = {
      keyPath: "requestPath"
    };
    this.cache = await IDexDB.open(DB_NAME, {
      name: "files",
      options
    });
    this.store = await this.cache.getStore("files");
  }
  async clearCache() {
    await this.cacheReady;
    await this.store.clear();
  }
  async evict(path) {
    await this.cacheReady;
    if (this.store.has(path)) {
      await this.store.delete(path);
    }
  }
  async readResponseHeaders(requestPath, xhr) {
    const headerParts = xhr.getAllResponseHeaders().split(/[\r\n]+/).map((v) => v.trim()).filter((v) => v.length > 0).map((line) => {
      const parts = line.split(": ");
      const key = parts.shift().toLowerCase();
      const value2 = parts.join(": ");
      return [key, value2];
    });
    const pList = new PriorityList(headerParts);
    const normalizedHeaderParts = Array.from(pList.keys()).map((key) => [
      key,
      pList.get(key).join(", ")
    ]);
    const headers = new Map(normalizedHeaderParts);
    const contentType = readResponseHeader(headers, "content-type", identity);
    const contentLength = readResponseHeader(headers, "content-length", parseFloat);
    const date = readResponseHeader(headers, "date", (v) => new Date(v));
    const fileName = readResponseHeader(headers, "content-disposition", (v) => {
      if (isDefined(v)) {
        const match = v.match(FILE_NAME_PATTERN);
        if (isDefined(match)) {
          return match[1];
        }
      }
      return null;
    });
    const response = {
      status: xhr.status,
      requestPath,
      responsePath: xhr.responseURL,
      content: void 0,
      contentType,
      contentLength,
      fileName,
      date,
      headers
    };
    return response;
  }
  async readResponse(requestPath, xhr) {
    const {
      responsePath,
      status,
      contentType,
      contentLength,
      fileName,
      date,
      headers
    } = await this.readResponseHeaders(requestPath, xhr);
    const response = {
      requestPath,
      responsePath,
      status,
      contentType,
      contentLength,
      fileName,
      date,
      headers,
      content: xhr.response
    };
    if (isDefined(response.content)) {
      response.contentType = response.contentType || response.content.type;
      response.contentLength = response.contentLength || response.content.size;
    }
    return response;
  }
  async decodeContent(xhrType, response) {
    return translateResponse(response, async (contentBlob) => {
      if (xhrType === "") {
        return null;
      } else if (isNullOrUndefined(response.contentType)) {
        const headerBlock = Array.from(response.headers.entries()).map((kv) => kv.join(": ")).join("\n  ");
        throw new Error("No content type found in headers: \n  " + headerBlock);
      } else if (xhrType === "blob") {
        return contentBlob;
      } else if (xhrType === "arraybuffer") {
        return await contentBlob.arrayBuffer();
      } else if (xhrType === "json") {
        const text2 = await contentBlob.text();
        if (text2.length > 0) {
          return JSON.parse(text2);
        } else {
          return null;
        }
      } else if (xhrType === "document") {
        const parser = new DOMParser();
        if (response.contentType === "application/xhtml+xml" || response.contentType === "text/html" || response.contentType === "application/xml" || response.contentType === "image/svg+xml" || response.contentType === "text/xml") {
          return parser.parseFromString(await contentBlob.text(), response.contentType);
        } else {
          throw new Error("Couldn't parse document");
        }
      } else if (xhrType === "text") {
        return await contentBlob.text();
      } else {
        assertNever(xhrType);
      }
    });
  }
  async withCachedTask(request, action) {
    if (request.method !== "GET" && request.method !== "HEAD" && request.method !== "OPTIONS") {
      return await action();
    }
    if (!this.tasks.has(request.method, request.path)) {
      this.tasks.add(
        request.method,
        request.path,
        action().finally(() => this.tasks.delete(request.method, request.path))
      );
    }
    return this.tasks.get(request.method, request.path);
  }
  sendNothingGetNothing(request) {
    return this.withCachedTask(
      request,
      withRetry(request.retryCount, async () => {
        const xhr = new XMLHttpRequest();
        const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, null, true);
        sendRequest(xhr, request.method, request.path, request.timeout, request.headers);
        await download;
        return await this.readResponseHeaders(request.path, xhr);
      })
    );
  }
  sendNothingGetSomething(xhrType, request, progress) {
    return this.withCachedTask(
      request,
      withRetry(request.retryCount, async () => {
        let response = null;
        const useCache = request.useCache && request.method === "GET";
        if (useCache) {
          if (isDefined(progress)) {
            progress.start();
          }
          await this.cacheReady;
          response = await this.store.get(request.path);
        }
        const noCachedResponse = isNullOrUndefined(response);
        if (noCachedResponse) {
          const xhr = new XMLHttpRequest();
          const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, progress, true);
          sendRequest(xhr, request.method, request.path, request.timeout, request.headers);
          await download;
          response = await this.readResponse(request.path, xhr);
          if (useCache) {
            await this.store.add(response);
          }
        }
        const value2 = await this.decodeContent(xhrType, response);
        if (noCachedResponse && isDefined(progress)) {
          progress.end();
        }
        return value2;
      })
    );
  }
  sendSomethingGetSomething(xhrType, request, defaultPostHeaders, progress) {
    let body = null;
    const headers = mapJoin(/* @__PURE__ */ new Map(), defaultPostHeaders, request.headers);
    if (request.body instanceof FormData && isDefined(headers)) {
      const toDelete = new Array();
      for (const key of headers.keys()) {
        if (key.toLowerCase() === "content-type") {
          toDelete.push(key);
        }
      }
      for (const key of toDelete) {
        headers.delete(key);
      }
    }
    if (isXHRBodyInit(request.body) && !isString(request.body)) {
      body = request.body;
    } else if (isDefined(request.body)) {
      body = JSON.stringify(request.body);
    }
    const hasBody = isDefined(body);
    const progs = progressSplit(progress, hasBody ? 2 : 1);
    const [progUpload, progDownload] = progs;
    const query = async () => {
      const xhr = new XMLHttpRequest();
      const upload = hasBody ? trackProgress("uploading", xhr, xhr.upload, progUpload, false) : Promise.resolve();
      const download = trackProgress("saving", xhr, xhr, progDownload, true, upload);
      sendRequest(xhr, request.method, request.path, request.timeout, headers, body);
      await upload;
      await download;
      const response = await this.readResponse(request.path, xhr);
      return await this.decodeContent(xhrType, response);
    };
    return withRetry(request.retryCount, query)();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/flags.ts
var oculusBrowserPattern = /OculusBrowser\/(\d+)\.(\d+)\.(\d+)/i;
var oculusMatch = /* @__PURE__ */ navigator.userAgent.match(oculusBrowserPattern);
var isOculusBrowser = !!oculusMatch;
var oculusBrowserVersion = isOculusBrowser && {
  major: parseFloat(oculusMatch[1]),
  minor: parseFloat(oculusMatch[2]),
  patch: parseFloat(oculusMatch[3])
};
var isOculusGo = isOculusBrowser && /pacific/i.test(navigator.userAgent);
var isOculusQuest = isOculusBrowser && /quest/i.test(navigator.userAgent);
var isOculusQuest2 = isOculusBrowser && /quest 2/i.test(navigator.userAgent);
var isWorkerSupported = "Worker" in globalThis;

// src/isDebug.ts
var url = /* @__PURE__ */ new URL(globalThis.location.href);
var isDebug = !url.searchParams.has("RELEASE");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/singleton.ts
function singleton(name, create6) {
  const box = globalThis;
  let value2 = box[name];
  if (isNullOrUndefined(value2)) {
    if (isNullOrUndefined(create6)) {
      throw new Error(`No value ${name} found`);
    }
    value2 = create6();
    box[name] = value2;
  }
  return value2;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/fonts.ts
var loadedFonts = singleton("juniper::loadedFonts", () => []);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/all.ts
function all(...tasks) {
  return Promise.all(tasks);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/strings/stringRandom.ts
var DEFAULT_CHAR_SET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZ";
function stringRandom(length4, charSet) {
  if (length4 < 0) {
    throw new Error("Length must be greater than 0");
  }
  if (isNullOrUndefined(charSet)) {
    charSet = DEFAULT_CHAR_SET;
  }
  let str3 = "";
  for (let i = 0; i < length4; ++i) {
    const idx = Math.floor(Math.random() * charSet.length);
    str3 += charSet[idx];
  }
  return str3;
}

// package.json
var version2 = "3.7.24";

// src/settings.ts
var version3 = isDebug ? stringRandom(10) : version2;
var DEMO_PPI = 50;
var DEMO_DIM = 12;
var DEMO_PX = DEMO_PPI * DEMO_DIM;
var defaultFont = {
  fontFamily: "Lato",
  fontSize: 20
};
var DLSBlue = rgb(30, 67, 136);
var BasicLabelColor = rgb(78, 77, 77);
var baseTextStyle = {
  fontFamily: defaultFont.fontFamily,
  fontSize: defaultFont.fontSize,
  textFillColor: "white"
};
var textButtonStyle = Object.assign({}, baseTextStyle, {
  bgFillColor: rgb(0, 120, 215),
  bgStrokeColor: "black",
  bgStrokeSize: 0.02,
  padding: {
    top: 0.025,
    left: 0.05,
    bottom: 0.025,
    right: 0.05
  },
  minHeight: 0.2,
  maxHeight: 0.2,
  scale: 300
});
var textLabelStyle = Object.assign({}, baseTextStyle, {
  textStrokeColor: "black",
  textStrokeSize: 0.01,
  minHeight: 0.25,
  maxHeight: 0.25
});
var JS_EXT = isDebug ? ".js" : ".min.js";
function getAppUrl(ext, name) {
  return `/js/${name}/index${ext}?v=${version3}`;
}
function getScriptUrl(name) {
  return getAppUrl(JS_EXT, name);
}

// src/createFetcher.ts
function createFetcher(enableWorkers = true) {
  let fallback = new FetchingService(new FetchingServiceImplXHR());
  if (false) {
    fallback = new FetchingServicePool({
      scriptPath: getWorkerUrl("fetcher")
    }, fallback);
  }
  return new Fetcher(fallback, !isDebug);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/URLBuilder.ts
function parsePort(portString) {
  if (isDefined(portString) && portString.length > 0) {
    return parseFloat(portString);
  }
  return null;
}
var URLBuilder = class {
  constructor(url2, base) {
    this._url = null;
    this._base = void 0;
    this._protocol = null;
    this._host = null;
    this._hostName = null;
    this._userName = null;
    this._password = null;
    this._port = null;
    this._pathName = null;
    this._hash = null;
    this._query = /* @__PURE__ */ new Map();
    if (url2 !== void 0) {
      this._url = new URL(url2, base);
      this.rehydrate();
    }
  }
  rehydrate() {
    if (isDefined(this._protocol) && this._protocol !== this._url.protocol) {
      this._url.protocol = this._protocol;
    }
    if (isDefined(this._host) && this._host !== this._url.host) {
      this._url.host = this._host;
    }
    if (isDefined(this._hostName) && this._hostName !== this._url.hostname) {
      this._url.hostname = this._hostName;
    }
    if (isDefined(this._userName) && this._userName !== this._url.username) {
      this._url.username = this._userName;
    }
    if (isDefined(this._password) && this._password !== this._url.password) {
      this._url.password = this._password;
    }
    if (isDefined(this._port) && this._port.toFixed(0) !== this._url.port) {
      this._url.port = this._port.toFixed(0);
    }
    if (isDefined(this._pathName) && this._pathName !== this._url.pathname) {
      this._url.pathname = this._pathName;
    }
    if (isDefined(this._hash) && this._hash !== this._url.hash) {
      this._url.hash = this._hash;
    }
    for (const [k, v] of this._query) {
      this._url.searchParams.set(k, v);
    }
    this._protocol = this._url.protocol;
    this._host = this._url.host;
    this._hostName = this._url.hostname;
    this._userName = this._url.username;
    this._password = this._url.password;
    this._port = parsePort(this._url.port);
    this._pathName = this._url.pathname;
    this._hash = this._url.hash;
    this._url.searchParams.forEach((v, k) => this._query.set(k, v));
  }
  refresh() {
    if (this._url === null) {
      if (isDefined(this._protocol) && (isDefined(this._host) || isDefined(this._hostName))) {
        if (isDefined(this._host)) {
          this._url = new URL(`${this._protocol}//${this._host}`, this._base);
          this._port = parsePort(this._url.port);
          this.rehydrate();
          return false;
        } else if (isDefined(this._hostName)) {
          this._url = new URL(`${this._protocol}//${this._hostName}`, this._base);
          this.rehydrate();
          return false;
        }
      } else if (isDefined(this._pathName) && isDefined(this._base)) {
        this._url = new URL(this._pathName, this._base);
        this.rehydrate();
        return false;
      }
    }
    return isDefined(this._url);
  }
  base(base) {
    if (this._url !== null) {
      throw new Error("Cannot redefine base after defining the protocol and domain");
    }
    this._base = base;
    this.refresh();
    return this;
  }
  protocol(protocol) {
    this._protocol = protocol;
    if (this.refresh()) {
      this._url.protocol = protocol;
    }
    return this;
  }
  host(host) {
    this._host = host;
    if (this.refresh()) {
      this._url.host = host;
      this._hostName = this._url.hostname;
      this._port = parsePort(this._url.port);
    }
    return this;
  }
  hostName(hostName) {
    this._hostName = hostName;
    if (this.refresh()) {
      this._url.hostname = hostName;
      this._host = `${this._url.hostname}:${this._url.port}`;
    }
    return this;
  }
  port(port) {
    this._port = port;
    if (this.refresh()) {
      this._url.port = port.toFixed(0);
      this._host = `${this._url.hostname}:${this._url.port}`;
    }
    return this;
  }
  userName(userName) {
    this._userName = userName;
    if (this.refresh()) {
      this._url.username = userName;
    }
    return this;
  }
  password(password) {
    this._password = password;
    if (this.refresh()) {
      this._url.password = password;
    }
    return this;
  }
  path(path) {
    this._pathName = path;
    if (this.refresh()) {
      this._url.pathname = path;
    }
    return this;
  }
  pathPop(pattern) {
    pattern = pattern || /\/[^/]+\/?$/;
    return this.path(this._pathName.replace(pattern, ""));
  }
  pathPush(part) {
    let path = this._pathName;
    if (!path.endsWith("/")) {
      path += "/";
    }
    path += part;
    return this.path(path);
  }
  query(name, value2) {
    this._query.set(name, value2);
    if (this.refresh()) {
      this._url.searchParams.set(name, value2);
    }
    return this;
  }
  hash(hash) {
    this._hash = hash;
    if (this.refresh()) {
      this._url.hash = hash;
    }
    return this;
  }
  toURL() {
    return this._url;
  }
  toString() {
    return this._url.href;
  }
  [Symbol.toStringTag]() {
    return this.toString();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/BaseNodeCluster.ts
var BaseNodeCluster = class extends BaseNode {
  constructor(type2, context2, inputs, endpoints, extras) {
    super(type2, context2);
    inputs = inputs || [];
    extras = extras || [];
    const exits = endpoints || inputs;
    this.inputs = inputs;
    const entries = inputs.filter(isIAudioNode).map((o) => o);
    this.outputs = exits.filter(isIAudioNode).map((o) => o);
    this.allNodes = Array.from(/* @__PURE__ */ new Set([
      ...entries,
      ...this.outputs,
      ...extras
    ]));
  }
  get exemplar() {
    return this.allNodes[0];
  }
  add(node) {
    this.allNodes.push(node);
    this.context._parent(this, node);
  }
  remove(node) {
    arrayRemove(this.allNodes, node);
    this.context._unparent(this, node);
  }
  onDisposing() {
    this.allNodes.forEach(dispose);
    super.onDisposing();
  }
  get channelCount() {
    return this.exemplar.channelCount;
  }
  set channelCount(v) {
    this.allNodes.forEach((n) => n.channelCount = v);
  }
  get channelCountMode() {
    return this.exemplar.channelCountMode;
  }
  set channelCountMode(v) {
    this.allNodes.forEach((n) => n.channelCountMode = v);
    ;
  }
  get channelInterpretation() {
    return this.exemplar.channelInterpretation;
  }
  set channelInterpretation(v) {
    this.allNodes.forEach((n) => n.channelInterpretation = v);
  }
  get numberOfInputs() {
    return this.inputs.length;
  }
  get numberOfOutputs() {
    return this.outputs.length;
  }
  static resolve(source, index) {
    index = index || 0;
    if (index < 0 || source.length <= index) {
      return null;
    }
    return source[index];
  }
  _resolveInput(input) {
    return {
      destination: BaseNodeCluster.resolve(this.inputs, input)
    };
  }
  _resolveOutput(output) {
    return {
      source: BaseNodeCluster.resolve(this.outputs, output)
    };
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/mat3.js
function create2() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add3,
  calculateW: () => calculateW,
  clone: () => clone3,
  conjugate: () => conjugate,
  copy: () => copy3,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues3,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity2,
  invert: () => invert,
  len: () => len2,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul2,
  multiply: () => multiply2,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random2,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  rotationTo: () => rotationTo,
  scale: () => scale3,
  set: () => set3,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen2,
  squaredLength: () => squaredLength3,
  str: () => str2
});

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale4) {
  out[0] = a[0] + b[0] * scale4;
  out[1] = a[1] + b[1] * scale4;
  out[2] = a[2] + b[2] * scale4;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len3 = x * x + y * y + z * z;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = a[0] * len3;
  out[1] = a[1] * len3;
  out[2] = a[2] * len3;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t2) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t2) {
  var factorTimes2 = t2 * t2;
  var factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  var factor2 = factorTimes2 * (t2 - 2) + t2;
  var factor3 = factorTimes2 * (t2 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t2) {
  var inverseFactor = 1 - t2;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t2 * t2;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t2 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t2;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale4) {
  scale4 = scale4 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale4;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale4;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec4.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues2(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set2(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len3 = x * x + y * y + z * z + w * w;
  if (len3 > 0) {
    len3 = 1 / Math.sqrt(len3);
  }
  out[0] = x * len3;
  out[1] = y * len3;
  out[2] = z * len3;
  out[3] = w * len3;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp2(out, a, b, t2) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  out[3] = aw + t2 * (b[3] - aw);
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply2(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX2(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY2(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ2(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t2 = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t2;
  out[1] = y * t2;
  out[2] = z * t2;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale3(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t2) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random2(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot4 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot4 ? 1 / dot4 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str2(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone3 = clone2;
var fromValues3 = fromValues2;
var copy3 = copy2;
var set3 = set2;
var add3 = add2;
var mul2 = multiply2;
var scale3 = scale2;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len2 = length3;
var squaredLength3 = squaredLength2;
var sqrLen2 = squaredLength3;
var normalize3 = normalize2;
var exactEquals3 = exactEquals2;
var equals3 = equals2;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a, b) {
    var dot4 = dot(a, b);
    if (dot4 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot4 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot4;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t2) {
    slerp(temp1, a, d, t2);
    slerp(temp2, b, c, t2);
    slerp(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes = function() {
  var matr = create2();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/listeners/BaseWebAudioListener.ts
var f = vec3_exports.create();
var u = vec3_exports.create();

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/Pose.ts
var Pose = class {
  /**
   * Creates a new position and orientation, at a given time.
   **/
  constructor() {
    this.p = vec3_exports.create();
    this.q = quat_exports.create();
    Object.seal(this);
  }
  /**
   * Sets the components of the pose.
   */
  set(px2, py, pz, qx, qy, qz, qw) {
    this.setPosition(px2, py, pz);
    this.setOrientation(qx, qy, qz, qw);
  }
  setPosition(px2, py, pz) {
    vec3_exports.set(this.p, px2, py, pz);
  }
  setOrientation(qx, qy, qz, qw) {
    quat_exports.set(this.q, qx, qy, qz, qw);
  }
  /**
   * Copies the components of another pose into this pose.
   */
  copy(other) {
    vec3_exports.copy(this.p, other.p);
    quat_exports.copy(this.q, other.q);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/BaseSpatializer.ts
var BaseSpatializer = class extends BaseNodeCluster {
  constructor(type2, context2, spatialized, input, output, nodes) {
    super(type2, context2, input, output, nodes);
    this.spatialized = spatialized;
    this._minDistance = 1;
    this._maxDistance = 10;
    this._algorithm = "inverse";
  }
  get minDistance() {
    return this._minDistance;
  }
  get maxDistance() {
    return this._maxDistance;
  }
  get algorithm() {
    return this._algorithm;
  }
  /**
   * Sets parameters that alter spatialization.
   **/
  setAudioProperties(minDistance, maxDistance, algorithm) {
    this._minDistance = minDistance;
    this._maxDistance = maxDistance;
    this._algorithm = algorithm;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/BaseWebAudioPanner.ts
var fwd = vec3_exports.create();

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/effects/RadioEffect.ts
var RadioEffectNode = class extends BaseNodeCluster {
  constructor(context2) {
    const filter = new JuniperBiquadFilterNode(context2, {
      type: "bandpass",
      frequency: 2500,
      Q: 4.5
    });
    const gain = new JuniperGainNode(context2, {
      gain: 10
    });
    filter.connect(gain);
    super("radio-effect", context2, [filter], [gain]);
  }
};
function RadioEffect(name, context2) {
  const node = new RadioEffectNode(context2);
  node.name = `${name}-radio-effect`;
  return node;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/effects/WallEffect.ts
function WallEffect(name, context2) {
  const node = new JuniperBiquadFilterNode(context2, {
    type: "bandpass",
    frequency: 400,
    Q: 4.5
  });
  node.name = `${name}-wall-effect`;
  return node;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/effects/index.ts
var effectStore = /* @__PURE__ */ new Map([
  ["Radio", RadioEffect],
  ["Wall", WallEffect]
]);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/BaseAudioSource.ts
var BaseAudioSource = class extends BaseNodeCluster {
  constructor(type2, context2, spatializer, effectNames, extras) {
    const volumeControl = new JuniperGainNode(context2);
    volumeControl.name = "volume-control";
    extras = extras || [];
    super(type2, context2, [], [spatializer], extras);
    this.spatializer = spatializer;
    this.effects = new Array();
    this.pose = new Pose();
    this.volumeControl = volumeControl;
    this.setEffects(...effectNames);
  }
  onDisposing() {
    arrayClear(this.effects);
    super.onDisposing();
  }
  setEffects(...effectNames) {
    this.disable();
    for (const effect of this.effects) {
      this.remove(effect);
      dispose(effect);
    }
    arrayClear(this.effects);
    let last = this.volumeControl;
    for (const effectName of effectNames) {
      if (isDefined(effectName)) {
        const createEffect = effectStore.get(effectName);
        if (isDefined(createEffect)) {
          const effect = createEffect(effectName, this.context);
          this.add(effect);
          this.effects.push(effect);
          last = last.connect(effect);
        }
      }
    }
    this.enable();
  }
  get spatialized() {
    return this.spatializer.spatialized;
  }
  get lastInternal() {
    return this.effects[this.effects.length - 1] || this.volumeControl;
  }
  enable() {
    if (!this.lastInternal.isConnected()) {
      this.lastInternal.connect(this.spatializer);
    }
  }
  disable() {
    if (this.lastInternal.isConnected()) {
      this.lastInternal.disconnect();
    }
  }
  tog() {
    if (this.lastInternal.isConnected()) {
      this.disable();
    } else {
      this.enable();
    }
  }
  get volume() {
    return this.volumeControl.gain.value;
  }
  set volume(v) {
    this.volumeControl.gain.value = v;
  }
  get minDistance() {
    if (isDefined(this.spatializer)) {
      return this.spatializer.minDistance;
    }
    return null;
  }
  get maxDistance() {
    if (isDefined(this.spatializer)) {
      return this.spatializer.maxDistance;
    }
    return null;
  }
  get algorithm() {
    if (isDefined(this.spatializer)) {
      return this.spatializer.algorithm;
    }
    return null;
  }
  setPosition(px2, py, pz) {
    if (isDefined(this.spatializer)) {
      this.pose.setPosition(px2, py, pz);
      this.spatializer.readPose(this.pose);
    }
  }
  setOrientation(qx, qy, qz, qw) {
    if (isDefined(this.spatializer)) {
      this.pose.setOrientation(qx, qy, qz, qw);
      this.spatializer.readPose(this.pose);
    }
  }
  set(px2, py, pz, qx, qy, qz, qw) {
    if (isDefined(this.spatializer)) {
      this.pose.set(px2, py, pz, qx, qy, qz, qw);
      this.spatializer.readPose(this.pose);
    }
  }
  setAudioProperties(minDistance, maxDistance, algorithm) {
    if (isDefined(this.spatializer)) {
      this.spatializer.setAudioProperties(minDistance, maxDistance, algorithm);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/IPlayable.ts
var MediaElementSourceEvent = class extends TypedEvent {
  constructor(type2, source) {
    super(type2);
    this.source = source;
  }
};
var MediaElementSourceLoadedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("loaded", source);
  }
};
var MediaElementSourcePlayedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("played", source);
  }
};
var MediaElementSourcePausedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("paused", source);
  }
};
var MediaElementSourceStoppedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("stopped", source);
  }
};
var MediaElementSourceProgressEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("progress", source);
    this.value = 0;
    this.total = 0;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/AudioElementSource.ts
var DISPOSING_EVT = new TypedEvent("disposing");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/NoSpatializer.ts
var NoSpatializer = class extends BaseSpatializer {
  constructor(node) {
    super("no-spatializer", node.context, false, [node], [node]);
  }
  readPose(_loc) {
  }
  getGainAtDistance(_) {
    return 1;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/SpeakerManager.ts
var canChangeAudioOutput = /* @__PURE__ */ isFunction(HTMLAudioElement.prototype.setSinkId);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/AudioManager.ts
var useHeadphonesToggledEvt = new TypedEvent("useheadphonestoggled");
var RELEASE_EVT = new TypedEvent("released");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/IPlayer.ts
var MediaPlayerEvent = class extends MediaElementSourceEvent {
  constructor(type2, source) {
    super(type2, source);
  }
};
var MediaPlayerLoadingEvent = class extends MediaPlayerEvent {
  constructor(source) {
    super("loading", source);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/AudioPlayer.ts
var AudioPlayer = class extends BaseAudioSource {
  constructor(context2, spatializer) {
    const mediaElement = Audio2(
      autoPlay(false),
      loop(false),
      controls(true)
    );
    const elementNode = new JuniperMediaElementAudioSourceNode(context2, {
      mediaElement
    });
    elementNode.name = "JuniperAudioPlayer-Input";
    super("audio-player", context2, spatializer, [], [elementNode]);
    this.cacheBustSources = /* @__PURE__ */ new Map();
    this._data = null;
    this._loaded = false;
    this.sourcesByURL = /* @__PURE__ */ new Map();
    this.sources = new Array();
    this.potatoes = new Array();
    elementNode.connect(this.volumeControl);
    this.element = mediaElement;
    this.loadingEvt = new MediaPlayerLoadingEvent(this);
    this.loadEvt = new MediaElementSourceLoadedEvent(this);
    this.playEvt = new MediaElementSourcePlayedEvent(this);
    this.pauseEvt = new MediaElementSourcePausedEvent(this);
    this.stopEvt = new MediaElementSourceStoppedEvent(this);
    this.progEvt = new MediaElementSourceProgressEvent(this);
    this.onPlay = async () => {
      this.enable();
      this.dispatchEvent(this.playEvt);
    };
    this.onPause = (evt) => {
      this.disable();
      if (this.element.currentTime === 0 || evt.type === "ended") {
        this.dispatchEvent(this.stopEvt);
      } else {
        this.dispatchEvent(this.pauseEvt);
      }
    };
    this.onTimeUpdate = async () => {
      this.progEvt.value = this.element.currentTime;
      this.progEvt.total = this.element.duration;
      this.dispatchEvent(this.progEvt);
    };
    this.onError = () => this.loadAudio();
    this.element.addEventListener("play", this.onPlay);
    this.element.addEventListener("pause", this.onPause);
    this.element.addEventListener("ended", this.onPause);
    this.element.addEventListener("error", this.onError);
    this.element.addEventListener("waiting", this.onWaiting);
    this.element.addEventListener("canplay", this.onCanPlay);
    this.element.addEventListener("timeupdate", this.onTimeUpdate);
    Object.assign(window, { audioPlayer: this });
  }
  get data() {
    return this._data;
  }
  get loaded() {
    return this._loaded;
  }
  get title() {
    return this.element.title;
  }
  setTitle(v) {
    this.element.title = v;
  }
  get hasAudio() {
    const source = this.sourcesByURL.get(this.element.src);
    return isDefined(source) && source.acodec !== "none" || isDefined(this.element.audioTracks) && this.element.audioTracks.length > 0 || isDefined(this.element.webkitAudioDecodedByteCount) && this.element.webkitAudioDecodedByteCount > 0 || isDefined(this.element.mozHasAudio) && this.element.mozHasAudio;
  }
  onDisposing() {
    super.onDisposing();
    this.clear();
    this.element.removeEventListener("play", this.onPlay);
    this.element.removeEventListener("pause", this.onPause);
    this.element.removeEventListener("ended", this.onPause);
    this.element.removeEventListener("error", this.onError);
    this.element.removeEventListener("waiting", this.onWaiting);
    this.element.removeEventListener("canplay", this.onCanPlay);
    this.element.removeEventListener("timeupdate", this.onTimeUpdate);
    this.element.dispatchEvent(RELEASE_EVT);
  }
  clear() {
    this.stop();
    this.sourcesByURL.clear();
    arrayClear(this.sources);
    arrayClear(this.potatoes);
    this.element.src = "";
    this._data = null;
    this._loaded = false;
  }
  cacheBust(data) {
    const curCount = this.cacheBustSources.get(data) || 0;
    this.cacheBustSources.set(data, curCount + 1);
  }
  async load(data, prog) {
    this.clear();
    this._data = data;
    if (isString(data)) {
      this.setTitle(data);
      this.potatoes.push(data);
    } else {
      this.setTitle(data.title);
      arraySortByKeyInPlace(data.audios, (f2) => -f2.resolution);
      arrayReplace(this.sources, ...data.audios);
    }
    for (const audio2 of this.sources) {
      this.sourcesByURL.set(audio2.url, audio2);
    }
    if (!this.hasSources) {
      throw new Error("No audio sources");
    }
    this.dispatchEvent(this.loadingEvt);
    await this.loadAudio(prog);
    if (!this.hasSources) {
      throw new Error("No audio sources");
    }
    this._loaded = true;
    this.dispatchEvent(this.loadEvt);
    return this;
  }
  async getMediaCapabilities(source) {
    const config = {
      type: "file",
      audio: {
        contentType: source.contentType,
        bitrate: source.abr * 1024,
        samplerate: source.asr
      }
    };
    try {
      return await navigator.mediaCapabilities.decodingInfo(config);
    } catch {
      return {
        supported: true,
        powerEfficient: false,
        smooth: false,
        configuration: config
      };
    }
  }
  get hasSources() {
    return this.sources.length > 0 || this.potatoes.length > 0;
  }
  async loadAudio(prog) {
    if (isDefined(prog)) {
      prog.start();
    }
    this.element.removeEventListener("error", this.onError);
    while (this.hasSources) {
      let url2 = null;
      const source = this.sources.shift();
      if (isDefined(source)) {
        const caps = await this.getMediaCapabilities(source);
        if (!caps.smooth || !caps.powerEfficient) {
          this.potatoes.push(source.url);
          continue;
        } else {
          url2 = source.url;
        }
      } else {
        url2 = this.potatoes.shift();
      }
      const cacheV = this.cacheBustSources.get(this.data);
      if (isDefined(cacheV)) {
        const uri = new URLBuilder(url2, location.href);
        uri.query("v", cacheV.toString());
        url2 = uri.toString();
      }
      this.element.src = url2;
      this.element.load();
      if (await mediaElementCanPlayThrough(this.element)) {
        if (isDefined(source)) {
          this.sources.unshift(source);
        } else {
          this.potatoes.unshift(url2);
        }
        this.element.addEventListener("error", this.onError);
        if (isDefined(prog)) {
          prog.end();
        }
        return;
      }
    }
  }
  get playbackState() {
    if (isNullOrUndefined(this.data)) {
      return "empty";
    }
    if (!this.loaded) {
      return "loading";
    }
    if (this.element.error) {
      return "errored";
    }
    if (this.element.ended || this.element.paused && this.element.currentTime === 0) {
      return "stopped";
    }
    if (this.element.paused) {
      return "paused";
    }
    return "playing";
  }
  async play() {
    await this.context.ready;
    await this.element.play();
  }
  async playThrough() {
    const endTask = once(this, "stopped");
    await this.play();
    await endTask;
  }
  pause() {
    this.element.pause();
  }
  stop() {
    this.pause();
    this.element.currentTime = 0;
  }
  restart() {
    this.stop();
    return this.play();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/math.ts
var Pi = Math.PI;
var HalfPi = 0.5 * Pi;
var Tau = 2 * Pi;
var TIME_MAX = 864e13;
var TIME_MIN = -TIME_MAX;
function clamp(v, min2, max2) {
  return Math.min(max2, Math.max(min2, v));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/PDFImage.ts
var import_pdfjs_dist = __toESM(require_pdf(), 1);

// ../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/package.json
var version4 = "2.16.105";

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/CanvasImage.ts
var CanvasImage = class extends TypedEventBase {
  constructor(width2, height, options) {
    super();
    this._scale = 250;
    this._visible = true;
    this.wasVisible = null;
    this.redrawnEvt = new TypedEvent("redrawn");
    this.element = null;
    if (isDefined(options)) {
      if (isDefined(options.scale)) {
        this._scale = options.scale;
      }
    }
    this._canvas = createUICanvas(width2, height);
    this._g = this.canvas.getContext("2d");
    if (isHTMLCanvas(this._canvas)) {
      this.element = this._canvas;
    }
  }
  fillRect(color, x, y, width2, height, margin2) {
    this.g.fillStyle = color;
    this.g.fillRect(x + margin2, y + margin2, width2 - 2 * margin2, height - 2 * margin2);
  }
  drawText(text2, x, y, align) {
    this.g.textAlign = align;
    this.g.strokeText(text2, x, y);
    this.g.fillText(text2, x, y);
  }
  redraw() {
    if ((this.visible || this.wasVisible) && this.onRedraw()) {
      this.wasVisible = this.visible;
      this.dispatchEvent(this.redrawnEvt);
    }
  }
  onClear() {
    this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  clear() {
    this.onClear();
    this.dispatchEvent(this.redrawnEvt);
  }
  get canvas() {
    return this._canvas;
  }
  get g() {
    return this._g;
  }
  get imageWidth() {
    return this.canvas.width;
  }
  get imageHeight() {
    return this.canvas.height;
  }
  get aspectRatio() {
    return this.imageWidth / this.imageHeight;
  }
  get width() {
    return this.imageWidth / this.scale;
  }
  get height() {
    return this.imageHeight / this.scale;
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    if (this.scale !== v) {
      this._scale = v;
      this.redraw();
    }
  }
  get visible() {
    return this._visible;
  }
  set visible(v) {
    if (this.visible !== v) {
      this.wasVisible = this._visible;
      this._visible = v;
      this.redraw();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/CancelToken.ts
var CancelSignalException = class extends Exception {
  constructor() {
    super("Cancellation!");
  }
};
var CancelToken = class {
  constructor() {
    this._cancelled = false;
  }
  get cancelled() {
    return this._cancelled;
  }
  check() {
    if (this.cancelled) {
      throw new CancelSignalException();
    }
  }
  cancel() {
    this._cancelled = true;
  }
  dispose() {
    throw new Error("Method not implemented.");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/PDFImage.ts
var pdfReady = singleton("Juniper:PdfReady", () => new Task(false));
var PDFImage = class extends CanvasImage {
  constructor(filePath, viewportParams) {
    super(1, 1);
    this.viewportParams = viewportParams;
    this.pdf = null;
    this._curPageIndex = null;
    this.ready = this.load(filePath);
  }
  static async prepare(workerPath, fetcher2, debug, tokenOrProg, prog) {
    let token = null;
    if (tokenOrProg instanceof CancelToken) {
      token = tokenOrProg;
    } else {
      prog = tokenOrProg;
    }
    token = token || new CancelToken();
    if (!pdfReady.started) {
      pdfReady.start();
      console.info(`PDF.js v${version4}`);
      const uri = new URLBuilder(workerPath, location.href);
      uri.query("v", version4);
      workerPath = uri.toString();
      import_pdfjs_dist.default.GlobalWorkerOptions.workerSrc = await fetcher2.get(workerPath).useCache(!debug).progress(prog).file().then(unwrapResponse);
      token.check();
      pdfReady.resolve();
    }
    await pdfReady;
    token.check();
  }
  get curPageIndex() {
    return this._curPageIndex;
  }
  get curPageNumber() {
    return this.curPageIndex + 1;
  }
  get canGoBack() {
    return this._curPageIndex > 0;
  }
  get canGoForward() {
    return this._curPageIndex < this.numPages - 1;
  }
  async load(filePath) {
    await pdfReady;
    const pdfTask = import_pdfjs_dist.default.getDocument(filePath);
    this.pdf = await pdfTask.promise;
    if (this.pdf.numPages === 0) {
      throw new Error("No pages found in PDF");
    }
  }
  async getPage(pageIndex) {
    await this.ready;
    pageIndex = clamp(pageIndex, 0, this.pdf.numPages - 1);
    if (pageIndex !== this._curPageIndex) {
      this._curPageIndex = pageIndex;
      const page = await this.pdf.getPage(pageIndex + 1);
      const viewport = page.getViewport(this.viewportParams);
      setContextSize(this.g, viewport.width, viewport.height);
      const renderTask = page.render({
        canvasContext: this.g,
        viewport,
        intent: "print"
      });
      await renderTask.promise;
      this.dispatchEvent(this.redrawnEvt);
    }
  }
  get numPages() {
    if (this.pdf) {
      return this.pdf.numPages;
    }
    return null;
  }
  onRedraw() {
    return false;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/db.ts
var MediaTypeDB = /* @__PURE__ */ singleton("Juniper:TSLib:MediaTypeDB", () => {
  const byExtension = /* @__PURE__ */ new Map();
  function guessByFileName(fileName) {
    if (!fileName) {
      console.warn("Couldn't guess media type. Must provide a valid fileName.");
      return [];
    }
    const idx = fileName.lastIndexOf(".");
    if (idx === -1) {
      console.warn("Couldn't guess media type. FileName has no extension.");
      return [];
    }
    let ext = fileName.substring(idx);
    if (!ext) {
      ext = "unknown";
    } else if (ext[0] == ".") {
      ext = ext.substring(1);
    }
    if (byExtension.has(ext)) {
      return byExtension.get(ext);
    } else {
      return [new MediaType("unknown", ext, [ext])];
    }
  }
  function normalizeFileType(fileName, fileType) {
    if (!fileType && fileName.indexOf(".") > -1) {
      const guesses = guessByFileName(fileName);
      if (guesses.length > 0) {
        fileType = guesses[0].value;
      }
    }
    return fileType;
  }
  function register(type2) {
    let isNew = false;
    const value2 = type2.__getValueUnsafe();
    type2 = singleton("Juniper.MediaTypes:" + value2, () => {
      isNew = true;
      return type2;
    });
    if (isNew) {
      for (const ext of type2.__getExtensionsUnsafe()) {
        if (!byExtension.has(ext)) {
          byExtension.set(ext, new Array());
        }
        const byExts = byExtension.get(ext);
        if (byExts.indexOf(type2) < 0) {
          byExts.push(type2);
        }
      }
    }
    return type2;
  }
  const db = {
    normalizeFileType
  };
  function regAll(values) {
    Object.values(values).forEach(register);
  }
  regAll(application_exports);
  regAll(audio_exports);
  regAll(chemical_exports);
  regAll(font_exports);
  regAll(image_exports);
  regAll(message_exports);
  regAll(model_exports);
  regAll(multipart_exports);
  regAll(text_exports);
  regAll(video_exports);
  regAll(xConference_exports);
  regAll(xShader_exports);
  return db;
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/blobToObjectURL.ts
function blobToObjectURL(obj) {
  return new URL(URL.createObjectURL(obj));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/units/fileSize.ts
var base2Labels = /* @__PURE__ */ new Map([
  [1, "KiB"],
  [2, "MiB"],
  [3, "GiB"],
  [4, "TiB"]
]);
var base10Labels = /* @__PURE__ */ new Map([
  [1, "KB"],
  [2, "MB"],
  [3, "GB"],
  [4, "TB"]
]);
var labels = /* @__PURE__ */ new Map([
  [2, base2Labels],
  [10, base10Labels]
]);
function formatBytes(value2, base = 10) {
  const isNegative = value2 < 0;
  value2 = Math.abs(value2);
  const systemBase = base === 2 ? 1024 : 1e3;
  let size = Math.min(4, Math.floor(Math.log(value2) / Math.log(systemBase)));
  let divisor = Math.pow(systemBase, size);
  if (2 * value2 >= systemBase * divisor && size < 4) {
    size++;
    divisor *= systemBase;
  }
  let label;
  if (size === 0) {
    label = "B";
  } else {
    const levels = labels.get(base);
    label = levels.get(size);
    value2 /= divisor;
  }
  const isExact = value2 % 1 === 0;
  const str3 = `${isNegative ? "-" : ""}${value2.toFixed(isExact ? 0 : 2)} ${label}`;
  return str3;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/data.ts
function isVideoRecord(obj) {
  return isString(obj.vcodec);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/BaseVideoPlayer.ts
var BaseVideoPlayer = class extends BaseAudioSource {
  constructor(type2, context2, spatializer) {
    const video2 = BaseVideoPlayer.createMediaElement(Video, controls(true));
    const audio2 = BaseVideoPlayer.createMediaElement(Audio2, controls(false));
    const videoNode = new JuniperMediaElementAudioSourceNode(
      context2,
      {
        mediaElement: video2
      }
    );
    videoNode.name = `${type2}-video`;
    const audioNode = new JuniperMediaElementAudioSourceNode(
      context2,
      {
        mediaElement: audio2
      }
    );
    audioNode.name = `${type2}-audio`;
    super(type2, context2, spatializer, [], [videoNode, audioNode]);
    this.onTimeUpdate = null;
    this.wasUsingAudioElement = false;
    this.nextStartTime = null;
    this._data = null;
    this._loaded = false;
    this.onError = /* @__PURE__ */ new Map();
    this.sourcesByURL = /* @__PURE__ */ new Map();
    this.sources = new PriorityList();
    this.potatoes = new PriorityList();
    videoNode.connect(this.volumeControl);
    audioNode.connect(this.volumeControl);
    this.video = video2;
    this.audio = audio2;
    this.loadingEvt = new MediaPlayerLoadingEvent(this);
    this.loadEvt = new MediaElementSourceLoadedEvent(this);
    this.playEvt = new MediaElementSourcePlayedEvent(this);
    this.pauseEvt = new MediaElementSourcePausedEvent(this);
    this.stopEvt = new MediaElementSourceStoppedEvent(this);
    this.progEvt = new MediaElementSourceProgressEvent(this);
    this.onSeeked = () => {
      if (this.useAudioElement) {
        this.audio.currentTime = this.video.currentTime;
      }
    };
    this.onPlay = async () => {
      this.onSeeked();
      if (this.useAudioElement) {
        await this.context.ready;
        await this.audio.play();
      }
      this.dispatchEvent(this.playEvt);
    };
    this.onPause = (evt) => {
      if (this.useAudioElement) {
        this.onSeeked();
        this.audio.pause();
      }
      if (this.video.currentTime === 0 || evt.type === "ended") {
        this.dispatchEvent(this.stopEvt);
      } else {
        this.dispatchEvent(this.pauseEvt);
      }
    };
    let wasWaiting = false;
    this.onWaiting = () => {
      if (this.useAudioElement) {
        wasWaiting = true;
        this.audio.pause();
      }
    };
    this.onCanPlay = async () => {
      if (this.useAudioElement && wasWaiting) {
        await this.context.ready;
        await this.audio.play();
        wasWaiting = false;
      }
    };
    this.wasUsingAudioElement = false;
    this.onTimeUpdate = async () => {
      const quality = this.video.getVideoPlaybackQuality();
      if (quality.totalVideoFrames === 0) {
        const onError = this.onError.get(this.video);
        if (isDefined(onError)) {
          await onError();
        }
      } else if (this.useAudioElement) {
        this.wasUsingAudioElement = false;
        const delta = this.video.currentTime - this.audio.currentTime;
        if (Math.abs(delta) > 0.25) {
          this.audio.currentTime = this.video.currentTime;
        }
      } else if (!this.wasUsingAudioElement) {
        this.wasUsingAudioElement = true;
        this.audio.pause();
      }
      this.progEvt.value = this.video.currentTime;
      this.progEvt.total = this.video.duration;
      this.dispatchEvent(this.progEvt);
    };
    this.video.addEventListener("seeked", this.onSeeked);
    this.video.addEventListener("play", this.onPlay);
    this.video.addEventListener("pause", this.onPause);
    this.video.addEventListener("ended", this.onPause);
    this.video.addEventListener("waiting", this.onWaiting);
    this.video.addEventListener("canplay", this.onCanPlay);
    this.video.addEventListener("timeupdate", this.onTimeUpdate);
    Object.assign(window, { videoPlayer: this });
  }
  get data() {
    return this._data;
  }
  get loaded() {
    return this._loaded;
  }
  get title() {
    return this.video.title;
  }
  setTitle(v) {
    this.video.title = v;
    this.audio.title = v;
  }
  elementHasAudio(elem) {
    const source = this.sourcesByURL.get(elem.src);
    return isDefined(source) && source.acodec !== "none" || isDefined(elem.audioTracks) && elem.audioTracks.length > 0 || isDefined(elem.webkitAudioDecodedByteCount) && elem.webkitAudioDecodedByteCount > 0 || isDefined(elem.mozHasAudio) && elem.mozHasAudio;
  }
  get useAudioElement() {
    return !this.elementHasAudio(this.video) && this.elementHasAudio(this.audio);
  }
  onDisposing() {
    this.clear();
    this.video.removeEventListener("seeked", this.onSeeked);
    this.video.removeEventListener("play", this.onPlay);
    this.video.removeEventListener("pause", this.onPause);
    this.video.removeEventListener("ended", this.onPause);
    this.video.removeEventListener("waiting", this.onWaiting);
    this.video.removeEventListener("canplay", this.onCanPlay);
    this.video.removeEventListener("timeupdate", this.onTimeUpdate);
    super.onDisposing();
    this.audio.dispatchEvent(RELEASE_EVT);
    this.video.dispatchEvent(RELEASE_EVT);
  }
  clear() {
    this.stop();
    for (const [elem, onError] of this.onError) {
      elem.removeEventListener("error", onError);
    }
    this.onError.clear();
    this.sourcesByURL.clear();
    this.sources.clear();
    this.potatoes.clear();
    this.video.src = "";
    this.audio.src = "";
    this.wasUsingAudioElement = false;
    this._data = null;
    this._loaded = false;
  }
  async load(data, prog) {
    this.clear();
    this._data = data;
    if (isString(data)) {
      this.setTitle(data);
      this.potatoes.add(this.video, data);
    } else {
      this.setTitle(data.title);
      this.fillSources(this.video, data.videos);
      this.fillSources(this.audio, data.audios);
    }
    if (!this.hasSources(this.video)) {
      throw new Error("No video sources found");
    }
    this.dispatchEvent(this.loadingEvt);
    await progressTasks(
      prog,
      (prog2) => this.loadMediaElement(this.audio, prog2),
      (prog2) => this.loadMediaElement(this.video, prog2)
    );
    if (isString(data)) {
      this.nextStartTime = null;
    } else {
      this.nextStartTime = data.startTime;
    }
    if (!this.hasSources(this.video)) {
      throw new Error("No video playable sources");
    }
    this._loaded = true;
    this.dispatchEvent(this.loadEvt);
    return this;
  }
  fillSources(elem, formats) {
    arraySortByKeyInPlace(formats, (f2) => -f2.resolution);
    for (const format of formats) {
      if (!Video_Vendor_Mpeg_Dash_Mpd.matches(format.contentType)) {
        this.sources.add(elem, format);
        this.sourcesByURL.set(format.url, format);
      }
    }
  }
  static createMediaElement(MediaElement, ...rest) {
    return MediaElement(
      autoPlay(false),
      loop(false),
      ...rest
    );
  }
  async getMediaCapabilities(source) {
    const config = {
      type: "file"
    };
    if (isVideoRecord(source)) {
      config.video = {
        contentType: source.contentType,
        bitrate: source.vbr * 1024,
        framerate: source.fps,
        width: source.width,
        height: source.height
      };
    } else if (source.acodec !== "none") {
      config.audio = {
        contentType: source.contentType,
        bitrate: source.abr * 1024,
        samplerate: source.asr
      };
    }
    try {
      return await navigator.mediaCapabilities.decodingInfo(config);
    } catch {
      return {
        supported: true,
        powerEfficient: false,
        smooth: false,
        configuration: config
      };
    }
  }
  hasSources(elem) {
    return this.sources.get(elem).length > 0 || this.potatoes.count(elem) > 0;
  }
  async loadMediaElement(elem, prog) {
    if (isDefined(prog)) {
      prog.start();
    }
    if (this.onError.has(elem)) {
      elem.removeEventListener("error", this.onError.get(elem));
      this.onError.delete(elem);
    }
    while (this.hasSources(elem)) {
      let url2 = null;
      const source = this.sources.get(elem).shift();
      if (isDefined(source)) {
        const caps = await this.getMediaCapabilities(source);
        if (!caps.smooth || !caps.powerEfficient) {
          this.potatoes.add(elem, source.url);
          continue;
        } else {
          url2 = source.url;
        }
      } else {
        url2 = this.potatoes.get(elem).shift();
      }
      elem.src = url2;
      elem.load();
      if (await mediaElementCanPlayThrough(elem)) {
        if (isDefined(source)) {
          this.sources.get(elem).unshift(source);
        } else {
          this.potatoes.get(elem).unshift(url2);
        }
        const onError = () => this.loadMediaElement(elem, prog);
        elem.addEventListener("error", onError);
        this.onError.set(elem, onError);
        this.wasUsingAudioElement = this.wasUsingAudioElement;
        if (isDefined(prog)) {
          prog.end();
        }
        return;
      }
    }
  }
  get width() {
    return this.video.videoWidth;
  }
  get height() {
    return this.video.videoHeight;
  }
  get playbackState() {
    if (isNullOrUndefined(this.data)) {
      return "empty";
    }
    if (!this.loaded) {
      return "loading";
    }
    if (this.video.error) {
      return "errored";
    }
    if (this.video.ended || this.video.paused && this.video.currentTime === 0) {
      return "stopped";
    }
    if (this.video.paused) {
      return "paused";
    }
    return "playing";
  }
  async play() {
    await this.context.ready;
    if (isDefined(this.nextStartTime) && this.nextStartTime > 0) {
      this.video.pause();
      this.video.currentTime = this.nextStartTime;
      this.nextStartTime = null;
    }
    await this.video.play();
  }
  async playThrough() {
    const endTask = once(this, "stopped");
    await this.play();
    await endTask;
  }
  pause() {
    this.video.pause();
  }
  stop() {
    this.pause();
    this.video.currentTime = 0;
  }
  restart() {
    this.stop();
    return this.play();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/VideoPlayer.ts
var loadingCursor = "wait";
var loadedCursor = "pointer";
var errorCursor = "not-allowed";
var VideoPlayer = class extends BaseVideoPlayer {
  constructor(context2, spatializer) {
    super("video-player", context2, spatializer);
    this.element = Div(
      display("inline-block"),
      this.thumbnail = Img(cursor(loadingCursor)),
      this.video,
      this.audio
    );
    this.thumbnail.addEventListener("click", () => {
      if (this.loaded) {
        this.play();
      }
    });
    this.addEventListener("played", () => this.showVideo(true));
    this.addEventListener("stopped", () => this.showVideo(false));
    this.showVideo(false);
  }
  onDisposing() {
    super.onDisposing();
    if (isDefined(this.element.parentElement)) {
      this.element.remove();
    }
  }
  showVideo(v) {
    elementSetDisplay(this.video, v, "inline-block");
    elementSetDisplay(this.thumbnail, !v, "inline-block");
  }
  async load(data, prog) {
    try {
      elementApply(
        this.thumbnail,
        opacity(0.5),
        cursor(loadingCursor)
      );
      const progs = progressSplitWeighted(prog, [1, 10]);
      await all(
        super.load(data, progs.shift()),
        this.loadThumbnail(data, progs.shift())
      );
      return this;
    } finally {
      elementApply(
        this.thumbnail,
        opacity(1),
        cursor(this.loaded ? loadedCursor : errorCursor)
      );
    }
  }
  clear() {
    super.clear();
    this.thumbnail.src = "";
  }
  setTitle(v) {
    super.setTitle(v);
    this.thumbnail.title = v;
  }
  async loadThumbnail(data, prog) {
    prog.start();
    if (isDefined(data)) {
      elementApply(
        this.thumbnail,
        src(data.thumbnail.url),
        opacity(0.5)
      );
      const loading = once(this.thumbnail, "load", "error");
      await success(loading);
    }
    prog.end();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/YouTubeProxy.ts
function isYouTube(url2) {
  return url2.hostname === "www.youtube.com" || url2.hostname === "youtube.com" || url2.hostname === "youtu.be";
}
var codecReplaces = /* @__PURE__ */ new Map([
  ["vp9", "vp09.00.10.08"]
]);
function classifyFormat(f2) {
  if (isNullOrUndefined(f2.vcodec) || f2.vcodec === "none") {
    return "audio";
  }
  return "video";
}
function combineContentTypeAndCodec(content_type, codec) {
  const parts = [content_type];
  if (isDefined(codec) && codec.length > 0 && codec !== "none") {
    codec = codecReplaces.get(codec) || codec;
  }
  if (isDefined(codec) && codec.length > 0 && codec !== "none") {
    const asterisk = encodeURI(codec) !== codec ? "*" : "";
    parts.push(`codecs${asterisk}="${codec}"`);
  }
  return parts.join(";");
}
var YouTubeProxy = class {
  constructor(fetcher2, makeProxyURL2) {
    this.fetcher = fetcher2;
    this.makeProxyURL = makeProxyURL2;
  }
  makeVideoRecord(f2) {
    const { content_type, acodec, vcodec } = f2;
    const fullContentType = combineContentTypeAndCodec(content_type, vcodec);
    return {
      contentType: fullContentType,
      url: this.makeProxyURL(f2.url).href,
      acodec,
      abr: f2.abr * 1024,
      asr: f2.asr,
      vcodec,
      vbr: f2.vbr * 1024,
      fps: f2.fps,
      width: f2.width,
      height: f2.height,
      resolution: f2.width * f2.height
    };
  }
  makeAudioRecord(f2) {
    const { content_type, acodec } = f2;
    const fullContentType = combineContentTypeAndCodec(content_type, acodec);
    return {
      contentType: fullContentType,
      url: this.makeProxyURL(f2.url).href,
      acodec,
      abr: f2.abr * 1024,
      asr: f2.asr,
      resolution: f2.abr
    };
  }
  makeImageRecord(f2) {
    const { content_type, url: url2, width: width2, height } = f2;
    return {
      contentType: content_type,
      url: this.makeProxyURL(url2).href,
      width: width2,
      height,
      resolution: width2 * height
    };
  }
  async loadData(pageURLOrMetadata, prog) {
    if (isNullOrUndefined(pageURLOrMetadata)) {
      throw new Error("must provide a YouTube URL or a YTMetadata object");
    }
    if (isDefined(prog)) {
      prog.start();
    }
    let metadata = null;
    if (isString(pageURLOrMetadata)) {
      metadata = await this.fetcher.get(pageURLOrMetadata).progress(prog).object().then(unwrapResponse);
    } else {
      if (isDefined(prog)) {
        prog.end(pageURLOrMetadata.title);
      }
      metadata = pageURLOrMetadata;
    }
    let startTime = 0;
    if (isDefined(metadata.original_url)) {
      const url2 = new URL(metadata.original_url);
      if (isYouTube(url2) && url2.searchParams.has("t")) {
        startTime = parseFloat(url2.searchParams.get("t"));
      }
    }
    const formats = new PriorityList((await Promise.all(metadata.formats)).map((f2) => [classifyFormat(f2), f2]));
    const title2 = metadata.title;
    const thumbnails = metadata.thumbnails || [];
    const thumbnail = metadata.thumbnail && this.makeImageRecord(arrayScan(thumbnails, (t2) => t2.url === metadata.thumbnail));
    const videos = formats.get("video").map((f2) => this.makeVideoRecord(f2));
    const audios = formats.get("audio").map((f2) => this.makeAudioRecord(f2));
    const data = {
      title: title2,
      thumbnail,
      videos,
      audios,
      startTime
    };
    return data;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/registerThumbnails.ts
function showThumbnail(elem, isPhotosphere) {
  elementSetDisplay(thumbnailView, true, "block");
  elementSetDisplay(thumbnailImage, !isPhotosphere, "block");
  elementSetDisplay(thumbnailIFrame, isPhotosphere, "block");
  const match = elem.src.match(/\/file\/(\d+)$/);
  if (isPhotosphere && match) {
    const id2 = parseInt(match[1], 10);
    thumbnailIFrame.src = `/Editor/PhotosphereViewer?FileID=${id2}`;
  } else {
    thumbnailImage.src = elem.src;
  }
}
function hideThumbnail() {
  thumbnailView.style.display = "none";
}
var existing = /* @__PURE__ */ new WeakSet();
function registerThumbnails() {
  const thumbnails = Array.from(document.querySelectorAll(".thumbnail"));
  for (const thumbnail of thumbnails) {
    if (!existing.has(thumbnail)) {
      thumbnail.addEventListener("click", () => showThumbnail(thumbnail, thumbnail.classList.contains("photosphere")));
      existing.add(thumbnail);
    }
  }
}
var thumbnailViewerID = "33D0371F-B096-473D-AEE3-B17F5392CCEC";
var thumbnailView = document.getElementById(thumbnailViewerID);
if (!thumbnailView) {
  thumbnailView = Div(
    id(thumbnailViewerID),
    className("thumbnail-view"),
    display("none"),
    Img(title("Thumbnail")),
    IFrame(title("Preview"))
  );
}
var thumbnailImage = thumbnailView.querySelector("img");
var thumbnailIFrame = thumbnailView.querySelector("iframe");
if (!thumbnailView.parentElement) {
  elementApply(document.body, thumbnailView);
  thumbnailView.addEventListener("pointerleave", hideThumbnail);
  thumbnailView.addEventListener("click", hideThumbnail);
}

// src/vr-apps/yarrow/data.ts
var Video_Vnd_DlsDc_YtDlp_Json = /* @__PURE__ */ specialize("video")("vnd.dlsdc.ytdlp+json", "ytdlp.json", "ytdlp", "json");
var Image_Vendor_Google_StreetView_Pano = (
  /*@__PURE_*/
  specialize("image")("vnd.google.streetview.pano")
);

// src/vr-apps/yarrow/proxy.ts
function resolveURL(url2) {
  if (isNullOrUndefined(url2)) {
    return null;
  }
  if (isString(url2)) {
    url2 = new URL(url2, location.href);
  }
  return url2;
}
function stripParameters(url2) {
  if (isNullOrUndefined(url2)) {
    throw new Error("URL is undefined");
  }
  url2 = resolveURL(url2);
  if (isYouTube(url2)) {
    const toRemove = Array.from(url2.searchParams.keys()).filter((key) => key !== "v" && key !== "t");
    for (const key of toRemove) {
      url2.searchParams.delete(key);
    }
  }
  return url2;
}
function makeProxyURL(url2) {
  url2 = resolveURL(url2);
  if (isNullOrUndefined(url2)) {
    throw new Error("URL is undefined");
  }
  url2 = stripParameters(url2);
  return new URLBuilder("/vr/link", location.href).query("q", url2.href).toURL();
}

// src/file-picker/FilePreviewer.ts
var anyAudio = create("audio", "*");
var anyImage = create("image", "*");
var anyText = create("text", "*");
var anyVideo = create("video", "*");
var FilePreviewer = class {
  constructor(element, fetcher2, audioSys) {
    this.element = element;
    this.fetcher = fetcher2;
    this.audioSys = audioSys;
    PDFImage.prepare(getScriptUrl("pdfjs"), fetcher2, true);
    this.yt = new YouTubeProxy(this.fetcher, makeProxyURL);
    let context2 = this.audioSys;
    if (context2 instanceof JuniperAudioContext) {
      const no = new NoSpatializer(context2.destination);
      this.vid = new VideoPlayer(context2, no);
      this.aud = new AudioPlayer(context2, no);
    } else {
      this.vid = new VideoPlayer(context2.audio.context, context2.audio.noSpatializer);
      this.aud = context2.audioPlayer;
      context2 = context2.audio.context;
    }
    const json = this.element.dataset.json;
    if (isDefined(json)) {
      const fileData = JSON.parse(json);
      this.setFile(fileData, ...fileData.tagsString.split(",").map((v) => v.trim().toLowerCase()));
    }
  }
  get hasFile() {
    return this._hasFile;
  }
  showLoading() {
    this.setElement(Div("Loading"), "Loading", "Loading", null);
  }
  async setFile(file, ...classes) {
    this.showLoading();
    let path = null;
    let type2 = null;
    let name = null;
    let size = null;
    let metadata = null;
    if (file instanceof URL) {
      const response = await this.fetcher.get(makeProxyURL(file)).file();
      path = response.content;
      name = response.fileName ?? file.href;
      type2 = response.contentType;
      size = response.contentLength;
    } else if (file instanceof File) {
      path = URL.createObjectURL(file);
      name = file.name;
      type2 = file.type;
      size = file.size;
    } else {
      path = file.filePath;
      name = file.name;
      type2 = file.mediaType;
      size = file.size;
      metadata = file.metadata;
    }
    if (isNullOrUndefined(type2) || type2.length === 0) {
      type2 = MediaTypeDB.normalizeFileType(name, type2);
    }
    let element = null;
    if (Video_Vnd_DlsDc_YtDlp_Json.matches(type2)) {
      const data = await this.yt.loadData(metadata || path);
      if (isNullOrUndefined(data.videos) || data.videos.length === 0) {
        element = await this.aud.load(data);
      } else {
        element = await this.vid.load(data);
      }
    } else if (Text_Html.matches(type2) || Application_X_Url.matches(type2)) {
      element = this.makeIFrame(path);
    } else if (Application_Pdf.matches(type2)) {
      element = await this.makePDF(path);
    } else if (anyAudio.matches(type2)) {
      element = this.makeAudio(path);
    } else if (anyVideo.matches(type2)) {
      element = this.makeVideo(path);
    } else if (anyImage.matches(type2)) {
      element = this.makeImage(path);
    } else if (anyText.matches(type2) || Application_Json.matches(type2) || Application_Javascript.matches(type2)) {
      element = await this.makeText(path);
    } else {
      element = await this.makeUnknown(path);
    }
    this.setElement(element, type2, name, size, ...classes);
  }
  clear() {
    elementClearChildren(this);
    this._hasFile = false;
  }
  makeAudio(path) {
    return Audio2(controls(true), src(path));
  }
  makeVideo(path) {
    return Video(controls(true), src(path));
  }
  async makeText(path) {
    const txt = await this.fetcher.get(path).text().then(unwrapResponse);
    return TextArea(txt);
  }
  async makePDF(path) {
    const pdf = new PDFImage(path, {
      scale: 72 / 50
    });
    await pdf.getPage(0);
    const canvBlob = await canvasToBlob(pdf.canvas, Image_Png);
    const canvURL = blobToObjectURL(canvBlob);
    return Img(
      classList(
        "thumbnail",
        "image"
      ),
      src(canvURL)
    );
  }
  makeImage(path) {
    return Img(
      classList(
        "thumbnail",
        "image"
      ),
      src(path)
    );
  }
  makeUnknown(path) {
    return Div(`Cannot preview file at path: ${path}`);
  }
  makeIFrame(path) {
    return IFrame(src(path));
  }
  setElement(element, type2, name, size, ...classes) {
    element = resolveElement(element);
    this._hasFile = element.tagName !== "DIV";
    elementClearChildren(this);
    elementApply(
      this,
      H2(name),
      Div(size && `${type2}: ${formatBytes(size)}` || ""),
      elementApply(
        element,
        classList(...classes)
      )
    );
    if (element.tagName === "IMG" || element.tagName === "CANVAS") {
      registerThumbnails();
    }
  }
};

// src/file-picker/TagPicker.ts
var TagPickerTagsChangedEvent = class extends TypedEvent {
  constructor(tags) {
    super("tagschanged");
    this.tags = tags;
  }
};
var fullWidth = width(perc(100));
var TagPicker = class extends TypedEventBase {
  constructor(newTagNameOrExistingTagsID, addTagButton, removeTagButton, tagsList) {
    super();
    this._tags = new Array();
    this.element = Div(
      display("grid"),
      gridAutoFlow("row"),
      width(em(10))
    );
    if (isString(newTagNameOrExistingTagsID)) {
      this.newTagName = InputText(
        id("newTagName"),
        list(newTagNameOrExistingTagsID),
        fullWidth
      );
      this.addTagButton = ButtonPrimary(
        id("addTagButton"),
        fullWidth,
        "Add"
      );
      this.removeTagButton = ButtonDanger(
        id("removeTagButton"),
        fullWidth,
        "Remove"
      );
      this.tagsList = Select(
        id("tagsList"),
        multiple(true),
        fullWidth
      );
    } else {
      this.newTagName = newTagNameOrExistingTagsID;
      this.addTagButton = addTagButton;
      this.removeTagButton = removeTagButton;
      this.tagsList = tagsList;
      this.newTagName.replaceWith(this.element);
    }
    elementApply(
      this.element,
      this.newTagName,
      this.addTagButton,
      this.tagsList,
      this.removeTagButton
    );
    this.addTagButton.disabled = true;
    this.removeTagButton.disabled = true;
    this.newTagName.addEventListener("input", () => {
      this.addTagButton.disabled = this.newTagName.value.length === 0;
    });
    const addTag = () => {
      if (this.newTagName.value.length > 0) {
        this.updateTags(this.newTagName.value.toLocaleLowerCase(), null);
      }
    };
    this.addTagButton.addEventListener("click", addTag);
    this.newTagName.addEventListener("keydown", makeEnterKeyEventHandler(addTag));
    this.tagsList.addEventListener("input", () => {
      this.removeTagButton.disabled = this.tagsList.selectedIndex === -1;
    });
    this.removeTagButton.addEventListener("click", () => {
      if (this.tagsList.selectedIndex > -1) {
        const tag2 = this.tagsList.selectedOptions[0].value;
        this.updateTags(null, tag2);
      }
    });
  }
  updateTags(newTag, oldTag) {
    const tags = new Array();
    if (newTag !== null) {
      newTag = newTag.trim().toLocaleLowerCase();
      if (newTag.length > 0) {
        arraySortedInsert(tags, newTag, false);
      }
    }
    for (let i = 0; i < this.tagsList.options.length; ++i) {
      const tag2 = this.tagsList.options[i].value;
      if (tag2 !== oldTag) {
        arraySortedInsert(tags, tag2, false);
      }
    }
    this.tags = tags;
    this.dispatchEvent(new TagPickerTagsChangedEvent(tags));
  }
  get tags() {
    return this._tags;
  }
  set tags(tags) {
    arrayReplace(this._tags, ...tags);
    this._tags.sort();
    elementClearChildren(this.tagsList);
    this.tagsList.append(...tags.map((t2) => Option(value(t2), t2)));
    this.newTagName.value = "";
    this.addTagButton.disabled = this.removeTagButton.disabled = true;
  }
};

// src/dom-apps/file-detail/index.ts
var fetcher = createFetcher(false);
var tagPicker = new TagPicker(
  getInput("#newTagName"),
  getButton("#addTagButton"),
  getButton("#removeTagButton"),
  getSelect("#tagsList")
);
var context = new JuniperAudioContext();
var thumbnailFile = new FileUploadInput(
  "Replace file",
  "danger",
  getInput("#formFile")
);
var preview = new FilePreviewer(
  getElement("#filePreview"),
  fetcher,
  context
);
var confirmUpdate = getElement("#confirmUpdate");
tagPicker.addEventListener("tagschanged", async (evt) => {
  const tagString = evt.tags.join(",");
  await fetcher.post(location.pathname).query("handler", "Tag").body(tagString, Application_JsonUTF8).exec();
  tagPicker.tags = evt.tags;
});
thumbnailFile.addEventListener("input", async (evt) => {
  if (evt.files.length > 0) {
    await preview.setFile(evt.files[0], ...tagPicker.tags);
  }
  confirmUpdate.style.display = preview.hasFile ? "block" : "none";
});
//# sourceMappingURL=index.js.map
