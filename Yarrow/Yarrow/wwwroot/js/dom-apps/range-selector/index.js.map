{
  "version": 3,
  "sources": ["../../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/src/typeChecks.ts", "../../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/arrays.ts", "../../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/src/PriorityList.ts", "../../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/events/src/Task.ts", "../../../../../../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/src/tags.ts", "../../../../src/dom-apps/range-selector/index.ts"],
  "sourcesContent": ["function t(o: any, s: string, c: Function) {\r\n    return typeof o === s\r\n        || o instanceof c;\r\n}\r\n\r\nexport function isFunction(obj: any): obj is Function {\r\n    return t(obj, \"function\", Function);\r\n}\r\n\r\nexport function isString(obj: any): obj is string {\r\n    return t(obj, \"string\", String);\r\n}\r\n\r\nexport function isBoolean(obj: any): obj is boolean {\r\n    return t(obj, \"boolean\", Boolean);\r\n}\r\n\r\nexport function isNumber(obj: any): obj is number {\r\n    return t(obj, \"number\", Number);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is the special NaN value or one of the Infinities.\r\n */\r\nexport function isBadNumber(num: number): boolean {\r\n    return isNullOrUndefined(num)\r\n        || !Number.isFinite(num)\r\n        || Number.isNaN(num);\r\n}\r\n\r\n/**\r\n * Check a value to see if it is of a number type\r\n * and is not the special NaN value nor one of the Infinities.\r\n */\r\nexport function isGoodNumber(obj: any): obj is number {\r\n    return isNumber(obj)\r\n        && !isBadNumber(obj);\r\n}\r\n\r\nexport function isObject(obj: any): obj is object {\r\n    return isDefined(obj)\r\n        && t(obj, \"object\", Object);\r\n}\r\n\r\nexport function isPromise<T>(obj: any): obj is Promise<T> {\r\n    return obj instanceof Promise;\r\n}\r\n\r\nexport function isDate(obj: any): obj is Date {\r\n    return obj instanceof Date;\r\n}\r\n\r\nexport function isArray(obj: any): obj is Array<any> {\r\n    return obj instanceof Array;\r\n}\r\n\r\nexport function assertNever(x: never, msg?: string): never {\r\n    throw new Error((msg || \"Unexpected object: \") + x);\r\n}\r\n\r\nexport function isNullOrUndefined<T>(obj: T | null | undefined): obj is null | undefined {\r\n    return obj === null\r\n        || obj === undefined;\r\n}\r\n\r\nexport function isDefined<T>(obj: T | null | undefined): obj is T {\r\n    return !isNullOrUndefined(obj);\r\n}\r\n\r\nexport function isEventListener(obj: EventListenerOrEventListenerObject): obj is EventListener {\r\n    return isFunction(obj);\r\n}\r\n\r\nexport function isEventListenerObject(obj: EventListenerOrEventListenerObject): obj is EventListenerObject {\r\n    return !isEventListener(obj);\r\n}\r\n\r\nexport function isArrayBufferView(obj: any): obj is ArrayBufferView {\r\n    return obj instanceof Uint8Array\r\n        || obj instanceof Uint8ClampedArray\r\n        || obj instanceof Int8Array\r\n        || obj instanceof Uint16Array\r\n        || obj instanceof Int16Array\r\n        || obj instanceof Uint32Array\r\n        || obj instanceof Int32Array\r\n        || obj instanceof Float32Array\r\n        || obj instanceof Float64Array\r\n        || \"BigUint64Array\" in globalThis && obj instanceof globalThis[\"BigUint64Array\"]\r\n        || \"BigInt64Array\" in globalThis && obj instanceof globalThis[\"BigInt64Array\"];\r\n}\r\n\r\nexport function isArrayBuffer(val: any): val is ArrayBuffer {\r\n    return val && typeof ArrayBuffer !== \"undefined\" &&\r\n        (val instanceof ArrayBuffer ||\r\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\r\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\r\n}", "import { isDefined, isFunction, isNullOrUndefined, isNumber, isObject, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\r\n\r\ninterface IComparable<T> {\r\n    compareTo(b: T): number;\r\n}\r\n\r\nfunction isIComparable<T>(obj: any): obj is IComparable<T> {\r\n    return isObject(obj)\r\n        && \"compareTo\" in obj\r\n        && isFunction(obj.compareTo);\r\n}\r\n\r\nexport type Comparable = number | Date | string | IComparable<any>;\r\nexport type CompareDirection = \"ascending\" | \"descending\";\r\nexport type CompareFunction<T> = ((a: T, b: T) => number) & {\r\n    direction: CompareDirection;\r\n}\r\n\r\nexport type ComparableSelector<T> = (obj: T) => Comparable;\r\n\r\nexport function compareBy<T>(direction: CompareDirection, ...getKeys: ComparableSelector<T>[]): CompareFunction<T>;\r\nexport function compareBy<T>(...getKeys: ComparableSelector<T>[]): CompareFunction<T>;\r\nexport function compareBy<T>(directionOrFirstKeyGetter: CompareDirection | ComparableSelector<T>, ...getKeys: ((obj: T) => Comparable)[]): CompareFunction<T> {\r\n    let direction: CompareDirection = null;\r\n    if (isString(directionOrFirstKeyGetter)) {\r\n        direction = directionOrFirstKeyGetter;\r\n    }\r\n    else {\r\n        direction = \"ascending\";\r\n        getKeys.unshift(directionOrFirstKeyGetter);\r\n    }\r\n\r\n    const d = direction === \"ascending\" ? 1 : -1;\r\n\r\n    const comparer = (a: T, b: T) => {\r\n        if (a === b) {\r\n            return 0;\r\n        }\r\n\r\n        for (const getKey of getKeys) {\r\n            const keyA = isNullOrUndefined(a) ? null : getKey(a);\r\n            const keyB = isNullOrUndefined(b) ? null : getKey(b);\r\n            const relation = keyA === keyB\r\n                ? 0\r\n                : isString(keyA) && isString(keyB)\r\n                    ? d * keyA.localeCompare(keyB)\r\n                    : isIComparable(keyA) && isIComparable(keyB)\r\n                        ? d * keyA.compareTo(keyB)\r\n                        : direction === \"ascending\" && keyA > keyB\r\n                            || direction === \"descending\" && keyA < keyB\r\n                            ? 1 : -1;\r\n\r\n            if (relation !== 0) {\r\n                return relation;\r\n            }\r\n        }\r\n\r\n        return 0;\r\n    };\r\n\r\n    return Object.assign(comparer, {\r\n        direction\r\n    });\r\n}\r\n\r\nexport type SearchMode = \"append\" | \"prepend\" | \"search\";\r\n\r\nexport function binarySearch<T>(arr: ArrayLike<T>, searchValue: T, comparer: CompareFunction<T>, mode: SearchMode = \"search\") {\r\n    let left = 0;\r\n    let right = arr.length - 1;\r\n    while (left <= right) {\r\n        let mid = (left + right) >> 1;\r\n        let relation = comparer(arr[mid], searchValue);\r\n        if (relation === 0) {\r\n            if (mode !== \"search\") {\r\n                const scanDirection = mode === \"append\" ? 1 : -1;\r\n                if (scanDirection > 0) {\r\n                    mid += scanDirection;\r\n                }\r\n                while (0 <= mid\r\n                    && mid < arr.length\r\n                    && (relation = comparer(arr[mid], searchValue)) === 0) {\r\n                    mid += scanDirection;\r\n                }\r\n                if (scanDirection < 0) {\r\n                    mid -= scanDirection;\r\n                }\r\n            }\r\n\r\n            return mid;\r\n        }\r\n        else if (relation < 0) {\r\n            left = mid - relation;\r\n        }\r\n        else {\r\n            right = mid - relation;\r\n        }\r\n    }\r\n\r\n    return -left - 1;\r\n}\r\n\r\nexport type InsertMode = \"set\" | SearchMode;\r\n\r\nexport function insertSorted<T>(arr: T[], val: T, idx: number): number;\r\nexport function insertSorted<T>(arr: T[], val: T, comparer: CompareFunction<T>): number;\r\nexport function insertSorted<T>(arr: T[], val: T, comparer: CompareFunction<T>, mode: InsertMode): number;\r\nexport function insertSorted<T>(arr: T[], val: T, comparerOrIdx: CompareFunction<T> | number, mode: InsertMode = \"search\"): number {\r\n    const allowDuplicates = mode !== \"set\";\r\n    if (mode === \"set\") {\r\n        mode = \"search\";\r\n    }\r\n\r\n    let idx: number = null;\r\n    if (isNumber(comparerOrIdx)) {\r\n        idx = comparerOrIdx;\r\n    }\r\n    else {\r\n        idx = binarySearch(arr, val, comparerOrIdx, mode);\r\n    }\r\n\r\n    if (idx < 0) {\r\n        idx = -idx - 1;\r\n    }\r\n    else if (!allowDuplicates) {\r\n        return -1;\r\n    }\r\n\r\n    arrayInsertAt(arr, val, idx);\r\n    return idx;\r\n}\r\n\r\nexport function removeSorted<T>(arr: T[], val: T, comparer: CompareFunction<T>): number {\r\n    const idx = binarySearch(arr, val, comparer);\r\n    if (idx >= 0) {\r\n        arrayRemoveAt(arr, idx);\r\n        return idx;\r\n    }\r\n    return -1;\r\n}\r\n\r\n\r\n/**\r\n * Empties out an array, returning the items that were in the array.\r\n * \r\n * @param arr the array to empty\r\n */\r\nexport function arrayClear<T>(arr: T[]) {\r\n    return arr.splice(0);\r\n}\r\n\r\n/**\r\n * Checks to see if two arrays contain the same elements\r\n * @returns -1 if the arrays match, the index of the first mismatched item if they don't.\r\n * @param arr1\r\n * @param arr2\r\n */\r\n\r\nexport function arrayCompare<T>(arr1: ReadonlyArray<T>, arr2: ReadonlyArray<T>): number {\r\n    for (let i = 0; i < arr1.length; ++i) {\r\n        if (arr1[i] !== arr2[i]) {\r\n            return i;\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n\r\n\r\nexport function arrayGen<T>(count: number, thunk: (i: number) => T): T[] {\r\n    return Array.from(iterableGen(count, thunk));\r\n}\r\n\r\nexport function* iterableGen<T>(count: number, thunk: (i: number) => T) {\r\n    for (let i = 0; i < count; ++i) {\r\n        yield thunk(i);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Inserts an item at the given index into an array.\r\n * @param arr\r\n * @param item\r\n * @param idx\r\n */\r\n\r\nexport function arrayInsertAt<T>(arr: T[], item: T, idx: number) {\r\n    arr.splice(idx, 0, item);\r\n}\r\n\r\n/**\r\n * Returns a random item from an array of items.\r\n *\r\n * Provides an option to consider an additional item as part of the collection\r\n * for random selection.\r\n */\r\nexport function arrayRandom<T>(arr: T[], defaultValue?: T): T | undefined {\r\n    const offset = defaultValue != null ? 1 : 0,\r\n        idx = Math.floor(Math.random() * (arr.length + offset)) - offset;\r\n    if (idx < 0) {\r\n        return defaultValue;\r\n    }\r\n    else {\r\n        return arr[idx];\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Removes a given item from an array, returning true if the item was removed.\r\n */\r\nexport function arrayRemove<T>(arr: T[], value: T) {\r\n    const idx = arr.indexOf(value);\r\n    if (idx > -1) {\r\n        arrayRemoveAt(arr, idx);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function arrayFilter<T>(arr: T[], predicate: (v: T) => boolean): T | null {\r\n    for (let i = arr.length - 1; i >= 0; --i) {\r\n        if (predicate(arr[i])) {\r\n            return arrayRemoveAt(arr, i);\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function arrayRemoveByKey<T, K>(arr: T[], key: K, getKey: (v: T) => K): T | null {\r\n    return arrayFilter(arr, (v) => getKey(v) === key);\r\n}\r\n\r\n/**\r\n * Removes an item at the given index from an array.\r\n */\r\nexport function arrayRemoveAt<T>(arr: T[], idx: number) {\r\n    return arr.splice(idx, 1)[0];\r\n}\r\n\r\n/**\r\n * Replaces all of the items in an array with the given items.\r\n *\r\n * This helps reduce GC pressure as you're not creating arrays\r\n * and then dropping them on the floor.\r\n * \r\n * @param arr the array to fill\r\n * @param items the items to put into the array\r\n */\r\nexport function arrayReplace<T>(arr: T[], ...items: T[]) {\r\n    arr.splice(0, arr.length, ...items);\r\n}\r\n\r\nexport function arrayCreate<T>(count: number, make: (i: number, len?: number) => T): T[] {\r\n    const arr = new Array<T>(count);\r\n    for (let i = 0; i < count; ++i) {\r\n        arr[i] = make(i, count);\r\n    }\r\n    return arr;\r\n}\r\n\r\n\r\nfunction _arrayScan<T>(forward: boolean, arr: readonly T[], tests: ((val: T) => boolean)[]): T {\r\n    const start = forward ? 0 : arr.length - 1;\r\n    const end = forward ? arr.length : -1;\r\n    const inc = forward ? 1 : -1;\r\n    for (const test of tests) {\r\n        for (let i = start; i != end; i += inc) {\r\n            const item = arr[i];\r\n            if (test(item)) {\r\n                return item;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Scans through a series of filters to find an item that matches\r\n * any of the filters. The first item of the first filter that matches\r\n * will be returned.\r\n */\r\nexport function arrayScan<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;\r\nexport function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T\r\nexport function arrayScan<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T {\r\n    return _arrayScan(true, arr, tests);\r\n}\r\n\r\n/**\r\n * Scans through a series of filters to find an item that matches\r\n * any of the filters. The last item of the first filter that matches\r\n * will be returned.\r\n */\r\nexport function arrayScanReverse<T, S extends T>(arr: readonly T[], ...tests: ((val: T) => val is S)[]): S;\r\nexport function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T;\r\nexport function arrayScanReverse<T>(arr: readonly T[], ...tests: ((val: T) => boolean)[]): T {\r\n    return _arrayScan(false, arr, tests);\r\n}\r\n\r\nexport function arrayShuffleInplace<T>(arr: T[]): void {\r\n    for (let i = 0; i < arr.length - 1; ++i) {\r\n        const subLength = arr.length - i;\r\n        const subIndex = Math.floor(Math.random() * subLength);\r\n        const temp = arr[i];\r\n        const j = subIndex + i;\r\n        arr[i] = arr[j];\r\n        arr[j] = temp;\r\n    }\r\n}\r\n\r\nexport function arrayShuffle<T>(arr: readonly T[]): T[] {\r\n    const output = arr.slice();\r\n    arrayShuffleInplace(output);\r\n    return output;\r\n}\r\n\r\nconst numericPattern = /^(-?(?:\\d+\\.)\\d+)/;\r\n/**\r\n * Creates a new array that is sorted by the key extracted\r\n * by the keySelector callback, not modifying the input array,\r\n * (unlike JavaScript's own Array.prototype.sort).\r\n *\r\n * If the values have a number at the beginning, they'll be sorted\r\n * by that number.\r\n * @param arr\r\n * @param keySelector\r\n */\r\nexport function arraySortNumericByKey<T>(arr: ReadonlyArray<T>, keySelector: (obj: T) => string): T[] {\r\n    const comparer = compareBy<T>(v => {\r\n        const key = keySelector(v);\r\n        const match = key.match(numericPattern);\r\n        if (isDefined(match)) {\r\n            return parseFloat(match[1]);\r\n        }\r\n        return key;\r\n    });\r\n\r\n    return Array\r\n        .from(arr)\r\n        .sort(comparer);\r\n}\r\n\r\nexport function arrayZip<T, V>(arr1: readonly T[], arr2: readonly T[], combine: (a: T, b: T) => V): V[] {\r\n    const len = Math.max(arr1.length, arr2.length);\r\n    const output = new Array<V>(len);\r\n    for (let i = 0; i < len; ++i) {\r\n        output[i] = combine(arr1[i], arr2[i]);\r\n    }\r\n\r\n    return output;\r\n}\r\n", "import { isDefined, isNullOrUndefined } from \"@juniper-lib/tslib/dist/typeChecks\";\r\nimport { arrayClear, arrayRemove } from \"./arrays\";\r\n\r\nexport class PriorityList<KeyT, ValueT> {\r\n    private readonly items = new Map<KeyT, ValueT[]>();\r\n    private readonly defaultItems = new Array<ValueT>();\r\n\r\n    constructor(init?: [KeyT, ValueT][]) {\r\n        if (isDefined(init)) {\r\n            for (const [key, value] of init) {\r\n                this.add(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    add(key: KeyT, ...values: ValueT[]): this {\r\n        for (const value of values) {\r\n            if (isNullOrUndefined(key)) {\r\n                this.defaultItems.push(value);\r\n            }\r\n            else {\r\n                let list = this.items.get(key);\r\n                if (isNullOrUndefined(list)) {\r\n                    this.items.set(key, list = []);\r\n                }\r\n\r\n                list.push(value);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    entries(): IterableIterator<[KeyT, ValueT[]]> {\r\n        return this.items.entries();\r\n    }\r\n\r\n    [Symbol.iterator]() {\r\n        return this.entries();\r\n    }\r\n\r\n    keys(): IterableIterator<KeyT> {\r\n        return this.items.keys();\r\n    }\r\n\r\n    *values(): IterableIterator<ValueT> {\r\n        for (const item of this.defaultItems) {\r\n            yield item;\r\n        }\r\n        for (const list of this.items.values()) {\r\n            for (const item of list) {\r\n                yield item;\r\n            }\r\n        }\r\n    }\r\n\r\n    has(key: KeyT): boolean {\r\n        if (isDefined(key)) {\r\n            return this.items.has(key);\r\n        }\r\n        else {\r\n            return this.defaultItems.length > 0;\r\n        }\r\n    }\r\n\r\n    get(key: KeyT): ValueT[] {\r\n        if (isNullOrUndefined(key)) {\r\n            return this.defaultItems;\r\n        }\r\n\r\n        return this.items.get(key) || [];\r\n    }\r\n\r\n    count(key: KeyT): number {\r\n        if (isNullOrUndefined(key)) {\r\n            return this.defaultItems.length;\r\n        }\r\n\r\n        const list = this.get(key);\r\n        if (isDefined(list)) {\r\n            return list.length;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    get size(): number {\r\n        let size = this.defaultItems.length;\r\n        for (const list of this.items.values()) {\r\n            size += list.length;\r\n        }\r\n        return size;\r\n    }\r\n\r\n    delete(key: KeyT) {\r\n        if (isNullOrUndefined(key)) {\r\n            return arrayClear(this.defaultItems).length > 0;\r\n        }\r\n        else {\r\n            return this.items.delete(key);\r\n        }\r\n    }\r\n\r\n    remove(key: KeyT, value: ValueT) {\r\n        if (isNullOrUndefined(key)) {\r\n            arrayRemove(this.defaultItems, value);\r\n        }\r\n        else {\r\n            const list = this.items.get(key);\r\n            if (isDefined(list)) {\r\n                arrayRemove(list, value);\r\n                if (list.length === 0) {\r\n                    this.items.delete(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clear(): void {\r\n        this.items.clear();\r\n        arrayClear(this.defaultItems);\r\n    }\r\n}\r\n\r\n\r\n", "import { arrayClear } from \"@juniper-lib/collections/dist/arrays\";\r\nimport { isDefined } from \"@juniper-lib/tslib/dist/typeChecks\";\r\nimport { TypedEventTarget, TypedEventMap } from \"./TypedEventTarget\";\r\n\r\nexport type TaskExecutionState =\r\n    | \"waiting\"\r\n    | \"running\"\r\n    | \"finished\"\r\n\r\nexport type TaskResultState =\r\n    | \"none\"\r\n    | \"resolved\"\r\n    | \"errored\";\r\n\r\n/**\r\n * A Task represents a Promise that exposes its resolve/reject functions\r\n * as methods, rather than requiring a callback being passed to its constructor.\r\n * Tasks can be used to build manually-resolved Promises with less\r\n * boilerplate of nested function blocks.\r\n **/\r\nexport class Task<ResultsT = void> implements Promise<ResultsT> {\r\n    private readonly onThens = new Array<(v: ResultsT) => any>();\r\n    private readonly onCatches = new Array<(reason?: any) => void>();\r\n\r\n    private _result: ResultsT = undefined;\r\n    private _error: any = undefined;\r\n    private _executionState: TaskExecutionState = \"waiting\";\r\n    private _resultState: TaskResultState = \"none\";\r\n\r\n    /**\r\n     * Signal success for the Task\r\n     *\r\n     * @param value - the value to store with the resolved Task.\r\n     **/\r\n    public readonly resolve: (value: ResultsT) => void;\r\n\r\n    /**\r\n     * Signal failrue for the Task\r\n     *\r\n     * @param value - the error to store with the rejected Task.\r\n     **/\r\n    public readonly reject: (reason: any) => void;\r\n\r\n\r\n    /**\r\n     * Create a new Task\r\n     *\r\n     * @param autoStart - set to false to require manually starting the Task. Useful\r\n     * for reusable tasks that run on timers.\r\n     */\r\n    constructor(private readonly autoStart = true) {\r\n        // It's very likely that we will want to use resolve/reject\r\n        // as values to pass to another function/method, so we create\r\n        // them not as methods, but as bound lambda expressions stored\r\n        // in public fields.\r\n        this.resolve = (value) => {\r\n            if (this.running) {\r\n                this._result = value;\r\n                this._resultState = \"resolved\";\r\n\r\n                for (const thenner of this.onThens) {\r\n                    thenner(value);\r\n                }\r\n\r\n                this.clear();\r\n                this._executionState = \"finished\";\r\n            }\r\n        };\r\n\r\n        this.reject = (reason) => {\r\n            if (this.running) {\r\n                this._error = reason;\r\n                this._resultState = \"errored\";\r\n\r\n                for (const catcher of this.onCatches) {\r\n                    catcher(reason);\r\n                }\r\n\r\n                this.clear();\r\n                this._executionState = \"finished\";\r\n            }\r\n        };\r\n\r\n        if (this.autoStart) {\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    private clear() {\r\n        arrayClear(this.onThens);\r\n        arrayClear(this.onCatches);\r\n    }\r\n\r\n    /**\r\n     * If the task was not auto-started, signal that the task is now ready to recieve\r\n     * resolutions or rejections.\r\n     **/\r\n    start() {\r\n        this._executionState = \"running\";\r\n    }\r\n\r\n    /**\r\n     * Creates a resolving callback for a static value.\r\n     * @param value\r\n     */\r\n    resolver(value: ResultsT) {\r\n        return () => this.resolve(value);\r\n    }\r\n\r\n    resolveOn<EventMapT extends TypedEventMap<string>, EventT extends keyof EventMapT = keyof EventMapT>(\r\n        target: TypedEventTarget<EventMapT> | EventTarget,\r\n        resolveEvt: EventT,\r\n        value: ResultsT) {\r\n        const resolver = this.resolver(value);\r\n        target.addEventListener(resolveEvt as any, resolver);\r\n        this.finally(() =>\r\n            target.removeEventListener(resolveEvt as any, resolver));\r\n    }\r\n\r\n    /**\r\n     * Get the last result that the task had resolved to, if any is available.\r\n     *\r\n     * If the Task had been rejected, attempting to get the result will rethrow\r\n     * the error that had rejected the task.\r\n     **/\r\n    get result(): ResultsT {\r\n        if (isDefined(this.error)) {\r\n            throw this.error;\r\n        }\r\n\r\n        return this._result;\r\n    }\r\n\r\n    /**\r\n     * Get the last error that the task had been rejected by, if any.\r\n     **/\r\n    get error(): any {\r\n        return this._error;\r\n    }\r\n\r\n    /**\r\n     * Get the current state of the task.\r\n     **/\r\n    get executionState() {\r\n        return this._executionState;\r\n    }\r\n\r\n    /**\r\n     * Returns true when the Task is hasn't started yet.\r\n     **/\r\n    get waiting(): boolean {\r\n        return this.executionState === \"waiting\";\r\n    }\r\n\r\n    /**\r\n     * Returns true when the Task is waiting to be resolved or rejected.\r\n     **/\r\n    get started(): boolean {\r\n        return this.executionState !== \"waiting\";\r\n    }\r\n\r\n    /**\r\n     * Returns true after the Task has started, but before it has finished.\r\n     **/\r\n    get running(): boolean {\r\n        return this.executionState === \"running\";\r\n    }\r\n\r\n    /**\r\n     * Returns true when the Task has been resolved or rejected.\r\n     **/\r\n    get finished(): boolean {\r\n        return this.executionState === \"finished\";\r\n    }\r\n\r\n    get resultState() {\r\n        return this._resultState;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the Task had been resolved successfully.\r\n     **/\r\n    get resolved(): boolean {\r\n        return this.resultState === \"resolved\";\r\n    }\r\n\r\n    /**\r\n     * Returns true if the Task had been rejected, regardless of any\r\n     * reason being given.\r\n     **/\r\n    get errored(): boolean {\r\n        return this.resultState === \"errored\";\r\n    }\r\n\r\n    get [Symbol.toStringTag](): string {\r\n        return this.toString();\r\n    }\r\n\r\n    /**\r\n     * Calling Task.then(), Task.catch(), or Task.finally() creates a new Promise.\r\n     * This method creates that promise and links it with the task.\r\n     **/\r\n    private project(): Promise<ResultsT> {\r\n        return new Promise<ResultsT>((resolve, reject) => {\r\n            if (!this.finished) {\r\n                this.onThens.push(resolve);\r\n                this.onCatches.push(reject);\r\n            }\r\n            else if (this.errored) {\r\n                reject(this.error);\r\n            }\r\n            else {\r\n                resolve(this.result);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Attach a handler to the task that fires when the task is resolved.\r\n     * \r\n     * @param onfulfilled\r\n     * @param onrejected\r\n     */\r\n    then<TResult1 = ResultsT, TResult2 = never>(onfulfilled?: (value: ResultsT) => TResult1 | PromiseLike<TResult1>, onrejected?: (reason: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2> {\r\n        return this.project().then(onfulfilled, onrejected);\r\n    }\r\n\r\n    /**\r\n     * Attach a handler that fires when the Task is rejected.\r\n     * \r\n     * @param onrejected\r\n     */\r\n    catch<TResult = never>(onrejected?: (reason: any) => TResult | PromiseLike<TResult>): Promise<ResultsT | TResult> {\r\n        return this.project().catch(onrejected);\r\n    }\r\n\r\n    /**\r\n     * Attach a handler that fires regardless of whether the Task is resolved\r\n     * or rejected.\r\n     * \r\n     * @param onfinally\r\n     */\r\n    finally(onfinally?: () => void): Promise<ResultsT> {\r\n        return this.project().finally(onfinally);\r\n    }\r\n\r\n    /**\r\n     * Resets the Task to an unsignalled state, which is useful for\r\n     * reducing GC pressure when working with lots of tasks.\r\n     **/\r\n    reset() {\r\n        this._reset(this.autoStart);\r\n    }\r\n\r\n    restart() {\r\n        this._reset(true);\r\n    }\r\n\r\n    private _reset(start: boolean) {\r\n        if (this.running) {\r\n            this.reject(\"Resetting previous invocation\");\r\n        }\r\n\r\n        this.clear();\r\n        this._result = undefined;\r\n        this._error = undefined;\r\n        this._executionState = \"waiting\";\r\n        this._resultState = \"none\";\r\n\r\n        if (start) {\r\n            this.start();\r\n        }\r\n    }\r\n}", "import { arrayRemove } from \"@juniper-lib/collections/dist/arrays\";\r\nimport { once } from \"@juniper-lib/events/dist/once\";\r\nimport { Text_Css } from \"@juniper-lib/mediatypes\";\r\nimport { IProgress } from \"@juniper-lib/progress/dist/IProgress\";\r\nimport { isBoolean, isDate, isDefined, isFunction, isNumber, isObject, isString } from \"@juniper-lib/tslib/dist/typeChecks\";\r\nimport { ClassList, Href, HtmlFor, Rel, Type, isAttr } from \"./attrs\";\r\nimport { PropSet, margin } from \"./css\";\r\n\r\nexport interface ErsatzElement<T extends Element = Element> {\r\n    element: T;\r\n}\r\n\r\nexport function isErsatzElement<T extends Element = Element>(obj: any): obj is ErsatzElement<T> {\r\n    if (!isObject(obj)) {\r\n        return false;\r\n    }\r\n\r\n    const elem = obj as ErsatzElement;\r\n    return elem.element instanceof Element;\r\n}\r\n\r\nexport type Elements<T extends Element = Element> = T | ErsatzElement<T>;\r\n\r\nexport function resolveElement<T extends Element = HTMLElement>(elem: Elements<T> | string): T {\r\n    if (isErsatzElement(elem)) {\r\n        return elem.element;\r\n    }\r\n    else if (isString(elem)) {\r\n        return getElement(elem);\r\n    }\r\n\r\n    return elem;\r\n}\r\n\r\nexport interface IElementAppliable<T extends Element = Element> {\r\n    applyToElement(x: Elements<T>): void;\r\n}\r\n\r\nexport function isIElementAppliable<T extends Element = Element>(obj: any): obj is IElementAppliable<T> {\r\n    return isObject(obj)\r\n        && \"applyToElement\" in obj\r\n        && isFunction((obj as any).applyToElement);\r\n}\r\n\r\nexport type ElementChild<T extends Element = Element> = Elements<T>\r\n    | IElementAppliable\r\n    | string\r\n    | number\r\n    | boolean\r\n    | Date;\r\n\r\nexport function isElementChild(obj: any): obj is ElementChild {\r\n    return obj instanceof Element\r\n        || isErsatzElement(obj)\r\n        || isIElementAppliable(obj)\r\n        || isString(obj)\r\n        || isNumber(obj)\r\n        || isBoolean(obj)\r\n        || isDate(obj);\r\n}\r\n\r\nexport function isElements(child: ElementChild): child is Elements {\r\n    return isErsatzElement(child)\r\n        || child instanceof Element;\r\n}\r\n\r\nexport interface IFocusable {\r\n    focus(): void;\r\n}\r\n\r\nexport function isFocusable(elem: any): elem is IFocusable {\r\n    return \"focus\" in elem && isFunction((elem as IFocusable).focus);\r\n}\r\n\r\nexport function elementSetDisplay<T extends HTMLElement = HTMLElement>(elem: Elements<T>, visible: boolean, visibleDisplayType: CssGlobalValue | CssDisplayValue = \"\"): void {\r\n    elem = resolveElement(elem);\r\n    if (visible) {\r\n        elem.style.removeProperty(\"display\");\r\n        const style = getComputedStyle(elem);\r\n        if (style.display === \"none\") {\r\n            elem.style.display = visibleDisplayType || \"block\";\r\n        }\r\n    }\r\n    else {\r\n        elem.style.display = \"none\";\r\n    }\r\n}\r\n\r\nexport function elementIsDisplayed<T extends HTMLElement = HTMLElement>(elem: Elements<T>): boolean {\r\n    elem = resolveElement(elem);\r\n    return elem.style.display !== \"none\";\r\n}\r\n\r\nexport function elementToggleDisplay<T extends HTMLElement = HTMLElement>(elem: Elements<T>, visibleDisplayType: CssGlobalValue | CssDisplayValue = \"block\"): void {\r\n    elementSetDisplay(elem, !elementIsDisplayed(elem), visibleDisplayType);\r\n}\r\n\r\nexport function elementInsertBefore(parent: Elements, newElem: Elements, refElem: Elements): void {\r\n    parent = resolveElement(parent);\r\n    newElem = resolveElement(newElem);\r\n    refElem = resolveElement(refElem);\r\n    if (parent && newElem) {\r\n        parent.insertBefore(newElem, refElem);\r\n    }\r\n}\r\n\r\nexport function elementGetIndexInParent(elem: Elements): number {\r\n    elem = resolveElement(elem);\r\n\r\n    if (elem.parentElement) {\r\n        for (let i = 0; i < elem.parentElement.childElementCount; ++i) {\r\n            if (elem.parentElement.children[i] === elem) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function Clear() {\r\n    return {\r\n        applyToElement(elem: HTMLElement) { elem.innerHTML = \"\"; }\r\n    }\r\n}\r\n\r\n\r\nexport function elementGetCustomData(elem: Elements<HTMLElement>, name: Lowercase<string>): string {\r\n    elem = resolveElement(elem);\r\n    return elem.dataset[name.toLowerCase()];\r\n}\r\n\r\ntype ReturnElementType<T> = T extends Element\r\n    ? T\r\n    : T extends ShadowRoot\r\n    ? T\r\n    : T extends Elements<infer ElementT>\r\n    ? ElementT\r\n    : never;\r\n\r\nexport function HtmlRender<T extends Elements | ShadowRoot>(element: T | string, ...children: ElementChild[]): ReturnElementType<T> {\r\n    const elem = element instanceof Element\r\n        ? element\r\n        : element instanceof ShadowRoot\r\n            ? element\r\n            : isString(element)\r\n                ? document.querySelector(element)\r\n                : element.element;\r\n\r\n    const target = elem instanceof HTMLTemplateElement\r\n        ? elem.content\r\n        : elem;\r\n\r\n    for (const child of children) {\r\n        if (isDefined(child)) {\r\n            if (child instanceof Node) {\r\n                target.appendChild(child);\r\n            }\r\n            else if (isErsatzElement(child)) {\r\n                target.appendChild(resolveElement(child));\r\n            }\r\n            else if (isIElementAppliable(child)) {\r\n                if (!(elem instanceof ShadowRoot)) {\r\n                    child.applyToElement(elem);\r\n                }\r\n            }\r\n            else {\r\n                target.appendChild(document.createTextNode(child.toLocaleString()));\r\n            }\r\n        }\r\n    }\r\n\r\n    return elem as ReturnElementType<T>;\r\n}\r\n\r\nexport function elementRemoveFromParent(elem: Elements | string): void {\r\n    elem = resolveElement(elem);\r\n    if (isDefined(elem)) {\r\n        elem.remove();\r\n    }\r\n}\r\n\r\nexport function elementReplace(elem: Elements, ...elems: Elements[]): Elements {\r\n    elem = resolveElement(elem);\r\n    elem.replaceWith(...elems.map(resolveElement));\r\n    return elem;\r\n}\r\n\r\nexport function elementSwap<T extends Elements>(elem: Elements, withPlaceholder: (placeholder: Elements) => T): T {\r\n    const placeholder = Div();\r\n    const e = withPlaceholder(placeholder);\r\n    elementReplace(placeholder, elementReplace(elem, e));\r\n    return e;\r\n}\r\n\r\nexport function getElement<T extends Element = HTMLElement>(selector: string): T {\r\n    return document.querySelector<T>(selector);\r\n}\r\n\r\nexport function getElements<T extends Element = HTMLElement>(selector: string): T[] {\r\n    return Array.from(document.querySelectorAll<T>(selector));\r\n}\r\n\r\nexport function getButton(selector: string) {\r\n    return getElement<HTMLButtonElement>(selector);\r\n}\r\n\r\nexport function getButtons(selector: string) {\r\n    return getElements<HTMLButtonElement>(selector);\r\n}\r\n\r\nexport function getInput(selector: string) {\r\n    return getElement<HTMLInputElement>(selector);\r\n}\r\n\r\nexport function getDataList(selector: string) {\r\n    return getElement<HTMLDataListElement>(selector);\r\n}\r\n\r\nexport function getInputs(selector: string) {\r\n    return getElements<HTMLInputElement>(selector);\r\n}\r\n\r\nexport function getSelect(selector: string) {\r\n    return getElement<HTMLSelectElement>(selector);\r\n}\r\n\r\nexport function getCanvas(selector: string) {\r\n    return getElement<HTMLCanvasElement>(selector);\r\n}\r\n\r\n/**\r\n * Creates an HTML element for a given tag name.\r\n * \r\n * Boolean attributes that you want to default to true can be passed\r\n * as just the attribute creating function, \r\n *   e.g. `Audio(autoPlay)` vs `Audio(autoPlay(true))`\r\n * @param name - the name of the tag\r\n * @param rest - optional attributes, child elements, and text\r\n * @returns\r\n */\r\nexport function HtmlTag<MapT extends Record<keyof MapT, HTMLElement> = HTMLElementTagNameMap, K extends keyof MapT & string = keyof MapT & string>(name: K, ...rest: ElementChild[]): MapT[K] {\r\n    let elem: MapT[K] & HTMLElement = null;\r\n\r\n    const finders = rest.filter(isAttr).filter(v => v.key === \"id\" || v.key === \"query\");\r\n    for (const finder of finders) {\r\n        if (finder.key === \"query\") {\r\n            elem = finder.value as any;\r\n            arrayRemove(rest, finder);\r\n        }\r\n        else if (finder.key === \"id\") {\r\n            elem = document.getElementById(finder.value as any) as any;\r\n            if (elem) {\r\n                arrayRemove(rest, finder);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (elem && elem.tagName !== name.toUpperCase()) {\r\n        console.warn(`Expected a \"${name.toUpperCase()}\" element but found a \"${elem.tagName}\".`);\r\n    }\r\n\r\n    if (!elem) {\r\n        elem = document.createElement(name) as MapT[K];\r\n    }\r\n\r\n    HtmlRender(elem, ...rest);\r\n\r\n    return elem;\r\n}\r\n\r\nexport interface IDisableable {\r\n    disabled: boolean;\r\n}\r\n\r\nexport function isDisableable(obj: any): obj is IDisableable {\r\n    return isObject(obj)\r\n        && \"disabled\" in obj\r\n        && isBoolean(obj.disabled);\r\n}\r\n\r\n/**\r\n * Empty an element of all children. This is faster than setting `innerHTML = \"\"`.\r\n */\r\nexport function elementClearChildren(elem: Elements) {\r\n    elem = resolveElement(elem);\r\n    while (elem.lastChild) {\r\n        elem.lastChild.remove();\r\n    }\r\n}\r\n\r\nexport function elementSetText(elem: Elements<HTMLElement>, text: string): void {\r\n    elem = resolveElement(elem);\r\n    elementClearChildren(elem);\r\n    elem.append(TextNode(text));\r\n}\r\n\r\nexport function elementGetText(elem: Elements<HTMLElement>): string {\r\n    elem = resolveElement(elem);\r\n    return elem.innerText;\r\n}\r\n\r\nexport function elementSetTitle(elem: Elements<HTMLElement>, text: string): void {\r\n    elem = resolveElement(elem);\r\n    elem.title = text;\r\n}\r\n\r\nexport function elementSetClass(elem: Elements, enabled: boolean, className: string) {\r\n    elem = resolveElement(elem);\r\n    const canEnable = isDefined(className);\r\n    const hasEnabled = canEnable && elem.classList.contains(className);\r\n\r\n    if (canEnable && hasEnabled !== enabled) {\r\n        elem.classList.toggle(className);\r\n    }\r\n}\r\n\r\nexport type ButtonStyleType =\r\n    | \"primary\"\r\n    | \"secondary\"\r\n    | \"success\"\r\n    | \"info\"\r\n    | \"warning\"\r\n    | \"danger\"\r\n    | \"light\"\r\n    | \"dark\";\r\n\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, enabled: boolean): void;\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, enabled: boolean, label: string): void;\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, enabled: boolean, label: string, title: string): void;\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, style: ButtonStyleType, enabled: boolean): void;\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, style: ButtonStyleType, enabled: boolean, label: string): void;\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, style: ButtonStyleType, enabled: boolean, label: string, title: string): void;\r\nexport function buttonSetEnabled(button: Elements<HTMLButtonElement>, styleOrEnabled: boolean | ButtonStyleType, enabledOrlabel?: string | boolean, labelOrTitle?: string, title?: string): void {\r\n    button = resolveElement(button);\r\n    let style: ButtonStyleType = null;\r\n    let enabled: boolean = null;\r\n    let label: string = null;\r\n    if (isBoolean(styleOrEnabled)) {\r\n        enabled = styleOrEnabled;\r\n        label = enabledOrlabel as string;\r\n        title = labelOrTitle;\r\n    }\r\n    else {\r\n        style = styleOrEnabled;\r\n        enabled = enabledOrlabel as boolean;\r\n        label = labelOrTitle;\r\n    }\r\n\r\n    button.disabled = !enabled;\r\n\r\n    if (label) {\r\n        elementSetText(button, label);\r\n    }\r\n\r\n    if (title) {\r\n        elementSetTitle(button, title);\r\n    }\r\n\r\n    if (style) {\r\n        button.classList.toggle(\"btn-\" + style, enabled);\r\n        button.classList.toggle(\"btn-outline-\" + style, !enabled);\r\n    }\r\n}\r\n\r\n\r\nasync function mediaElementCan(type: \"canplay\" | \"canplaythrough\", elem: HTMLMediaElement, prog?: IProgress): Promise<boolean> {\r\n    if (isDefined(prog)) {\r\n        prog.start();\r\n    }\r\n\r\n    const expectedState = type === \"canplay\"\r\n        ? elem.HAVE_CURRENT_DATA\r\n        : elem.HAVE_ENOUGH_DATA;\r\n\r\n    if (elem.readyState >= expectedState) {\r\n        return true;\r\n    }\r\n\r\n    try {\r\n        await once(elem, type, \"error\");\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        console.warn(elem.error, err);\r\n        return false;\r\n    }\r\n    finally {\r\n        if (isDefined(prog)) {\r\n            prog.end();\r\n        }\r\n    }\r\n}\r\n\r\nexport function mediaElementCanPlay(elem: HTMLMediaElement, prog?: IProgress): Promise<boolean> {\r\n    return mediaElementCan(\"canplay\", elem, prog);\r\n}\r\n\r\nexport function mediaElementCanPlayThrough(elem: HTMLMediaElement, prog?: IProgress): Promise<boolean> {\r\n    return mediaElementCan(\"canplaythrough\", elem, prog);\r\n}\r\n\r\nexport function A(...rest: ElementChild[]): HTMLAnchorElement { return HtmlTag(\"a\", ...rest); }\r\nexport function Abbr(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"abbr\", ...rest); }\r\nexport function Address(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"address\", ...rest); }\r\nexport function Area(...rest: ElementChild[]): HTMLAreaElement { return HtmlTag(\"area\", ...rest); }\r\nexport function Article(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"article\", ...rest); }\r\nexport function Aside(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"aside\", ...rest); }\r\nexport function Audio(...rest: ElementChild[]): HTMLAudioElement { return HtmlTag(\"audio\", ...rest); }\r\nexport function B(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"b\", ...rest); }\r\nexport function Base(...rest: ElementChild[]): HTMLBaseElement { return HtmlTag(\"base\", ...rest); }\r\nexport function BDI(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"bdi\", ...rest); }\r\nexport function BDO(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"bdo\", ...rest); }\r\nexport function BlockQuote(...rest: ElementChild[]): HTMLQuoteElement { return HtmlTag(\"blockquote\", ...rest); }\r\nexport function Body(...rest: ElementChild[]): HTMLBodyElement { return HtmlTag(\"body\", ...rest); }\r\nexport function BR(): HTMLBRElement { return HtmlTag(\"br\"); }\r\nexport function ButtonRaw(...rest: ElementChild[]): HTMLButtonElement { return HtmlTag(\"button\", ...rest); }\r\nexport function Button(...rest: ElementChild[]): HTMLButtonElement { return ButtonRaw(...rest, Type(\"button\")); }\r\nexport function ButtonSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\")); }\r\nexport function ButtonPrimary(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-primary\")); }\r\nexport function ButtonPrimaryOutline(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-outline-primary\")); }\r\nexport function ButtonPrimarySmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\", \"btn-primary\")); }\r\nexport function ButtonPrimaryOutlineSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\", \"btn-outline-primary\")); }\r\nexport function ButtonSecondary(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-secondary\")); }\r\nexport function ButtonSecondaryOutline(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-outline-secondary\")); }\r\nexport function ButtonSecondarySmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\", \"btn-secondary\")); }\r\nexport function ButtonSecondaryOutlineSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\", \"btn-outline-secondary\")); }\r\nexport function ButtonDanger(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-danger\")); }\r\nexport function ButtonDangerOutline(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-outline-danger\")); }\r\nexport function ButtonDangerSmall(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\", \"btn-danger\")); }\r\nexport function ButtonDangerOutlineSmalle(...rest: ElementChild[]): HTMLButtonElement { return Button(...rest, ClassList(\"btn\", \"btn-sm\", \"btn-outline-danger\")); }\r\nexport function ButtonSubmit(...rest: ElementChild[]): HTMLButtonElement { return ButtonRaw(...rest, Type(\"submit\")); }\r\nexport function ButtonReset(...rest: ElementChild[]): HTMLButtonElement { return ButtonRaw(...rest, Type(\"reset\")); }\r\nexport function Canvas(...rest: ElementChild[]): HTMLCanvasElement { return HtmlTag(\"canvas\", ...rest); }\r\nexport function Caption(...rest: ElementChild[]): HTMLTableCaptionElement { return HtmlTag(\"caption\", ...rest); }\r\nexport function Cite(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"cite\", ...rest); }\r\nexport function Code(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"code\", ...rest); }\r\nexport function Col(...rest: ElementChild[]): HTMLTableColElement { return HtmlTag(\"col\", ...rest); }\r\nexport function ColGroup(...rest: ElementChild[]): HTMLTableColElement { return HtmlTag(\"colgroup\", ...rest); }\r\nexport function DataTag(...rest: ElementChild[]): HTMLDataElement { return HtmlTag(\"data\", ...rest); }\r\nexport function DataList(...rest: ElementChild[]): HTMLDataListElement { return HtmlTag(\"datalist\", ...rest); }\r\nexport function DD(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"dd\", ...rest); }\r\nexport function Del(...rest: ElementChild[]): HTMLModElement { return HtmlTag(\"del\", ...rest); }\r\nexport function Details(...rest: ElementChild[]): HTMLDetailsElement { return HtmlTag(\"details\", ...rest); }\r\nexport function DFN(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"dfn\", ...rest); }\r\nexport function Dialog(...rest: ElementChild[]): HTMLDialogElement { return HtmlTag(\"dialog\", ...rest); }\r\nexport function Div(...rest: ElementChild[]): HTMLDivElement { return HtmlTag(\"div\", ...rest); }\r\nexport function DL(...rest: ElementChild[]): HTMLDListElement { return HtmlTag(\"dl\", ...rest); }\r\nexport function DT(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"dt\", ...rest); }\r\nexport function Em(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"em\", ...rest); }\r\nexport function Embed(...rest: ElementChild[]): HTMLEmbedElement { return HtmlTag(\"embed\", ...rest); }\r\nexport function FieldSet(...rest: ElementChild[]): HTMLFieldSetElement { return HtmlTag(\"fieldset\", ...rest); }\r\nexport function FigCaption(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"figcaption\", ...rest); }\r\nexport function Figure(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"figure\", ...rest); }\r\nexport function Footer(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"footer\", ...rest); }\r\nexport function Form(...rest: ElementChild[]): HTMLFormElement { return HtmlTag(\"form\", ...rest); }\r\nexport function H1(...rest: ElementChild[]): HTMLHeadingElement { return HtmlTag(\"h1\", ...rest); }\r\nexport function H2(...rest: ElementChild[]): HTMLHeadingElement { return HtmlTag(\"h2\", ...rest); }\r\nexport function H3(...rest: ElementChild[]): HTMLHeadingElement { return HtmlTag(\"h3\", ...rest); }\r\nexport function H4(...rest: ElementChild[]): HTMLHeadingElement { return HtmlTag(\"h4\", ...rest); }\r\nexport function H5(...rest: ElementChild[]): HTMLHeadingElement { return HtmlTag(\"h5\", ...rest); }\r\nexport function H6(...rest: ElementChild[]): HTMLHeadingElement { return HtmlTag(\"h6\", ...rest); }\r\nexport function HR(...rest: ElementChild[]): HTMLHRElement { return HtmlTag(\"hr\", ...rest); }\r\nexport function Head(...rest: ElementChild[]): HTMLHeadElement { return HtmlTag(\"head\", ...rest); }\r\nexport function Header(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"header\", ...rest); }\r\nexport function HGroup(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"hgroup\", ...rest); }\r\nexport function HTML(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"html\", ...rest); }\r\nexport function I(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"i\", ...rest); }\r\nexport function FAIcon(iconName: string, ...rest: ElementChild[]): HTMLElement { return I(ClassList(`fa fa-${iconName}`), ...rest); }\r\nexport function IFrame(...rest: ElementChild[]): HTMLIFrameElement { return HtmlTag(\"iframe\", ...rest); }\r\nexport function Img(...rest: ElementChild[]): HTMLImageElement { return HtmlTag(\"img\", ...rest); }\r\nexport function Input(...rest: ElementChild[]): HTMLInputElement { return HtmlTag(\"input\", ...rest); }\r\nexport function Ins(...rest: ElementChild[]): HTMLModElement { return HtmlTag(\"ins\", ...rest); }\r\nexport function KBD(...rest: ElementChild[]): HTMLElement { return HtmlTag(\"kbd\", ...rest); }\r\nexport function Label(...rest: ElementChild[]): HTMLLabelElement { return HtmlTag(\"label\", ...rest); }\r\nexport function PreLabeled<T extends Elements>(id: string, label: ElementChild, input: T): [HTMLLabelElement, T] {\r\n    resolveElement(input).id = id;\r\n    return [\r\n        Label(HtmlFor(id), label),\r\n        input\r\n    ];\r\n}\r\nexport function PostLabeled<T extends Elements>(id: string, label: ElementChild, input: T): [T, HTMLLabelElement] {\r\n    resolveElement(input).id = id;\r\n    return [\r\n        input,\r\n        Label(HtmlFor(id), label)\r\n    ];\r\n}\r\nexport function Legend(...rest: ElementChild[]) { return HtmlTag(\"legend\", ...rest); }\r\nexport function LI(...rest: ElementChild[]) { return HtmlTag(\"li\", ...rest); }\r\nexport function Link(...rest: ElementChild[]) { return HtmlTag(\"link\", ...rest); }\r\nexport function Main(...rest: ElementChild[]) { return HtmlTag(\"main\", ...rest); }\r\nexport function Map_tag(...rest: ElementChild[]) { return HtmlTag(\"map\", ...rest); }\r\nexport function Mark(...rest: ElementChild[]) { return HtmlTag(\"mark\", ...rest); }\r\nexport function Menu(...rest: ElementChild[]) { return HtmlTag(\"menu\", ...rest); }\r\nexport function Meta(...rest: ElementChild[]) { return HtmlTag(\"meta\", ...rest); }\r\nexport function Meter(...rest: ElementChild[]) { return HtmlTag(\"meter\", ...rest); }\r\nexport function Nav(...rest: ElementChild[]) { return HtmlTag(\"nav\", ...rest); }\r\nexport function NoScript(...rest: ElementChild[]) { return HtmlTag(\"noscript\", ...rest); }\r\nexport function Object_tag(...rest: ElementChild[]) { return HtmlTag(\"object\", ...rest); }\r\nexport function OL(...rest: ElementChild[]) { return HtmlTag(\"ol\", ...rest); }\r\nexport function OptGroup(...rest: ElementChild[]) { return HtmlTag(\"optgroup\", ...rest); }\r\nexport function Option(...rest: ElementChild[]) { return HtmlTag(\"option\", ...rest); }\r\nexport function Output(...rest: ElementChild[]) { return HtmlTag(\"output\", ...rest); }\r\nexport function P(...rest: ElementChild[]) { return HtmlTag(\"p\", ...rest); }\r\nexport function Picture(...rest: ElementChild[]) { return HtmlTag(\"picture\", ...rest); }\r\nexport function Pre(...rest: ElementChild[]) { return HtmlTag(\"pre\", ...rest); }\r\nexport function Progress(...rest: ElementChild[]) { return HtmlTag(\"progress\", ...rest); }\r\nexport function Q(...rest: ElementChild[]) { return HtmlTag(\"q\", ...rest); }\r\nexport function RP(...rest: ElementChild[]) { return HtmlTag(\"rp\", ...rest); }\r\nexport function RT(...rest: ElementChild[]) { return HtmlTag(\"rt\", ...rest); }\r\nexport function Ruby(...rest: ElementChild[]) { return HtmlTag(\"ruby\", ...rest); }\r\nexport function S(...rest: ElementChild[]) { return HtmlTag(\"s\", ...rest); }\r\nexport function Samp(...rest: ElementChild[]) { return HtmlTag(\"samp\", ...rest); }\r\nexport function Script(...rest: ElementChild[]) { return HtmlTag(\"script\", ...rest); }\r\nexport function Section(...rest: ElementChild[]) { return HtmlTag(\"section\", ...rest); }\r\nexport function Select(...rest: ElementChild[]) { return HtmlTag(\"select\", ...rest); }\r\nexport function Slot(...rest: ElementChild[]) { return HtmlTag(\"slot\", ...rest); }\r\nexport function Small(...rest: ElementChild[]) { return HtmlTag(\"small\", ...rest); }\r\nexport function Source(...rest: ElementChild[]) { return HtmlTag(\"source\", ...rest); }\r\nexport function Span(...rest: ElementChild[]) { return HtmlTag(\"span\", ...rest); }\r\nexport function Strong(...rest: ElementChild[]) { return HtmlTag(\"strong\", ...rest); }\r\nexport function Sub(...rest: ElementChild[]) { return HtmlTag(\"sub\", ...rest); }\r\nexport function Summary(...rest: ElementChild[]) { return HtmlTag(\"summary\", ...rest); }\r\nexport function Sup(...rest: ElementChild[]) { return HtmlTag(\"sup\", ...rest); }\r\nexport function Table(...rest: ElementChild[]) { return HtmlTag(\"table\", ...rest); }\r\nexport function TBody(...rest: ElementChild[]) { return HtmlTag(\"tbody\", ...rest); }\r\nexport function TD(...rest: ElementChild[]) { return HtmlTag(\"td\", ...rest); }\r\nexport function Template(...rest: ElementChild[]) { return HtmlTag(\"template\", ...rest); }\r\nexport function TextArea(...rest: ElementChild[]) { return HtmlTag(\"textarea\", ...rest); }\r\nexport function TFoot(...rest: ElementChild[]) { return HtmlTag(\"tfoot\", ...rest); }\r\nexport function TH(...rest: ElementChild[]) { return HtmlTag(\"th\", ...rest); }\r\nexport function THead(...rest: ElementChild[]) { return HtmlTag(\"thead\", ...rest); }\r\nexport function Time(...rest: ElementChild[]) { return HtmlTag(\"time\", ...rest); }\r\nexport function Title(...rest: ElementChild[]) { return HtmlTag(\"title\", ...rest); }\r\nexport function TR(...rest: ElementChild[]) { return HtmlTag(\"tr\", ...rest); }\r\nexport function Track(...rest: ElementChild[]) { return HtmlTag(\"track\", ...rest); }\r\nexport function U(...rest: ElementChild[]) { return HtmlTag(\"u\", ...rest); }\r\nexport function UL(...rest: ElementChild[]) { return HtmlTag(\"ul\", ...rest); }\r\nexport function Var(...rest: ElementChild[]) { return HtmlTag(\"var\", ...rest); }\r\nexport function Video(...rest: ElementChild[]) { return HtmlTag(\"video\", ...rest); }\r\nexport function WBR() { return HtmlTag(\"wbr\"); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a button.\r\n */\r\nexport function InputButton(...rest: ElementChild[]) { return Input(Type(\"button\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a checkbox.\r\n */\r\nexport function InputCheckbox(...rest: ElementChild[]) { return Input(Type(\"checkbox\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a color picker.\r\n */\r\nexport function InputColor(...rest: ElementChild[]) { return Input(Type(\"color\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a date picker.\r\n */\r\nexport function InputDate(...rest: ElementChild[]) { return Input(Type(\"date\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a local date-time picker.\r\n */\r\nexport function InputDateTime(...rest: ElementChild[]) { return Input(Type(\"datetime-local\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is an email entry field.\r\n */\r\nexport function InputEmail(...rest: ElementChild[]) { return Input(Type(\"email\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a file picker.\r\n */\r\nexport function InputFile(...rest: ElementChild[]) { return Input(Type(\"file\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a hidden field.\r\n */\r\nexport function InputHidden(...rest: ElementChild[]) { return Input(Type(\"hidden\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a graphical submit button.\r\n */\r\nexport function InputImage(...rest: ElementChild[]) { return Input(Type(\"image\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a month picker.\r\n */\r\nexport function InputMonth(...rest: ElementChild[]) { return Input(Type(\"month\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a month picker.\r\n */\r\nexport function InputNumber(...rest: ElementChild[]) { return Input(Type(\"number\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a password entry field.\r\n */\r\nexport function InputPassword(...rest: ElementChild[]) { return Input(Type(\"password\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a radio button.\r\n */\r\nexport function InputRadio(...rest: ElementChild[]) { return Input(Type(\"radio\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a range selector.\r\n */\r\nexport function InputRange(...rest: ElementChild[]) { return Input(Type(\"range\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a form reset button.\r\n */\r\nexport function InputReset(...rest: ElementChild[]) { return Input(Type(\"reset\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a search entry field.\r\n */\r\nexport function InputSearch(...rest: ElementChild[]) { return Input(Type(\"search\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a submit button.\r\n */\r\nexport function InputSubmit(...rest: ElementChild[]) { return Input(Type(\"submit\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a telephone number entry field.\r\n */\r\nexport function InputTelephone(...rest: ElementChild[]) { return Input(Type(\"tel\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a text entry field.\r\n */\r\nexport function InputText(...rest: ElementChild[]) { return Input(Type(\"text\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a time picker.\r\n */\r\nexport function InputTime(...rest: ElementChild[]) { return Input(Type(\"time\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a URL entry field.\r\n */\r\nexport function InputURL(...rest: ElementChild[]) { return Input(Type(\"url\"), ...rest); }\r\n\r\n/**\r\n * creates an HTML Input tag that is a week picker.\r\n */\r\nexport function InputWeek(...rest: ElementChild[]) { return Input(Type(\"week\"), ...rest); }\r\n\r\n/**\r\n * Creates a text node out of the give input.\r\n */\r\nexport function TextNode(txt: any) {\r\n    return document.createTextNode(txt);\r\n}\r\n\r\n/**\r\n * Creates a Div element with margin: auto.\r\n */\r\nexport function Run(...rest: ElementChild[]) {\r\n    return Div(\r\n        margin(\"auto\"),\r\n        ...rest);\r\n}\r\n\r\nexport function Style(...props: PropSet[]) {\r\n    const elem = document.createElement(\"style\");\r\n    document.head.append(elem);\r\n    for (const prop of props) {\r\n        prop.applyToSheet(elem.sheet);\r\n    }\r\n\r\n    return elem;\r\n}\r\n\r\nexport function StyleBlob(...props: (string | PropSet)[]) {\r\n    const blob = new Blob(props.map(p => p.toString()), {\r\n        type: Text_Css.value\r\n    });\r\n    return Link(\r\n        Rel(\"stylesheet\"),\r\n        Href(blob)\r\n    );\r\n}", "import { PriorityList } from \"@juniper-lib/collections/dist/PriorityList\";\r\nimport { elementSetClass, getInputs } from \"@juniper-lib/dom/dist/tags\";\r\nimport { isDefined, isNullOrUndefined } from \"@juniper-lib/tslib/dist/typeChecks\";\r\n\r\n\r\nconst starters = new PriorityList<string, HTMLInputElement>();\r\nconst enders = new PriorityList<string, HTMLInputElement>();\r\nconst includers = new PriorityList<string, HTMLInputElement>();\r\nconst ranges = new Map<string, [number, number]>();\r\nconst inputs = getInputs(\"input.range-selector\");\r\nconst forms = new Map<HTMLFormElement, string>();\r\nconst tableRows = new Map<string, HTMLTableRowElement[]>();\r\nfor (const input of inputs) {\r\n    const rangeName = input.dataset.rangename;\r\n    const list = isStart(input)\r\n        ? starters\r\n        : isEnd(input)\r\n            ? enders\r\n            : isInclude(input)\r\n                ? includers\r\n                : null;\r\n    if (isDefined(list)) {\r\n        list.add(rangeName, input);\r\n        if (!isInclude(input)) {\r\n            input.name = rangeName + (isStart(input) ? \"start\" : \"end\");\r\n            input.addEventListener(\"input\", selectInput);\r\n            forms.set(input.form, rangeName);\r\n            ranges.set(rangeName, [null, null]);\r\n            let here: HTMLElement = input;\r\n            while (isDefined(here) && here.tagName !== \"TABLE\") {\r\n                here = here.parentElement;\r\n            }\r\n            if (isDefined(here) && here instanceof HTMLTableElement) {\r\n                tableRows.set(rangeName, Array.from(here.querySelectorAll(\"tbody > tr\")));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfor (const [form, rangeName] of forms) {\r\n    form.addEventListener(\"reset\", () => {\r\n        ranges.set(rangeName, [null, null]);\r\n        [starters, enders]\r\n            .flatMap(v => v.get(rangeName))\r\n            .forEach(v => v.disabled = false);\r\n        if (tableRows.has(rangeName)) {\r\n            tableRows.get(rangeName)\r\n                .forEach(v => v.classList.remove(\"table-dark\"));\r\n        }\r\n    });\r\n}\r\n\r\nfunction isStart(input: HTMLInputElement) {\r\n    return input.classList.contains(\"range-selector-start\");\r\n}\r\n\r\nfunction isEnd(input: HTMLInputElement) {\r\n    return input.classList.contains(\"range-selector-end\");\r\n}\r\n\r\nfunction isInclude(input: HTMLInputElement) {\r\n    return input.classList.contains(\"range-selector-include\");\r\n}\r\n\r\nfunction selectInput(this: HTMLInputElement) {\r\n    const rangeName = this.dataset.rangename;\r\n    const [list, other, inc] = (isStart(this)\r\n        ? [starters, enders, includers]\r\n        : [enders, starters, includers])\r\n        .map(v => v.get(rangeName));\r\n    const index = list.indexOf(this);\r\n    for (let i = 0; i < other.length; ++i) {\r\n        other[i].disabled = isStart(this) && i < index\r\n            || isEnd(this) && i > index;\r\n    }\r\n\r\n    let [start, end] = ranges.get(rangeName);\r\n    if (isStart(this)) {\r\n        start = index;\r\n        if (isNullOrUndefined(end)) {\r\n            end = start;\r\n            other[end].checked = true;\r\n        }\r\n    }\r\n    else {\r\n        end = index;\r\n        if (isNullOrUndefined(start)) {\r\n            start = end;\r\n            other[start].checked = true;\r\n        }\r\n    }\r\n\r\n    ranges.set(rangeName, [start, end]);\r\n\r\n    if (isDefined(start) && isDefined(end)) {\r\n        for (let i = 0; i < inc.length; ++i) {\r\n            inc[i].checked = start <= i && i <= end;\r\n        }\r\n\r\n        if (tableRows.has(rangeName)) {\r\n            const rows = tableRows.get(rangeName);\r\n            for (let i = 0; i < rows.length; ++i) {\r\n                elementSetClass(rows[i], start <= i && i <= end, \"table-dark\");\r\n            }\r\n        }\r\n    }\r\n}"],
  "mappings": "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",
  "names": []
}
