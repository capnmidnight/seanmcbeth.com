var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj2, key, value2) => key in obj2 ? __defProp(obj2, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj2[key] = value2;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name3 in all2)
    __defProp(target, name3, { get: all2[name3], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj2, key, value2) => {
  __defNormalProp(obj2, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
var __accessCheck = (obj2, member, msg) => {
  if (!member.has(obj2))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj2, member, getter) => {
  __accessCheck(obj2, member, "read from private field");
  return getter ? getter.call(obj2) : member.get(obj2);
};
var __privateAdd = (obj2, member, value2) => {
  if (member.has(obj2))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj2) : member.set(obj2, value2);
};
var __privateSet = (obj2, member, value2, setter) => {
  __accessCheck(obj2, member, "write to private field");
  setter ? setter.call(obj2, value2) : member.set(obj2, value2);
  return value2;
};
var __privateWrapper = (obj2, member, setter, getter) => ({
  set _(value2) {
    __privateSet(obj2, member, value2, setter);
  },
  get _() {
    return __privateGet(obj2, member, getter);
  }
});
var __privateMethod = (obj2, member, method) => {
  __accessCheck(obj2, member, "access private method");
  return method;
};

// ../Juniper/src/Juniper.TypeScript/node_modules/cardboard-vr-display/dist/cardboard-vr-display.js
var require_cardboard_vr_display = __commonJS({
  "../Juniper/src/Juniper.TypeScript/node_modules/cardboard-vr-display/dist/cardboard-vr-display.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.CardboardVRDisplay = factory();
    })(exports2, function() {
      "use strict";
      var asyncGenerator = function() {
        function AwaitValue(value2) {
          this.value = value2;
        }
        function AsyncGenerator(gen) {
          var front, back;
          function send(key, arg) {
            return new Promise(function(resolve, reject) {
              var request = {
                key,
                arg,
                resolve,
                reject,
                next: null
              };
              if (back) {
                back = back.next = request;
              } else {
                front = back = request;
                resume(key, arg);
              }
            });
          }
          function resume(key, arg) {
            try {
              var result = gen[key](arg);
              var value2 = result.value;
              if (value2 instanceof AwaitValue) {
                Promise.resolve(value2.value).then(function(arg2) {
                  resume("next", arg2);
                }, function(arg2) {
                  resume("throw", arg2);
                });
              } else {
                settle(result.done ? "return" : "normal", result.value);
              }
            } catch (err) {
              settle("throw", err);
            }
          }
          function settle(type2, value2) {
            switch (type2) {
              case "return":
                front.resolve({
                  value: value2,
                  done: true
                });
                break;
              case "throw":
                front.reject(value2);
                break;
              default:
                front.resolve({
                  value: value2,
                  done: false
                });
                break;
            }
            front = front.next;
            if (front) {
              resume(front.key, front.arg);
            } else {
              back = null;
            }
          }
          this._invoke = send;
          if (typeof gen.return !== "function") {
            this.return = void 0;
          }
        }
        if (typeof Symbol === "function" && Symbol.asyncIterator) {
          AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
            return this;
          };
        }
        AsyncGenerator.prototype.next = function(arg) {
          return this._invoke("next", arg);
        };
        AsyncGenerator.prototype.throw = function(arg) {
          return this._invoke("throw", arg);
        };
        AsyncGenerator.prototype.return = function(arg) {
          return this._invoke("return", arg);
        };
        return {
          wrap: function(fn) {
            return function() {
              return new AsyncGenerator(fn.apply(this, arguments));
            };
          },
          await: function(value2) {
            return new AwaitValue(value2);
          }
        };
      }();
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps)
            defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var MIN_TIMESTEP = 1e-3;
      var MAX_TIMESTEP = 1;
      var dataUri = function dataUri2(mimeType, svg) {
        return "data:" + mimeType + "," + encodeURIComponent(svg);
      };
      var lerp8 = function lerp9(a, b, t2) {
        return a + (b - a) * t2;
      };
      var isIOS2 = function() {
        var isIOS3 = /iPad|iPhone|iPod/.test(navigator.platform);
        return function() {
          return isIOS3;
        };
      }();
      var isWebViewAndroid = function() {
        var isWebViewAndroid2 = navigator.userAgent.indexOf("Version") !== -1 && navigator.userAgent.indexOf("Android") !== -1 && navigator.userAgent.indexOf("Chrome") !== -1;
        return function() {
          return isWebViewAndroid2;
        };
      }();
      var isSafari2 = function() {
        var isSafari3 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        return function() {
          return isSafari3;
        };
      }();
      var isFirefoxAndroid = function() {
        var isFirefoxAndroid2 = navigator.userAgent.indexOf("Firefox") !== -1 && navigator.userAgent.indexOf("Android") !== -1;
        return function() {
          return isFirefoxAndroid2;
        };
      }();
      var getChromeVersion = function() {
        var match = navigator.userAgent.match(/.*Chrome\/([0-9]+)/);
        var value2 = match ? parseInt(match[1], 10) : null;
        return function() {
          return value2;
        };
      }();
      var isSafariWithoutDeviceMotion = function() {
        var value2 = false;
        value2 = isIOS2() && isSafari2() && navigator.userAgent.indexOf("13_4") !== -1;
        return function() {
          return value2;
        };
      }();
      var isChromeWithoutDeviceMotion = function() {
        var value2 = false;
        if (getChromeVersion() === 65) {
          var match = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
          if (match) {
            var _match$1$split = match[1].split("."), _match$1$split2 = slicedToArray(_match$1$split, 4), major = _match$1$split2[0], minor = _match$1$split2[1], branch = _match$1$split2[2], build2 = _match$1$split2[3];
            value2 = parseInt(branch, 10) === 3325 && parseInt(build2, 10) < 148;
          }
        }
        return function() {
          return value2;
        };
      }();
      var isR7 = function() {
        var isR72 = navigator.userAgent.indexOf("R7 Build") !== -1;
        return function() {
          return isR72;
        };
      }();
      var isLandscapeMode = function isLandscapeMode2() {
        var rtn = window.orientation == 90 || window.orientation == -90;
        return isR7() ? !rtn : rtn;
      };
      var isTimestampDeltaValid = function isTimestampDeltaValid2(timestampDeltaS) {
        if (isNaN(timestampDeltaS)) {
          return false;
        }
        if (timestampDeltaS <= MIN_TIMESTEP) {
          return false;
        }
        if (timestampDeltaS > MAX_TIMESTEP) {
          return false;
        }
        return true;
      };
      var getScreenWidth = function getScreenWidth2() {
        return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
      };
      var getScreenHeight = function getScreenHeight2() {
        return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
      };
      var requestFullscreen = function requestFullscreen2(element) {
        if (isWebViewAndroid()) {
          return false;
        }
        if (element.requestFullscreen) {
          element.requestFullscreen();
        } else if (element.webkitRequestFullscreen) {
          element.webkitRequestFullscreen();
        } else if (element.mozRequestFullScreen) {
          element.mozRequestFullScreen();
        } else if (element.msRequestFullscreen) {
          element.msRequestFullscreen();
        } else {
          return false;
        }
        return true;
      };
      var exitFullscreen = function exitFullscreen2() {
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        } else {
          return false;
        }
        return true;
      };
      var getFullscreenElement = function getFullscreenElement2() {
        return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
      };
      var linkProgram = function linkProgram2(gl, vertexSource, fragmentSource, attribLocationMap) {
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexSource);
        gl.compileShader(vertexShader);
        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentSource);
        gl.compileShader(fragmentShader);
        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        for (var attribName in attribLocationMap) {
          gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
        }
        gl.linkProgram(program);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        return program;
      };
      var getProgramUniforms = function getProgramUniforms2(gl, program) {
        var uniforms = {};
        var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        var uniformName = "";
        for (var i = 0; i < uniformCount; i++) {
          var uniformInfo = gl.getActiveUniform(program, i);
          uniformName = uniformInfo.name.replace("[0]", "");
          uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
        }
        return uniforms;
      };
      var orthoMatrix = function orthoMatrix2(out, left2, right, bottom, top2, near, far) {
        var lr = 1 / (left2 - right), bt = 1 / (bottom - top2), nf = 1 / (near - far);
        out[0] = -2 * lr;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -2 * bt;
        out[6] = 0;
        out[7] = 0;
        out[8] = 0;
        out[9] = 0;
        out[10] = 2 * nf;
        out[11] = 0;
        out[12] = (left2 + right) * lr;
        out[13] = (top2 + bottom) * bt;
        out[14] = (far + near) * nf;
        out[15] = 1;
        return out;
      };
      var isMobile3 = function isMobile4() {
        var check = false;
        (function(a) {
          if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
            check = true;
        })(navigator.userAgent || navigator.vendor || window.opera);
        return check;
      };
      var extend = function extend2(dest, src2) {
        for (var key in src2) {
          if (src2.hasOwnProperty(key)) {
            dest[key] = src2[key];
          }
        }
        return dest;
      };
      var safariCssSizeWorkaround = function safariCssSizeWorkaround2(canvas) {
        if (isIOS2()) {
          var width2 = canvas.style.width;
          var height2 = canvas.style.height;
          canvas.style.width = parseInt(width2) + 1 + "px";
          canvas.style.height = parseInt(height2) + "px";
          setTimeout(function() {
            canvas.style.width = width2;
            canvas.style.height = height2;
          }, 100);
        }
        window.canvas = canvas;
      };
      var frameDataFromPose = function() {
        var piOver180 = Math.PI / 180;
        var rad45 = Math.PI * 0.25;
        function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
          var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45), downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45), leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45), rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45), xScale = 2 / (leftTan + rightTan), yScale = 2 / (upTan + downTan);
          out[0] = xScale;
          out[1] = 0;
          out[2] = 0;
          out[3] = 0;
          out[4] = 0;
          out[5] = yScale;
          out[6] = 0;
          out[7] = 0;
          out[8] = -((leftTan - rightTan) * xScale * 0.5);
          out[9] = (upTan - downTan) * yScale * 0.5;
          out[10] = far / (near - far);
          out[11] = -1;
          out[12] = 0;
          out[13] = 0;
          out[14] = far * near / (near - far);
          out[15] = 0;
          return out;
        }
        function mat4_fromRotationTranslation(out, q, v) {
          var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
          out[0] = 1 - (yy + zz);
          out[1] = xy + wz;
          out[2] = xz - wy;
          out[3] = 0;
          out[4] = xy - wz;
          out[5] = 1 - (xx + zz);
          out[6] = yz + wx;
          out[7] = 0;
          out[8] = xz + wy;
          out[9] = yz - wx;
          out[10] = 1 - (xx + yy);
          out[11] = 0;
          out[12] = v[0];
          out[13] = v[1];
          out[14] = v[2];
          out[15] = 1;
          return out;
        }
        function mat4_translate(out, a, v) {
          var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
          if (a === out) {
            out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
            out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
            out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
            out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
          } else {
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            out[0] = a00;
            out[1] = a01;
            out[2] = a02;
            out[3] = a03;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a20;
            out[9] = a21;
            out[10] = a22;
            out[11] = a23;
            out[12] = a00 * x + a10 * y + a20 * z + a[12];
            out[13] = a01 * x + a11 * y + a21 * z + a[13];
            out[14] = a02 * x + a12 * y + a22 * z + a[14];
            out[15] = a03 * x + a13 * y + a23 * z + a[15];
          }
          return out;
        }
        function mat4_invert(out, a) {
          var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) {
            return null;
          }
          det = 1 / det;
          out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
          out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
          out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
          out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
          out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
          out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
          out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
          out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
          out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
          out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
          out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
          out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
          out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
          out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
          out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
          out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
          return out;
        }
        var defaultOrientation = new Float32Array([0, 0, 0, 1]);
        var defaultPosition = new Float32Array([0, 0, 0]);
        function updateEyeMatrices(projection, view, pose, fov, offset, vrDisplay) {
          mat4_perspectiveFromFieldOfView(projection, fov || null, vrDisplay.depthNear, vrDisplay.depthFar);
          var orientation = pose.orientation || defaultOrientation;
          var position = pose.position || defaultPosition;
          mat4_fromRotationTranslation(view, orientation, position);
          if (offset)
            mat4_translate(view, view, offset);
          mat4_invert(view, view);
        }
        return function(frameData, pose, vrDisplay) {
          if (!frameData || !pose)
            return false;
          frameData.pose = pose;
          frameData.timestamp = pose.timestamp;
          updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay._getFieldOfView("left"), vrDisplay._getEyeOffset("left"), vrDisplay);
          updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay._getFieldOfView("right"), vrDisplay._getEyeOffset("right"), vrDisplay);
          return true;
        };
      }();
      var isInsideCrossOriginIFrame = function isInsideCrossOriginIFrame2() {
        var isFramed = window.self !== window.top;
        var refOrigin = getOriginFromUrl(document.referrer);
        var thisOrigin = getOriginFromUrl(window.location.href);
        return isFramed && refOrigin !== thisOrigin;
      };
      var getOriginFromUrl = function getOriginFromUrl2(url2) {
        var domainIdx;
        var protoSepIdx = url2.indexOf("://");
        if (protoSepIdx !== -1) {
          domainIdx = protoSepIdx + 3;
        } else {
          domainIdx = 0;
        }
        var domainEndIdx = url2.indexOf("/", domainIdx);
        if (domainEndIdx === -1) {
          domainEndIdx = url2.length;
        }
        return url2.substring(0, domainEndIdx);
      };
      var getQuaternionAngle = function getQuaternionAngle2(quat) {
        if (quat.w > 1) {
          console.warn("getQuaternionAngle: w > 1");
          return 0;
        }
        var angle5 = 2 * Math.acos(quat.w);
        return angle5;
      };
      var warnOnce = function() {
        var observedWarnings = {};
        return function(key, message2) {
          if (observedWarnings[key] === void 0) {
            console.warn("webvr-polyfill: " + message2);
            observedWarnings[key] = true;
          }
        };
      }();
      var deprecateWarning = function deprecateWarning2(deprecated, suggested) {
        var alternative = suggested ? "Please use " + suggested + " instead." : "";
        warnOnce(deprecated, deprecated + " has been deprecated. This may not work on native WebVR displays. " + alternative);
      };
      function WGLUPreserveGLState(gl, bindings, callback) {
        if (!bindings) {
          callback(gl);
          return;
        }
        var boundValues = [];
        var activeTexture = null;
        for (var i = 0; i < bindings.length; ++i) {
          var binding = bindings[i];
          switch (binding) {
            case gl.TEXTURE_BINDING_2D:
            case gl.TEXTURE_BINDING_CUBE_MAP:
              var textureUnit = bindings[++i];
              if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
                console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
                boundValues.push(null, null);
                break;
              }
              if (!activeTexture) {
                activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
              }
              gl.activeTexture(textureUnit);
              boundValues.push(gl.getParameter(binding), null);
              break;
            case gl.ACTIVE_TEXTURE:
              activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
              boundValues.push(null);
              break;
            default:
              boundValues.push(gl.getParameter(binding));
              break;
          }
        }
        callback(gl);
        for (var i = 0; i < bindings.length; ++i) {
          var binding = bindings[i];
          var boundValue = boundValues[i];
          switch (binding) {
            case gl.ACTIVE_TEXTURE:
              break;
            case gl.ARRAY_BUFFER_BINDING:
              gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
              break;
            case gl.COLOR_CLEAR_VALUE:
              gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
              break;
            case gl.COLOR_WRITEMASK:
              gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
              break;
            case gl.CURRENT_PROGRAM:
              gl.useProgram(boundValue);
              break;
            case gl.ELEMENT_ARRAY_BUFFER_BINDING:
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
              break;
            case gl.FRAMEBUFFER_BINDING:
              gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
              break;
            case gl.RENDERBUFFER_BINDING:
              gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
              break;
            case gl.TEXTURE_BINDING_2D:
              var textureUnit = bindings[++i];
              if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                break;
              gl.activeTexture(textureUnit);
              gl.bindTexture(gl.TEXTURE_2D, boundValue);
              break;
            case gl.TEXTURE_BINDING_CUBE_MAP:
              var textureUnit = bindings[++i];
              if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
                break;
              gl.activeTexture(textureUnit);
              gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
              break;
            case gl.VIEWPORT:
              gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
              break;
            case gl.BLEND:
            case gl.CULL_FACE:
            case gl.DEPTH_TEST:
            case gl.SCISSOR_TEST:
            case gl.STENCIL_TEST:
              if (boundValue) {
                gl.enable(binding);
              } else {
                gl.disable(binding);
              }
              break;
            default:
              console.log("No GL restore behavior for 0x" + binding.toString(16));
              break;
          }
          if (activeTexture) {
            gl.activeTexture(activeTexture);
          }
        }
      }
      var glPreserveState = WGLUPreserveGLState;
      var distortionVS = ["attribute vec2 position;", "attribute vec3 texCoord;", "varying vec2 vTexCoord;", "uniform vec4 viewportOffsetScale[2];", "void main() {", "  vec4 viewport = viewportOffsetScale[int(texCoord.z)];", "  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;", "  gl_Position = vec4( position, 1.0, 1.0 );", "}"].join("\n");
      var distortionFS = ["precision mediump float;", "uniform sampler2D diffuse;", "varying vec2 vTexCoord;", "void main() {", "  gl_FragColor = texture2D(diffuse, vTexCoord);", "}"].join("\n");
      function CardboardDistorter(gl, cardboardUI, bufferScale, dirtySubmitFrameBindings) {
        this.gl = gl;
        this.cardboardUI = cardboardUI;
        this.bufferScale = bufferScale;
        this.dirtySubmitFrameBindings = dirtySubmitFrameBindings;
        this.ctxAttribs = gl.getContextAttributes();
        this.instanceExt = gl.getExtension("ANGLE_instanced_arrays");
        this.meshWidth = 20;
        this.meshHeight = 20;
        this.bufferWidth = gl.drawingBufferWidth;
        this.bufferHeight = gl.drawingBufferHeight;
        this.realBindFramebuffer = gl.bindFramebuffer;
        this.realEnable = gl.enable;
        this.realDisable = gl.disable;
        this.realColorMask = gl.colorMask;
        this.realClearColor = gl.clearColor;
        this.realViewport = gl.viewport;
        if (!isIOS2()) {
          this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "width");
          this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, "height");
        }
        this.isPatched = false;
        this.lastBoundFramebuffer = null;
        this.cullFace = false;
        this.depthTest = false;
        this.blend = false;
        this.scissorTest = false;
        this.stencilTest = false;
        this.viewport = [0, 0, 0, 0];
        this.colorMask = [true, true, true, true];
        this.clearColor = [0, 0, 0, 0];
        this.attribs = {
          position: 0,
          texCoord: 1
        };
        this.program = linkProgram(gl, distortionVS, distortionFS, this.attribs);
        this.uniforms = getProgramUniforms(gl, this.program);
        this.viewportOffsetScale = new Float32Array(8);
        this.setTextureBounds();
        this.vertexBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        this.indexCount = 0;
        this.renderTarget = gl.createTexture();
        this.framebuffer = gl.createFramebuffer();
        this.depthStencilBuffer = null;
        this.depthBuffer = null;
        this.stencilBuffer = null;
        if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
          this.depthStencilBuffer = gl.createRenderbuffer();
        } else if (this.ctxAttribs.depth) {
          this.depthBuffer = gl.createRenderbuffer();
        } else if (this.ctxAttribs.stencil) {
          this.stencilBuffer = gl.createRenderbuffer();
        }
        this.patch();
        this.onResize();
      }
      CardboardDistorter.prototype.destroy = function() {
        var gl = this.gl;
        this.unpatch();
        gl.deleteProgram(this.program);
        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.indexBuffer);
        gl.deleteTexture(this.renderTarget);
        gl.deleteFramebuffer(this.framebuffer);
        if (this.depthStencilBuffer) {
          gl.deleteRenderbuffer(this.depthStencilBuffer);
        }
        if (this.depthBuffer) {
          gl.deleteRenderbuffer(this.depthBuffer);
        }
        if (this.stencilBuffer) {
          gl.deleteRenderbuffer(this.stencilBuffer);
        }
        if (this.cardboardUI) {
          this.cardboardUI.destroy();
        }
      };
      CardboardDistorter.prototype.onResize = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.RENDERBUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0];
        glPreserveState(gl, glState, function(gl2) {
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
          if (self2.scissorTest) {
            self2.realDisable.call(gl2, gl2.SCISSOR_TEST);
          }
          self2.realColorMask.call(gl2, true, true, true, true);
          self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
          self2.realClearColor.call(gl2, 0, 0, 0, 1);
          gl2.clear(gl2.COLOR_BUFFER_BIT);
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.framebuffer);
          gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget);
          gl2.texImage2D(gl2.TEXTURE_2D, 0, self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB, self2.bufferWidth, self2.bufferHeight, 0, self2.ctxAttribs.alpha ? gl2.RGBA : gl2.RGB, gl2.UNSIGNED_BYTE, null);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MAG_FILTER, gl2.LINEAR);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_MIN_FILTER, gl2.LINEAR);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_S, gl2.CLAMP_TO_EDGE);
          gl2.texParameteri(gl2.TEXTURE_2D, gl2.TEXTURE_WRAP_T, gl2.CLAMP_TO_EDGE);
          gl2.framebufferTexture2D(gl2.FRAMEBUFFER, gl2.COLOR_ATTACHMENT0, gl2.TEXTURE_2D, self2.renderTarget, 0);
          if (self2.ctxAttribs.depth && self2.ctxAttribs.stencil) {
            gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthStencilBuffer);
            gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_STENCIL, self2.bufferWidth, self2.bufferHeight);
            gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_STENCIL_ATTACHMENT, gl2.RENDERBUFFER, self2.depthStencilBuffer);
          } else if (self2.ctxAttribs.depth) {
            gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.depthBuffer);
            gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.DEPTH_COMPONENT16, self2.bufferWidth, self2.bufferHeight);
            gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.DEPTH_ATTACHMENT, gl2.RENDERBUFFER, self2.depthBuffer);
          } else if (self2.ctxAttribs.stencil) {
            gl2.bindRenderbuffer(gl2.RENDERBUFFER, self2.stencilBuffer);
            gl2.renderbufferStorage(gl2.RENDERBUFFER, gl2.STENCIL_INDEX8, self2.bufferWidth, self2.bufferHeight);
            gl2.framebufferRenderbuffer(gl2.FRAMEBUFFER, gl2.STENCIL_ATTACHMENT, gl2.RENDERBUFFER, self2.stencilBuffer);
          }
          if (!gl2.checkFramebufferStatus(gl2.FRAMEBUFFER) === gl2.FRAMEBUFFER_COMPLETE) {
            console.error("Framebuffer incomplete!");
          }
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer);
          if (self2.scissorTest) {
            self2.realEnable.call(gl2, gl2.SCISSOR_TEST);
          }
          self2.realColorMask.apply(gl2, self2.colorMask);
          self2.realViewport.apply(gl2, self2.viewport);
          self2.realClearColor.apply(gl2, self2.clearColor);
        });
        if (this.cardboardUI) {
          this.cardboardUI.onResize();
        }
      };
      CardboardDistorter.prototype.patch = function() {
        if (this.isPatched) {
          return;
        }
        var self2 = this;
        var canvas = this.gl.canvas;
        var gl = this.gl;
        if (!isIOS2()) {
          canvas.width = getScreenWidth() * this.bufferScale;
          canvas.height = getScreenHeight() * this.bufferScale;
          Object.defineProperty(canvas, "width", {
            configurable: true,
            enumerable: true,
            get: function get() {
              return self2.bufferWidth;
            },
            set: function set7(value2) {
              self2.bufferWidth = value2;
              self2.realCanvasWidth.set.call(canvas, value2);
              self2.onResize();
            }
          });
          Object.defineProperty(canvas, "height", {
            configurable: true,
            enumerable: true,
            get: function get() {
              return self2.bufferHeight;
            },
            set: function set7(value2) {
              self2.bufferHeight = value2;
              self2.realCanvasHeight.set.call(canvas, value2);
              self2.onResize();
            }
          });
        }
        this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
        if (this.lastBoundFramebuffer == null) {
          this.lastBoundFramebuffer = this.framebuffer;
          this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        }
        this.gl.bindFramebuffer = function(target, framebuffer) {
          self2.lastBoundFramebuffer = framebuffer ? framebuffer : self2.framebuffer;
          self2.realBindFramebuffer.call(gl, target, self2.lastBoundFramebuffer);
        };
        this.cullFace = gl.getParameter(gl.CULL_FACE);
        this.depthTest = gl.getParameter(gl.DEPTH_TEST);
        this.blend = gl.getParameter(gl.BLEND);
        this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
        this.stencilTest = gl.getParameter(gl.STENCIL_TEST);
        gl.enable = function(pname) {
          switch (pname) {
            case gl.CULL_FACE:
              self2.cullFace = true;
              break;
            case gl.DEPTH_TEST:
              self2.depthTest = true;
              break;
            case gl.BLEND:
              self2.blend = true;
              break;
            case gl.SCISSOR_TEST:
              self2.scissorTest = true;
              break;
            case gl.STENCIL_TEST:
              self2.stencilTest = true;
              break;
          }
          self2.realEnable.call(gl, pname);
        };
        gl.disable = function(pname) {
          switch (pname) {
            case gl.CULL_FACE:
              self2.cullFace = false;
              break;
            case gl.DEPTH_TEST:
              self2.depthTest = false;
              break;
            case gl.BLEND:
              self2.blend = false;
              break;
            case gl.SCISSOR_TEST:
              self2.scissorTest = false;
              break;
            case gl.STENCIL_TEST:
              self2.stencilTest = false;
              break;
          }
          self2.realDisable.call(gl, pname);
        };
        this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
        gl.colorMask = function(r, g, b, a) {
          self2.colorMask[0] = r;
          self2.colorMask[1] = g;
          self2.colorMask[2] = b;
          self2.colorMask[3] = a;
          self2.realColorMask.call(gl, r, g, b, a);
        };
        this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
        gl.clearColor = function(r, g, b, a) {
          self2.clearColor[0] = r;
          self2.clearColor[1] = g;
          self2.clearColor[2] = b;
          self2.clearColor[3] = a;
          self2.realClearColor.call(gl, r, g, b, a);
        };
        this.viewport = gl.getParameter(gl.VIEWPORT);
        gl.viewport = function(x, y, w, h) {
          self2.viewport[0] = x;
          self2.viewport[1] = y;
          self2.viewport[2] = w;
          self2.viewport[3] = h;
          self2.realViewport.call(gl, x, y, w, h);
        };
        this.isPatched = true;
        safariCssSizeWorkaround(canvas);
      };
      CardboardDistorter.prototype.unpatch = function() {
        if (!this.isPatched) {
          return;
        }
        var gl = this.gl;
        var canvas = this.gl.canvas;
        if (!isIOS2()) {
          Object.defineProperty(canvas, "width", this.realCanvasWidth);
          Object.defineProperty(canvas, "height", this.realCanvasHeight);
        }
        canvas.width = this.bufferWidth;
        canvas.height = this.bufferHeight;
        gl.bindFramebuffer = this.realBindFramebuffer;
        gl.enable = this.realEnable;
        gl.disable = this.realDisable;
        gl.colorMask = this.realColorMask;
        gl.clearColor = this.realClearColor;
        gl.viewport = this.realViewport;
        if (this.lastBoundFramebuffer == this.framebuffer) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }
        this.isPatched = false;
        setTimeout(function() {
          safariCssSizeWorkaround(canvas);
        }, 1);
      };
      CardboardDistorter.prototype.setTextureBounds = function(leftBounds, rightBounds) {
        if (!leftBounds) {
          leftBounds = [0, 0, 0.5, 1];
        }
        if (!rightBounds) {
          rightBounds = [0.5, 0, 0.5, 1];
        }
        this.viewportOffsetScale[0] = leftBounds[0];
        this.viewportOffsetScale[1] = leftBounds[1];
        this.viewportOffsetScale[2] = leftBounds[2];
        this.viewportOffsetScale[3] = leftBounds[3];
        this.viewportOffsetScale[4] = rightBounds[0];
        this.viewportOffsetScale[5] = rightBounds[1];
        this.viewportOffsetScale[6] = rightBounds[2];
        this.viewportOffsetScale[7] = rightBounds[3];
      };
      CardboardDistorter.prototype.submitFrame = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [];
        if (!this.dirtySubmitFrameBindings) {
          glState.push(gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0);
        }
        glPreserveState(gl, glState, function(gl2) {
          self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, null);
          var positionDivisor = 0;
          var texCoordDivisor = 0;
          if (self2.instanceExt) {
            positionDivisor = gl2.getVertexAttrib(self2.attribs.position, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
            texCoordDivisor = gl2.getVertexAttrib(self2.attribs.texCoord, self2.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
          }
          if (self2.cullFace) {
            self2.realDisable.call(gl2, gl2.CULL_FACE);
          }
          if (self2.depthTest) {
            self2.realDisable.call(gl2, gl2.DEPTH_TEST);
          }
          if (self2.blend) {
            self2.realDisable.call(gl2, gl2.BLEND);
          }
          if (self2.scissorTest) {
            self2.realDisable.call(gl2, gl2.SCISSOR_TEST);
          }
          if (self2.stencilTest) {
            self2.realDisable.call(gl2, gl2.STENCIL_TEST);
          }
          self2.realColorMask.call(gl2, true, true, true, true);
          self2.realViewport.call(gl2, 0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
          if (self2.ctxAttribs.alpha || isIOS2()) {
            self2.realClearColor.call(gl2, 0, 0, 0, 1);
            gl2.clear(gl2.COLOR_BUFFER_BIT);
          }
          gl2.useProgram(self2.program);
          gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
          gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
          gl2.enableVertexAttribArray(self2.attribs.position);
          gl2.enableVertexAttribArray(self2.attribs.texCoord);
          gl2.vertexAttribPointer(self2.attribs.position, 2, gl2.FLOAT, false, 20, 0);
          gl2.vertexAttribPointer(self2.attribs.texCoord, 3, gl2.FLOAT, false, 20, 8);
          if (self2.instanceExt) {
            if (positionDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, 0);
            }
            if (texCoordDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, 0);
            }
          }
          gl2.activeTexture(gl2.TEXTURE0);
          gl2.uniform1i(self2.uniforms.diffuse, 0);
          gl2.bindTexture(gl2.TEXTURE_2D, self2.renderTarget);
          gl2.uniform4fv(self2.uniforms.viewportOffsetScale, self2.viewportOffsetScale);
          gl2.drawElements(gl2.TRIANGLES, self2.indexCount, gl2.UNSIGNED_SHORT, 0);
          if (self2.cardboardUI) {
            self2.cardboardUI.renderNoState();
          }
          self2.realBindFramebuffer.call(self2.gl, gl2.FRAMEBUFFER, self2.framebuffer);
          if (!self2.ctxAttribs.preserveDrawingBuffer) {
            self2.realClearColor.call(gl2, 0, 0, 0, 0);
            gl2.clear(gl2.COLOR_BUFFER_BIT);
          }
          if (!self2.dirtySubmitFrameBindings) {
            self2.realBindFramebuffer.call(gl2, gl2.FRAMEBUFFER, self2.lastBoundFramebuffer);
          }
          if (self2.cullFace) {
            self2.realEnable.call(gl2, gl2.CULL_FACE);
          }
          if (self2.depthTest) {
            self2.realEnable.call(gl2, gl2.DEPTH_TEST);
          }
          if (self2.blend) {
            self2.realEnable.call(gl2, gl2.BLEND);
          }
          if (self2.scissorTest) {
            self2.realEnable.call(gl2, gl2.SCISSOR_TEST);
          }
          if (self2.stencilTest) {
            self2.realEnable.call(gl2, gl2.STENCIL_TEST);
          }
          self2.realColorMask.apply(gl2, self2.colorMask);
          self2.realViewport.apply(gl2, self2.viewport);
          if (self2.ctxAttribs.alpha || !self2.ctxAttribs.preserveDrawingBuffer) {
            self2.realClearColor.apply(gl2, self2.clearColor);
          }
          if (self2.instanceExt) {
            if (positionDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.position, positionDivisor);
            }
            if (texCoordDivisor != 0) {
              self2.instanceExt.vertexAttribDivisorANGLE(self2.attribs.texCoord, texCoordDivisor);
            }
          }
        });
        if (isIOS2()) {
          var canvas = gl.canvas;
          if (canvas.width != self2.bufferWidth || canvas.height != self2.bufferHeight) {
            self2.bufferWidth = canvas.width;
            self2.bufferHeight = canvas.height;
            self2.onResize();
          }
        }
      };
      CardboardDistorter.prototype.updateDeviceInfo = function(deviceInfo) {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
        glPreserveState(gl, glState, function(gl2) {
          var vertices = self2.computeMeshVertices_(self2.meshWidth, self2.meshHeight, deviceInfo);
          gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
          gl2.bufferData(gl2.ARRAY_BUFFER, vertices, gl2.STATIC_DRAW);
          if (!self2.indexCount) {
            var indices = self2.computeMeshIndices_(self2.meshWidth, self2.meshHeight);
            gl2.bindBuffer(gl2.ELEMENT_ARRAY_BUFFER, self2.indexBuffer);
            gl2.bufferData(gl2.ELEMENT_ARRAY_BUFFER, indices, gl2.STATIC_DRAW);
            self2.indexCount = indices.length;
          }
        });
      };
      CardboardDistorter.prototype.computeMeshVertices_ = function(width2, height2, deviceInfo) {
        var vertices = new Float32Array(2 * width2 * height2 * 5);
        var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
        var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
        var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
        var vidx = 0;
        for (var e2 = 0; e2 < 2; e2++) {
          for (var j = 0; j < height2; j++) {
            for (var i = 0; i < width2; i++, vidx++) {
              var u2 = i / (width2 - 1);
              var v = j / (height2 - 1);
              var s = u2;
              var t2 = v;
              var x = lerp8(lensFrustum[0], lensFrustum[2], u2);
              var y = lerp8(lensFrustum[3], lensFrustum[1], v);
              var d = Math.sqrt(x * x + y * y);
              var r = deviceInfo.distortion.distortInverse(d);
              var p = x * r / d;
              var q = y * r / d;
              u2 = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
              v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
              u2 = (viewport.x + u2 * viewport.width - 0.5) * 2;
              v = (viewport.y + v * viewport.height - 0.5) * 2;
              vertices[vidx * 5 + 0] = u2;
              vertices[vidx * 5 + 1] = v;
              vertices[vidx * 5 + 2] = s;
              vertices[vidx * 5 + 3] = t2;
              vertices[vidx * 5 + 4] = e2;
            }
          }
          var w = lensFrustum[2] - lensFrustum[0];
          lensFrustum[0] = -(w + lensFrustum[0]);
          lensFrustum[2] = w - lensFrustum[2];
          w = noLensFrustum[2] - noLensFrustum[0];
          noLensFrustum[0] = -(w + noLensFrustum[0]);
          noLensFrustum[2] = w - noLensFrustum[2];
          viewport.x = 1 - (viewport.x + viewport.width);
        }
        return vertices;
      };
      CardboardDistorter.prototype.computeMeshIndices_ = function(width2, height2) {
        var indices = new Uint16Array(2 * (width2 - 1) * (height2 - 1) * 6);
        var halfwidth = width2 / 2;
        var halfheight = height2 / 2;
        var vidx = 0;
        var iidx = 0;
        for (var e2 = 0; e2 < 2; e2++) {
          for (var j = 0; j < height2; j++) {
            for (var i = 0; i < width2; i++, vidx++) {
              if (i == 0 || j == 0)
                continue;
              if (i <= halfwidth == j <= halfheight) {
                indices[iidx++] = vidx;
                indices[iidx++] = vidx - width2 - 1;
                indices[iidx++] = vidx - width2;
                indices[iidx++] = vidx - width2 - 1;
                indices[iidx++] = vidx;
                indices[iidx++] = vidx - 1;
              } else {
                indices[iidx++] = vidx - 1;
                indices[iidx++] = vidx - width2;
                indices[iidx++] = vidx;
                indices[iidx++] = vidx - width2;
                indices[iidx++] = vidx - 1;
                indices[iidx++] = vidx - width2 - 1;
              }
            }
          }
        }
        return indices;
      };
      CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function(proto, attrName) {
        var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
        if (descriptor.get === void 0 || descriptor.set === void 0) {
          descriptor.configurable = true;
          descriptor.enumerable = true;
          descriptor.get = function() {
            return this.getAttribute(attrName);
          };
          descriptor.set = function(val) {
            this.setAttribute(attrName, val);
          };
        }
        return descriptor;
      };
      var uiVS = ["attribute vec2 position;", "uniform mat4 projectionMat;", "void main() {", "  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );", "}"].join("\n");
      var uiFS = ["precision mediump float;", "uniform vec4 color;", "void main() {", "  gl_FragColor = color;", "}"].join("\n");
      var DEG2RAD = Math.PI / 180;
      var kAnglePerGearSection = 60;
      var kOuterRimEndAngle = 12;
      var kInnerRimBeginAngle = 20;
      var kOuterRadius = 1;
      var kMiddleRadius = 0.75;
      var kInnerRadius = 0.3125;
      var kCenterLineThicknessDp = 4;
      var kButtonWidthDp = 28;
      var kTouchSlopFactor = 1.5;
      function CardboardUI(gl) {
        this.gl = gl;
        this.attribs = {
          position: 0
        };
        this.program = linkProgram(gl, uiVS, uiFS, this.attribs);
        this.uniforms = getProgramUniforms(gl, this.program);
        this.vertexBuffer = gl.createBuffer();
        this.gearOffset = 0;
        this.gearVertexCount = 0;
        this.arrowOffset = 0;
        this.arrowVertexCount = 0;
        this.projMat = new Float32Array(16);
        this.listener = null;
        this.onResize();
      }
      CardboardUI.prototype.destroy = function() {
        var gl = this.gl;
        if (this.listener) {
          gl.canvas.removeEventListener("click", this.listener, false);
        }
        gl.deleteProgram(this.program);
        gl.deleteBuffer(this.vertexBuffer);
      };
      CardboardUI.prototype.listen = function(optionsCallback, backCallback) {
        var canvas = this.gl.canvas;
        this.listener = function(event) {
          var midline = canvas.clientWidth / 2;
          var buttonSize = kButtonWidthDp * kTouchSlopFactor;
          if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize) {
            optionsCallback(event);
          } else if (event.clientX < buttonSize && event.clientY < buttonSize) {
            backCallback(event);
          }
        };
        canvas.addEventListener("click", this.listener, false);
      };
      CardboardUI.prototype.onResize = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.ARRAY_BUFFER_BINDING];
        glPreserveState(gl, glState, function(gl2) {
          var vertices = [];
          var midline = gl2.drawingBufferWidth / 2;
          var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
          var scalingRatio = gl2.drawingBufferWidth / physicalPixels;
          var dps = scalingRatio * window.devicePixelRatio;
          var lineWidth = kCenterLineThicknessDp * dps / 2;
          var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
          var buttonScale = kButtonWidthDp * dps / 2;
          var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
          vertices.push(midline - lineWidth, buttonSize);
          vertices.push(midline - lineWidth, gl2.drawingBufferHeight);
          vertices.push(midline + lineWidth, buttonSize);
          vertices.push(midline + lineWidth, gl2.drawingBufferHeight);
          self2.gearOffset = vertices.length / 2;
          function addGearSegment(theta, r) {
            var angle5 = (90 - theta) * DEG2RAD;
            var x = Math.cos(angle5);
            var y = Math.sin(angle5);
            vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
            vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
          }
          for (var i = 0; i <= 6; i++) {
            var segmentTheta = i * kAnglePerGearSection;
            addGearSegment(segmentTheta, kOuterRadius);
            addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
            addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
            addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
            addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
          }
          self2.gearVertexCount = vertices.length / 2 - self2.gearOffset;
          self2.arrowOffset = vertices.length / 2;
          function addArrowVertex(x, y) {
            vertices.push(buttonBorder + x, gl2.drawingBufferHeight - buttonBorder - y);
          }
          var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
          addArrowVertex(0, buttonScale);
          addArrowVertex(buttonScale, 0);
          addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
          addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
          addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
          addArrowVertex(0, buttonScale);
          addArrowVertex(buttonScale, buttonScale * 2);
          addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);
          addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
          addArrowVertex(0, buttonScale);
          addArrowVertex(angledLineWidth, buttonScale - lineWidth);
          addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
          addArrowVertex(angledLineWidth, buttonScale + lineWidth);
          addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
          self2.arrowVertexCount = vertices.length / 2 - self2.arrowOffset;
          gl2.bindBuffer(gl2.ARRAY_BUFFER, self2.vertexBuffer);
          gl2.bufferData(gl2.ARRAY_BUFFER, new Float32Array(vertices), gl2.STATIC_DRAW);
        });
      };
      CardboardUI.prototype.render = function() {
        var gl = this.gl;
        var self2 = this;
        var glState = [gl.CULL_FACE, gl.DEPTH_TEST, gl.BLEND, gl.SCISSOR_TEST, gl.STENCIL_TEST, gl.COLOR_WRITEMASK, gl.VIEWPORT, gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING];
        glPreserveState(gl, glState, function(gl2) {
          gl2.disable(gl2.CULL_FACE);
          gl2.disable(gl2.DEPTH_TEST);
          gl2.disable(gl2.BLEND);
          gl2.disable(gl2.SCISSOR_TEST);
          gl2.disable(gl2.STENCIL_TEST);
          gl2.colorMask(true, true, true, true);
          gl2.viewport(0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight);
          self2.renderNoState();
        });
      };
      CardboardUI.prototype.renderNoState = function() {
        var gl = this.gl;
        gl.useProgram(this.program);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.enableVertexAttribArray(this.attribs.position);
        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);
        gl.uniform4f(this.uniforms.color, 1, 1, 1, 1);
        orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024);
        gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
        gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
      };
      function Distortion(coefficients) {
        this.coefficients = coefficients;
      }
      Distortion.prototype.distortInverse = function(radius2) {
        var r0 = 0;
        var r1 = 1;
        var dr0 = radius2 - this.distort(r0);
        while (Math.abs(r1 - r0) > 1e-4) {
          var dr1 = radius2 - this.distort(r1);
          var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
          r0 = r1;
          r1 = r2;
          dr0 = dr1;
        }
        return r1;
      };
      Distortion.prototype.distort = function(radius2) {
        var r2 = radius2 * radius2;
        var ret = 0;
        for (var i = 0; i < this.coefficients.length; i++) {
          ret = r2 * (ret + this.coefficients[i]);
        }
        return (ret + 1) * radius2;
      };
      var degToRad = Math.PI / 180;
      var radToDeg = 180 / Math.PI;
      var Vector34 = function Vector35(x, y, z) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
      };
      Vector34.prototype = {
        constructor: Vector34,
        set: function set7(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
          return this;
        },
        copy: function copy10(v) {
          this.x = v.x;
          this.y = v.y;
          this.z = v.z;
          return this;
        },
        length: function length8() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        },
        normalize: function normalize9() {
          var scalar = this.length();
          if (scalar !== 0) {
            var invScalar = 1 / scalar;
            this.multiplyScalar(invScalar);
          } else {
            this.x = 0;
            this.y = 0;
            this.z = 0;
          }
          return this;
        },
        multiplyScalar: function multiplyScalar(scalar) {
          this.x *= scalar;
          this.y *= scalar;
          this.z *= scalar;
        },
        applyQuaternion: function applyQuaternion(q) {
          var x = this.x;
          var y = this.y;
          var z = this.z;
          var qx = q.x;
          var qy = q.y;
          var qz = q.z;
          var qw = q.w;
          var ix = qw * x + qy * z - qz * y;
          var iy = qw * y + qz * x - qx * z;
          var iz = qw * z + qx * y - qy * x;
          var iw = -qx * x - qy * y - qz * z;
          this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
          this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
          this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
          return this;
        },
        dot: function dot8(v) {
          return this.x * v.x + this.y * v.y + this.z * v.z;
        },
        crossVectors: function crossVectors(a, b) {
          var ax = a.x, ay = a.y, az = a.z;
          var bx = b.x, by = b.y, bz = b.z;
          this.x = ay * bz - az * by;
          this.y = az * bx - ax * bz;
          this.z = ax * by - ay * bx;
          return this;
        }
      };
      var Quaternion2 = function Quaternion3(x, y, z, w) {
        this.x = x || 0;
        this.y = y || 0;
        this.z = z || 0;
        this.w = w !== void 0 ? w : 1;
      };
      Quaternion2.prototype = {
        constructor: Quaternion2,
        set: function set7(x, y, z, w) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          return this;
        },
        copy: function copy10(quaternion) {
          this.x = quaternion.x;
          this.y = quaternion.y;
          this.z = quaternion.z;
          this.w = quaternion.w;
          return this;
        },
        setFromEulerXYZ: function setFromEulerXYZ(x, y, z) {
          var c1 = Math.cos(x / 2);
          var c2 = Math.cos(y / 2);
          var c3 = Math.cos(z / 2);
          var s1 = Math.sin(x / 2);
          var s2 = Math.sin(y / 2);
          var s3 = Math.sin(z / 2);
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 + s1 * s2 * c3;
          this.w = c1 * c2 * c3 - s1 * s2 * s3;
          return this;
        },
        setFromEulerYXZ: function setFromEulerYXZ(x, y, z) {
          var c1 = Math.cos(x / 2);
          var c2 = Math.cos(y / 2);
          var c3 = Math.cos(z / 2);
          var s1 = Math.sin(x / 2);
          var s2 = Math.sin(y / 2);
          var s3 = Math.sin(z / 2);
          this.x = s1 * c2 * c3 + c1 * s2 * s3;
          this.y = c1 * s2 * c3 - s1 * c2 * s3;
          this.z = c1 * c2 * s3 - s1 * s2 * c3;
          this.w = c1 * c2 * c3 + s1 * s2 * s3;
          return this;
        },
        setFromAxisAngle: function setFromAxisAngle(axis, angle5) {
          var halfAngle = angle5 / 2, s = Math.sin(halfAngle);
          this.x = axis.x * s;
          this.y = axis.y * s;
          this.z = axis.z * s;
          this.w = Math.cos(halfAngle);
          return this;
        },
        multiply: function multiply7(q) {
          return this.multiplyQuaternions(this, q);
        },
        multiplyQuaternions: function multiplyQuaternions(a, b) {
          var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
          var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;
          this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
          this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
          this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
          this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
          return this;
        },
        inverse: function inverse4() {
          this.x *= -1;
          this.y *= -1;
          this.z *= -1;
          this.normalize();
          return this;
        },
        normalize: function normalize9() {
          var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
          if (l === 0) {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
          } else {
            l = 1 / l;
            this.x = this.x * l;
            this.y = this.y * l;
            this.z = this.z * l;
            this.w = this.w * l;
          }
          return this;
        },
        slerp: function slerp3(qb, t2) {
          if (t2 === 0)
            return this;
          if (t2 === 1)
            return this.copy(qb);
          var x = this.x, y = this.y, z = this.z, w = this.w;
          var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
          if (cosHalfTheta < 0) {
            this.w = -qb.w;
            this.x = -qb.x;
            this.y = -qb.y;
            this.z = -qb.z;
            cosHalfTheta = -cosHalfTheta;
          } else {
            this.copy(qb);
          }
          if (cosHalfTheta >= 1) {
            this.w = w;
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
          }
          var halfTheta = Math.acos(cosHalfTheta);
          var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
          if (Math.abs(sinHalfTheta) < 1e-3) {
            this.w = 0.5 * (w + this.w);
            this.x = 0.5 * (x + this.x);
            this.y = 0.5 * (y + this.y);
            this.z = 0.5 * (z + this.z);
            return this;
          }
          var ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
          this.w = w * ratioA + this.w * ratioB;
          this.x = x * ratioA + this.x * ratioB;
          this.y = y * ratioA + this.y * ratioB;
          this.z = z * ratioA + this.z * ratioB;
          return this;
        },
        setFromUnitVectors: function() {
          var v1, r;
          var EPS = 1e-6;
          return function(vFrom, vTo) {
            if (v1 === void 0)
              v1 = new Vector34();
            r = vFrom.dot(vTo) + 1;
            if (r < EPS) {
              r = 0;
              if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                v1.set(-vFrom.y, vFrom.x, 0);
              } else {
                v1.set(0, -vFrom.z, vFrom.y);
              }
            } else {
              v1.crossVectors(vFrom, vTo);
            }
            this.x = v1.x;
            this.y = v1.y;
            this.z = v1.z;
            this.w = r;
            this.normalize();
            return this;
          };
        }()
      };
      function Device(params) {
        this.width = params.width || getScreenWidth();
        this.height = params.height || getScreenHeight();
        this.widthMeters = params.widthMeters;
        this.heightMeters = params.heightMeters;
        this.bevelMeters = params.bevelMeters;
      }
      var DEFAULT_ANDROID = new Device({
        widthMeters: 0.11,
        heightMeters: 0.062,
        bevelMeters: 4e-3
      });
      var DEFAULT_IOS = new Device({
        widthMeters: 0.1038,
        heightMeters: 0.0584,
        bevelMeters: 4e-3
      });
      var Viewers = {
        CardboardV1: new CardboardViewer({
          id: "CardboardV1",
          label: "Cardboard I/O 2014",
          fov: 40,
          interLensDistance: 0.06,
          baselineLensDistance: 0.035,
          screenLensDistance: 0.042,
          distortionCoefficients: [0.441, 0.156],
          inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 1559834e-9]
        }),
        CardboardV2: new CardboardViewer({
          id: "CardboardV2",
          label: "Cardboard I/O 2015",
          fov: 60,
          interLensDistance: 0.064,
          baselineLensDistance: 0.035,
          screenLensDistance: 0.039,
          distortionCoefficients: [0.34, 0.55],
          inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 9177956e-9, -9904169e-10, 6183535e-11, -16981803e-13]
        })
      };
      function DeviceInfo(deviceParams, additionalViewers) {
        this.viewer = Viewers.CardboardV2;
        this.updateDeviceParams(deviceParams);
        this.distortion = new Distortion(this.viewer.distortionCoefficients);
        for (var i = 0; i < additionalViewers.length; i++) {
          var viewer = additionalViewers[i];
          Viewers[viewer.id] = new CardboardViewer(viewer);
        }
      }
      DeviceInfo.prototype.updateDeviceParams = function(deviceParams) {
        this.device = this.determineDevice_(deviceParams) || this.device;
      };
      DeviceInfo.prototype.getDevice = function() {
        return this.device;
      };
      DeviceInfo.prototype.setViewer = function(viewer) {
        this.viewer = viewer;
        this.distortion = new Distortion(this.viewer.distortionCoefficients);
      };
      DeviceInfo.prototype.determineDevice_ = function(deviceParams) {
        if (!deviceParams) {
          if (isIOS2()) {
            console.warn("Using fallback iOS device measurements.");
            return DEFAULT_IOS;
          } else {
            console.warn("Using fallback Android device measurements.");
            return DEFAULT_ANDROID;
          }
        }
        var METERS_PER_INCH = 0.0254;
        var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
        var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
        var width2 = getScreenWidth();
        var height2 = getScreenHeight();
        return new Device({
          widthMeters: metersPerPixelX * width2,
          heightMeters: metersPerPixelY * height2,
          bevelMeters: deviceParams.bevelMm * 1e-3
        });
      };
      DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var eyeToScreenDistance = viewer.screenLensDistance;
        var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
        var innerDist = viewer.interLensDistance / 2;
        var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
        var topDist = device.heightMeters - bottomDist;
        var outerAngle = radToDeg * Math.atan(distortion.distort(outerDist / eyeToScreenDistance));
        var innerAngle = radToDeg * Math.atan(distortion.distort(innerDist / eyeToScreenDistance));
        var bottomAngle = radToDeg * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance));
        var topAngle = radToDeg * Math.atan(distortion.distort(topDist / eyeToScreenDistance));
        return {
          leftDegrees: Math.min(outerAngle, viewer.fov),
          rightDegrees: Math.min(innerAngle, viewer.fov),
          downDegrees: Math.min(bottomAngle, viewer.fov),
          upDegrees: Math.min(topAngle, viewer.fov)
        };
      };
      DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var fovLeft = Math.tan(-degToRad * viewer.fov);
        var fovTop = Math.tan(degToRad * viewer.fov);
        var fovRight = Math.tan(degToRad * viewer.fov);
        var fovBottom = Math.tan(-degToRad * viewer.fov);
        var halfWidth = device.widthMeters / 4;
        var halfHeight = device.heightMeters / 2;
        var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
        var centerX = viewer.interLensDistance / 2 - halfWidth;
        var centerY = -verticalLensOffset;
        var centerZ = viewer.screenLensDistance;
        var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
        var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
        var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
        var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
        var result = new Float32Array(4);
        result[0] = Math.max(fovLeft, screenLeft);
        result[1] = Math.min(fovTop, screenTop);
        result[2] = Math.min(fovRight, screenRight);
        result[3] = Math.max(fovBottom, screenBottom);
        return result;
      };
      DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var result = new Float32Array(4);
        var fovLeft = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
        var fovTop = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
        var fovRight = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
        var fovBottom = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
        var halfWidth = device.widthMeters / 4;
        var halfHeight = device.heightMeters / 2;
        var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
        var centerX = viewer.interLensDistance / 2 - halfWidth;
        var centerY = -verticalLensOffset;
        var centerZ = viewer.screenLensDistance;
        var screenLeft = (centerX - halfWidth) / centerZ;
        var screenTop = (centerY + halfHeight) / centerZ;
        var screenRight = (centerX + halfWidth) / centerZ;
        var screenBottom = (centerY - halfHeight) / centerZ;
        result[0] = Math.max(fovLeft, screenLeft);
        result[1] = Math.min(fovTop, screenTop);
        result[2] = Math.min(fovRight, screenRight);
        result[3] = Math.max(fovBottom, screenBottom);
        return result;
      };
      DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function(undistortedFrustum) {
        var viewer = this.viewer;
        var device = this.device;
        var dist4 = viewer.screenLensDistance;
        var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
        var eyeY = viewer.baselineLensDistance - device.bevelMeters;
        var left2 = (undistortedFrustum[0] * dist4 + eyeX) / device.widthMeters;
        var top2 = (undistortedFrustum[1] * dist4 + eyeY) / device.heightMeters;
        var right = (undistortedFrustum[2] * dist4 + eyeX) / device.widthMeters;
        var bottom = (undistortedFrustum[3] * dist4 + eyeY) / device.heightMeters;
        return {
          x: left2,
          y: bottom,
          width: right - left2,
          height: top2 - bottom
        };
      };
      DeviceInfo.prototype.getFieldOfViewLeftEye = function(opt_isUndistorted) {
        return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
      };
      DeviceInfo.prototype.getFieldOfViewRightEye = function(opt_isUndistorted) {
        var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
        return {
          leftDegrees: fov.rightDegrees,
          rightDegrees: fov.leftDegrees,
          upDegrees: fov.upDegrees,
          downDegrees: fov.downDegrees
        };
      };
      DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function() {
        var p = this.getUndistortedParams_();
        return {
          leftDegrees: radToDeg * Math.atan(p.outerDist),
          rightDegrees: radToDeg * Math.atan(p.innerDist),
          downDegrees: radToDeg * Math.atan(p.bottomDist),
          upDegrees: radToDeg * Math.atan(p.topDist)
        };
      };
      DeviceInfo.prototype.getUndistortedViewportLeftEye = function() {
        var p = this.getUndistortedParams_();
        var viewer = this.viewer;
        var device = this.device;
        var eyeToScreenDistance = viewer.screenLensDistance;
        var screenWidth = device.widthMeters / eyeToScreenDistance;
        var screenHeight = device.heightMeters / eyeToScreenDistance;
        var xPxPerTanAngle = device.width / screenWidth;
        var yPxPerTanAngle = device.height / screenHeight;
        var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
        var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
        return {
          x,
          y,
          width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
          height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
        };
      };
      DeviceInfo.prototype.getUndistortedParams_ = function() {
        var viewer = this.viewer;
        var device = this.device;
        var distortion = this.distortion;
        var eyeToScreenDistance = viewer.screenLensDistance;
        var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
        var screenWidth = device.widthMeters / eyeToScreenDistance;
        var screenHeight = device.heightMeters / eyeToScreenDistance;
        var eyePosX = screenWidth / 2 - halfLensDistance;
        var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
        var maxFov = viewer.fov;
        var viewerMax = distortion.distortInverse(Math.tan(degToRad * maxFov));
        var outerDist = Math.min(eyePosX, viewerMax);
        var innerDist = Math.min(halfLensDistance, viewerMax);
        var bottomDist = Math.min(eyePosY, viewerMax);
        var topDist = Math.min(screenHeight - eyePosY, viewerMax);
        return {
          outerDist,
          innerDist,
          topDist,
          bottomDist,
          eyePosX,
          eyePosY
        };
      };
      function CardboardViewer(params) {
        this.id = params.id;
        this.label = params.label;
        this.fov = params.fov;
        this.interLensDistance = params.interLensDistance;
        this.baselineLensDistance = params.baselineLensDistance;
        this.screenLensDistance = params.screenLensDistance;
        this.distortionCoefficients = params.distortionCoefficients;
        this.inverseCoefficients = params.inverseCoefficients;
      }
      DeviceInfo.Viewers = Viewers;
      var format = 1;
      var last_updated = "2019-11-09T17:36:14Z";
      var devices = [{ "type": "android", "rules": [{ "mdmh": "asus/*/Nexus 7/*" }, { "ua": "Nexus 7" }], "dpi": [320.8, 323], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_X00PD/*" }, { "ua": "ASUS_X00PD" }], "dpi": 245, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_X008D/*" }, { "ua": "ASUS_X008D" }], "dpi": 282, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "asus/*/ASUS_Z00AD/*" }, { "ua": "ASUS_Z00AD" }], "dpi": [403, 404.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 2 XL/*" }, { "ua": "Pixel 2 XL" }], "dpi": 537.9, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 3 XL/*" }, { "ua": "Pixel 3 XL" }], "dpi": [558.5, 553.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel XL/*" }, { "ua": "Pixel XL" }], "dpi": [537.9, 533], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 3/*" }, { "ua": "Pixel 3" }], "dpi": 442.4, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel 2/*" }, { "ua": "Pixel 2" }], "dpi": 441, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Google/*/Pixel/*" }, { "ua": "Pixel" }], "dpi": [432.6, 436.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC6435LVW/*" }, { "ua": "HTC6435LVW" }], "dpi": [449.7, 443.3], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One XL/*" }, { "ua": "HTC One XL" }], "dpi": [315.3, 314.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "htc/*/Nexus 9/*" }, { "ua": "Nexus 9" }], "dpi": 289, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One M9/*" }, { "ua": "HTC One M9" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One_M8/*" }, { "ua": "HTC One_M8" }], "dpi": [449.7, 447.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "HTC/*/HTC One/*" }, { "ua": "HTC One" }], "dpi": 472.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/Nexus 6P/*" }, { "ua": "Nexus 6P" }], "dpi": [515.1, 518], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/BLN-L24/*" }, { "ua": "HONORBLN-L24" }], "dpi": 480, "bw": 4, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/BKL-L09/*" }, { "ua": "BKL-L09" }], "dpi": 403, "bw": 3.47, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LENOVO/*/Lenovo PB2-690Y/*" }, { "ua": "Lenovo PB2-690Y" }], "dpi": [457.2, 454.713], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5X/*" }, { "ua": "Nexus 5X" }], "dpi": [422, 419.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS345/*" }, { "ua": "LGMS345" }], "dpi": [221.7, 219.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D800/*" }, { "ua": "LG-D800" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-D850/*" }, { "ua": "LG-D850" }], "dpi": [537.9, 541.9], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/VS985 4G/*" }, { "ua": "VS985 4G" }], "dpi": [537.9, 535.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 5/*" }, { "ua": "Nexus 5 B" }], "dpi": [442.4, 444.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/Nexus 4/*" }, { "ua": "Nexus 4" }], "dpi": [319.8, 318.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LG-P769/*" }, { "ua": "LG-P769" }], "dpi": [240.6, 247.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGMS323/*" }, { "ua": "LGMS323" }], "dpi": [206.6, 204.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "LGE/*/LGLS996/*" }, { "ua": "LGLS996" }], "dpi": [403.4, 401.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/4560MMX/*" }, { "ua": "4560MMX" }], "dpi": [240, 219.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/A250/*" }, { "ua": "Micromax A250" }], "dpi": [480, 446.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Micromax/*/Micromax AQ4501/*" }, { "ua": "Micromax AQ4501" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G5/*" }, { "ua": "Moto G (5) Plus" }], "dpi": [403.4, 403], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/DROID RAZR/*" }, { "ua": "DROID RAZR" }], "dpi": [368.1, 256.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT830C/*" }, { "ua": "XT830C" }], "dpi": [254, 255.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1021/*" }, { "ua": "XT1021" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1023/*" }, { "ua": "XT1023" }], "dpi": [254, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1028/*" }, { "ua": "XT1028" }], "dpi": [326.6, 327.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1034/*" }, { "ua": "XT1034" }], "dpi": [326.6, 328.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1053/*" }, { "ua": "XT1053" }], "dpi": [315.3, 316.1], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1562/*" }, { "ua": "XT1562" }], "dpi": [403.4, 402.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/Nexus 6/*" }, { "ua": "Nexus 6 B" }], "dpi": [494.3, 489.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1063/*" }, { "ua": "XT1063" }], "dpi": [295, 296.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1064/*" }, { "ua": "XT1064" }], "dpi": [295, 295.6], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1092/*" }, { "ua": "XT1092" }], "dpi": [422, 424.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/XT1095/*" }, { "ua": "XT1095" }], "dpi": [422, 423.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "motorola/*/G4/*" }, { "ua": "Moto G (4)" }], "dpi": 401, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/A0001/*" }, { "ua": "A0001" }], "dpi": [403.4, 401], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1001/*" }, { "ua": "ONE E1001" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1003/*" }, { "ua": "ONE E1003" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE E1005/*" }, { "ua": "ONE E1005" }], "dpi": [442.4, 441.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2001/*" }, { "ua": "ONE A2001" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2003/*" }, { "ua": "ONE A2003" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A2005/*" }, { "ua": "ONE A2005" }], "dpi": [391.9, 405.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3000/*" }, { "ua": "ONEPLUS A3000" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3003/*" }, { "ua": "ONEPLUS A3003" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A3010/*" }, { "ua": "ONEPLUS A3010" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A5000/*" }, { "ua": "ONEPLUS A5000 " }], "dpi": [403.411, 399.737], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONE A5010/*" }, { "ua": "ONEPLUS A5010" }], "dpi": [403, 400], "bw": 2, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6000/*" }, { "ua": "ONEPLUS A6000" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6003/*" }, { "ua": "ONEPLUS A6003" }], "dpi": 401, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6010/*" }, { "ua": "ONEPLUS A6010" }], "dpi": 401, "bw": 2, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OnePlus/*/ONEPLUS A6013/*" }, { "ua": "ONEPLUS A6013" }], "dpi": 401, "bw": 2, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "OPPO/*/X909/*" }, { "ua": "X909" }], "dpi": [442.4, 444.1], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9082/*" }, { "ua": "GT-I9082" }], "dpi": [184.7, 185.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G360P/*" }, { "ua": "SM-G360P" }], "dpi": [196.7, 205.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Nexus S/*" }, { "ua": "Nexus S" }], "dpi": [234.5, 229.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [304.8, 303.9], "bw": 5, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T230NU/*" }, { "ua": "SM-T230NU" }], "dpi": 216, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-T399/*" }, { "ua": "SGH-T399" }], "dpi": [217.7, 231.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SGH-M919/*" }, { "ua": "SGH-M919" }], "dpi": [440.8, 437.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N9005/*" }, { "ua": "SM-N9005" }], "dpi": [386.4, 387], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SM-N900A/*" }, { "ua": "SAMSUNG-SM-N900A" }], "dpi": [386.4, 387.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9500/*" }, { "ua": "GT-I9500" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9505/*" }, { "ua": "GT-I9505" }], "dpi": 439.4, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900F/*" }, { "ua": "SM-G900F" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G900M/*" }, { "ua": "SM-G900M" }], "dpi": [415.6, 431.6], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G800F/*" }, { "ua": "SM-G800F" }], "dpi": 326.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G906S/*" }, { "ua": "SM-G906S" }], "dpi": [562.7, 572.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300/*" }, { "ua": "GT-I9300" }], "dpi": [306.7, 304.8], "bw": 5, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-T535/*" }, { "ua": "SM-T535" }], "dpi": [142.6, 136.4], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920C/*" }, { "ua": "SM-N920C" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920P/*" }, { "ua": "SM-N920P" }], "dpi": [386.3655, 390.144], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N920W8/*" }, { "ua": "SM-N920W8" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9300I/*" }, { "ua": "GT-I9300I" }], "dpi": [304.8, 305.8], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-I9195/*" }, { "ua": "GT-I9195" }], "dpi": [249.4, 256.7], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-L520/*" }, { "ua": "SPH-L520" }], "dpi": [249.4, 255.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SAMSUNG-SGH-I717/*" }, { "ua": "SAMSUNG-SGH-I717" }], "dpi": 285.8, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SPH-D710/*" }, { "ua": "SPH-D710" }], "dpi": [217.7, 204.2], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/GT-N7100/*" }, { "ua": "GT-N7100" }], "dpi": 265.1, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SCH-I605/*" }, { "ua": "SCH-I605" }], "dpi": 265.1, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/Galaxy Nexus/*" }, { "ua": "Galaxy Nexus" }], "dpi": [315.3, 314.2], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910H/*" }, { "ua": "SM-N910H" }], "dpi": [515.1, 518], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-N910C/*" }, { "ua": "SM-N910C" }], "dpi": [515.2, 520.2], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G130M/*" }, { "ua": "SM-G130M" }], "dpi": [165.9, 164.8], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G928I/*" }, { "ua": "SM-G928I" }], "dpi": [515.1, 518.4], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920F/*" }, { "ua": "SM-G920F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G920P/*" }, { "ua": "SM-G920P" }], "dpi": [522.5, 577], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925F/*" }, { "ua": "SM-G925F" }], "dpi": 580.6, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G925V/*" }, { "ua": "SM-G925V" }], "dpi": [522.5, 576.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G930F/*" }, { "ua": "SM-G930F" }], "dpi": 576.6, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G935F/*" }, { "ua": "SM-G935F" }], "dpi": 533, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G950F/*" }, { "ua": "SM-G950F" }], "dpi": [562.707, 565.293], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955U/*" }, { "ua": "SM-G955U" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G955F/*" }, { "ua": "SM-G955F" }], "dpi": [522.514, 525.762], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960F/*" }, { "ua": "SM-G960F" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G9600/*" }, { "ua": "SM-G9600" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960T/*" }, { "ua": "SM-G960T" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960N/*" }, { "ua": "SM-G960N" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960U/*" }, { "ua": "SM-G960U" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G9608/*" }, { "ua": "SM-G9608" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960FD/*" }, { "ua": "SM-G960FD" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G960W/*" }, { "ua": "SM-G960W" }], "dpi": [569.575, 571.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G965F/*" }, { "ua": "SM-G965F" }], "dpi": 529, "bw": 2, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/C6903/*" }, { "ua": "C6903" }], "dpi": [442.5, 443.3], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/D6653/*" }, { "ua": "D6653" }], "dpi": [428.6, 427.6], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6653/*" }, { "ua": "E6653" }], "dpi": [428.6, 425.7], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/E6853/*" }, { "ua": "E6853" }], "dpi": [403.4, 401.9], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Sony/*/SGP321/*" }, { "ua": "SGP321" }], "dpi": [224.7, 224.1], "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "TCT/*/ALCATEL ONE TOUCH Fierce/*" }, { "ua": "ALCATEL ONE TOUCH Fierce" }], "dpi": [240, 247.5], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "THL/*/thl 5000/*" }, { "ua": "thl 5000" }], "dpi": [480, 443.3], "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Fly/*/IQ4412/*" }, { "ua": "IQ4412" }], "dpi": 307.9, "bw": 3, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "ZTE/*/ZTE Blade L2/*" }, { "ua": "ZTE Blade L2" }], "dpi": 240, "bw": 3, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "BENEVE/*/VR518/*" }, { "ua": "VR518" }], "dpi": 480, "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [640, 960] }], "dpi": [325.1, 328.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [640, 1136] }], "dpi": [317.1, 320.2], "bw": 3, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [750, 1334] }], "dpi": 326.4, "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1242, 2208] }], "dpi": [453.6, 458.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1125, 2001] }], "dpi": [410.9, 415.4], "bw": 4, "ac": 1e3 }, { "type": "ios", "rules": [{ "res": [1125, 2436] }], "dpi": 458, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "Huawei/*/EML-L29/*" }, { "ua": "EML-L29" }], "dpi": 428, "bw": 3.45, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "Nokia/*/Nokia 7.1/*" }, { "ua": "Nokia 7.1" }], "dpi": [432, 431.9], "bw": 3, "ac": 500 }, { "type": "ios", "rules": [{ "res": [1242, 2688] }], "dpi": 458, "bw": 4, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G570M/*" }, { "ua": "SM-G570M" }], "dpi": 320, "bw": 3.684, "ac": 1e3 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G970F/*" }, { "ua": "SM-G970F" }], "dpi": 438, "bw": 2.281, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G973F/*" }, { "ua": "SM-G973F" }], "dpi": 550, "bw": 2.002, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G975F/*" }, { "ua": "SM-G975F" }], "dpi": 522, "bw": 2.054, "ac": 500 }, { "type": "android", "rules": [{ "mdmh": "samsung/*/SM-G977F/*" }, { "ua": "SM-G977F" }], "dpi": 505, "bw": 2.334, "ac": 500 }, { "type": "ios", "rules": [{ "res": [828, 1792] }], "dpi": 326, "bw": 5, "ac": 500 }];
      var DPDB_CACHE = {
        format,
        last_updated,
        devices
      };
      function Dpdb(url2, onDeviceParamsUpdated) {
        this.dpdb = DPDB_CACHE;
        this.recalculateDeviceParams_();
        if (url2) {
          this.onDeviceParamsUpdated = onDeviceParamsUpdated;
          var xhr = new XMLHttpRequest();
          var obj2 = this;
          xhr.open("GET", url2, true);
          xhr.addEventListener("load", function() {
            obj2.loading = false;
            if (xhr.status >= 200 && xhr.status <= 299) {
              obj2.dpdb = JSON.parse(xhr.response);
              obj2.recalculateDeviceParams_();
            } else {
              console.error("Error loading online DPDB!");
            }
          });
          xhr.send();
        }
      }
      Dpdb.prototype.getDeviceParams = function() {
        return this.deviceParams;
      };
      Dpdb.prototype.recalculateDeviceParams_ = function() {
        var newDeviceParams = this.calcDeviceParams_();
        if (newDeviceParams) {
          this.deviceParams = newDeviceParams;
          if (this.onDeviceParamsUpdated) {
            this.onDeviceParamsUpdated(this.deviceParams);
          }
        } else {
          console.error("Failed to recalculate device parameters.");
        }
      };
      Dpdb.prototype.calcDeviceParams_ = function() {
        var db = this.dpdb;
        if (!db) {
          console.error("DPDB not available.");
          return null;
        }
        if (db.format != 1) {
          console.error("DPDB has unexpected format version.");
          return null;
        }
        if (!db.devices || !db.devices.length) {
          console.error("DPDB does not have a devices section.");
          return null;
        }
        var userAgent = navigator.userAgent || navigator.vendor || window.opera;
        var width2 = getScreenWidth();
        var height2 = getScreenHeight();
        if (!db.devices) {
          console.error("DPDB has no devices section.");
          return null;
        }
        for (var i = 0; i < db.devices.length; i++) {
          var device = db.devices[i];
          if (!device.rules) {
            console.warn("Device[" + i + "] has no rules section.");
            continue;
          }
          if (device.type != "ios" && device.type != "android") {
            console.warn("Device[" + i + "] has invalid type.");
            continue;
          }
          if (isIOS2() != (device.type == "ios"))
            continue;
          var matched = false;
          for (var j = 0; j < device.rules.length; j++) {
            var rule2 = device.rules[j];
            if (this.ruleMatches_(rule2, userAgent, width2, height2)) {
              matched = true;
              break;
            }
          }
          if (!matched)
            continue;
          var xdpi = device.dpi[0] || device.dpi;
          var ydpi = device.dpi[1] || device.dpi;
          return new DeviceParams({ xdpi, ydpi, bevelMm: device.bw });
        }
        console.warn("No DPDB device match.");
        return null;
      };
      Dpdb.prototype.ruleMatches_ = function(rule2, ua, screenWidth, screenHeight) {
        if (!rule2.ua && !rule2.res)
          return false;
        if (rule2.ua && rule2.ua.substring(0, 2) === "SM")
          rule2.ua = rule2.ua.substring(0, 7);
        if (rule2.ua && ua.indexOf(rule2.ua) < 0)
          return false;
        if (rule2.res) {
          if (!rule2.res[0] || !rule2.res[1])
            return false;
          var resX = rule2.res[0];
          var resY = rule2.res[1];
          if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
            return false;
          }
        }
        return true;
      };
      function DeviceParams(params) {
        this.xdpi = params.xdpi;
        this.ydpi = params.ydpi;
        this.bevelMm = params.bevelMm;
      }
      function SensorSample(sample, timestampS) {
        this.set(sample, timestampS);
      }
      SensorSample.prototype.set = function(sample, timestampS) {
        this.sample = sample;
        this.timestampS = timestampS;
      };
      SensorSample.prototype.copy = function(sensorSample) {
        this.set(sensorSample.sample, sensorSample.timestampS);
      };
      function ComplementaryFilter(kFilter, isDebug2) {
        this.kFilter = kFilter;
        this.isDebug = isDebug2;
        this.currentAccelMeasurement = new SensorSample();
        this.currentGyroMeasurement = new SensorSample();
        this.previousGyroMeasurement = new SensorSample();
        if (isIOS2()) {
          this.filterQ = new Quaternion2(-1, 0, 0, 1);
        } else {
          this.filterQ = new Quaternion2(1, 0, 0, 1);
        }
        this.previousFilterQ = new Quaternion2();
        this.previousFilterQ.copy(this.filterQ);
        this.accelQ = new Quaternion2();
        this.isOrientationInitialized = false;
        this.estimatedGravity = new Vector34();
        this.measuredGravity = new Vector34();
        this.gyroIntegralQ = new Quaternion2();
      }
      ComplementaryFilter.prototype.addAccelMeasurement = function(vector, timestampS) {
        this.currentAccelMeasurement.set(vector, timestampS);
      };
      ComplementaryFilter.prototype.addGyroMeasurement = function(vector, timestampS) {
        this.currentGyroMeasurement.set(vector, timestampS);
        var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
        if (isTimestampDeltaValid(deltaT)) {
          this.run_();
        }
        this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
      };
      ComplementaryFilter.prototype.run_ = function() {
        if (!this.isOrientationInitialized) {
          this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
          this.previousFilterQ.copy(this.accelQ);
          this.isOrientationInitialized = true;
          return;
        }
        var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;
        var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
        this.gyroIntegralQ.multiply(gyroDeltaQ);
        this.filterQ.copy(this.previousFilterQ);
        this.filterQ.multiply(gyroDeltaQ);
        var invFilterQ = new Quaternion2();
        invFilterQ.copy(this.filterQ);
        invFilterQ.inverse();
        this.estimatedGravity.set(0, 0, -1);
        this.estimatedGravity.applyQuaternion(invFilterQ);
        this.estimatedGravity.normalize();
        this.measuredGravity.copy(this.currentAccelMeasurement.sample);
        this.measuredGravity.normalize();
        var deltaQ = new Quaternion2();
        deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
        deltaQ.inverse();
        if (this.isDebug) {
          console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)", radToDeg * getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
        }
        var targetQ = new Quaternion2();
        targetQ.copy(this.filterQ);
        targetQ.multiply(deltaQ);
        this.filterQ.slerp(targetQ, 1 - this.kFilter);
        this.previousFilterQ.copy(this.filterQ);
      };
      ComplementaryFilter.prototype.getOrientation = function() {
        return this.filterQ;
      };
      ComplementaryFilter.prototype.accelToQuaternion_ = function(accel) {
        var normAccel = new Vector34();
        normAccel.copy(accel);
        normAccel.normalize();
        var quat = new Quaternion2();
        quat.setFromUnitVectors(new Vector34(0, 0, -1), normAccel);
        quat.inverse();
        return quat;
      };
      ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function(gyro, dt) {
        var quat = new Quaternion2();
        var axis = new Vector34();
        axis.copy(gyro);
        axis.normalize();
        quat.setFromAxisAngle(axis, gyro.length() * dt);
        return quat;
      };
      function PosePredictor(predictionTimeS, isDebug2) {
        this.predictionTimeS = predictionTimeS;
        this.isDebug = isDebug2;
        this.previousQ = new Quaternion2();
        this.previousTimestampS = null;
        this.deltaQ = new Quaternion2();
        this.outQ = new Quaternion2();
      }
      PosePredictor.prototype.getPrediction = function(currentQ, gyro, timestampS) {
        if (!this.previousTimestampS) {
          this.previousQ.copy(currentQ);
          this.previousTimestampS = timestampS;
          return currentQ;
        }
        var axis = new Vector34();
        axis.copy(gyro);
        axis.normalize();
        var angularSpeed = gyro.length();
        if (angularSpeed < degToRad * 20) {
          if (this.isDebug) {
            console.log("Moving slowly, at %s deg/s: no prediction", (radToDeg * angularSpeed).toFixed(1));
          }
          this.outQ.copy(currentQ);
          this.previousQ.copy(currentQ);
          return this.outQ;
        }
        var predictAngle = angularSpeed * this.predictionTimeS;
        this.deltaQ.setFromAxisAngle(axis, predictAngle);
        this.outQ.copy(this.previousQ);
        this.outQ.multiply(this.deltaQ);
        this.previousQ.copy(currentQ);
        this.previousTimestampS = timestampS;
        return this.outQ;
      };
      function FusionPoseSensor(kFilter, predictionTime, yawOnly, isDebug2) {
        this.yawOnly = yawOnly;
        this.accelerometer = new Vector34();
        this.gyroscope = new Vector34();
        this.filter = new ComplementaryFilter(kFilter, isDebug2);
        this.posePredictor = new PosePredictor(predictionTime, isDebug2);
        this.isFirefoxAndroid = isFirefoxAndroid();
        this.isIOS = isIOS2();
        var chromeVersion = getChromeVersion();
        this.isDeviceMotionInRadians = !this.isIOS && chromeVersion && chromeVersion < 66;
        this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion() || isSafariWithoutDeviceMotion();
        this.filterToWorldQ = new Quaternion2();
        if (isIOS2()) {
          this.filterToWorldQ.setFromAxisAngle(new Vector34(1, 0, 0), Math.PI / 2);
        } else {
          this.filterToWorldQ.setFromAxisAngle(new Vector34(1, 0, 0), -Math.PI / 2);
        }
        this.inverseWorldToScreenQ = new Quaternion2();
        this.worldToScreenQ = new Quaternion2();
        this.originalPoseAdjustQ = new Quaternion2();
        this.originalPoseAdjustQ.setFromAxisAngle(new Vector34(0, 0, 1), -window.orientation * Math.PI / 180);
        this.setScreenTransform_();
        if (isLandscapeMode()) {
          this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
        }
        this.resetQ = new Quaternion2();
        this.orientationOut_ = new Float32Array(4);
        this.start();
      }
      FusionPoseSensor.prototype.getPosition = function() {
        return null;
      };
      FusionPoseSensor.prototype.getOrientation = function() {
        var orientation = void 0;
        if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
          this.deviceOrientationFixQ = this.deviceOrientationFixQ || function() {
            var z = new Quaternion2().setFromAxisAngle(new Vector34(0, 0, -1), 0);
            var y = new Quaternion2();
            if (window.orientation === -90) {
              y.setFromAxisAngle(new Vector34(0, 1, 0), Math.PI / -2);
            } else {
              y.setFromAxisAngle(new Vector34(0, 1, 0), Math.PI / 2);
            }
            return z.multiply(y);
          }();
          this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function() {
            var q = new Quaternion2();
            q.setFromAxisAngle(new Vector34(1, 0, 0), -Math.PI / 2);
            return q;
          }();
          orientation = this._deviceOrientationQ;
          var out = new Quaternion2();
          out.copy(orientation);
          out.multiply(this.deviceOrientationFilterToWorldQ);
          out.multiply(this.resetQ);
          out.multiply(this.worldToScreenQ);
          out.multiplyQuaternions(this.deviceOrientationFixQ, out);
          if (this.yawOnly) {
            out.x = 0;
            out.z = 0;
            out.normalize();
          }
          this.orientationOut_[0] = out.x;
          this.orientationOut_[1] = out.y;
          this.orientationOut_[2] = out.z;
          this.orientationOut_[3] = out.w;
          return this.orientationOut_;
        } else {
          var filterOrientation = this.filter.getOrientation();
          orientation = this.posePredictor.getPrediction(filterOrientation, this.gyroscope, this.previousTimestampS);
        }
        var out = new Quaternion2();
        out.copy(this.filterToWorldQ);
        out.multiply(this.resetQ);
        out.multiply(orientation);
        out.multiply(this.worldToScreenQ);
        if (this.yawOnly) {
          out.x = 0;
          out.z = 0;
          out.normalize();
        }
        this.orientationOut_[0] = out.x;
        this.orientationOut_[1] = out.y;
        this.orientationOut_[2] = out.z;
        this.orientationOut_[3] = out.w;
        return this.orientationOut_;
      };
      FusionPoseSensor.prototype.resetPose = function() {
        this.resetQ.copy(this.filter.getOrientation());
        this.resetQ.x = 0;
        this.resetQ.y = 0;
        this.resetQ.z *= -1;
        this.resetQ.normalize();
        if (isLandscapeMode()) {
          this.resetQ.multiply(this.inverseWorldToScreenQ);
        }
        this.resetQ.multiply(this.originalPoseAdjustQ);
      };
      FusionPoseSensor.prototype.onDeviceOrientation_ = function(e2) {
        this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion2();
        var alpha = e2.alpha, beta2 = e2.beta, gamma = e2.gamma;
        alpha = (alpha || 0) * Math.PI / 180;
        beta2 = (beta2 || 0) * Math.PI / 180;
        gamma = (gamma || 0) * Math.PI / 180;
        this._deviceOrientationQ.setFromEulerYXZ(beta2, alpha, -gamma);
      };
      FusionPoseSensor.prototype.onDeviceMotion_ = function(deviceMotion) {
        this.updateDeviceMotion_(deviceMotion);
      };
      FusionPoseSensor.prototype.updateDeviceMotion_ = function(deviceMotion) {
        var accGravity = deviceMotion.accelerationIncludingGravity;
        var rotRate = deviceMotion.rotationRate;
        var timestampS = deviceMotion.timeStamp / 1e3;
        var deltaS = timestampS - this.previousTimestampS;
        if (deltaS < 0) {
          warnOnce("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion");
          this.previousTimestampS = timestampS;
          return;
        } else if (deltaS <= MIN_TIMESTEP || deltaS > MAX_TIMESTEP) {
          warnOnce("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range.");
          this.previousTimestampS = timestampS;
          return;
        }
        this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
        if (rotRate) {
          if (isR7()) {
            this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma);
          } else {
            this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
          }
          if (!this.isDeviceMotionInRadians) {
            this.gyroscope.multiplyScalar(Math.PI / 180);
          }
          this.filter.addGyroMeasurement(this.gyroscope, timestampS);
        }
        this.filter.addAccelMeasurement(this.accelerometer, timestampS);
        this.previousTimestampS = timestampS;
      };
      FusionPoseSensor.prototype.onOrientationChange_ = function(screenOrientation) {
        this.setScreenTransform_();
      };
      FusionPoseSensor.prototype.onMessage_ = function(event) {
        var message2 = event.data;
        if (!message2 || !message2.type) {
          return;
        }
        var type2 = message2.type.toLowerCase();
        if (type2 !== "devicemotion") {
          return;
        }
        this.updateDeviceMotion_(message2.deviceMotionEvent);
      };
      FusionPoseSensor.prototype.setScreenTransform_ = function() {
        this.worldToScreenQ.set(0, 0, 0, 1);
        switch (window.orientation) {
          case 0:
            break;
          case 90:
            this.worldToScreenQ.setFromAxisAngle(new Vector34(0, 0, 1), -Math.PI / 2);
            break;
          case -90:
            this.worldToScreenQ.setFromAxisAngle(new Vector34(0, 0, 1), Math.PI / 2);
            break;
          case 180:
            break;
        }
        this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
        this.inverseWorldToScreenQ.inverse();
      };
      FusionPoseSensor.prototype.start = function() {
        this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
        this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
        this.onMessageCallback_ = this.onMessage_.bind(this);
        this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this);
        if (isIOS2() && isInsideCrossOriginIFrame()) {
          window.addEventListener("message", this.onMessageCallback_);
        }
        window.addEventListener("orientationchange", this.onOrientationChangeCallback_);
        if (this.isWithoutDeviceMotion) {
          window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_);
        } else {
          window.addEventListener("devicemotion", this.onDeviceMotionCallback_);
        }
      };
      FusionPoseSensor.prototype.stop = function() {
        window.removeEventListener("devicemotion", this.onDeviceMotionCallback_);
        window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_);
        window.removeEventListener("orientationchange", this.onOrientationChangeCallback_);
        window.removeEventListener("message", this.onMessageCallback_);
      };
      var SENSOR_FREQUENCY = 60;
      var X_AXIS = new Vector34(1, 0, 0);
      var Z_AXIS = new Vector34(0, 0, 1);
      var SENSOR_TO_VR = new Quaternion2();
      SENSOR_TO_VR.setFromAxisAngle(X_AXIS, -Math.PI / 2);
      SENSOR_TO_VR.multiply(new Quaternion2().setFromAxisAngle(Z_AXIS, Math.PI / 2));
      var PoseSensor = function() {
        function PoseSensor2(config2) {
          classCallCheck(this, PoseSensor2);
          this.config = config2;
          this.sensor = null;
          this.fusionSensor = null;
          this._out = new Float32Array(4);
          this.api = null;
          this.errors = [];
          this._sensorQ = new Quaternion2();
          this._outQ = new Quaternion2();
          this._onSensorRead = this._onSensorRead.bind(this);
          this._onSensorError = this._onSensorError.bind(this);
          this.init();
        }
        createClass(PoseSensor2, [{
          key: "init",
          value: function init() {
            var sensor = null;
            try {
              sensor = new RelativeOrientationSensor({
                frequency: SENSOR_FREQUENCY,
                referenceFrame: "screen"
              });
              sensor.addEventListener("error", this._onSensorError);
            } catch (error) {
              this.errors.push(error);
              if (error.name === "SecurityError") {
                console.error("Cannot construct sensors due to the Feature Policy");
                console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.');
                this.useDeviceMotion();
              } else if (error.name === "ReferenceError") {
                this.useDeviceMotion();
              } else {
                console.error(error);
              }
            }
            if (sensor) {
              this.api = "sensor";
              this.sensor = sensor;
              this.sensor.addEventListener("reading", this._onSensorRead);
              this.sensor.start();
            }
          }
        }, {
          key: "useDeviceMotion",
          value: function useDeviceMotion() {
            this.api = "devicemotion";
            this.fusionSensor = new FusionPoseSensor(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG);
            if (this.sensor) {
              this.sensor.removeEventListener("reading", this._onSensorRead);
              this.sensor.removeEventListener("error", this._onSensorError);
              this.sensor = null;
            }
          }
        }, {
          key: "getOrientation",
          value: function getOrientation() {
            if (this.fusionSensor) {
              return this.fusionSensor.getOrientation();
            }
            if (!this.sensor || !this.sensor.quaternion) {
              this._out[0] = this._out[1] = this._out[2] = 0;
              this._out[3] = 1;
              return this._out;
            }
            var q = this.sensor.quaternion;
            this._sensorQ.set(q[0], q[1], q[2], q[3]);
            var out = this._outQ;
            out.copy(SENSOR_TO_VR);
            out.multiply(this._sensorQ);
            if (this.config.YAW_ONLY) {
              out.x = out.z = 0;
              out.normalize();
            }
            this._out[0] = out.x;
            this._out[1] = out.y;
            this._out[2] = out.z;
            this._out[3] = out.w;
            return this._out;
          }
        }, {
          key: "_onSensorError",
          value: function _onSensorError(event) {
            this.errors.push(event.error);
            if (event.error.name === "NotAllowedError") {
              console.error("Permission to access sensor was denied");
            } else if (event.error.name === "NotReadableError") {
              console.error("Sensor could not be read");
            } else {
              console.error(event.error);
            }
            this.useDeviceMotion();
          }
        }, {
          key: "_onSensorRead",
          value: function _onSensorRead() {
          }
        }]);
        return PoseSensor2;
      }();
      var rotateInstructionsAsset = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
      function RotateInstructions() {
        this.loadIcon_();
        var overlay = document.createElement("div");
        var s = overlay.style;
        s.position = "fixed";
        s.top = 0;
        s.right = 0;
        s.bottom = 0;
        s.left = 0;
        s.backgroundColor = "gray";
        s.fontFamily = "sans-serif";
        s.zIndex = 1e6;
        var img = document.createElement("img");
        img.src = this.icon;
        var s = img.style;
        s.marginLeft = "25%";
        s.marginTop = "25%";
        s.width = "50%";
        overlay.appendChild(img);
        var text2 = document.createElement("div");
        var s = text2.style;
        s.textAlign = "center";
        s.fontSize = "16px";
        s.lineHeight = "24px";
        s.margin = "24px 25%";
        s.width = "50%";
        text2.innerHTML = "Place your phone into your Cardboard viewer.";
        overlay.appendChild(text2);
        var snackbar = document.createElement("div");
        var s = snackbar.style;
        s.backgroundColor = "#CFD8DC";
        s.position = "fixed";
        s.bottom = 0;
        s.width = "100%";
        s.height = "48px";
        s.padding = "14px 24px";
        s.boxSizing = "border-box";
        s.color = "#656A6B";
        overlay.appendChild(snackbar);
        var snackbarText = document.createElement("div");
        snackbarText.style.float = "left";
        snackbarText.innerHTML = "No Cardboard viewer?";
        var snackbarButton = document.createElement("a");
        snackbarButton.href = "https://www.google.com/get/cardboard/get-cardboard/";
        snackbarButton.innerHTML = "get one";
        snackbarButton.target = "_blank";
        var s = snackbarButton.style;
        s.float = "right";
        s.fontWeight = 600;
        s.textTransform = "uppercase";
        s.borderLeft = "1px solid gray";
        s.paddingLeft = "24px";
        s.textDecoration = "none";
        s.color = "#656A6B";
        snackbar.appendChild(snackbarText);
        snackbar.appendChild(snackbarButton);
        this.overlay = overlay;
        this.text = text2;
        this.hide();
      }
      RotateInstructions.prototype.show = function(parent) {
        if (!parent && !this.overlay.parentElement) {
          document.body.appendChild(this.overlay);
        } else if (parent) {
          if (this.overlay.parentElement && this.overlay.parentElement != parent)
            this.overlay.parentElement.removeChild(this.overlay);
          parent.appendChild(this.overlay);
        }
        this.overlay.style.display = "block";
        var img = this.overlay.querySelector("img");
        var s = img.style;
        if (isLandscapeMode()) {
          s.width = "20%";
          s.marginLeft = "40%";
          s.marginTop = "3%";
        } else {
          s.width = "50%";
          s.marginLeft = "25%";
          s.marginTop = "25%";
        }
      };
      RotateInstructions.prototype.hide = function() {
        this.overlay.style.display = "none";
      };
      RotateInstructions.prototype.showTemporarily = function(ms, parent) {
        this.show(parent);
        this.timer = setTimeout(this.hide.bind(this), ms);
      };
      RotateInstructions.prototype.disableShowTemporarily = function() {
        clearTimeout(this.timer);
      };
      RotateInstructions.prototype.update = function() {
        this.disableShowTemporarily();
        if (!isLandscapeMode() && isMobile3()) {
          this.show();
        } else {
          this.hide();
        }
      };
      RotateInstructions.prototype.loadIcon_ = function() {
        this.icon = dataUri("image/svg+xml", rotateInstructionsAsset);
      };
      var DEFAULT_VIEWER = "CardboardV1";
      var VIEWER_KEY = "WEBVR_CARDBOARD_VIEWER";
      var CLASS_NAME = "webvr-polyfill-viewer-selector";
      function ViewerSelector(defaultViewer) {
        try {
          this.selectedKey = localStorage.getItem(VIEWER_KEY);
        } catch (error) {
          console.error("Failed to load viewer profile: %s", error);
        }
        if (!this.selectedKey) {
          this.selectedKey = defaultViewer || DEFAULT_VIEWER;
        }
        this.dialog = this.createDialog_(DeviceInfo.Viewers);
        this.root = null;
        this.onChangeCallbacks_ = [];
      }
      ViewerSelector.prototype.show = function(root) {
        this.root = root;
        root.appendChild(this.dialog);
        var selected2 = this.dialog.querySelector("#" + this.selectedKey);
        selected2.checked = true;
        this.dialog.style.display = "block";
      };
      ViewerSelector.prototype.hide = function() {
        if (this.root && this.root.contains(this.dialog)) {
          this.root.removeChild(this.dialog);
        }
        this.dialog.style.display = "none";
      };
      ViewerSelector.prototype.getCurrentViewer = function() {
        return DeviceInfo.Viewers[this.selectedKey];
      };
      ViewerSelector.prototype.getSelectedKey_ = function() {
        var input = this.dialog.querySelector("input[name=field]:checked");
        if (input) {
          return input.id;
        }
        return null;
      };
      ViewerSelector.prototype.onChange = function(cb) {
        this.onChangeCallbacks_.push(cb);
      };
      ViewerSelector.prototype.fireOnChange_ = function(viewer) {
        for (var i = 0; i < this.onChangeCallbacks_.length; i++) {
          this.onChangeCallbacks_[i](viewer);
        }
      };
      ViewerSelector.prototype.onSave_ = function() {
        this.selectedKey = this.getSelectedKey_();
        if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
          console.error("ViewerSelector.onSave_: this should never happen!");
          return;
        }
        this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);
        try {
          localStorage.setItem(VIEWER_KEY, this.selectedKey);
        } catch (error) {
          console.error("Failed to save viewer profile: %s", error);
        }
        this.hide();
      };
      ViewerSelector.prototype.createDialog_ = function(options) {
        var container = document.createElement("div");
        container.classList.add(CLASS_NAME);
        container.style.display = "none";
        var overlay = document.createElement("div");
        var s = overlay.style;
        s.position = "fixed";
        s.left = 0;
        s.top = 0;
        s.width = "100%";
        s.height = "100%";
        s.background = "rgba(0, 0, 0, 0.3)";
        overlay.addEventListener("click", this.hide.bind(this));
        var width2 = 280;
        var dialog = document.createElement("div");
        var s = dialog.style;
        s.boxSizing = "border-box";
        s.position = "fixed";
        s.top = "24px";
        s.left = "50%";
        s.marginLeft = -width2 / 2 + "px";
        s.width = width2 + "px";
        s.padding = "24px";
        s.overflow = "hidden";
        s.background = "#fafafa";
        s.fontFamily = "'Roboto', sans-serif";
        s.boxShadow = "0px 5px 20px #666";
        dialog.appendChild(this.createH1_("Select your viewer"));
        for (var id2 in options) {
          dialog.appendChild(this.createChoice_(id2, options[id2].label));
        }
        dialog.appendChild(this.createButton_("Save", this.onSave_.bind(this)));
        container.appendChild(overlay);
        container.appendChild(dialog);
        return container;
      };
      ViewerSelector.prototype.createH1_ = function(name3) {
        var h1 = document.createElement("h1");
        var s = h1.style;
        s.color = "black";
        s.fontSize = "20px";
        s.fontWeight = "bold";
        s.marginTop = 0;
        s.marginBottom = "24px";
        h1.innerHTML = name3;
        return h1;
      };
      ViewerSelector.prototype.createChoice_ = function(id2, name3) {
        var div4 = document.createElement("div");
        div4.style.marginTop = "8px";
        div4.style.color = "black";
        var input = document.createElement("input");
        input.style.fontSize = "30px";
        input.setAttribute("id", id2);
        input.setAttribute("type", "radio");
        input.setAttribute("value", id2);
        input.setAttribute("name", "field");
        var label = document.createElement("label");
        label.style.marginLeft = "4px";
        label.setAttribute("for", id2);
        label.innerHTML = name3;
        div4.appendChild(input);
        div4.appendChild(label);
        return div4;
      };
      ViewerSelector.prototype.createButton_ = function(label, onclick) {
        var button = document.createElement("button");
        button.innerHTML = label;
        var s = button.style;
        s.float = "right";
        s.textTransform = "uppercase";
        s.color = "#1094f7";
        s.fontSize = "14px";
        s.letterSpacing = 0;
        s.border = 0;
        s.background = "none";
        s.marginTop = "16px";
        button.addEventListener("click", onclick);
        return button;
      };
      var commonjsGlobal = typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function unwrapExports(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      function createCommonjsModule(fn, module3) {
        return module3 = { exports: {} }, fn(module3, module3.exports), module3.exports;
      }
      var NoSleep = createCommonjsModule(function(module3, exports3) {
        (function webpackUniversalModuleDefinition(root, factory) {
          module3.exports = factory();
        })(commonjsGlobal, function() {
          return function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
              if (installedModules[moduleId]) {
                return installedModules[moduleId].exports;
              }
              var module4 = installedModules[moduleId] = {
                i: moduleId,
                l: false,
                exports: {}
              };
              modules[moduleId].call(module4.exports, module4, module4.exports, __webpack_require__);
              module4.l = true;
              return module4.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports4, name3, getter) {
              if (!__webpack_require__.o(exports4, name3)) {
                Object.defineProperty(exports4, name3, {
                  configurable: false,
                  enumerable: true,
                  get: getter
                });
              }
            };
            __webpack_require__.n = function(module4) {
              var getter = module4 && module4.__esModule ? function getDefault() {
                return module4["default"];
              } : function getModuleExports() {
                return module4;
              };
              __webpack_require__.d(getter, "a", getter);
              return getter;
            };
            __webpack_require__.o = function(object, property) {
              return Object.prototype.hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 0);
          }([
            function(module4, exports4, __webpack_require__) {
              "use strict";
              var _createClass = function() {
                function defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var mediaFile = __webpack_require__(1);
              var oldIOS = typeof navigator !== "undefined" && parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_", "")) < 10 && !window.MSStream;
              var NoSleep2 = function() {
                function NoSleep3() {
                  _classCallCheck(this, NoSleep3);
                  if (oldIOS) {
                    this.noSleepTimer = null;
                  } else {
                    this.noSleepVideo = document.createElement("video");
                    this.noSleepVideo.setAttribute("playsinline", "");
                    this.noSleepVideo.setAttribute("src", mediaFile);
                    this.noSleepVideo.addEventListener("timeupdate", function(e2) {
                      if (this.noSleepVideo.currentTime > 0.5) {
                        this.noSleepVideo.currentTime = Math.random();
                      }
                    }.bind(this));
                  }
                }
                _createClass(NoSleep3, [{
                  key: "enable",
                  value: function enable() {
                    if (oldIOS) {
                      this.disable();
                      this.noSleepTimer = window.setInterval(function() {
                        window.location.href = "/";
                        window.setTimeout(window.stop, 0);
                      }, 15e3);
                    } else {
                      this.noSleepVideo.play();
                    }
                  }
                }, {
                  key: "disable",
                  value: function disable() {
                    if (oldIOS) {
                      if (this.noSleepTimer) {
                        window.clearInterval(this.noSleepTimer);
                        this.noSleepTimer = null;
                      }
                    } else {
                      this.noSleepVideo.pause();
                    }
                  }
                }]);
                return NoSleep3;
              }();
              module4.exports = NoSleep2;
            },
            function(module4, exports4, __webpack_require__) {
              "use strict";
              module4.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA=";
            }
          ]);
        });
      });
      var NoSleep$1 = unwrapExports(NoSleep);
      var nextDisplayId = 1e3;
      var defaultLeftBounds = [0, 0, 0.5, 1];
      var defaultRightBounds = [0.5, 0, 0.5, 1];
      var raf = window.requestAnimationFrame;
      var caf = window.cancelAnimationFrame;
      function VRFrameData() {
        this.leftProjectionMatrix = new Float32Array(16);
        this.leftViewMatrix = new Float32Array(16);
        this.rightProjectionMatrix = new Float32Array(16);
        this.rightViewMatrix = new Float32Array(16);
        this.pose = null;
      }
      function VRDisplayCapabilities(config2) {
        Object.defineProperties(this, {
          hasPosition: {
            writable: false,
            enumerable: true,
            value: config2.hasPosition
          },
          hasExternalDisplay: {
            writable: false,
            enumerable: true,
            value: config2.hasExternalDisplay
          },
          canPresent: {
            writable: false,
            enumerable: true,
            value: config2.canPresent
          },
          maxLayers: {
            writable: false,
            enumerable: true,
            value: config2.maxLayers
          },
          hasOrientation: {
            enumerable: true,
            get: function get() {
              deprecateWarning("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData");
              return config2.hasOrientation;
            }
          }
        });
      }
      function VRDisplay(config2) {
        config2 = config2 || {};
        var USE_WAKELOCK = "wakelock" in config2 ? config2.wakelock : true;
        this.isPolyfilled = true;
        this.displayId = nextDisplayId++;
        this.displayName = "";
        this.depthNear = 0.01;
        this.depthFar = 1e4;
        this.isPresenting = false;
        Object.defineProperty(this, "isConnected", {
          get: function get() {
            deprecateWarning("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay");
            return false;
          }
        });
        this.capabilities = new VRDisplayCapabilities({
          hasPosition: false,
          hasOrientation: false,
          hasExternalDisplay: false,
          canPresent: false,
          maxLayers: 1
        });
        this.stageParameters = null;
        this.waitingForPresent_ = false;
        this.layer_ = null;
        this.originalParent_ = null;
        this.fullscreenElement_ = null;
        this.fullscreenWrapper_ = null;
        this.fullscreenElementCachedStyle_ = null;
        this.fullscreenEventTarget_ = null;
        this.fullscreenChangeHandler_ = null;
        this.fullscreenErrorHandler_ = null;
        if (USE_WAKELOCK && isMobile3()) {
          this.wakelock_ = new NoSleep$1();
        }
      }
      VRDisplay.prototype.getFrameData = function(frameData) {
        return frameDataFromPose(frameData, this._getPose(), this);
      };
      VRDisplay.prototype.getPose = function() {
        deprecateWarning("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData");
        return this._getPose();
      };
      VRDisplay.prototype.resetPose = function() {
        deprecateWarning("VRDisplay.prototype.resetPose");
        return this._resetPose();
      };
      VRDisplay.prototype.getImmediatePose = function() {
        deprecateWarning("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData");
        return this._getPose();
      };
      VRDisplay.prototype.requestAnimationFrame = function(callback) {
        return raf(callback);
      };
      VRDisplay.prototype.cancelAnimationFrame = function(id2) {
        return caf(id2);
      };
      VRDisplay.prototype.wrapForFullscreen = function(element) {
        if (isIOS2()) {
          return element;
        }
        if (!this.fullscreenWrapper_) {
          this.fullscreenWrapper_ = document.createElement("div");
          var cssProperties = ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important", "left: 0 !important", "right: 0 !important", "border: 0", "margin: 0", "padding: 0", "z-index: 999999 !important", "position: fixed"];
          this.fullscreenWrapper_.setAttribute("style", cssProperties.join("; ") + ";");
          this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper");
        }
        if (this.fullscreenElement_ == element) {
          return this.fullscreenWrapper_;
        }
        if (this.fullscreenElement_) {
          if (this.originalParent_) {
            this.originalParent_.appendChild(this.fullscreenElement_);
          } else {
            this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_);
          }
        }
        this.fullscreenElement_ = element;
        this.originalParent_ = element.parentElement;
        if (!this.originalParent_) {
          document.body.appendChild(element);
        }
        if (!this.fullscreenWrapper_.parentElement) {
          var parent = this.fullscreenElement_.parentElement;
          parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
          parent.removeChild(this.fullscreenElement_);
        }
        this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
        this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
        var self2 = this;
        function applyFullscreenElementStyle() {
          if (!self2.fullscreenElement_) {
            return;
          }
          var cssProperties2 = ["position: absolute", "top: 0", "left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0", "margin: 0", "padding: 0"];
          self2.fullscreenElement_.setAttribute("style", cssProperties2.join("; ") + ";");
        }
        applyFullscreenElementStyle();
        return this.fullscreenWrapper_;
      };
      VRDisplay.prototype.removeFullscreenWrapper = function() {
        if (!this.fullscreenElement_) {
          return;
        }
        var element = this.fullscreenElement_;
        if (this.fullscreenElementCachedStyle_) {
          element.setAttribute("style", this.fullscreenElementCachedStyle_);
        } else {
          element.removeAttribute("style");
        }
        this.fullscreenElement_ = null;
        this.fullscreenElementCachedStyle_ = null;
        var parent = this.fullscreenWrapper_.parentElement;
        this.fullscreenWrapper_.removeChild(element);
        if (this.originalParent_ === parent) {
          parent.insertBefore(element, this.fullscreenWrapper_);
        } else if (this.originalParent_) {
          this.originalParent_.appendChild(element);
        }
        parent.removeChild(this.fullscreenWrapper_);
        return element;
      };
      VRDisplay.prototype.requestPresent = function(layers) {
        var wasPresenting = this.isPresenting;
        var self2 = this;
        if (!(layers instanceof Array)) {
          deprecateWarning("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument");
          layers = [layers];
        }
        return new Promise(function(resolve, reject) {
          if (!self2.capabilities.canPresent) {
            reject(new Error("VRDisplay is not capable of presenting."));
            return;
          }
          if (layers.length == 0 || layers.length > self2.capabilities.maxLayers) {
            reject(new Error("Invalid number of layers."));
            return;
          }
          var incomingLayer = layers[0];
          if (!incomingLayer.source) {
            resolve();
            return;
          }
          var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
          var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
          if (wasPresenting) {
            var layer = self2.layer_;
            if (layer.source !== incomingLayer.source) {
              layer.source = incomingLayer.source;
            }
            for (var i = 0; i < 4; i++) {
              layer.leftBounds[i] = leftBounds[i];
              layer.rightBounds[i] = rightBounds[i];
            }
            self2.wrapForFullscreen(self2.layer_.source);
            self2.updatePresent_();
            resolve();
            return;
          }
          self2.layer_ = {
            predistorted: incomingLayer.predistorted,
            source: incomingLayer.source,
            leftBounds: leftBounds.slice(0),
            rightBounds: rightBounds.slice(0)
          };
          self2.waitingForPresent_ = false;
          if (self2.layer_ && self2.layer_.source) {
            var fullscreenElement = self2.wrapForFullscreen(self2.layer_.source);
            var onFullscreenChange = function onFullscreenChange2() {
              var actualFullscreenElement = getFullscreenElement();
              self2.isPresenting = fullscreenElement === actualFullscreenElement;
              if (self2.isPresenting) {
                if (screen.orientation && screen.orientation.lock) {
                  screen.orientation.lock("landscape-primary").catch(function(error) {
                    console.error("screen.orientation.lock() failed due to", error.message);
                  });
                }
                self2.waitingForPresent_ = false;
                self2.beginPresent_();
                resolve();
              } else {
                if (screen.orientation && screen.orientation.unlock) {
                  screen.orientation.unlock();
                }
                self2.removeFullscreenWrapper();
                self2.disableWakeLock();
                self2.endPresent_();
                self2.removeFullscreenListeners_();
              }
              self2.fireVRDisplayPresentChange_();
            };
            var onFullscreenError = function onFullscreenError2() {
              if (!self2.waitingForPresent_) {
                return;
              }
              self2.removeFullscreenWrapper();
              self2.removeFullscreenListeners_();
              self2.disableWakeLock();
              self2.waitingForPresent_ = false;
              self2.isPresenting = false;
              reject(new Error("Unable to present."));
            };
            self2.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError);
            if (requestFullscreen(fullscreenElement)) {
              self2.enableWakeLock();
              self2.waitingForPresent_ = true;
            } else if (isIOS2() || isWebViewAndroid()) {
              self2.enableWakeLock();
              self2.isPresenting = true;
              self2.beginPresent_();
              self2.fireVRDisplayPresentChange_();
              resolve();
            }
          }
          if (!self2.waitingForPresent_ && !isIOS2()) {
            exitFullscreen();
            reject(new Error("Unable to present."));
          }
        });
      };
      VRDisplay.prototype.exitPresent = function() {
        var wasPresenting = this.isPresenting;
        var self2 = this;
        this.isPresenting = false;
        this.layer_ = null;
        this.disableWakeLock();
        return new Promise(function(resolve, reject) {
          if (wasPresenting) {
            if (!exitFullscreen() && isIOS2()) {
              self2.endPresent_();
              self2.fireVRDisplayPresentChange_();
            }
            if (isWebViewAndroid()) {
              self2.removeFullscreenWrapper();
              self2.removeFullscreenListeners_();
              self2.endPresent_();
              self2.fireVRDisplayPresentChange_();
            }
            resolve();
          } else {
            reject(new Error("Was not presenting to VRDisplay."));
          }
        });
      };
      VRDisplay.prototype.getLayers = function() {
        if (this.layer_) {
          return [this.layer_];
        }
        return [];
      };
      VRDisplay.prototype.fireVRDisplayPresentChange_ = function() {
        var event = new CustomEvent("vrdisplaypresentchange", { detail: { display: this } });
        window.dispatchEvent(event);
      };
      VRDisplay.prototype.fireVRDisplayConnect_ = function() {
        var event = new CustomEvent("vrdisplayconnect", { detail: { display: this } });
        window.dispatchEvent(event);
      };
      VRDisplay.prototype.addFullscreenListeners_ = function(element, changeHandler, errorHandler) {
        this.removeFullscreenListeners_();
        this.fullscreenEventTarget_ = element;
        this.fullscreenChangeHandler_ = changeHandler;
        this.fullscreenErrorHandler_ = errorHandler;
        if (changeHandler) {
          if (document.fullscreenEnabled) {
            element.addEventListener("fullscreenchange", changeHandler, false);
          } else if (document.webkitFullscreenEnabled) {
            element.addEventListener("webkitfullscreenchange", changeHandler, false);
          } else if (document.mozFullScreenEnabled) {
            document.addEventListener("mozfullscreenchange", changeHandler, false);
          } else if (document.msFullscreenEnabled) {
            element.addEventListener("msfullscreenchange", changeHandler, false);
          }
        }
        if (errorHandler) {
          if (document.fullscreenEnabled) {
            element.addEventListener("fullscreenerror", errorHandler, false);
          } else if (document.webkitFullscreenEnabled) {
            element.addEventListener("webkitfullscreenerror", errorHandler, false);
          } else if (document.mozFullScreenEnabled) {
            document.addEventListener("mozfullscreenerror", errorHandler, false);
          } else if (document.msFullscreenEnabled) {
            element.addEventListener("msfullscreenerror", errorHandler, false);
          }
        }
      };
      VRDisplay.prototype.removeFullscreenListeners_ = function() {
        if (!this.fullscreenEventTarget_)
          return;
        var element = this.fullscreenEventTarget_;
        if (this.fullscreenChangeHandler_) {
          var changeHandler = this.fullscreenChangeHandler_;
          element.removeEventListener("fullscreenchange", changeHandler, false);
          element.removeEventListener("webkitfullscreenchange", changeHandler, false);
          document.removeEventListener("mozfullscreenchange", changeHandler, false);
          element.removeEventListener("msfullscreenchange", changeHandler, false);
        }
        if (this.fullscreenErrorHandler_) {
          var errorHandler = this.fullscreenErrorHandler_;
          element.removeEventListener("fullscreenerror", errorHandler, false);
          element.removeEventListener("webkitfullscreenerror", errorHandler, false);
          document.removeEventListener("mozfullscreenerror", errorHandler, false);
          element.removeEventListener("msfullscreenerror", errorHandler, false);
        }
        this.fullscreenEventTarget_ = null;
        this.fullscreenChangeHandler_ = null;
        this.fullscreenErrorHandler_ = null;
      };
      VRDisplay.prototype.enableWakeLock = function() {
        if (this.wakelock_) {
          this.wakelock_.enable();
        }
      };
      VRDisplay.prototype.disableWakeLock = function() {
        if (this.wakelock_) {
          this.wakelock_.disable();
        }
      };
      VRDisplay.prototype.beginPresent_ = function() {
      };
      VRDisplay.prototype.endPresent_ = function() {
      };
      VRDisplay.prototype.submitFrame = function(pose) {
      };
      VRDisplay.prototype.getEyeParameters = function(whichEye) {
        return null;
      };
      var config = {
        ADDITIONAL_VIEWERS: [],
        DEFAULT_VIEWER: "",
        MOBILE_WAKE_LOCK: true,
        DEBUG: false,
        DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
        K_FILTER: 0.98,
        PREDICTION_TIME_S: 0.04,
        CARDBOARD_UI_DISABLED: false,
        ROTATE_INSTRUCTIONS_DISABLED: false,
        YAW_ONLY: false,
        BUFFER_SCALE: 0.5,
        DIRTY_SUBMIT_FRAME_BINDINGS: false
      };
      var Eye = {
        LEFT: "left",
        RIGHT: "right"
      };
      function CardboardVRDisplay2(config$$1) {
        var defaults = extend({}, config);
        config$$1 = extend(defaults, config$$1 || {});
        VRDisplay.call(this, {
          wakelock: config$$1.MOBILE_WAKE_LOCK
        });
        this.config = config$$1;
        this.displayName = "Cardboard VRDisplay";
        this.capabilities = new VRDisplayCapabilities({
          hasPosition: false,
          hasOrientation: true,
          hasExternalDisplay: false,
          canPresent: true,
          maxLayers: 1
        });
        this.stageParameters = null;
        this.bufferScale_ = this.config.BUFFER_SCALE;
        this.poseSensor_ = new PoseSensor(this.config);
        this.distorter_ = null;
        this.cardboardUI_ = null;
        this.dpdb_ = new Dpdb(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this));
        this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams(), config$$1.ADDITIONAL_VIEWERS);
        this.viewerSelector_ = new ViewerSelector(config$$1.DEFAULT_VIEWER);
        this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));
        this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
        if (!this.config.ROTATE_INSTRUCTIONS_DISABLED) {
          this.rotateInstructions_ = new RotateInstructions();
        }
        if (isIOS2()) {
          window.addEventListener("resize", this.onResize_.bind(this));
        }
      }
      CardboardVRDisplay2.prototype = Object.create(VRDisplay.prototype);
      CardboardVRDisplay2.prototype._getPose = function() {
        return {
          position: null,
          orientation: this.poseSensor_.getOrientation(),
          linearVelocity: null,
          linearAcceleration: null,
          angularVelocity: null,
          angularAcceleration: null
        };
      };
      CardboardVRDisplay2.prototype._resetPose = function() {
        if (this.poseSensor_.resetPose) {
          this.poseSensor_.resetPose();
        }
      };
      CardboardVRDisplay2.prototype._getFieldOfView = function(whichEye) {
        var fieldOfView;
        if (whichEye == Eye.LEFT) {
          fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
        } else if (whichEye == Eye.RIGHT) {
          fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
        } else {
          console.error("Invalid eye provided: %s", whichEye);
          return null;
        }
        return fieldOfView;
      };
      CardboardVRDisplay2.prototype._getEyeOffset = function(whichEye) {
        var offset;
        if (whichEye == Eye.LEFT) {
          offset = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
        } else if (whichEye == Eye.RIGHT) {
          offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0, 0];
        } else {
          console.error("Invalid eye provided: %s", whichEye);
          return null;
        }
        return offset;
      };
      CardboardVRDisplay2.prototype.getEyeParameters = function(whichEye) {
        var offset = this._getEyeOffset(whichEye);
        var fieldOfView = this._getFieldOfView(whichEye);
        var eyeParams = {
          offset,
          renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
          renderHeight: this.deviceInfo_.device.height * this.bufferScale_
        };
        Object.defineProperty(eyeParams, "fieldOfView", {
          enumerable: true,
          get: function get() {
            deprecateWarning("VRFieldOfView", "VRFrameData's projection matrices");
            return fieldOfView;
          }
        });
        return eyeParams;
      };
      CardboardVRDisplay2.prototype.onDeviceParamsUpdated_ = function(newParams) {
        if (this.config.DEBUG) {
          console.log("DPDB reported that device params were updated.");
        }
        this.deviceInfo_.updateDeviceParams(newParams);
        if (this.distorter_) {
          this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }
      };
      CardboardVRDisplay2.prototype.updateBounds_ = function() {
        if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
          this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
        }
      };
      CardboardVRDisplay2.prototype.beginPresent_ = function() {
        var gl = this.layer_.source.getContext("webgl");
        if (!gl)
          gl = this.layer_.source.getContext("experimental-webgl");
        if (!gl)
          gl = this.layer_.source.getContext("webgl2");
        if (!gl)
          return;
        if (this.layer_.predistorted) {
          if (!this.config.CARDBOARD_UI_DISABLED) {
            gl.canvas.width = getScreenWidth() * this.bufferScale_;
            gl.canvas.height = getScreenHeight() * this.bufferScale_;
            this.cardboardUI_ = new CardboardUI(gl);
          }
        } else {
          if (!this.config.CARDBOARD_UI_DISABLED) {
            this.cardboardUI_ = new CardboardUI(gl);
          }
          this.distorter_ = new CardboardDistorter(gl, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS);
          this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }
        if (this.cardboardUI_) {
          this.cardboardUI_.listen(function(e2) {
            this.viewerSelector_.show(this.layer_.source.parentElement);
            e2.stopPropagation();
            e2.preventDefault();
          }.bind(this), function(e2) {
            this.exitPresent();
            e2.stopPropagation();
            e2.preventDefault();
          }.bind(this));
        }
        if (this.rotateInstructions_) {
          if (isLandscapeMode() && isMobile3()) {
            this.rotateInstructions_.showTemporarily(3e3, this.layer_.source.parentElement);
          } else {
            this.rotateInstructions_.update();
          }
        }
        this.orientationHandler = this.onOrientationChange_.bind(this);
        window.addEventListener("orientationchange", this.orientationHandler);
        this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
        window.addEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
        this.fireVRDisplayDeviceParamsChange_();
      };
      CardboardVRDisplay2.prototype.endPresent_ = function() {
        if (this.distorter_) {
          this.distorter_.destroy();
          this.distorter_ = null;
        }
        if (this.cardboardUI_) {
          this.cardboardUI_.destroy();
          this.cardboardUI_ = null;
        }
        if (this.rotateInstructions_) {
          this.rotateInstructions_.hide();
        }
        this.viewerSelector_.hide();
        window.removeEventListener("orientationchange", this.orientationHandler);
        window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler);
      };
      CardboardVRDisplay2.prototype.updatePresent_ = function() {
        this.endPresent_();
        this.beginPresent_();
      };
      CardboardVRDisplay2.prototype.submitFrame = function(pose) {
        if (this.distorter_) {
          this.updateBounds_();
          this.distorter_.submitFrame();
        } else if (this.cardboardUI_ && this.layer_) {
          var gl = this.layer_.source.getContext("webgl");
          if (!gl)
            gl = this.layer_.source.getContext("experimental-webgl");
          if (!gl)
            gl = this.layer_.source.getContext("webgl2");
          var canvas = gl.canvas;
          if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
            this.cardboardUI_.onResize();
          }
          this.lastWidth = canvas.width;
          this.lastHeight = canvas.height;
          this.cardboardUI_.render();
        }
      };
      CardboardVRDisplay2.prototype.onOrientationChange_ = function(e2) {
        this.viewerSelector_.hide();
        if (this.rotateInstructions_) {
          this.rotateInstructions_.update();
        }
        this.onResize_();
      };
      CardboardVRDisplay2.prototype.onResize_ = function(e2) {
        if (this.layer_) {
          var gl = this.layer_.source.getContext("webgl");
          if (!gl)
            gl = this.layer_.source.getContext("experimental-webgl");
          if (!gl)
            gl = this.layer_.source.getContext("webgl2");
          var cssProperties = [
            "position: absolute",
            "top: 0",
            "left: 0",
            "width: 100vw",
            "height: 100vh",
            "border: 0",
            "margin: 0",
            "padding: 0px",
            "box-sizing: content-box"
          ];
          gl.canvas.setAttribute("style", cssProperties.join("; ") + ";");
          safariCssSizeWorkaround(gl.canvas);
        }
      };
      CardboardVRDisplay2.prototype.onViewerChanged_ = function(viewer) {
        this.deviceInfo_.setViewer(viewer);
        if (this.distorter_) {
          this.distorter_.updateDeviceInfo(this.deviceInfo_);
        }
        this.fireVRDisplayDeviceParamsChange_();
      };
      CardboardVRDisplay2.prototype.fireVRDisplayDeviceParamsChange_ = function() {
        var event = new CustomEvent("vrdisplaydeviceparamschange", {
          detail: {
            vrdisplay: this,
            deviceInfo: this.deviceInfo_
          }
        });
        window.dispatchEvent(event);
      };
      CardboardVRDisplay2.VRFrameData = VRFrameData;
      CardboardVRDisplay2.VRDisplay = VRDisplay;
      return CardboardVRDisplay2;
    });
  }
});

// (disabled):fs
var require_fs = __commonJS({
  "(disabled):fs"() {
  }
});

// (disabled):canvas
var require_canvas = __commonJS({
  "(disabled):canvas"() {
  }
});

// (disabled):zlib
var require_zlib = __commonJS({
  "(disabled):zlib"() {
  }
});

// (disabled):http
var require_http = __commonJS({
  "(disabled):http"() {
  }
});

// (disabled):https
var require_https = __commonJS({
  "(disabled):https"() {
  }
});

// (disabled):url
var require_url = __commonJS({
  "(disabled):url"() {
  }
});

// ../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/build/pdf.js
var require_pdf = __commonJS({
  "../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/build/pdf.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("pdfjs-dist/build/pdf", [], factory);
      else if (typeof exports === "object")
        exports["pdfjs-dist/build/pdf"] = factory();
      else
        root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory();
    })(globalThis, () => {
      return (
        /******/
        (() => {
          "use strict";
          var __webpack_modules__ = [
            ,
            /* 1 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.VerbosityLevel = exports2.Util = exports2.UnknownErrorException = exports2.UnexpectedResponseException = exports2.UNSUPPORTED_FEATURES = exports2.TextRenderingMode = exports2.StreamType = exports2.RenderingIntentFlag = exports2.PermissionFlag = exports2.PasswordResponses = exports2.PasswordException = exports2.PageActionEventType = exports2.OPS = exports2.MissingPDFException = exports2.LINE_FACTOR = exports2.LINE_DESCENT_FACTOR = exports2.InvalidPDFException = exports2.ImageKind = exports2.IDENTITY_MATRIX = exports2.FormatError = exports2.FontType = exports2.FeatureTest = exports2.FONT_IDENTITY_MATRIX = exports2.DocumentActionEventType = exports2.CMapCompressionType = exports2.BaseException = exports2.AnnotationType = exports2.AnnotationStateModelType = exports2.AnnotationReviewState = exports2.AnnotationReplyType = exports2.AnnotationMode = exports2.AnnotationMarkedState = exports2.AnnotationFlag = exports2.AnnotationFieldFlag = exports2.AnnotationEditorType = exports2.AnnotationEditorPrefix = exports2.AnnotationEditorParamsType = exports2.AnnotationBorderStyleType = exports2.AnnotationActionEventType = exports2.AbortException = void 0;
              exports2.arrayByteLength = arrayByteLength;
              exports2.arraysToBytes = arraysToBytes;
              exports2.assert = assert;
              exports2.bytesToString = bytesToString;
              exports2.createPromiseCapability = createPromiseCapability;
              exports2.createValidAbsoluteUrl = createValidAbsoluteUrl;
              exports2.escapeString = escapeString;
              exports2.getModificationDate = getModificationDate;
              exports2.getVerbosityLevel = getVerbosityLevel;
              exports2.info = info;
              exports2.isArrayBuffer = isArrayBuffer2;
              exports2.isArrayEqual = isArrayEqual;
              exports2.isAscii = isAscii;
              exports2.objectFromMap = objectFromMap;
              exports2.objectSize = objectSize;
              exports2.setVerbosityLevel = setVerbosityLevel;
              exports2.shadow = shadow;
              exports2.string32 = string32;
              exports2.stringToBytes = stringToBytes;
              exports2.stringToPDFString = stringToPDFString;
              exports2.stringToUTF16BEString = stringToUTF16BEString;
              exports2.stringToUTF8String = stringToUTF8String;
              exports2.unreachable = unreachable;
              exports2.utf8StringToString = utf8StringToString;
              exports2.warn = warn;
              __w_pdfjs_require__2(2);
              const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
              exports2.IDENTITY_MATRIX = IDENTITY_MATRIX;
              const FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
              exports2.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
              const LINE_FACTOR = 1.35;
              exports2.LINE_FACTOR = LINE_FACTOR;
              const LINE_DESCENT_FACTOR = 0.35;
              exports2.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
              const RenderingIntentFlag = {
                ANY: 1,
                DISPLAY: 2,
                PRINT: 4,
                ANNOTATIONS_FORMS: 16,
                ANNOTATIONS_STORAGE: 32,
                ANNOTATIONS_DISABLE: 64,
                OPLIST: 256
              };
              exports2.RenderingIntentFlag = RenderingIntentFlag;
              const AnnotationMode = {
                DISABLE: 0,
                ENABLE: 1,
                ENABLE_FORMS: 2,
                ENABLE_STORAGE: 3
              };
              exports2.AnnotationMode = AnnotationMode;
              const AnnotationEditorPrefix = "pdfjs_internal_editor_";
              exports2.AnnotationEditorPrefix = AnnotationEditorPrefix;
              const AnnotationEditorType = {
                DISABLE: -1,
                NONE: 0,
                FREETEXT: 3,
                INK: 15
              };
              exports2.AnnotationEditorType = AnnotationEditorType;
              const AnnotationEditorParamsType = {
                FREETEXT_SIZE: 1,
                FREETEXT_COLOR: 2,
                FREETEXT_OPACITY: 3,
                INK_COLOR: 11,
                INK_THICKNESS: 12,
                INK_OPACITY: 13
              };
              exports2.AnnotationEditorParamsType = AnnotationEditorParamsType;
              const PermissionFlag = {
                PRINT: 4,
                MODIFY_CONTENTS: 8,
                COPY: 16,
                MODIFY_ANNOTATIONS: 32,
                FILL_INTERACTIVE_FORMS: 256,
                COPY_FOR_ACCESSIBILITY: 512,
                ASSEMBLE: 1024,
                PRINT_HIGH_QUALITY: 2048
              };
              exports2.PermissionFlag = PermissionFlag;
              const TextRenderingMode = {
                FILL: 0,
                STROKE: 1,
                FILL_STROKE: 2,
                INVISIBLE: 3,
                FILL_ADD_TO_PATH: 4,
                STROKE_ADD_TO_PATH: 5,
                FILL_STROKE_ADD_TO_PATH: 6,
                ADD_TO_PATH: 7,
                FILL_STROKE_MASK: 3,
                ADD_TO_PATH_FLAG: 4
              };
              exports2.TextRenderingMode = TextRenderingMode;
              const ImageKind = {
                GRAYSCALE_1BPP: 1,
                RGB_24BPP: 2,
                RGBA_32BPP: 3
              };
              exports2.ImageKind = ImageKind;
              const AnnotationType = {
                TEXT: 1,
                LINK: 2,
                FREETEXT: 3,
                LINE: 4,
                SQUARE: 5,
                CIRCLE: 6,
                POLYGON: 7,
                POLYLINE: 8,
                HIGHLIGHT: 9,
                UNDERLINE: 10,
                SQUIGGLY: 11,
                STRIKEOUT: 12,
                STAMP: 13,
                CARET: 14,
                INK: 15,
                POPUP: 16,
                FILEATTACHMENT: 17,
                SOUND: 18,
                MOVIE: 19,
                WIDGET: 20,
                SCREEN: 21,
                PRINTERMARK: 22,
                TRAPNET: 23,
                WATERMARK: 24,
                THREED: 25,
                REDACT: 26
              };
              exports2.AnnotationType = AnnotationType;
              const AnnotationStateModelType = {
                MARKED: "Marked",
                REVIEW: "Review"
              };
              exports2.AnnotationStateModelType = AnnotationStateModelType;
              const AnnotationMarkedState = {
                MARKED: "Marked",
                UNMARKED: "Unmarked"
              };
              exports2.AnnotationMarkedState = AnnotationMarkedState;
              const AnnotationReviewState = {
                ACCEPTED: "Accepted",
                REJECTED: "Rejected",
                CANCELLED: "Cancelled",
                COMPLETED: "Completed",
                NONE: "None"
              };
              exports2.AnnotationReviewState = AnnotationReviewState;
              const AnnotationReplyType = {
                GROUP: "Group",
                REPLY: "R"
              };
              exports2.AnnotationReplyType = AnnotationReplyType;
              const AnnotationFlag = {
                INVISIBLE: 1,
                HIDDEN: 2,
                PRINT: 4,
                NOZOOM: 8,
                NOROTATE: 16,
                NOVIEW: 32,
                READONLY: 64,
                LOCKED: 128,
                TOGGLENOVIEW: 256,
                LOCKEDCONTENTS: 512
              };
              exports2.AnnotationFlag = AnnotationFlag;
              const AnnotationFieldFlag = {
                READONLY: 1,
                REQUIRED: 2,
                NOEXPORT: 4,
                MULTILINE: 4096,
                PASSWORD: 8192,
                NOTOGGLETOOFF: 16384,
                RADIO: 32768,
                PUSHBUTTON: 65536,
                COMBO: 131072,
                EDIT: 262144,
                SORT: 524288,
                FILESELECT: 1048576,
                MULTISELECT: 2097152,
                DONOTSPELLCHECK: 4194304,
                DONOTSCROLL: 8388608,
                COMB: 16777216,
                RICHTEXT: 33554432,
                RADIOSINUNISON: 33554432,
                COMMITONSELCHANGE: 67108864
              };
              exports2.AnnotationFieldFlag = AnnotationFieldFlag;
              const AnnotationBorderStyleType = {
                SOLID: 1,
                DASHED: 2,
                BEVELED: 3,
                INSET: 4,
                UNDERLINE: 5
              };
              exports2.AnnotationBorderStyleType = AnnotationBorderStyleType;
              const AnnotationActionEventType = {
                E: "Mouse Enter",
                X: "Mouse Exit",
                D: "Mouse Down",
                U: "Mouse Up",
                Fo: "Focus",
                Bl: "Blur",
                PO: "PageOpen",
                PC: "PageClose",
                PV: "PageVisible",
                PI: "PageInvisible",
                K: "Keystroke",
                F: "Format",
                V: "Validate",
                C: "Calculate"
              };
              exports2.AnnotationActionEventType = AnnotationActionEventType;
              const DocumentActionEventType = {
                WC: "WillClose",
                WS: "WillSave",
                DS: "DidSave",
                WP: "WillPrint",
                DP: "DidPrint"
              };
              exports2.DocumentActionEventType = DocumentActionEventType;
              const PageActionEventType = {
                O: "PageOpen",
                C: "PageClose"
              };
              exports2.PageActionEventType = PageActionEventType;
              const StreamType = {
                UNKNOWN: "UNKNOWN",
                FLATE: "FLATE",
                LZW: "LZW",
                DCT: "DCT",
                JPX: "JPX",
                JBIG: "JBIG",
                A85: "A85",
                AHX: "AHX",
                CCF: "CCF",
                RLX: "RLX"
              };
              exports2.StreamType = StreamType;
              const FontType = {
                UNKNOWN: "UNKNOWN",
                TYPE1: "TYPE1",
                TYPE1STANDARD: "TYPE1STANDARD",
                TYPE1C: "TYPE1C",
                CIDFONTTYPE0: "CIDFONTTYPE0",
                CIDFONTTYPE0C: "CIDFONTTYPE0C",
                TRUETYPE: "TRUETYPE",
                CIDFONTTYPE2: "CIDFONTTYPE2",
                TYPE3: "TYPE3",
                OPENTYPE: "OPENTYPE",
                TYPE0: "TYPE0",
                MMTYPE1: "MMTYPE1"
              };
              exports2.FontType = FontType;
              const VerbosityLevel = {
                ERRORS: 0,
                WARNINGS: 1,
                INFOS: 5
              };
              exports2.VerbosityLevel = VerbosityLevel;
              const CMapCompressionType = {
                NONE: 0,
                BINARY: 1,
                STREAM: 2
              };
              exports2.CMapCompressionType = CMapCompressionType;
              const OPS = {
                dependency: 1,
                setLineWidth: 2,
                setLineCap: 3,
                setLineJoin: 4,
                setMiterLimit: 5,
                setDash: 6,
                setRenderingIntent: 7,
                setFlatness: 8,
                setGState: 9,
                save: 10,
                restore: 11,
                transform: 12,
                moveTo: 13,
                lineTo: 14,
                curveTo: 15,
                curveTo2: 16,
                curveTo3: 17,
                closePath: 18,
                rectangle: 19,
                stroke: 20,
                closeStroke: 21,
                fill: 22,
                eoFill: 23,
                fillStroke: 24,
                eoFillStroke: 25,
                closeFillStroke: 26,
                closeEOFillStroke: 27,
                endPath: 28,
                clip: 29,
                eoClip: 30,
                beginText: 31,
                endText: 32,
                setCharSpacing: 33,
                setWordSpacing: 34,
                setHScale: 35,
                setLeading: 36,
                setFont: 37,
                setTextRenderingMode: 38,
                setTextRise: 39,
                moveText: 40,
                setLeadingMoveText: 41,
                setTextMatrix: 42,
                nextLine: 43,
                showText: 44,
                showSpacedText: 45,
                nextLineShowText: 46,
                nextLineSetSpacingShowText: 47,
                setCharWidth: 48,
                setCharWidthAndBounds: 49,
                setStrokeColorSpace: 50,
                setFillColorSpace: 51,
                setStrokeColor: 52,
                setStrokeColorN: 53,
                setFillColor: 54,
                setFillColorN: 55,
                setStrokeGray: 56,
                setFillGray: 57,
                setStrokeRGBColor: 58,
                setFillRGBColor: 59,
                setStrokeCMYKColor: 60,
                setFillCMYKColor: 61,
                shadingFill: 62,
                beginInlineImage: 63,
                beginImageData: 64,
                endInlineImage: 65,
                paintXObject: 66,
                markPoint: 67,
                markPointProps: 68,
                beginMarkedContent: 69,
                beginMarkedContentProps: 70,
                endMarkedContent: 71,
                beginCompat: 72,
                endCompat: 73,
                paintFormXObjectBegin: 74,
                paintFormXObjectEnd: 75,
                beginGroup: 76,
                endGroup: 77,
                beginAnnotations: 78,
                endAnnotations: 79,
                beginAnnotation: 80,
                endAnnotation: 81,
                paintJpegXObject: 82,
                paintImageMaskXObject: 83,
                paintImageMaskXObjectGroup: 84,
                paintImageXObject: 85,
                paintInlineImageXObject: 86,
                paintInlineImageXObjectGroup: 87,
                paintImageXObjectRepeat: 88,
                paintImageMaskXObjectRepeat: 89,
                paintSolidColorImageMask: 90,
                constructPath: 91
              };
              exports2.OPS = OPS;
              const UNSUPPORTED_FEATURES = {
                unknown: "unknown",
                forms: "forms",
                javaScript: "javaScript",
                signatures: "signatures",
                smask: "smask",
                shadingPattern: "shadingPattern",
                font: "font",
                errorTilingPattern: "errorTilingPattern",
                errorExtGState: "errorExtGState",
                errorXObject: "errorXObject",
                errorFontLoadType3: "errorFontLoadType3",
                errorFontState: "errorFontState",
                errorFontMissing: "errorFontMissing",
                errorFontTranslate: "errorFontTranslate",
                errorColorSpace: "errorColorSpace",
                errorOperatorList: "errorOperatorList",
                errorFontToUnicode: "errorFontToUnicode",
                errorFontLoadNative: "errorFontLoadNative",
                errorFontBuildPath: "errorFontBuildPath",
                errorFontGetPath: "errorFontGetPath",
                errorMarkedContent: "errorMarkedContent",
                errorContentSubStream: "errorContentSubStream"
              };
              exports2.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
              const PasswordResponses = {
                NEED_PASSWORD: 1,
                INCORRECT_PASSWORD: 2
              };
              exports2.PasswordResponses = PasswordResponses;
              let verbosity = VerbosityLevel.WARNINGS;
              function setVerbosityLevel(level) {
                if (Number.isInteger(level)) {
                  verbosity = level;
                }
              }
              function getVerbosityLevel() {
                return verbosity;
              }
              function info(msg) {
                if (verbosity >= VerbosityLevel.INFOS) {
                  console.log(`Info: ${msg}`);
                }
              }
              function warn(msg) {
                if (verbosity >= VerbosityLevel.WARNINGS) {
                  console.log(`Warning: ${msg}`);
                }
              }
              function unreachable(msg) {
                throw new Error(msg);
              }
              function assert(cond, msg) {
                if (!cond) {
                  unreachable(msg);
                }
              }
              function _isValidProtocol(url2) {
                if (!url2) {
                  return false;
                }
                switch (url2.protocol) {
                  case "http:":
                  case "https:":
                  case "ftp:":
                  case "mailto:":
                  case "tel:":
                    return true;
                  default:
                    return false;
                }
              }
              function createValidAbsoluteUrl(url2, baseUrl = null, options = null) {
                if (!url2) {
                  return null;
                }
                try {
                  if (options && typeof url2 === "string") {
                    if (options.addDefaultProtocol && url2.startsWith("www.")) {
                      const dots = url2.match(/\./g);
                      if (dots && dots.length >= 2) {
                        url2 = `http://${url2}`;
                      }
                    }
                    if (options.tryConvertEncoding) {
                      try {
                        url2 = stringToUTF8String(url2);
                      } catch (ex) {
                      }
                    }
                  }
                  const absoluteUrl = baseUrl ? new URL(url2, baseUrl) : new URL(url2);
                  if (_isValidProtocol(absoluteUrl)) {
                    return absoluteUrl;
                  }
                } catch (ex) {
                }
                return null;
              }
              function shadow(obj2, prop, value2) {
                Object.defineProperty(obj2, prop, {
                  value: value2,
                  enumerable: true,
                  configurable: true,
                  writable: false
                });
                return value2;
              }
              const BaseException = function BaseExceptionClosure() {
                function BaseException2(message2, name3) {
                  if (this.constructor === BaseException2) {
                    unreachable("Cannot initialize BaseException.");
                  }
                  this.message = message2;
                  this.name = name3;
                }
                BaseException2.prototype = new Error();
                BaseException2.constructor = BaseException2;
                return BaseException2;
              }();
              exports2.BaseException = BaseException;
              class PasswordException extends BaseException {
                constructor(msg, code) {
                  super(msg, "PasswordException");
                  this.code = code;
                }
              }
              exports2.PasswordException = PasswordException;
              class UnknownErrorException extends BaseException {
                constructor(msg, details) {
                  super(msg, "UnknownErrorException");
                  this.details = details;
                }
              }
              exports2.UnknownErrorException = UnknownErrorException;
              class InvalidPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "InvalidPDFException");
                }
              }
              exports2.InvalidPDFException = InvalidPDFException;
              class MissingPDFException extends BaseException {
                constructor(msg) {
                  super(msg, "MissingPDFException");
                }
              }
              exports2.MissingPDFException = MissingPDFException;
              class UnexpectedResponseException extends BaseException {
                constructor(msg, status) {
                  super(msg, "UnexpectedResponseException");
                  this.status = status;
                }
              }
              exports2.UnexpectedResponseException = UnexpectedResponseException;
              class FormatError extends BaseException {
                constructor(msg) {
                  super(msg, "FormatError");
                }
              }
              exports2.FormatError = FormatError;
              class AbortException extends BaseException {
                constructor(msg) {
                  super(msg, "AbortException");
                }
              }
              exports2.AbortException = AbortException;
              function bytesToString(bytes) {
                if (typeof bytes !== "object" || bytes === null || bytes.length === void 0) {
                  unreachable("Invalid argument for bytesToString");
                }
                const length8 = bytes.length;
                const MAX_ARGUMENT_COUNT = 8192;
                if (length8 < MAX_ARGUMENT_COUNT) {
                  return String.fromCharCode.apply(null, bytes);
                }
                const strBuf = [];
                for (let i = 0; i < length8; i += MAX_ARGUMENT_COUNT) {
                  const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length8);
                  const chunk = bytes.subarray(i, chunkEnd);
                  strBuf.push(String.fromCharCode.apply(null, chunk));
                }
                return strBuf.join("");
              }
              function stringToBytes(str5) {
                if (typeof str5 !== "string") {
                  unreachable("Invalid argument for stringToBytes");
                }
                const length8 = str5.length;
                const bytes = new Uint8Array(length8);
                for (let i = 0; i < length8; ++i) {
                  bytes[i] = str5.charCodeAt(i) & 255;
                }
                return bytes;
              }
              function arrayByteLength(arr) {
                if (arr.length !== void 0) {
                  return arr.length;
                }
                if (arr.byteLength !== void 0) {
                  return arr.byteLength;
                }
                unreachable("Invalid argument for arrayByteLength");
              }
              function arraysToBytes(arr) {
                const length8 = arr.length;
                if (length8 === 1 && arr[0] instanceof Uint8Array) {
                  return arr[0];
                }
                let resultLength = 0;
                for (let i = 0; i < length8; i++) {
                  resultLength += arrayByteLength(arr[i]);
                }
                let pos = 0;
                const data = new Uint8Array(resultLength);
                for (let i = 0; i < length8; i++) {
                  let item = arr[i];
                  if (!(item instanceof Uint8Array)) {
                    if (typeof item === "string") {
                      item = stringToBytes(item);
                    } else {
                      item = new Uint8Array(item);
                    }
                  }
                  const itemLength = item.byteLength;
                  data.set(item, pos);
                  pos += itemLength;
                }
                return data;
              }
              function string32(value2) {
                return String.fromCharCode(value2 >> 24 & 255, value2 >> 16 & 255, value2 >> 8 & 255, value2 & 255);
              }
              function objectSize(obj2) {
                return Object.keys(obj2).length;
              }
              function objectFromMap(map) {
                const obj2 = /* @__PURE__ */ Object.create(null);
                for (const [key, value2] of map) {
                  obj2[key] = value2;
                }
                return obj2;
              }
              function isLittleEndian() {
                const buffer8 = new Uint8Array(4);
                buffer8[0] = 1;
                const view32 = new Uint32Array(buffer8.buffer, 0, 1);
                return view32[0] === 1;
              }
              function isEvalSupported() {
                try {
                  new Function("");
                  return true;
                } catch (e2) {
                  return false;
                }
              }
              class FeatureTest {
                static get isLittleEndian() {
                  return shadow(this, "isLittleEndian", isLittleEndian());
                }
                static get isEvalSupported() {
                  return shadow(this, "isEvalSupported", isEvalSupported());
                }
                static get isOffscreenCanvasSupported() {
                  return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
                }
              }
              exports2.FeatureTest = FeatureTest;
              const hexNumbers = [...Array(256).keys()].map((n2) => n2.toString(16).padStart(2, "0"));
              class Util {
                static makeHexColor(r, g, b) {
                  return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
                }
                static scaleMinMax(transform2, minMax) {
                  let temp;
                  if (transform2[0]) {
                    if (transform2[0] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform2[0];
                    minMax[1] *= transform2[0];
                    if (transform2[3] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform2[3];
                    minMax[3] *= transform2[3];
                  } else {
                    temp = minMax[0];
                    minMax[0] = minMax[2];
                    minMax[2] = temp;
                    temp = minMax[1];
                    minMax[1] = minMax[3];
                    minMax[3] = temp;
                    if (transform2[1] < 0) {
                      temp = minMax[2];
                      minMax[2] = minMax[3];
                      minMax[3] = temp;
                    }
                    minMax[2] *= transform2[1];
                    minMax[3] *= transform2[1];
                    if (transform2[2] < 0) {
                      temp = minMax[0];
                      minMax[0] = minMax[1];
                      minMax[1] = temp;
                    }
                    minMax[0] *= transform2[2];
                    minMax[1] *= transform2[2];
                  }
                  minMax[0] += transform2[4];
                  minMax[1] += transform2[4];
                  minMax[2] += transform2[5];
                  minMax[3] += transform2[5];
                }
                static transform(m1, m2) {
                  return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
                }
                static applyTransform(p, m) {
                  const xt = p[0] * m[0] + p[1] * m[2] + m[4];
                  const yt = p[0] * m[1] + p[1] * m[3] + m[5];
                  return [xt, yt];
                }
                static applyInverseTransform(p, m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
                  const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
                  return [xt, yt];
                }
                static getAxialAlignedBoundingBox(r, m) {
                  const p1 = Util.applyTransform(r, m);
                  const p2 = Util.applyTransform(r.slice(2, 4), m);
                  const p3 = Util.applyTransform([r[0], r[3]], m);
                  const p4 = Util.applyTransform([r[2], r[1]], m);
                  return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
                }
                static inverseTransform(m) {
                  const d = m[0] * m[3] - m[1] * m[2];
                  return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
                }
                static apply3dTransform(m, v) {
                  return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
                }
                static singularValueDecompose2dScale(m) {
                  const transpose = [m[0], m[2], m[1], m[3]];
                  const a = m[0] * transpose[0] + m[1] * transpose[2];
                  const b = m[0] * transpose[1] + m[1] * transpose[3];
                  const c = m[2] * transpose[0] + m[3] * transpose[2];
                  const d = m[2] * transpose[1] + m[3] * transpose[3];
                  const first = (a + d) / 2;
                  const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
                  const sx = first + second || 1;
                  const sy = first - second || 1;
                  return [Math.sqrt(sx), Math.sqrt(sy)];
                }
                static normalizeRect(rect) {
                  const r = rect.slice(0);
                  if (rect[0] > rect[2]) {
                    r[0] = rect[2];
                    r[2] = rect[0];
                  }
                  if (rect[1] > rect[3]) {
                    r[1] = rect[3];
                    r[3] = rect[1];
                  }
                  return r;
                }
                static intersect(rect1, rect2) {
                  const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
                  const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
                  if (xLow > xHigh) {
                    return null;
                  }
                  const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
                  const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
                  if (yLow > yHigh) {
                    return null;
                  }
                  return [xLow, yLow, xHigh, yHigh];
                }
                static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
                  const tvalues = [], bounds = [[], []];
                  let a, b, c, t2, t1, t22, b2ac, sqrtb2ac;
                  for (let i = 0; i < 2; ++i) {
                    if (i === 0) {
                      b = 6 * x0 - 12 * x1 + 6 * x2;
                      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
                      c = 3 * x1 - 3 * x0;
                    } else {
                      b = 6 * y0 - 12 * y1 + 6 * y2;
                      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                      c = 3 * y1 - 3 * y0;
                    }
                    if (Math.abs(a) < 1e-12) {
                      if (Math.abs(b) < 1e-12) {
                        continue;
                      }
                      t2 = -c / b;
                      if (0 < t2 && t2 < 1) {
                        tvalues.push(t2);
                      }
                      continue;
                    }
                    b2ac = b * b - 4 * c * a;
                    sqrtb2ac = Math.sqrt(b2ac);
                    if (b2ac < 0) {
                      continue;
                    }
                    t1 = (-b + sqrtb2ac) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                      tvalues.push(t1);
                    }
                    t22 = (-b - sqrtb2ac) / (2 * a);
                    if (0 < t22 && t22 < 1) {
                      tvalues.push(t22);
                    }
                  }
                  let j = tvalues.length, mt;
                  const jlen = j;
                  while (j--) {
                    t2 = tvalues[j];
                    mt = 1 - t2;
                    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t2 * x1 + 3 * mt * t2 * t2 * x2 + t2 * t2 * t2 * x3;
                    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t2 * y1 + 3 * mt * t2 * t2 * y2 + t2 * t2 * t2 * y3;
                  }
                  bounds[0][jlen] = x0;
                  bounds[1][jlen] = y0;
                  bounds[0][jlen + 1] = x3;
                  bounds[1][jlen + 1] = y3;
                  bounds[0].length = bounds[1].length = jlen + 2;
                  return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
                }
              }
              exports2.Util = Util;
              const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
              function stringToPDFString(str5) {
                if (str5[0] >= "\xEF") {
                  let encoding;
                  if (str5[0] === "\xFE" && str5[1] === "\xFF") {
                    encoding = "utf-16be";
                  } else if (str5[0] === "\xFF" && str5[1] === "\xFE") {
                    encoding = "utf-16le";
                  } else if (str5[0] === "\xEF" && str5[1] === "\xBB" && str5[2] === "\xBF") {
                    encoding = "utf-8";
                  }
                  if (encoding) {
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = stringToBytes(str5);
                      return decoder.decode(buffer);
                    } catch (ex) {
                      warn(`stringToPDFString: "${ex}".`);
                    }
                  }
                }
                const strBuf = [];
                for (let i = 0, ii = str5.length; i < ii; i++) {
                  const code = PDFStringTranslateTable[str5.charCodeAt(i)];
                  strBuf.push(code ? String.fromCharCode(code) : str5.charAt(i));
                }
                return strBuf.join("");
              }
              function escapeString(str5) {
                return str5.replace(/([()\\\n\r])/g, (match) => {
                  if (match === "\n") {
                    return "\\n";
                  } else if (match === "\r") {
                    return "\\r";
                  }
                  return `\\${match}`;
                });
              }
              function isAscii(str5) {
                return /^[\x00-\x7F]*$/.test(str5);
              }
              function stringToUTF16BEString(str5) {
                const buf = ["\xFE\xFF"];
                for (let i = 0, ii = str5.length; i < ii; i++) {
                  const char = str5.charCodeAt(i);
                  buf.push(String.fromCharCode(char >> 8 & 255), String.fromCharCode(char & 255));
                }
                return buf.join("");
              }
              function stringToUTF8String(str5) {
                return decodeURIComponent(escape(str5));
              }
              function utf8StringToString(str5) {
                return unescape(encodeURIComponent(str5));
              }
              function isArrayBuffer2(v) {
                return typeof v === "object" && v !== null && v.byteLength !== void 0;
              }
              function isArrayEqual(arr1, arr2) {
                if (arr1.length !== arr2.length) {
                  return false;
                }
                for (let i = 0, ii = arr1.length; i < ii; i++) {
                  if (arr1[i] !== arr2[i]) {
                    return false;
                  }
                }
                return true;
              }
              function getModificationDate(date = /* @__PURE__ */ new Date()) {
                const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
                return buffer.join("");
              }
              function createPromiseCapability() {
                const capability = /* @__PURE__ */ Object.create(null);
                let isSettled = false;
                Object.defineProperty(capability, "settled", {
                  get() {
                    return isSettled;
                  }
                });
                capability.promise = new Promise(function(resolve, reject) {
                  capability.resolve = function(data) {
                    isSettled = true;
                    resolve(data);
                  };
                  capability.reject = function(reason) {
                    isSettled = true;
                    reject(reason);
                  };
                });
                return capability;
              }
            },
            /* 2 */
            /***/
            (__unused_webpack_module2, __unused_webpack_exports, __w_pdfjs_require__2) => {
              var _is_node2 = __w_pdfjs_require__2(3);
              ;
            },
            /* 3 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.isNodeJS = void 0;
              const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
              exports2.isNodeJS = isNodeJS;
            },
            /* 4 */
            /***/
            (__unused_webpack_module, exports, __w_pdfjs_require__) => {
              var _docId, _workerPorts, _docStats, _pageCache, _pagePromises, _metadataPromise, _objs, _ensureObj, ensureObj_fn, _internalRenderTask, _canvasInUse;
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
              exports.getDocument = getDocument;
              exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
              exports.version = void 0;
              var _util = __w_pdfjs_require__(1);
              var _annotation_storage = __w_pdfjs_require__(5);
              var _display_utils = __w_pdfjs_require__(8);
              var _font_loader = __w_pdfjs_require__(11);
              var _canvas = __w_pdfjs_require__(12);
              var _worker_options = __w_pdfjs_require__(15);
              var _is_node = __w_pdfjs_require__(3);
              var _message_handler = __w_pdfjs_require__(16);
              var _metadata = __w_pdfjs_require__(17);
              var _optional_content_config = __w_pdfjs_require__(18);
              var _transport_stream = __w_pdfjs_require__(19);
              var _xfa_text = __w_pdfjs_require__(20);
              const DEFAULT_RANGE_CHUNK_SIZE = 65536;
              const RENDERING_CANCELLED_TIMEOUT = 100;
              let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
              exports.DefaultCanvasFactory = DefaultCanvasFactory;
              let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
              exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
              let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
              exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
              if (_is_node.isNodeJS) {
                const {
                  NodeCanvasFactory,
                  NodeCMapReaderFactory,
                  NodeStandardFontDataFactory
                } = __w_pdfjs_require__(21);
                exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
                exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
                exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
              }
              let createPDFNetworkStream;
              function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
                createPDFNetworkStream = pdfNetworkStreamFactory;
              }
              function getDocument(src2) {
                const task = new PDFDocumentLoadingTask();
                let source;
                if (typeof src2 === "string" || src2 instanceof URL) {
                  source = {
                    url: src2
                  };
                } else if ((0, _util.isArrayBuffer)(src2)) {
                  source = {
                    data: src2
                  };
                } else if (src2 instanceof PDFDataRangeTransport) {
                  source = {
                    range: src2
                  };
                } else {
                  if (typeof src2 !== "object") {
                    throw new Error("Invalid parameter in getDocument, need either string, URL, TypedArray, or parameter object.");
                  }
                  if (!src2.url && !src2.data && !src2.range) {
                    throw new Error("Invalid parameter object: need either .data, .range or .url");
                  }
                  source = src2;
                }
                const params = /* @__PURE__ */ Object.create(null);
                let rangeTransport = null, worker2 = null;
                for (const key in source) {
                  const value2 = source[key];
                  switch (key) {
                    case "url":
                      if (typeof window !== "undefined") {
                        try {
                          params[key] = new URL(value2, window.location).href;
                          continue;
                        } catch (ex) {
                          (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
                        }
                      } else if (typeof value2 === "string" || value2 instanceof URL) {
                        params[key] = value2.toString();
                        continue;
                      }
                      throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
                    case "range":
                      rangeTransport = value2;
                      continue;
                    case "worker":
                      worker2 = value2;
                      continue;
                    case "data":
                      if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value2 instanceof Buffer) {
                        params[key] = new Uint8Array(value2);
                      } else if (value2 instanceof Uint8Array) {
                        break;
                      } else if (typeof value2 === "string") {
                        params[key] = (0, _util.stringToBytes)(value2);
                      } else if (typeof value2 === "object" && value2 !== null && !isNaN(value2.length)) {
                        params[key] = new Uint8Array(value2);
                      } else if ((0, _util.isArrayBuffer)(value2)) {
                        params[key] = new Uint8Array(value2);
                      } else {
                        throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
                      }
                      continue;
                  }
                  params[key] = value2;
                }
                params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
                params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
                params.ignoreErrors = params.stopAtErrors !== true;
                params.fontExtraProperties = params.fontExtraProperties === true;
                params.pdfBug = params.pdfBug === true;
                params.enableXfa = params.enableXfa === true;
                if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
                  params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
                }
                if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
                  params.docBaseUrl = null;
                }
                if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
                  params.maxImageSize = -1;
                }
                if (typeof params.cMapUrl !== "string") {
                  params.cMapUrl = null;
                }
                if (typeof params.standardFontDataUrl !== "string") {
                  params.standardFontDataUrl = null;
                }
                if (typeof params.useWorkerFetch !== "boolean") {
                  params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
                }
                if (typeof params.isEvalSupported !== "boolean") {
                  params.isEvalSupported = true;
                }
                if (typeof params.disableFontFace !== "boolean") {
                  params.disableFontFace = _is_node.isNodeJS;
                }
                if (typeof params.useSystemFonts !== "boolean") {
                  params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
                }
                if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
                  params.ownerDocument = globalThis.document;
                }
                if (typeof params.disableRange !== "boolean") {
                  params.disableRange = false;
                }
                if (typeof params.disableStream !== "boolean") {
                  params.disableStream = false;
                }
                if (typeof params.disableAutoFetch !== "boolean") {
                  params.disableAutoFetch = false;
                }
                (0, _util.setVerbosityLevel)(params.verbosity);
                if (!worker2) {
                  const workerParams = {
                    verbosity: params.verbosity,
                    port: _worker_options.GlobalWorkerOptions.workerPort
                  };
                  worker2 = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
                  task._worker = worker2;
                }
                const docId = task.docId;
                worker2.promise.then(function() {
                  if (task.destroyed) {
                    throw new Error("Loading aborted");
                  }
                  const workerIdPromise = _fetchDocument(worker2, params, rangeTransport, docId);
                  const networkStreamPromise = new Promise(function(resolve) {
                    let networkStream;
                    if (rangeTransport) {
                      networkStream = new _transport_stream.PDFDataTransportStream({
                        length: params.length,
                        initialData: params.initialData,
                        progressiveDone: params.progressiveDone,
                        contentDispositionFilename: params.contentDispositionFilename,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      }, rangeTransport);
                    } else if (!params.data) {
                      networkStream = createPDFNetworkStream({
                        url: params.url,
                        length: params.length,
                        httpHeaders: params.httpHeaders,
                        withCredentials: params.withCredentials,
                        rangeChunkSize: params.rangeChunkSize,
                        disableRange: params.disableRange,
                        disableStream: params.disableStream
                      });
                    }
                    resolve(networkStream);
                  });
                  return Promise.all([workerIdPromise, networkStreamPromise]).then(function([workerId, networkStream]) {
                    if (task.destroyed) {
                      throw new Error("Loading aborted");
                    }
                    const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker2.port);
                    const transport = new WorkerTransport(messageHandler, task, networkStream, params);
                    task._transport = transport;
                    messageHandler.send("Ready", null);
                  });
                }).catch(task._capability.reject);
                return task;
              }
              async function _fetchDocument(worker2, source, pdfDataRangeTransport, docId) {
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                if (pdfDataRangeTransport) {
                  source.length = pdfDataRangeTransport.length;
                  source.initialData = pdfDataRangeTransport.initialData;
                  source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                  source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                }
                const workerId = await worker2.messageHandler.sendWithPromise("GetDocRequest", {
                  docId,
                  apiVersion: "2.16.105",
                  source: {
                    data: source.data,
                    url: source.url,
                    password: source.password,
                    disableAutoFetch: source.disableAutoFetch,
                    rangeChunkSize: source.rangeChunkSize,
                    length: source.length
                  },
                  maxImageSize: source.maxImageSize,
                  disableFontFace: source.disableFontFace,
                  docBaseUrl: source.docBaseUrl,
                  ignoreErrors: source.ignoreErrors,
                  isEvalSupported: source.isEvalSupported,
                  fontExtraProperties: source.fontExtraProperties,
                  enableXfa: source.enableXfa,
                  useSystemFonts: source.useSystemFonts,
                  cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                  standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                });
                if (source.data) {
                  source.data = null;
                }
                if (worker2.destroyed) {
                  throw new Error("Worker was destroyed");
                }
                return workerId;
              }
              const _PDFDocumentLoadingTask = class {
                constructor() {
                  this._capability = (0, _util.createPromiseCapability)();
                  this._transport = null;
                  this._worker = null;
                  this.docId = `d${__privateWrapper(_PDFDocumentLoadingTask, _docId)._++}`;
                  this.destroyed = false;
                  this.onPassword = null;
                  this.onProgress = null;
                  this.onUnsupportedFeature = null;
                }
                get promise() {
                  return this._capability.promise;
                }
                async destroy() {
                  this.destroyed = true;
                  await this._transport?.destroy();
                  this._transport = null;
                  if (this._worker) {
                    this._worker.destroy();
                    this._worker = null;
                  }
                }
              };
              let PDFDocumentLoadingTask = _PDFDocumentLoadingTask;
              _docId = new WeakMap();
              __privateAdd(PDFDocumentLoadingTask, _docId, 0);
              exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
              class PDFDataRangeTransport {
                constructor(length8, initialData, progressiveDone = false, contentDispositionFilename = null) {
                  this.length = length8;
                  this.initialData = initialData;
                  this.progressiveDone = progressiveDone;
                  this.contentDispositionFilename = contentDispositionFilename;
                  this._rangeListeners = [];
                  this._progressListeners = [];
                  this._progressiveReadListeners = [];
                  this._progressiveDoneListeners = [];
                  this._readyCapability = (0, _util.createPromiseCapability)();
                }
                addRangeListener(listener) {
                  this._rangeListeners.push(listener);
                }
                addProgressListener(listener) {
                  this._progressListeners.push(listener);
                }
                addProgressiveReadListener(listener) {
                  this._progressiveReadListeners.push(listener);
                }
                addProgressiveDoneListener(listener) {
                  this._progressiveDoneListeners.push(listener);
                }
                onDataRange(begin, chunk) {
                  for (const listener of this._rangeListeners) {
                    listener(begin, chunk);
                  }
                }
                onDataProgress(loaded, total) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressListeners) {
                      listener(loaded, total);
                    }
                  });
                }
                onDataProgressiveRead(chunk) {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveReadListeners) {
                      listener(chunk);
                    }
                  });
                }
                onDataProgressiveDone() {
                  this._readyCapability.promise.then(() => {
                    for (const listener of this._progressiveDoneListeners) {
                      listener();
                    }
                  });
                }
                transportReady() {
                  this._readyCapability.resolve();
                }
                requestDataRange(begin, end2) {
                  (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
                }
                abort() {
                }
              }
              exports.PDFDataRangeTransport = PDFDataRangeTransport;
              class PDFDocumentProxy {
                constructor(pdfInfo, transport) {
                  this._pdfInfo = pdfInfo;
                  this._transport = transport;
                  Object.defineProperty(this, "fingerprint", {
                    get() {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, please use `PDFDocumentProxy.fingerprints` instead.");
                      return this.fingerprints[0];
                    }
                  });
                  Object.defineProperty(this, "getStats", {
                    value: async () => {
                      (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, please use the `PDFDocumentProxy.stats`-getter instead.");
                      return this.stats || {
                        streamTypes: {},
                        fontTypes: {}
                      };
                    }
                  });
                }
                get annotationStorage() {
                  return this._transport.annotationStorage;
                }
                get numPages() {
                  return this._pdfInfo.numPages;
                }
                get fingerprints() {
                  return this._pdfInfo.fingerprints;
                }
                get stats() {
                  return this._transport.stats;
                }
                get isPureXfa() {
                  return !!this._transport._htmlForXfa;
                }
                get allXfaHtml() {
                  return this._transport._htmlForXfa;
                }
                getPage(pageNumber) {
                  return this._transport.getPage(pageNumber);
                }
                getPageIndex(ref) {
                  return this._transport.getPageIndex(ref);
                }
                getDestinations() {
                  return this._transport.getDestinations();
                }
                getDestination(id2) {
                  return this._transport.getDestination(id2);
                }
                getPageLabels() {
                  return this._transport.getPageLabels();
                }
                getPageLayout() {
                  return this._transport.getPageLayout();
                }
                getPageMode() {
                  return this._transport.getPageMode();
                }
                getViewerPreferences() {
                  return this._transport.getViewerPreferences();
                }
                getOpenAction() {
                  return this._transport.getOpenAction();
                }
                getAttachments() {
                  return this._transport.getAttachments();
                }
                getJavaScript() {
                  return this._transport.getJavaScript();
                }
                getJSActions() {
                  return this._transport.getDocJSActions();
                }
                getOutline() {
                  return this._transport.getOutline();
                }
                getOptionalContentConfig() {
                  return this._transport.getOptionalContentConfig();
                }
                getPermissions() {
                  return this._transport.getPermissions();
                }
                getMetadata() {
                  return this._transport.getMetadata();
                }
                getMarkInfo() {
                  return this._transport.getMarkInfo();
                }
                getData() {
                  return this._transport.getData();
                }
                getDownloadInfo() {
                  return this._transport.downloadInfoCapability.promise;
                }
                cleanup(keepLoadedFonts = false) {
                  return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
                }
                destroy() {
                  return this.loadingTask.destroy();
                }
                get loadingParams() {
                  return this._transport.loadingParams;
                }
                get loadingTask() {
                  return this._transport.loadingTask;
                }
                saveDocument() {
                  if (this._transport.annotationStorage.size <= 0) {
                    (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
                  }
                  return this._transport.saveDocument();
                }
                getFieldObjects() {
                  return this._transport.getFieldObjects();
                }
                hasJSActions() {
                  return this._transport.hasJSActions();
                }
                getCalculationOrderIds() {
                  return this._transport.getCalculationOrderIds();
                }
              }
              exports.PDFDocumentProxy = PDFDocumentProxy;
              class PDFPageProxy {
                constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
                  this._pageIndex = pageIndex;
                  this._pageInfo = pageInfo;
                  this._ownerDocument = ownerDocument;
                  this._transport = transport;
                  this._stats = pdfBug ? new _display_utils.StatTimer() : null;
                  this._pdfBug = pdfBug;
                  this.commonObjs = transport.commonObjs;
                  this.objs = new PDFObjects();
                  this._bitmaps = /* @__PURE__ */ new Set();
                  this.cleanupAfterRender = false;
                  this.pendingCleanup = false;
                  this._intentStates = /* @__PURE__ */ new Map();
                  this._annotationPromises = /* @__PURE__ */ new Map();
                  this.destroyed = false;
                }
                get pageNumber() {
                  return this._pageIndex + 1;
                }
                get rotate() {
                  return this._pageInfo.rotate;
                }
                get ref() {
                  return this._pageInfo.ref;
                }
                get userUnit() {
                  return this._pageInfo.userUnit;
                }
                get view() {
                  return this._pageInfo.view;
                }
                getViewport({
                  scale: scale8,
                  rotation = this.rotate,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                } = {}) {
                  return new _display_utils.PageViewport({
                    viewBox: this.view,
                    scale: scale8,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                getAnnotations({
                  intent = "display"
                } = {}) {
                  const intentArgs = this._transport.getRenderingIntent(intent);
                  let promise = this._annotationPromises.get(intentArgs.cacheKey);
                  if (!promise) {
                    promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);
                    this._annotationPromises.set(intentArgs.cacheKey, promise);
                    promise = promise.then((annotations) => {
                      for (const annotation of annotations) {
                        if (annotation.titleObj !== void 0) {
                          Object.defineProperty(annotation, "title", {
                            get() {
                              (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                              return annotation.titleObj.str;
                            }
                          });
                        }
                        if (annotation.contentsObj !== void 0) {
                          Object.defineProperty(annotation, "contents", {
                            get() {
                              (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                              return annotation.contentsObj.str;
                            }
                          });
                        }
                      }
                      return annotations;
                    });
                  }
                  return promise;
                }
                getJSActions() {
                  return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);
                }
                async getXfa() {
                  return this._transport._htmlForXfa?.children[this._pageIndex] || null;
                }
                render({
                  canvasContext,
                  viewport,
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  transform: transform2 = null,
                  imageLayer = null,
                  canvasFactory = null,
                  background = null,
                  optionalContentConfigPromise = null,
                  annotationCanvasMap = null,
                  pageColors = null,
                  printAnnotationStorage = null
                }) {
                  if (arguments[0]?.renderInteractiveForms !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                    }
                  }
                  if (arguments[0]?.includeAnnotationStorage !== void 0) {
                    (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, please use the `annotationMode`-option instead.");
                    if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                      annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                    }
                  }
                  if (this._stats) {
                    this._stats.time("Overall");
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);
                  this.pendingCleanup = false;
                  if (!optionalContentConfigPromise) {
                    optionalContentConfigPromise = this._transport.getOptionalContentConfig();
                  }
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  if (intentState.streamReaderCancelTimeout) {
                    clearTimeout(intentState.streamReaderCancelTimeout);
                    intentState.streamReaderCancelTimeout = null;
                  }
                  const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                    ownerDocument: this._ownerDocument
                  });
                  const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);
                  if (!intentState.displayReadyCapability) {
                    intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  const complete = (error) => {
                    intentState.renderTasks.delete(internalRenderTask);
                    if (this.cleanupAfterRender || intentPrint) {
                      this.pendingCleanup = true;
                    }
                    this._tryCleanup();
                    if (error) {
                      internalRenderTask.capability.reject(error);
                      this._abortOperatorList({
                        intentState,
                        reason: error instanceof Error ? error : new Error(error)
                      });
                    } else {
                      internalRenderTask.capability.resolve();
                    }
                    if (this._stats) {
                      this._stats.timeEnd("Rendering");
                      this._stats.timeEnd("Overall");
                    }
                  };
                  const internalRenderTask = new InternalRenderTask({
                    callback: complete,
                    params: {
                      canvasContext,
                      viewport,
                      transform: transform2,
                      imageLayer,
                      background
                    },
                    objs: this.objs,
                    commonObjs: this.commonObjs,
                    annotationCanvasMap,
                    operatorList: intentState.operatorList,
                    pageIndex: this._pageIndex,
                    canvasFactory: canvasFactoryInstance,
                    useRequestAnimationFrame: !intentPrint,
                    pdfBug: this._pdfBug,
                    pageColors
                  });
                  (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
                  const renderTask = internalRenderTask.task;
                  Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
                    if (this.pendingCleanup) {
                      complete();
                      return;
                    }
                    if (this._stats) {
                      this._stats.time("Rendering");
                    }
                    internalRenderTask.initializeGraphics({
                      transparency,
                      optionalContentConfig
                    });
                    internalRenderTask.operatorListChanged();
                  }).catch(complete);
                  return renderTask;
                }
                getOperatorList({
                  intent = "display",
                  annotationMode = _util.AnnotationMode.ENABLE,
                  printAnnotationStorage = null
                } = {}) {
                  function operatorListChanged() {
                    if (intentState.operatorList.lastChunk) {
                      intentState.opListReadCapability.resolve(intentState.operatorList);
                      intentState.renderTasks.delete(opListTask);
                    }
                  }
                  const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);
                  let intentState = this._intentStates.get(intentArgs.cacheKey);
                  if (!intentState) {
                    intentState = /* @__PURE__ */ Object.create(null);
                    this._intentStates.set(intentArgs.cacheKey, intentState);
                  }
                  let opListTask;
                  if (!intentState.opListReadCapability) {
                    opListTask = /* @__PURE__ */ Object.create(null);
                    opListTask.operatorListChanged = operatorListChanged;
                    intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                    (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
                    intentState.operatorList = {
                      fnArray: [],
                      argsArray: [],
                      lastChunk: false,
                      separateAnnots: null
                    };
                    if (this._stats) {
                      this._stats.time("Page Request");
                    }
                    this._pumpOperatorList(intentArgs);
                  }
                  return intentState.opListReadCapability.promise;
                }
                streamTextContent({
                  disableCombineTextItems = false,
                  includeMarkedContent = false
                } = {}) {
                  const TEXT_CONTENT_CHUNK_SIZE = 100;
                  return this._transport.messageHandler.sendWithStream("GetTextContent", {
                    pageIndex: this._pageIndex,
                    combineTextItems: disableCombineTextItems !== true,
                    includeMarkedContent: includeMarkedContent === true
                  }, {
                    highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                    size(textContent) {
                      return textContent.items.length;
                    }
                  });
                }
                getTextContent(params = {}) {
                  if (this._transport._htmlForXfa) {
                    return this.getXfa().then((xfa) => {
                      return _xfa_text.XfaText.textContent(xfa);
                    });
                  }
                  const readableStream = this.streamTextContent(params);
                  return new Promise(function(resolve, reject) {
                    function pump() {
                      reader.read().then(function({
                        value: value2,
                        done
                      }) {
                        if (done) {
                          resolve(textContent);
                          return;
                        }
                        Object.assign(textContent.styles, value2.styles);
                        textContent.items.push(...value2.items);
                        pump();
                      }, reject);
                    }
                    const reader = readableStream.getReader();
                    const textContent = {
                      items: [],
                      styles: /* @__PURE__ */ Object.create(null)
                    };
                    pump();
                  });
                }
                getStructTree() {
                  return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);
                }
                _destroy() {
                  this.destroyed = true;
                  const waitOn = [];
                  for (const intentState of this._intentStates.values()) {
                    this._abortOperatorList({
                      intentState,
                      reason: new Error("Page was destroyed."),
                      force: true
                    });
                    if (intentState.opListReadCapability) {
                      continue;
                    }
                    for (const internalRenderTask of intentState.renderTasks) {
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  }
                  this.objs.clear();
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  this.pendingCleanup = false;
                  return Promise.all(waitOn);
                }
                cleanup(resetStats = false) {
                  this.pendingCleanup = true;
                  return this._tryCleanup(resetStats);
                }
                _tryCleanup(resetStats = false) {
                  if (!this.pendingCleanup) {
                    return false;
                  }
                  for (const {
                    renderTasks,
                    operatorList
                  } of this._intentStates.values()) {
                    if (renderTasks.size > 0 || !operatorList.lastChunk) {
                      return false;
                    }
                  }
                  this._intentStates.clear();
                  this.objs.clear();
                  this._annotationPromises.clear();
                  this._jsActionsPromise = null;
                  this._structTreePromise = null;
                  if (resetStats && this._stats) {
                    this._stats = new _display_utils.StatTimer();
                  }
                  for (const bitmap of this._bitmaps) {
                    bitmap.close();
                  }
                  this._bitmaps.clear();
                  this.pendingCleanup = false;
                  return true;
                }
                _startRenderPage(transparency, cacheKey) {
                  const intentState = this._intentStates.get(cacheKey);
                  if (!intentState) {
                    return;
                  }
                  if (this._stats) {
                    this._stats.timeEnd("Page Request");
                  }
                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.resolve(transparency);
                  }
                }
                _renderPageChunk(operatorListChunk, intentState) {
                  for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
                    intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                    intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
                  }
                  intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
                  intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  if (operatorListChunk.lastChunk) {
                    this._tryCleanup();
                  }
                }
                _pumpOperatorList({
                  renderingIntent,
                  cacheKey,
                  annotationStorageMap
                }) {
                  const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                    pageIndex: this._pageIndex,
                    intent: renderingIntent,
                    cacheKey,
                    annotationStorage: annotationStorageMap
                  });
                  const reader = readableStream.getReader();
                  const intentState = this._intentStates.get(cacheKey);
                  intentState.streamReader = reader;
                  const pump = () => {
                    reader.read().then(({
                      value: value2,
                      done
                    }) => {
                      if (done) {
                        intentState.streamReader = null;
                        return;
                      }
                      if (this._transport.destroyed) {
                        return;
                      }
                      this._renderPageChunk(value2, intentState);
                      pump();
                    }, (reason) => {
                      intentState.streamReader = null;
                      if (this._transport.destroyed) {
                        return;
                      }
                      if (intentState.operatorList) {
                        intentState.operatorList.lastChunk = true;
                        for (const internalRenderTask of intentState.renderTasks) {
                          internalRenderTask.operatorListChanged();
                        }
                        this._tryCleanup();
                      }
                      if (intentState.displayReadyCapability) {
                        intentState.displayReadyCapability.reject(reason);
                      } else if (intentState.opListReadCapability) {
                        intentState.opListReadCapability.reject(reason);
                      } else {
                        throw reason;
                      }
                    });
                  };
                  pump();
                }
                _abortOperatorList({
                  intentState,
                  reason,
                  force = false
                }) {
                  if (!intentState.streamReader) {
                    return;
                  }
                  if (!force) {
                    if (intentState.renderTasks.size > 0) {
                      return;
                    }
                    if (reason instanceof _display_utils.RenderingCancelledException) {
                      intentState.streamReaderCancelTimeout = setTimeout(() => {
                        this._abortOperatorList({
                          intentState,
                          reason,
                          force: true
                        });
                        intentState.streamReaderCancelTimeout = null;
                      }, RENDERING_CANCELLED_TIMEOUT);
                      return;
                    }
                  }
                  intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {
                  });
                  intentState.streamReader = null;
                  if (this._transport.destroyed) {
                    return;
                  }
                  for (const [curCacheKey, curIntentState] of this._intentStates) {
                    if (curIntentState === intentState) {
                      this._intentStates.delete(curCacheKey);
                      break;
                    }
                  }
                  this.cleanup();
                }
                get stats() {
                  return this._stats;
                }
              }
              exports.PDFPageProxy = PDFPageProxy;
              class LoopbackPort {
                constructor() {
                  this._listeners = [];
                  this._deferred = Promise.resolve();
                }
                postMessage(obj2, transfers) {
                  const event = {
                    data: structuredClone(obj2, transfers)
                  };
                  this._deferred.then(() => {
                    for (const listener of this._listeners) {
                      listener.call(this, event);
                    }
                  });
                }
                addEventListener(name3, listener) {
                  this._listeners.push(listener);
                }
                removeEventListener(name3, listener) {
                  const i = this._listeners.indexOf(listener);
                  this._listeners.splice(i, 1);
                }
                terminate() {
                  this._listeners.length = 0;
                }
              }
              exports.LoopbackPort = LoopbackPort;
              const PDFWorkerUtil = {
                isWorkerDisabled: false,
                fallbackWorkerSrc: null,
                fakeWorkerId: 0
              };
              exports.PDFWorkerUtil = PDFWorkerUtil;
              {
                if (_is_node.isNodeJS && typeof __require === "function") {
                  PDFWorkerUtil.isWorkerDisabled = true;
                  PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
                } else if (typeof document === "object") {
                  const pdfjsFilePath = document?.currentScript?.src;
                  if (pdfjsFilePath) {
                    PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
                  }
                }
                PDFWorkerUtil.isSameOrigin = function(baseUrl, otherUrl) {
                  let base;
                  try {
                    base = new URL(baseUrl);
                    if (!base.origin || base.origin === "null") {
                      return false;
                    }
                  } catch (e2) {
                    return false;
                  }
                  const other = new URL(otherUrl, base);
                  return base.origin === other.origin;
                };
                PDFWorkerUtil.createCDNWrapper = function(url2) {
                  const wrapper = `importScripts("${url2}");`;
                  return URL.createObjectURL(new Blob([wrapper]));
                };
              }
              const _PDFWorker = class {
                constructor({
                  name: name3 = null,
                  port = null,
                  verbosity = (0, _util.getVerbosityLevel)()
                } = {}) {
                  if (port && __privateGet(_PDFWorker, _workerPorts).has(port)) {
                    throw new Error("Cannot use more than one PDFWorker per port.");
                  }
                  this.name = name3;
                  this.destroyed = false;
                  this.verbosity = verbosity;
                  this._readyCapability = (0, _util.createPromiseCapability)();
                  this._port = null;
                  this._webWorker = null;
                  this._messageHandler = null;
                  if (port) {
                    __privateGet(_PDFWorker, _workerPorts).set(port, this);
                    this._initializeFromPort(port);
                    return;
                  }
                  this._initialize();
                }
                get promise() {
                  return this._readyCapability.promise;
                }
                get port() {
                  return this._port;
                }
                get messageHandler() {
                  return this._messageHandler;
                }
                _initializeFromPort(port) {
                  this._port = port;
                  this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);
                  this._messageHandler.on("ready", function() {
                  });
                  this._readyCapability.resolve();
                }
                _initialize() {
                  if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                    let {
                      workerSrc
                    } = _PDFWorker;
                    try {
                      if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
                        workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                      }
                      const worker2 = new Worker(workerSrc);
                      const messageHandler = new _message_handler.MessageHandler("main", "worker", worker2);
                      const terminateEarly = () => {
                        worker2.removeEventListener("error", onWorkerError);
                        messageHandler.destroy();
                        worker2.terminate();
                        if (this.destroyed) {
                          this._readyCapability.reject(new Error("Worker was destroyed"));
                        } else {
                          this._setupFakeWorker();
                        }
                      };
                      const onWorkerError = () => {
                        if (!this._webWorker) {
                          terminateEarly();
                        }
                      };
                      worker2.addEventListener("error", onWorkerError);
                      messageHandler.on("test", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        if (data) {
                          this._messageHandler = messageHandler;
                          this._port = worker2;
                          this._webWorker = worker2;
                          this._readyCapability.resolve();
                          messageHandler.send("configure", {
                            verbosity: this.verbosity
                          });
                        } else {
                          this._setupFakeWorker();
                          messageHandler.destroy();
                          worker2.terminate();
                        }
                      });
                      messageHandler.on("ready", (data) => {
                        worker2.removeEventListener("error", onWorkerError);
                        if (this.destroyed) {
                          terminateEarly();
                          return;
                        }
                        try {
                          sendTest();
                        } catch (e2) {
                          this._setupFakeWorker();
                        }
                      });
                      const sendTest = () => {
                        const testObj = new Uint8Array();
                        messageHandler.send("test", testObj, [testObj.buffer]);
                      };
                      sendTest();
                      return;
                    } catch (e2) {
                      (0, _util.info)("The worker has been disabled.");
                    }
                  }
                  this._setupFakeWorker();
                }
                _setupFakeWorker() {
                  if (!PDFWorkerUtil.isWorkerDisabled) {
                    (0, _util.warn)("Setting up fake worker.");
                    PDFWorkerUtil.isWorkerDisabled = true;
                  }
                  _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
                    if (this.destroyed) {
                      this._readyCapability.reject(new Error("Worker was destroyed"));
                      return;
                    }
                    const port = new LoopbackPort();
                    this._port = port;
                    const id2 = `fake${PDFWorkerUtil.fakeWorkerId++}`;
                    const workerHandler = new _message_handler.MessageHandler(id2 + "_worker", id2, port);
                    WorkerMessageHandler.setup(workerHandler, port);
                    const messageHandler = new _message_handler.MessageHandler(id2, id2 + "_worker", port);
                    this._messageHandler = messageHandler;
                    this._readyCapability.resolve();
                    messageHandler.send("configure", {
                      verbosity: this.verbosity
                    });
                  }).catch((reason) => {
                    this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
                  });
                }
                destroy() {
                  this.destroyed = true;
                  if (this._webWorker) {
                    this._webWorker.terminate();
                    this._webWorker = null;
                  }
                  __privateGet(_PDFWorker, _workerPorts).delete(this._port);
                  this._port = null;
                  if (this._messageHandler) {
                    this._messageHandler.destroy();
                    this._messageHandler = null;
                  }
                }
                static fromPort(params) {
                  if (!params?.port) {
                    throw new Error("PDFWorker.fromPort - invalid method signature.");
                  }
                  if (__privateGet(this, _workerPorts).has(params.port)) {
                    return __privateGet(this, _workerPorts).get(params.port);
                  }
                  return new _PDFWorker(params);
                }
                static get workerSrc() {
                  if (_worker_options.GlobalWorkerOptions.workerSrc) {
                    return _worker_options.GlobalWorkerOptions.workerSrc;
                  }
                  if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                    if (!_is_node.isNodeJS) {
                      (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                    }
                    return PDFWorkerUtil.fallbackWorkerSrc;
                  }
                  throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
                }
                static get _mainThreadWorkerMessageHandler() {
                  try {
                    return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
                  } catch (ex) {
                    return null;
                  }
                }
                static get _setupFakeWorkerGlobal() {
                  const loader = async () => {
                    const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                    if (mainWorkerMessageHandler) {
                      return mainWorkerMessageHandler;
                    }
                    if (_is_node.isNodeJS && typeof __require === "function") {
                      const worker = eval("require")(this.workerSrc);
                      return worker.WorkerMessageHandler;
                    }
                    await (0, _display_utils.loadScript)(this.workerSrc);
                    return window.pdfjsWorker.WorkerMessageHandler;
                  };
                  return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
                }
              };
              let PDFWorker = _PDFWorker;
              _workerPorts = new WeakMap();
              __privateAdd(PDFWorker, _workerPorts, /* @__PURE__ */ new WeakMap());
              exports.PDFWorker = PDFWorker;
              {
                PDFWorker.getWorkerSrc = function() {
                  (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
                  return this.workerSrc;
                };
              }
              class WorkerTransport {
                constructor(messageHandler, loadingTask, networkStream, params) {
                  __privateAdd(this, _docStats, null);
                  __privateAdd(this, _pageCache, /* @__PURE__ */ new Map());
                  __privateAdd(this, _pagePromises, /* @__PURE__ */ new Map());
                  __privateAdd(this, _metadataPromise, null);
                  this.messageHandler = messageHandler;
                  this.loadingTask = loadingTask;
                  this.commonObjs = new PDFObjects();
                  this.fontLoader = new _font_loader.FontLoader({
                    docId: loadingTask.docId,
                    onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                    ownerDocument: params.ownerDocument,
                    styleElement: params.styleElement
                  });
                  this._params = params;
                  if (!params.useWorkerFetch) {
                    this.CMapReaderFactory = new params.CMapReaderFactory({
                      baseUrl: params.cMapUrl,
                      isCompressed: params.cMapPacked
                    });
                    this.StandardFontDataFactory = new params.StandardFontDataFactory({
                      baseUrl: params.standardFontDataUrl
                    });
                  }
                  this.destroyed = false;
                  this.destroyCapability = null;
                  this._passwordCapability = null;
                  this._networkStream = networkStream;
                  this._fullReader = null;
                  this._lastProgress = null;
                  this.downloadInfoCapability = (0, _util.createPromiseCapability)();
                  this.setupMessageHandler();
                }
                get annotationStorage() {
                  return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
                }
                get stats() {
                  return __privateGet(this, _docStats);
                }
                getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
                  let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
                  let annotationMap = null;
                  switch (intent) {
                    case "any":
                      renderingIntent = _util.RenderingIntentFlag.ANY;
                      break;
                    case "display":
                      break;
                    case "print":
                      renderingIntent = _util.RenderingIntentFlag.PRINT;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
                  }
                  switch (annotationMode) {
                    case _util.AnnotationMode.DISABLE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                      break;
                    case _util.AnnotationMode.ENABLE:
                      break;
                    case _util.AnnotationMode.ENABLE_FORMS:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                      break;
                    case _util.AnnotationMode.ENABLE_STORAGE:
                      renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                      const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
                      annotationMap = annotationStorage.serializable;
                      break;
                    default:
                      (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
                  }
                  if (isOpList) {
                    renderingIntent += _util.RenderingIntentFlag.OPLIST;
                  }
                  return {
                    renderingIntent,
                    cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,
                    annotationStorageMap: annotationMap
                  };
                }
                destroy() {
                  if (this.destroyCapability) {
                    return this.destroyCapability.promise;
                  }
                  this.destroyed = true;
                  this.destroyCapability = (0, _util.createPromiseCapability)();
                  if (this._passwordCapability) {
                    this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
                  }
                  const waitOn = [];
                  for (const page of __privateGet(this, _pageCache).values()) {
                    waitOn.push(page._destroy());
                  }
                  __privateGet(this, _pageCache).clear();
                  __privateGet(this, _pagePromises).clear();
                  if (this.hasOwnProperty("annotationStorage")) {
                    this.annotationStorage.resetModified();
                  }
                  const terminated = this.messageHandler.sendWithPromise("Terminate", null);
                  waitOn.push(terminated);
                  Promise.all(waitOn).then(() => {
                    this.commonObjs.clear();
                    this.fontLoader.clear();
                    __privateSet(this, _metadataPromise, null);
                    this._getFieldObjectsPromise = null;
                    this._hasJSActionsPromise = null;
                    if (this._networkStream) {
                      this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                    }
                    if (this.messageHandler) {
                      this.messageHandler.destroy();
                      this.messageHandler = null;
                    }
                    this.destroyCapability.resolve();
                  }, this.destroyCapability.reject);
                  return this.destroyCapability.promise;
                }
                setupMessageHandler() {
                  const {
                    messageHandler,
                    loadingTask
                  } = this;
                  messageHandler.on("GetReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
                    this._fullReader = this._networkStream.getFullReader();
                    this._fullReader.onProgress = (evt) => {
                      this._lastProgress = {
                        loaded: evt.loaded,
                        total: evt.total
                      };
                    };
                    sink.onPull = () => {
                      this._fullReader.read().then(function({
                        value: value2,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value2), "GetReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value2), 1, [value2]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      this._fullReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("ReaderHeadersReady", (data) => {
                    const headersCapability = (0, _util.createPromiseCapability)();
                    const fullReader = this._fullReader;
                    fullReader.headersReady.then(() => {
                      if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                        if (this._lastProgress) {
                          loadingTask.onProgress?.(this._lastProgress);
                        }
                        fullReader.onProgress = (evt) => {
                          loadingTask.onProgress?.({
                            loaded: evt.loaded,
                            total: evt.total
                          });
                        };
                      }
                      headersCapability.resolve({
                        isStreamingSupported: fullReader.isStreamingSupported,
                        isRangeSupported: fullReader.isRangeSupported,
                        contentLength: fullReader.contentLength
                      });
                    }, headersCapability.reject);
                    return headersCapability.promise;
                  });
                  messageHandler.on("GetRangeReader", (data, sink) => {
                    (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                    const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
                    if (!rangeReader) {
                      sink.close();
                      return;
                    }
                    sink.onPull = () => {
                      rangeReader.read().then(function({
                        value: value2,
                        done
                      }) {
                        if (done) {
                          sink.close();
                          return;
                        }
                        (0, _util.assert)((0, _util.isArrayBuffer)(value2), "GetRangeReader - expected an ArrayBuffer.");
                        sink.enqueue(new Uint8Array(value2), 1, [value2]);
                      }).catch((reason) => {
                        sink.error(reason);
                      });
                    };
                    sink.onCancel = (reason) => {
                      rangeReader.cancel(reason);
                      sink.ready.catch((readyReason) => {
                        if (this.destroyed) {
                          return;
                        }
                        throw readyReason;
                      });
                    };
                  });
                  messageHandler.on("GetDoc", ({
                    pdfInfo
                  }) => {
                    this._numPages = pdfInfo.numPages;
                    this._htmlForXfa = pdfInfo.htmlForXfa;
                    delete pdfInfo.htmlForXfa;
                    loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
                  });
                  messageHandler.on("DocException", function(ex) {
                    let reason;
                    switch (ex.name) {
                      case "PasswordException":
                        reason = new _util.PasswordException(ex.message, ex.code);
                        break;
                      case "InvalidPDFException":
                        reason = new _util.InvalidPDFException(ex.message);
                        break;
                      case "MissingPDFException":
                        reason = new _util.MissingPDFException(ex.message);
                        break;
                      case "UnexpectedResponseException":
                        reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                        break;
                      case "UnknownErrorException":
                        reason = new _util.UnknownErrorException(ex.message, ex.details);
                        break;
                      default:
                        (0, _util.unreachable)("DocException - expected a valid Error.");
                    }
                    loadingTask._capability.reject(reason);
                  });
                  messageHandler.on("PasswordRequest", (exception) => {
                    this._passwordCapability = (0, _util.createPromiseCapability)();
                    if (loadingTask.onPassword) {
                      const updatePassword = (password) => {
                        if (password instanceof Error) {
                          this._passwordCapability.reject(password);
                        } else {
                          this._passwordCapability.resolve({
                            password
                          });
                        }
                      };
                      try {
                        loadingTask.onPassword(updatePassword, exception.code);
                      } catch (ex) {
                        this._passwordCapability.reject(ex);
                      }
                    } else {
                      this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                    }
                    return this._passwordCapability.promise;
                  });
                  messageHandler.on("DataLoaded", (data) => {
                    loadingTask.onProgress?.({
                      loaded: data.length,
                      total: data.length
                    });
                    this.downloadInfoCapability.resolve(data);
                  });
                  messageHandler.on("StartRenderPage", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    const page = __privateGet(this, _pageCache).get(data.pageIndex);
                    page._startRenderPage(data.transparency, data.cacheKey);
                  });
                  messageHandler.on("commonobj", ([id2, type2, exportedData]) => {
                    if (this.destroyed) {
                      return;
                    }
                    if (this.commonObjs.has(id2)) {
                      return;
                    }
                    switch (type2) {
                      case "Font":
                        const params = this._params;
                        if ("error" in exportedData) {
                          const exportedError = exportedData.error;
                          (0, _util.warn)(`Error during font loading: ${exportedError}`);
                          this.commonObjs.resolve(id2, exportedError);
                          break;
                        }
                        let fontRegistry = null;
                        if (params.pdfBug && globalThis.FontInspector?.enabled) {
                          fontRegistry = {
                            registerFont(font3, url2) {
                              globalThis.FontInspector.fontAdded(font3, url2);
                            }
                          };
                        }
                        const font2 = new _font_loader.FontFaceObject(exportedData, {
                          isEvalSupported: params.isEvalSupported,
                          disableFontFace: params.disableFontFace,
                          ignoreErrors: params.ignoreErrors,
                          onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
                          fontRegistry
                        });
                        this.fontLoader.bind(font2).catch((reason) => {
                          return messageHandler.sendWithPromise("FontFallback", {
                            id: id2
                          });
                        }).finally(() => {
                          if (!params.fontExtraProperties && font2.data) {
                            font2.data = null;
                          }
                          this.commonObjs.resolve(id2, font2);
                        });
                        break;
                      case "FontPath":
                      case "Image":
                        this.commonObjs.resolve(id2, exportedData);
                        break;
                      default:
                        throw new Error(`Got unknown common object type ${type2}`);
                    }
                  });
                  messageHandler.on("obj", ([id2, pageIndex, type2, imageData]) => {
                    if (this.destroyed) {
                      return;
                    }
                    const pageProxy = __privateGet(this, _pageCache).get(pageIndex);
                    if (pageProxy.objs.has(id2)) {
                      return;
                    }
                    switch (type2) {
                      case "Image":
                        pageProxy.objs.resolve(id2, imageData);
                        const MAX_IMAGE_SIZE_TO_STORE = 8e6;
                        if (imageData) {
                          let length8;
                          if (imageData.bitmap) {
                            const {
                              bitmap,
                              width: width2,
                              height: height2
                            } = imageData;
                            length8 = width2 * height2 * 4;
                            pageProxy._bitmaps.add(bitmap);
                          } else {
                            length8 = imageData.data?.length || 0;
                          }
                          if (length8 > MAX_IMAGE_SIZE_TO_STORE) {
                            pageProxy.cleanupAfterRender = true;
                          }
                        }
                        break;
                      case "Pattern":
                        pageProxy.objs.resolve(id2, imageData);
                        break;
                      default:
                        throw new Error(`Got unknown object type ${type2}`);
                    }
                  });
                  messageHandler.on("DocProgress", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    loadingTask.onProgress?.({
                      loaded: data.loaded,
                      total: data.total
                    });
                  });
                  messageHandler.on("DocStats", (data) => {
                    if (this.destroyed) {
                      return;
                    }
                    __privateSet(this, _docStats, Object.freeze({
                      streamTypes: Object.freeze(data.streamTypes),
                      fontTypes: Object.freeze(data.fontTypes)
                    }));
                  });
                  messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
                  messageHandler.on("FetchBuiltInCMap", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.CMapReaderFactory) {
                      return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.CMapReaderFactory.fetch(data);
                  });
                  messageHandler.on("FetchStandardFontData", (data) => {
                    if (this.destroyed) {
                      return Promise.reject(new Error("Worker was destroyed."));
                    }
                    if (!this.StandardFontDataFactory) {
                      return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                    }
                    return this.StandardFontDataFactory.fetch(data);
                  });
                }
                _onUnsupportedFeature({
                  featureId
                }) {
                  if (this.destroyed) {
                    return;
                  }
                  this.loadingTask.onUnsupportedFeature?.(featureId);
                }
                getData() {
                  return this.messageHandler.sendWithPromise("GetData", null);
                }
                getPage(pageNumber) {
                  if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                    return Promise.reject(new Error("Invalid page request."));
                  }
                  const pageIndex = pageNumber - 1, cachedPromise = __privateGet(this, _pagePromises).get(pageIndex);
                  if (cachedPromise) {
                    return cachedPromise;
                  }
                  const promise = this.messageHandler.sendWithPromise("GetPage", {
                    pageIndex
                  }).then((pageInfo) => {
                    if (this.destroyed) {
                      throw new Error("Transport destroyed");
                    }
                    const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
                    __privateGet(this, _pageCache).set(pageIndex, page);
                    return page;
                  });
                  __privateGet(this, _pagePromises).set(pageIndex, promise);
                  return promise;
                }
                getPageIndex(ref) {
                  if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
                    return Promise.reject(new Error("Invalid pageIndex request."));
                  }
                  return this.messageHandler.sendWithPromise("GetPageIndex", {
                    num: ref.num,
                    gen: ref.gen
                  });
                }
                getAnnotations(pageIndex, intent) {
                  return this.messageHandler.sendWithPromise("GetAnnotations", {
                    pageIndex,
                    intent
                  });
                }
                saveDocument() {
                  return this.messageHandler.sendWithPromise("SaveDocument", {
                    isPureXfa: !!this._htmlForXfa,
                    numPages: this._numPages,
                    annotationStorage: this.annotationStorage.serializable,
                    filename: this._fullReader?.filename ?? null
                  }).finally(() => {
                    this.annotationStorage.resetModified();
                  });
                }
                getFieldObjects() {
                  return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise("GetFieldObjects", null);
                }
                hasJSActions() {
                  return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise("HasJSActions", null);
                }
                getCalculationOrderIds() {
                  return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
                }
                getDestinations() {
                  return this.messageHandler.sendWithPromise("GetDestinations", null);
                }
                getDestination(id2) {
                  if (typeof id2 !== "string") {
                    return Promise.reject(new Error("Invalid destination request."));
                  }
                  return this.messageHandler.sendWithPromise("GetDestination", {
                    id: id2
                  });
                }
                getPageLabels() {
                  return this.messageHandler.sendWithPromise("GetPageLabels", null);
                }
                getPageLayout() {
                  return this.messageHandler.sendWithPromise("GetPageLayout", null);
                }
                getPageMode() {
                  return this.messageHandler.sendWithPromise("GetPageMode", null);
                }
                getViewerPreferences() {
                  return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
                }
                getOpenAction() {
                  return this.messageHandler.sendWithPromise("GetOpenAction", null);
                }
                getAttachments() {
                  return this.messageHandler.sendWithPromise("GetAttachments", null);
                }
                getJavaScript() {
                  return this.messageHandler.sendWithPromise("GetJavaScript", null);
                }
                getDocJSActions() {
                  return this.messageHandler.sendWithPromise("GetDocJSActions", null);
                }
                getPageJSActions(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetPageJSActions", {
                    pageIndex
                  });
                }
                getStructTree(pageIndex) {
                  return this.messageHandler.sendWithPromise("GetStructTree", {
                    pageIndex
                  });
                }
                getOutline() {
                  return this.messageHandler.sendWithPromise("GetOutline", null);
                }
                getOptionalContentConfig() {
                  return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((results) => {
                    return new _optional_content_config.OptionalContentConfig(results);
                  });
                }
                getPermissions() {
                  return this.messageHandler.sendWithPromise("GetPermissions", null);
                }
                getMetadata() {
                  return __privateGet(this, _metadataPromise) || __privateSet(this, _metadataPromise, this.messageHandler.sendWithPromise("GetMetadata", null).then((results) => {
                    return {
                      info: results[0],
                      metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                      contentDispositionFilename: this._fullReader?.filename ?? null,
                      contentLength: this._fullReader?.contentLength ?? null
                    };
                  }));
                }
                getMarkInfo() {
                  return this.messageHandler.sendWithPromise("GetMarkInfo", null);
                }
                async startCleanup(keepLoadedFonts = false) {
                  await this.messageHandler.sendWithPromise("Cleanup", null);
                  if (this.destroyed) {
                    return;
                  }
                  for (const page of __privateGet(this, _pageCache).values()) {
                    const cleanupSuccessful = page.cleanup();
                    if (!cleanupSuccessful) {
                      throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
                    }
                  }
                  this.commonObjs.clear();
                  if (!keepLoadedFonts) {
                    this.fontLoader.clear();
                  }
                  __privateSet(this, _metadataPromise, null);
                  this._getFieldObjectsPromise = null;
                  this._hasJSActionsPromise = null;
                }
                get loadingParams() {
                  const params = this._params;
                  return (0, _util.shadow)(this, "loadingParams", {
                    disableAutoFetch: params.disableAutoFetch,
                    enableXfa: params.enableXfa
                  });
                }
              }
              _docStats = new WeakMap();
              _pageCache = new WeakMap();
              _pagePromises = new WeakMap();
              _metadataPromise = new WeakMap();
              class PDFObjects {
                constructor() {
                  __privateAdd(this, _ensureObj);
                  __privateAdd(this, _objs, /* @__PURE__ */ Object.create(null));
                }
                get(objId, callback = null) {
                  if (callback) {
                    const obj3 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                    obj3.capability.promise.then(() => callback(obj3.data));
                    return null;
                  }
                  const obj2 = __privateGet(this, _objs)[objId];
                  if (!obj2?.capability.settled) {
                    throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
                  }
                  return obj2.data;
                }
                has(objId) {
                  const obj2 = __privateGet(this, _objs)[objId];
                  return obj2?.capability.settled || false;
                }
                resolve(objId, data = null) {
                  const obj2 = __privateMethod(this, _ensureObj, ensureObj_fn).call(this, objId);
                  obj2.data = data;
                  obj2.capability.resolve();
                }
                clear() {
                  __privateSet(this, _objs, /* @__PURE__ */ Object.create(null));
                }
              }
              _objs = new WeakMap();
              _ensureObj = new WeakSet();
              ensureObj_fn = function(objId) {
                const obj2 = __privateGet(this, _objs)[objId];
                if (obj2) {
                  return obj2;
                }
                return __privateGet(this, _objs)[objId] = {
                  capability: (0, _util.createPromiseCapability)(),
                  data: null
                };
              };
              class RenderTask {
                constructor(internalRenderTask) {
                  __privateAdd(this, _internalRenderTask, null);
                  __privateSet(this, _internalRenderTask, internalRenderTask);
                  this.onContinue = null;
                }
                get promise() {
                  return __privateGet(this, _internalRenderTask).capability.promise;
                }
                cancel() {
                  __privateGet(this, _internalRenderTask).cancel();
                }
                get separateAnnots() {
                  const {
                    separateAnnots
                  } = __privateGet(this, _internalRenderTask).operatorList;
                  if (!separateAnnots) {
                    return false;
                  }
                  const {
                    annotationCanvasMap
                  } = __privateGet(this, _internalRenderTask);
                  return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
                }
              }
              _internalRenderTask = new WeakMap();
              exports.RenderTask = RenderTask;
              const _InternalRenderTask = class {
                constructor({
                  callback,
                  params,
                  objs,
                  commonObjs,
                  annotationCanvasMap,
                  operatorList,
                  pageIndex,
                  canvasFactory,
                  useRequestAnimationFrame = false,
                  pdfBug = false,
                  pageColors = null
                }) {
                  this.callback = callback;
                  this.params = params;
                  this.objs = objs;
                  this.commonObjs = commonObjs;
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.operatorListIdx = null;
                  this.operatorList = operatorList;
                  this._pageIndex = pageIndex;
                  this.canvasFactory = canvasFactory;
                  this._pdfBug = pdfBug;
                  this.pageColors = pageColors;
                  this.running = false;
                  this.graphicsReadyCallback = null;
                  this.graphicsReady = false;
                  this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
                  this.cancelled = false;
                  this.capability = (0, _util.createPromiseCapability)();
                  this.task = new RenderTask(this);
                  this._cancelBound = this.cancel.bind(this);
                  this._continueBound = this._continue.bind(this);
                  this._scheduleNextBound = this._scheduleNext.bind(this);
                  this._nextBound = this._next.bind(this);
                  this._canvas = params.canvasContext.canvas;
                }
                get completed() {
                  return this.capability.promise.catch(function() {
                  });
                }
                initializeGraphics({
                  transparency = false,
                  optionalContentConfig
                }) {
                  if (this.cancelled) {
                    return;
                  }
                  if (this._canvas) {
                    if (__privateGet(_InternalRenderTask, _canvasInUse).has(this._canvas)) {
                      throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                    }
                    __privateGet(_InternalRenderTask, _canvasInUse).add(this._canvas);
                  }
                  if (this._pdfBug && globalThis.StepperManager?.enabled) {
                    this.stepper = globalThis.StepperManager.create(this._pageIndex);
                    this.stepper.init(this.operatorList);
                    this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
                  }
                  const {
                    canvasContext,
                    viewport,
                    transform: transform2,
                    imageLayer,
                    background
                  } = this.params;
                  this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
                  this.gfx.beginDrawing({
                    transform: transform2,
                    viewport,
                    transparency,
                    background
                  });
                  this.operatorListIdx = 0;
                  this.graphicsReady = true;
                  if (this.graphicsReadyCallback) {
                    this.graphicsReadyCallback();
                  }
                }
                cancel(error = null) {
                  this.running = false;
                  this.cancelled = true;
                  if (this.gfx) {
                    this.gfx.endDrawing();
                  }
                  if (this._canvas) {
                    __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                  }
                  this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
                }
                operatorListChanged() {
                  if (!this.graphicsReady) {
                    if (!this.graphicsReadyCallback) {
                      this.graphicsReadyCallback = this._continueBound;
                    }
                    return;
                  }
                  if (this.stepper) {
                    this.stepper.updateOperatorList(this.operatorList);
                  }
                  if (this.running) {
                    return;
                  }
                  this._continue();
                }
                _continue() {
                  this.running = true;
                  if (this.cancelled) {
                    return;
                  }
                  if (this.task.onContinue) {
                    this.task.onContinue(this._scheduleNextBound);
                  } else {
                    this._scheduleNext();
                  }
                }
                _scheduleNext() {
                  if (this._useRequestAnimationFrame) {
                    window.requestAnimationFrame(() => {
                      this._nextBound().catch(this._cancelBound);
                    });
                  } else {
                    Promise.resolve().then(this._nextBound).catch(this._cancelBound);
                  }
                }
                async _next() {
                  if (this.cancelled) {
                    return;
                  }
                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);
                  if (this.operatorListIdx === this.operatorList.argsArray.length) {
                    this.running = false;
                    if (this.operatorList.lastChunk) {
                      this.gfx.endDrawing();
                      if (this._canvas) {
                        __privateGet(_InternalRenderTask, _canvasInUse).delete(this._canvas);
                      }
                      this.callback();
                    }
                  }
                }
              };
              let InternalRenderTask = _InternalRenderTask;
              _canvasInUse = new WeakMap();
              __privateAdd(InternalRenderTask, _canvasInUse, /* @__PURE__ */ new WeakSet());
              const version = "2.16.105";
              exports.version = version;
              const build = "172ccdbe5";
              exports.build = build;
            },
            /* 5 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _setModified, setModified_fn, _serializable;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PrintAnnotationStorage = exports2.AnnotationStorage = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(6);
              var _murmurhash = __w_pdfjs_require__2(10);
              class AnnotationStorage {
                constructor() {
                  __privateAdd(this, _setModified);
                  this._storage = /* @__PURE__ */ new Map();
                  this._modified = false;
                  this.onSetModified = null;
                  this.onResetModified = null;
                  this.onAnnotationEditor = null;
                }
                getValue(key, defaultValue) {
                  const value2 = this._storage.get(key);
                  if (value2 === void 0) {
                    return defaultValue;
                  }
                  return Object.assign(defaultValue, value2);
                }
                getRawValue(key) {
                  return this._storage.get(key);
                }
                remove(key) {
                  this._storage.delete(key);
                  if (this._storage.size === 0) {
                    this.resetModified();
                  }
                  if (typeof this.onAnnotationEditor === "function") {
                    for (const value2 of this._storage.values()) {
                      if (value2 instanceof _editor.AnnotationEditor) {
                        return;
                      }
                    }
                    this.onAnnotationEditor(null);
                  }
                }
                setValue(key, value2) {
                  const obj2 = this._storage.get(key);
                  let modified = false;
                  if (obj2 !== void 0) {
                    for (const [entry, val] of Object.entries(value2)) {
                      if (obj2[entry] !== val) {
                        modified = true;
                        obj2[entry] = val;
                      }
                    }
                  } else {
                    modified = true;
                    this._storage.set(key, value2);
                  }
                  if (modified) {
                    __privateMethod(this, _setModified, setModified_fn).call(this);
                  }
                  if (value2 instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
                    this.onAnnotationEditor(value2.constructor._type);
                  }
                }
                has(key) {
                  return this._storage.has(key);
                }
                getAll() {
                  return this._storage.size > 0 ? (0, _util2.objectFromMap)(this._storage) : null;
                }
                get size() {
                  return this._storage.size;
                }
                resetModified() {
                  if (this._modified) {
                    this._modified = false;
                    if (typeof this.onResetModified === "function") {
                      this.onResetModified();
                    }
                  }
                }
                get print() {
                  return new PrintAnnotationStorage(this);
                }
                get serializable() {
                  if (this._storage.size === 0) {
                    return null;
                  }
                  const clone9 = /* @__PURE__ */ new Map();
                  for (const [key, val] of this._storage) {
                    const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;
                    if (serialized) {
                      clone9.set(key, serialized);
                    }
                  }
                  return clone9;
                }
                static getHash(map) {
                  if (!map) {
                    return "";
                  }
                  const hash = new _murmurhash.MurmurHash3_64();
                  for (const [key, val] of map) {
                    hash.update(`${key}:${JSON.stringify(val)}`);
                  }
                  return hash.hexdigest();
                }
              }
              _setModified = new WeakSet();
              setModified_fn = function() {
                if (!this._modified) {
                  this._modified = true;
                  if (typeof this.onSetModified === "function") {
                    this.onSetModified();
                  }
                }
              };
              exports2.AnnotationStorage = AnnotationStorage;
              class PrintAnnotationStorage extends AnnotationStorage {
                constructor(parent) {
                  super();
                  __privateAdd(this, _serializable, null);
                  __privateSet(this, _serializable, structuredClone(parent.serializable));
                }
                get print() {
                  (0, _util2.unreachable)("Should not call PrintAnnotationStorage.print");
                }
                get serializable() {
                  return __privateGet(this, _serializable);
                }
              }
              _serializable = new WeakMap();
              exports2.PrintAnnotationStorage = PrintAnnotationStorage;
            },
            /* 6 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundFocusin, _boundFocusout, _hasBeenSelected, _isEditing, _isInEditMode, _zIndex;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditor = void 0;
              var _tools = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              const _AnnotationEditor = class {
                constructor(parameters) {
                  __privateAdd(this, _boundFocusin, this.focusin.bind(this));
                  __privateAdd(this, _boundFocusout, this.focusout.bind(this));
                  __privateAdd(this, _hasBeenSelected, false);
                  __privateAdd(this, _isEditing, false);
                  __privateAdd(this, _isInEditMode, false);
                  __privateAdd(this, _zIndex, _AnnotationEditor._zIndex++);
                  if (this.constructor === _AnnotationEditor) {
                    (0, _util2.unreachable)("Cannot initialize AnnotationEditor.");
                  }
                  this.parent = parameters.parent;
                  this.id = parameters.id;
                  this.width = this.height = null;
                  this.pageIndex = parameters.parent.pageIndex;
                  this.name = parameters.name;
                  this.div = null;
                  const [width2, height2] = this.parent.viewportBaseDimensions;
                  this.x = parameters.x / width2;
                  this.y = parameters.y / height2;
                  this.rotation = this.parent.viewport.rotation;
                  this.isAttachedToDOM = false;
                }
                static get _defaultLineColor() {
                  return (0, _util2.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
                }
                setInBackground() {
                  this.div.style.zIndex = 0;
                }
                setInForeground() {
                  this.div.style.zIndex = __privateGet(this, _zIndex);
                }
                focusin(event) {
                  if (!__privateGet(this, _hasBeenSelected)) {
                    this.parent.setSelected(this);
                  } else {
                    __privateSet(this, _hasBeenSelected, false);
                  }
                }
                focusout(event) {
                  if (!this.isAttachedToDOM) {
                    return;
                  }
                  const target = event.relatedTarget;
                  if (target?.closest(`#${this.id}`)) {
                    return;
                  }
                  event.preventDefault();
                  if (!this.parent.isMultipleSelection) {
                    this.commitOrRemove();
                  }
                }
                commitOrRemove() {
                  if (this.isEmpty()) {
                    this.remove();
                  } else {
                    this.commit();
                  }
                }
                commit() {
                  this.parent.addToAnnotationStorage(this);
                }
                dragstart(event) {
                  const rect = this.parent.div.getBoundingClientRect();
                  this.startX = event.clientX - rect.x;
                  this.startY = event.clientY - rect.y;
                  event.dataTransfer.setData("text/plain", this.id);
                  event.dataTransfer.effectAllowed = "move";
                }
                setAt(x, y, tx, ty) {
                  const [width2, height2] = this.parent.viewportBaseDimensions;
                  [tx, ty] = this.screenToPageTranslation(tx, ty);
                  this.x = (x + tx) / width2;
                  this.y = (y + ty) / height2;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                translate(x, y) {
                  const [width2, height2] = this.parent.viewportBaseDimensions;
                  [x, y] = this.screenToPageTranslation(x, y);
                  this.x += x / width2;
                  this.y += y / height2;
                  this.div.style.left = `${100 * this.x}%`;
                  this.div.style.top = `${100 * this.y}%`;
                }
                screenToPageTranslation(x, y) {
                  const {
                    rotation
                  } = this.parent.viewport;
                  switch (rotation) {
                    case 90:
                      return [y, -x];
                    case 180:
                      return [-x, -y];
                    case 270:
                      return [-y, x];
                    default:
                      return [x, y];
                  }
                }
                setDims(width2, height2) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.div.style.width = `${100 * width2 / parentWidth}%`;
                  this.div.style.height = `${100 * height2 / parentHeight}%`;
                }
                getInitialTranslation() {
                  return [0, 0];
                }
                render() {
                  this.div = document.createElement("div");
                  this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
                  this.div.className = this.name;
                  this.div.setAttribute("id", this.id);
                  this.div.setAttribute("tabIndex", 0);
                  this.setInForeground();
                  this.div.addEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.addEventListener("focusout", __privateGet(this, _boundFocusout));
                  const [tx, ty] = this.getInitialTranslation();
                  this.translate(tx, ty);
                  (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
                  return this.div;
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    event.preventDefault();
                    return;
                  }
                  if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
                    this.parent.toggleSelected(this);
                  } else {
                    this.parent.setSelected(this);
                  }
                  __privateSet(this, _hasBeenSelected, true);
                }
                getRect(tx, ty) {
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  const [pageWidth, pageHeight] = this.parent.pageDimensions;
                  const shiftX = pageWidth * tx / parentWidth;
                  const shiftY = pageHeight * ty / parentHeight;
                  const x = this.x * pageWidth;
                  const y = this.y * pageHeight;
                  const width2 = this.width * pageWidth;
                  const height2 = this.height * pageHeight;
                  switch (this.rotation) {
                    case 0:
                      return [x + shiftX, pageHeight - y - shiftY - height2, x + shiftX + width2, pageHeight - y - shiftY];
                    case 90:
                      return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height2, pageHeight - y + shiftX + width2];
                    case 180:
                      return [x - shiftX - width2, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height2];
                    case 270:
                      return [x - shiftY - height2, pageHeight - y - shiftX - width2, x - shiftY, pageHeight - y - shiftX];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                getRectInCurrentCoords(rect, pageHeight) {
                  const [x1, y1, x2, y2] = rect;
                  const width2 = x2 - x1;
                  const height2 = y2 - y1;
                  switch (this.rotation) {
                    case 0:
                      return [x1, pageHeight - y2, width2, height2];
                    case 90:
                      return [x1, pageHeight - y1, height2, width2];
                    case 180:
                      return [x2, pageHeight - y1, width2, height2];
                    case 270:
                      return [x2, pageHeight - y2, height2, width2];
                    default:
                      throw new Error("Invalid rotation");
                  }
                }
                onceAdded() {
                }
                isEmpty() {
                  return false;
                }
                enableEditMode() {
                  __privateSet(this, _isInEditMode, true);
                }
                disableEditMode() {
                  __privateSet(this, _isInEditMode, false);
                }
                isInEditMode() {
                  return __privateGet(this, _isInEditMode);
                }
                shouldGetKeyboardEvents() {
                  return false;
                }
                needsToBeRebuilt() {
                  return this.div && !this.isAttachedToDOM;
                }
                rebuild() {
                  this.div?.addEventListener("focusin", __privateGet(this, _boundFocusin));
                }
                serialize() {
                  (0, _util2.unreachable)("An editor must be serializable");
                }
                static deserialize(data, parent) {
                  const editor2 = new this.prototype.constructor({
                    parent,
                    id: parent.getNextId()
                  });
                  editor2.rotation = data.rotation;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const [x, y, width2, height2] = editor2.getRectInCurrentCoords(data.rect, pageHeight);
                  editor2.x = x / pageWidth;
                  editor2.y = y / pageHeight;
                  editor2.width = width2 / pageWidth;
                  editor2.height = height2 / pageHeight;
                  return editor2;
                }
                remove() {
                  this.div.removeEventListener("focusin", __privateGet(this, _boundFocusin));
                  this.div.removeEventListener("focusout", __privateGet(this, _boundFocusout));
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.parent.remove(this);
                }
                select() {
                  this.div?.classList.add("selectedEditor");
                }
                unselect() {
                  this.div?.classList.remove("selectedEditor");
                }
                updateParams(type2, value2) {
                }
                disableEditing() {
                }
                enableEditing() {
                }
                get propertiesToUpdate() {
                  return {};
                }
                get contentDiv() {
                  return this.div;
                }
                get isEditing() {
                  return __privateGet(this, _isEditing);
                }
                set isEditing(value2) {
                  __privateSet(this, _isEditing, value2);
                  if (value2) {
                    this.parent.setSelected(this);
                    this.parent.setActiveEditor(this);
                  } else {
                    this.parent.setActiveEditor(null);
                  }
                }
              };
              let AnnotationEditor = _AnnotationEditor;
              _boundFocusin = new WeakMap();
              _boundFocusout = new WeakMap();
              _hasBeenSelected = new WeakMap();
              _isEditing = new WeakMap();
              _isInEditMode = new WeakMap();
              _zIndex = new WeakMap();
              __publicField(AnnotationEditor, "_colorManager", new _tools.ColorManager());
              __publicField(AnnotationEditor, "_zIndex", 1);
              exports2.AnnotationEditor = AnnotationEditor;
            },
            /* 7 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _id, _commands, _locked, _maxSize, _position, _serialize, serialize_fn, _elements, _activeEditor, _allEditors, _allLayers, _clipboardManager, _commandManager, _currentPageIndex, _editorTypes, _eventBus, _idManager, _isEnabled, _mode, _selectedEditors, _boundKeydown, _boundOnEditingAction, _boundOnPageChanging, _previousStates, _container, _addKeyboardManager, addKeyboardManager_fn, _removeKeyboardManager, removeKeyboardManager_fn, _dispatchUpdateStates, dispatchUpdateStates_fn, _dispatchUpdateUI, dispatchUpdateUI_fn, _enableAll, enableAll_fn, _disableAll, disableAll_fn, _addEditorToLayer, addEditorToLayer_fn, _isEmpty, isEmpty_fn, _selectEditors, selectEditors_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.KeyboardManager = exports2.CommandManager = exports2.ColorManager = exports2.AnnotationEditorUIManager = void 0;
              exports2.bindEvents = bindEvents;
              exports2.opacityToHex = opacityToHex;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              function bindEvents(obj2, element, names) {
                for (const name3 of names) {
                  element.addEventListener(name3, obj2[name3].bind(obj2));
                }
              }
              function opacityToHex(opacity2) {
                return Math.round(Math.min(255, Math.max(1, 255 * opacity2))).toString(16).padStart(2, "0");
              }
              class IdManager {
                constructor() {
                  __privateAdd(this, _id, 0);
                }
                getId() {
                  return `${_util2.AnnotationEditorPrefix}${__privateWrapper(this, _id)._++}`;
                }
              }
              _id = new WeakMap();
              class CommandManager {
                constructor(maxSize = 128) {
                  __privateAdd(this, _commands, []);
                  __privateAdd(this, _locked, false);
                  __privateAdd(this, _maxSize, void 0);
                  __privateAdd(this, _position, -1);
                  __privateSet(this, _maxSize, maxSize);
                }
                add({
                  cmd,
                  undo,
                  mustExec,
                  type: type2 = NaN,
                  overwriteIfSameType = false,
                  keepUndo = false
                }) {
                  if (mustExec) {
                    cmd();
                  }
                  if (__privateGet(this, _locked)) {
                    return;
                  }
                  const save = {
                    cmd,
                    undo,
                    type: type2
                  };
                  if (__privateGet(this, _position) === -1) {
                    if (__privateGet(this, _commands).length > 0) {
                      __privateGet(this, _commands).length = 0;
                    }
                    __privateSet(this, _position, 0);
                    __privateGet(this, _commands).push(save);
                    return;
                  }
                  if (overwriteIfSameType && __privateGet(this, _commands)[__privateGet(this, _position)].type === type2) {
                    if (keepUndo) {
                      save.undo = __privateGet(this, _commands)[__privateGet(this, _position)].undo;
                    }
                    __privateGet(this, _commands)[__privateGet(this, _position)] = save;
                    return;
                  }
                  const next = __privateGet(this, _position) + 1;
                  if (next === __privateGet(this, _maxSize)) {
                    __privateGet(this, _commands).splice(0, 1);
                  } else {
                    __privateSet(this, _position, next);
                    if (next < __privateGet(this, _commands).length) {
                      __privateGet(this, _commands).splice(next);
                    }
                  }
                  __privateGet(this, _commands).push(save);
                }
                undo() {
                  if (__privateGet(this, _position) === -1) {
                    return;
                  }
                  __privateSet(this, _locked, true);
                  __privateGet(this, _commands)[__privateGet(this, _position)].undo();
                  __privateSet(this, _locked, false);
                  __privateSet(this, _position, __privateGet(this, _position) - 1);
                }
                redo() {
                  if (__privateGet(this, _position) < __privateGet(this, _commands).length - 1) {
                    __privateSet(this, _position, __privateGet(this, _position) + 1);
                    __privateSet(this, _locked, true);
                    __privateGet(this, _commands)[__privateGet(this, _position)].cmd();
                    __privateSet(this, _locked, false);
                  }
                }
                hasSomethingToUndo() {
                  return __privateGet(this, _position) !== -1;
                }
                hasSomethingToRedo() {
                  return __privateGet(this, _position) < __privateGet(this, _commands).length - 1;
                }
                destroy() {
                  __privateSet(this, _commands, null);
                }
              }
              _commands = new WeakMap();
              _locked = new WeakMap();
              _maxSize = new WeakMap();
              _position = new WeakMap();
              exports2.CommandManager = CommandManager;
              const _KeyboardManager = class {
                constructor(callbacks) {
                  __privateAdd(this, _serialize);
                  this.buffer = [];
                  this.callbacks = /* @__PURE__ */ new Map();
                  this.allKeys = /* @__PURE__ */ new Set();
                  const isMac = _KeyboardManager.platform.isMac;
                  for (const [keys, callback] of callbacks) {
                    for (const key of keys) {
                      const isMacKey = key.startsWith("mac+");
                      if (isMac && isMacKey) {
                        this.callbacks.set(key.slice(4), callback);
                        this.allKeys.add(key.split("+").at(-1));
                      } else if (!isMac && !isMacKey) {
                        this.callbacks.set(key, callback);
                        this.allKeys.add(key.split("+").at(-1));
                      }
                    }
                  }
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
                exec(self2, event) {
                  if (!this.allKeys.has(event.key)) {
                    return;
                  }
                  const callback = this.callbacks.get(__privateMethod(this, _serialize, serialize_fn).call(this, event));
                  if (!callback) {
                    return;
                  }
                  callback.bind(self2)();
                  event.stopPropagation();
                  event.preventDefault();
                }
              };
              let KeyboardManager = _KeyboardManager;
              _serialize = new WeakSet();
              serialize_fn = function(event) {
                if (event.altKey) {
                  this.buffer.push("alt");
                }
                if (event.ctrlKey) {
                  this.buffer.push("ctrl");
                }
                if (event.metaKey) {
                  this.buffer.push("meta");
                }
                if (event.shiftKey) {
                  this.buffer.push("shift");
                }
                this.buffer.push(event.key);
                const str5 = this.buffer.join("+");
                this.buffer.length = 0;
                return str5;
              };
              exports2.KeyboardManager = KeyboardManager;
              class ClipboardManager {
                constructor() {
                  __privateAdd(this, _elements, null);
                }
                copy(element) {
                  if (!element) {
                    return;
                  }
                  if (Array.isArray(element)) {
                    __privateSet(this, _elements, element.map((el) => el.serialize()));
                  } else {
                    __privateSet(this, _elements, [element.serialize()]);
                  }
                  __privateSet(this, _elements, __privateGet(this, _elements).filter((el) => !!el));
                  if (__privateGet(this, _elements).length === 0) {
                    __privateSet(this, _elements, null);
                  }
                }
                paste() {
                  return __privateGet(this, _elements);
                }
                isEmpty() {
                  return __privateGet(this, _elements) === null;
                }
                destroy() {
                  __privateSet(this, _elements, null);
                }
              }
              _elements = new WeakMap();
              const _ColorManager = class {
                get _colors() {
                  const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
                  (0, _display_utils2.getColorValues)(colors);
                  return (0, _util2.shadow)(this, "_colors", colors);
                }
                convert(color2) {
                  const rgb2 = (0, _display_utils2.getRGB)(color2);
                  if (!window.matchMedia("(forced-colors: active)").matches) {
                    return rgb2;
                  }
                  for (const [name3, RGB] of this._colors) {
                    if (RGB.every((x, i) => x === rgb2[i])) {
                      return _ColorManager._colorsMapping.get(name3);
                    }
                  }
                  return rgb2;
                }
                getHexCode(name3) {
                  const rgb2 = this._colors.get(name3);
                  if (!rgb2) {
                    return name3;
                  }
                  return _util2.Util.makeHexColor(...rgb2);
                }
              };
              let ColorManager = _ColorManager;
              __publicField(ColorManager, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
              exports2.ColorManager = ColorManager;
              const _AnnotationEditorUIManager = class {
                constructor(container, eventBus) {
                  __privateAdd(this, _addKeyboardManager);
                  __privateAdd(this, _removeKeyboardManager);
                  __privateAdd(this, _dispatchUpdateStates);
                  __privateAdd(this, _dispatchUpdateUI);
                  __privateAdd(this, _enableAll);
                  __privateAdd(this, _disableAll);
                  __privateAdd(this, _addEditorToLayer);
                  __privateAdd(this, _isEmpty);
                  __privateAdd(this, _selectEditors);
                  __privateAdd(this, _activeEditor, null);
                  __privateAdd(this, _allEditors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _allLayers, /* @__PURE__ */ new Map());
                  __privateAdd(this, _clipboardManager, new ClipboardManager());
                  __privateAdd(this, _commandManager, new CommandManager());
                  __privateAdd(this, _currentPageIndex, 0);
                  __privateAdd(this, _editorTypes, null);
                  __privateAdd(this, _eventBus, null);
                  __privateAdd(this, _idManager, new IdManager());
                  __privateAdd(this, _isEnabled, false);
                  __privateAdd(this, _mode, _util2.AnnotationEditorType.NONE);
                  __privateAdd(this, _selectedEditors, /* @__PURE__ */ new Set());
                  __privateAdd(this, _boundKeydown, this.keydown.bind(this));
                  __privateAdd(this, _boundOnEditingAction, this.onEditingAction.bind(this));
                  __privateAdd(this, _boundOnPageChanging, this.onPageChanging.bind(this));
                  __privateAdd(this, _previousStates, {
                    isEditing: false,
                    isEmpty: true,
                    hasEmptyClipboard: true,
                    hasSomethingToUndo: false,
                    hasSomethingToRedo: false,
                    hasSelectedEditor: false
                  });
                  __privateAdd(this, _container, null);
                  __privateSet(this, _container, container);
                  __privateSet(this, _eventBus, eventBus);
                  __privateGet(this, _eventBus)._on("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._on("pagechanging", __privateGet(this, _boundOnPageChanging));
                }
                destroy() {
                  __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                  __privateGet(this, _eventBus)._off("editingaction", __privateGet(this, _boundOnEditingAction));
                  __privateGet(this, _eventBus)._off("pagechanging", __privateGet(this, _boundOnPageChanging));
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.destroy();
                  }
                  __privateGet(this, _allLayers).clear();
                  __privateGet(this, _allEditors).clear();
                  __privateSet(this, _activeEditor, null);
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _clipboardManager).destroy();
                  __privateGet(this, _commandManager).destroy();
                }
                onPageChanging({
                  pageNumber
                }) {
                  __privateSet(this, _currentPageIndex, pageNumber - 1);
                }
                focusMainContainer() {
                  __privateGet(this, _container).focus();
                }
                keydown(event) {
                  if (!this.getActive()?.shouldGetKeyboardEvents()) {
                    _AnnotationEditorUIManager._keyboardManager.exec(this, event);
                  }
                }
                onEditingAction(details) {
                  if (["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(details.name)) {
                    this[details.name]();
                  }
                }
                setEditingState(isEditing) {
                  if (isEditing) {
                    __privateMethod(this, _addKeyboardManager, addKeyboardManager_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: __privateGet(this, _mode) !== _util2.AnnotationEditorType.NONE,
                      isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this),
                      hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                      hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                      hasSelectedEditor: false,
                      hasEmptyClipboard: __privateGet(this, _clipboardManager).isEmpty()
                    });
                  } else {
                    __privateMethod(this, _removeKeyboardManager, removeKeyboardManager_fn).call(this);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      isEditing: false
                    });
                  }
                }
                registerEditorTypes(types) {
                  __privateSet(this, _editorTypes, types);
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editorType.defaultPropertiesToUpdate);
                  }
                }
                getId() {
                  return __privateGet(this, _idManager).getId();
                }
                addLayer(layer) {
                  __privateGet(this, _allLayers).set(layer.pageIndex, layer);
                  if (__privateGet(this, _isEnabled)) {
                    layer.enable();
                  } else {
                    layer.disable();
                  }
                }
                removeLayer(layer) {
                  __privateGet(this, _allLayers).delete(layer.pageIndex);
                }
                updateMode(mode) {
                  __privateSet(this, _mode, mode);
                  if (mode === _util2.AnnotationEditorType.NONE) {
                    this.setEditingState(false);
                    __privateMethod(this, _disableAll, disableAll_fn).call(this);
                  } else {
                    this.setEditingState(true);
                    __privateMethod(this, _enableAll, enableAll_fn).call(this);
                    for (const layer of __privateGet(this, _allLayers).values()) {
                      layer.updateMode(mode);
                    }
                  }
                }
                updateToolbar(mode) {
                  if (mode === __privateGet(this, _mode)) {
                    return;
                  }
                  __privateGet(this, _eventBus).dispatch("switchannotationeditormode", {
                    source: this,
                    mode
                  });
                }
                updateParams(type2, value2) {
                  for (const editor2 of __privateGet(this, _selectedEditors)) {
                    editor2.updateParams(type2, value2);
                  }
                  for (const editorType of __privateGet(this, _editorTypes)) {
                    editorType.updateDefaultParams(type2, value2);
                  }
                }
                getEditors(pageIndex) {
                  const editors = [];
                  for (const editor2 of __privateGet(this, _allEditors).values()) {
                    if (editor2.pageIndex === pageIndex) {
                      editors.push(editor2);
                    }
                  }
                  return editors;
                }
                getEditor(id2) {
                  return __privateGet(this, _allEditors).get(id2);
                }
                addEditor(editor2) {
                  __privateGet(this, _allEditors).set(editor2.id, editor2);
                }
                removeEditor(editor2) {
                  __privateGet(this, _allEditors).delete(editor2.id);
                  this.unselect(editor2);
                }
                setActiveEditor(editor2) {
                  if (__privateGet(this, _activeEditor) === editor2) {
                    return;
                  }
                  __privateSet(this, _activeEditor, editor2);
                  if (editor2) {
                    __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor2.propertiesToUpdate);
                  }
                }
                toggleSelected(editor2) {
                  if (__privateGet(this, _selectedEditors).has(editor2)) {
                    __privateGet(this, _selectedEditors).delete(editor2);
                    editor2.unselect();
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasSelectedEditor: this.hasSelection
                    });
                    return;
                  }
                  __privateGet(this, _selectedEditors).add(editor2);
                  editor2.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor2.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                setSelected(editor2) {
                  for (const ed of __privateGet(this, _selectedEditors)) {
                    if (ed !== editor2) {
                      ed.unselect();
                    }
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateGet(this, _selectedEditors).add(editor2);
                  editor2.select();
                  __privateMethod(this, _dispatchUpdateUI, dispatchUpdateUI_fn).call(this, editor2.propertiesToUpdate);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: true
                  });
                }
                isSelected(editor2) {
                  return __privateGet(this, _selectedEditors).has(editor2);
                }
                unselect(editor2) {
                  editor2.unselect();
                  __privateGet(this, _selectedEditors).delete(editor2);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: this.hasSelection
                  });
                }
                get hasSelection() {
                  return __privateGet(this, _selectedEditors).size !== 0;
                }
                undo() {
                  __privateGet(this, _commandManager).undo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: __privateGet(this, _commandManager).hasSomethingToUndo(),
                    hasSomethingToRedo: true,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                redo() {
                  __privateGet(this, _commandManager).redo();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: __privateGet(this, _commandManager).hasSomethingToRedo(),
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                addCommands(params) {
                  __privateGet(this, _commandManager).add(params);
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSomethingToUndo: true,
                    hasSomethingToRedo: false,
                    isEmpty: __privateMethod(this, _isEmpty, isEmpty_fn).call(this)
                  });
                }
                delete() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (!this.hasSelection) {
                    return;
                  }
                  const editors = [...__privateGet(this, _selectedEditors)];
                  const cmd = () => {
                    for (const editor2 of editors) {
                      editor2.remove();
                    }
                  };
                  const undo = () => {
                    for (const editor2 of editors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor2);
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                copy() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                  }
                  if (this.hasSelection) {
                    const editors = [];
                    for (const editor2 of __privateGet(this, _selectedEditors)) {
                      if (!editor2.isEmpty()) {
                        editors.push(editor2);
                      }
                    }
                    if (editors.length === 0) {
                      return;
                    }
                    __privateGet(this, _clipboardManager).copy(editors);
                    __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                      hasEmptyClipboard: false
                    });
                  }
                }
                cut() {
                  this.copy();
                  this.delete();
                }
                paste() {
                  if (__privateGet(this, _clipboardManager).isEmpty()) {
                    return;
                  }
                  this.unselectAll();
                  const layer = __privateGet(this, _allLayers).get(__privateGet(this, _currentPageIndex));
                  const newEditors = __privateGet(this, _clipboardManager).paste().map((data) => layer.deserialize(data));
                  const cmd = () => {
                    for (const editor2 of newEditors) {
                      __privateMethod(this, _addEditorToLayer, addEditorToLayer_fn).call(this, editor2);
                    }
                    __privateMethod(this, _selectEditors, selectEditors_fn).call(this, newEditors);
                  };
                  const undo = () => {
                    for (const editor2 of newEditors) {
                      editor2.remove();
                    }
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                selectAll() {
                  for (const editor2 of __privateGet(this, _selectedEditors)) {
                    editor2.commit();
                  }
                  __privateMethod(this, _selectEditors, selectEditors_fn).call(this, __privateGet(this, _allEditors).values());
                }
                unselectAll() {
                  if (__privateGet(this, _activeEditor)) {
                    __privateGet(this, _activeEditor).commitOrRemove();
                    return;
                  }
                  if (__privateMethod(this, _selectEditors, selectEditors_fn).size === 0) {
                    return;
                  }
                  for (const editor2 of __privateGet(this, _selectedEditors)) {
                    editor2.unselect();
                  }
                  __privateGet(this, _selectedEditors).clear();
                  __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                    hasSelectedEditor: false
                  });
                }
                isActive(editor2) {
                  return __privateGet(this, _activeEditor) === editor2;
                }
                getActive() {
                  return __privateGet(this, _activeEditor);
                }
                getMode() {
                  return __privateGet(this, _mode);
                }
              };
              let AnnotationEditorUIManager = _AnnotationEditorUIManager;
              _activeEditor = new WeakMap();
              _allEditors = new WeakMap();
              _allLayers = new WeakMap();
              _clipboardManager = new WeakMap();
              _commandManager = new WeakMap();
              _currentPageIndex = new WeakMap();
              _editorTypes = new WeakMap();
              _eventBus = new WeakMap();
              _idManager = new WeakMap();
              _isEnabled = new WeakMap();
              _mode = new WeakMap();
              _selectedEditors = new WeakMap();
              _boundKeydown = new WeakMap();
              _boundOnEditingAction = new WeakMap();
              _boundOnPageChanging = new WeakMap();
              _previousStates = new WeakMap();
              _container = new WeakMap();
              _addKeyboardManager = new WeakSet();
              addKeyboardManager_fn = function() {
                __privateGet(this, _container).addEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _removeKeyboardManager = new WeakSet();
              removeKeyboardManager_fn = function() {
                __privateGet(this, _container).removeEventListener("keydown", __privateGet(this, _boundKeydown));
              };
              _dispatchUpdateStates = new WeakSet();
              dispatchUpdateStates_fn = function(details) {
                const hasChanged = Object.entries(details).some(([key, value2]) => __privateGet(this, _previousStates)[key] !== value2);
                if (hasChanged) {
                  __privateGet(this, _eventBus).dispatch("annotationeditorstateschanged", {
                    source: this,
                    details: Object.assign(__privateGet(this, _previousStates), details)
                  });
                }
              };
              _dispatchUpdateUI = new WeakSet();
              dispatchUpdateUI_fn = function(details) {
                __privateGet(this, _eventBus).dispatch("annotationeditorparamschanged", {
                  source: this,
                  details
                });
              };
              _enableAll = new WeakSet();
              enableAll_fn = function() {
                if (!__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, true);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.enable();
                  }
                }
              };
              _disableAll = new WeakSet();
              disableAll_fn = function() {
                this.unselectAll();
                if (__privateGet(this, _isEnabled)) {
                  __privateSet(this, _isEnabled, false);
                  for (const layer of __privateGet(this, _allLayers).values()) {
                    layer.disable();
                  }
                }
              };
              _addEditorToLayer = new WeakSet();
              addEditorToLayer_fn = function(editor2) {
                const layer = __privateGet(this, _allLayers).get(editor2.pageIndex);
                if (layer) {
                  layer.addOrRebuild(editor2);
                } else {
                  this.addEditor(editor2);
                }
              };
              _isEmpty = new WeakSet();
              isEmpty_fn = function() {
                if (__privateGet(this, _allEditors).size === 0) {
                  return true;
                }
                if (__privateGet(this, _allEditors).size === 1) {
                  for (const editor2 of __privateGet(this, _allEditors).values()) {
                    return editor2.isEmpty();
                  }
                }
                return false;
              };
              _selectEditors = new WeakSet();
              selectEditors_fn = function(editors) {
                __privateGet(this, _selectedEditors).clear();
                for (const editor2 of editors) {
                  if (editor2.isEmpty()) {
                    continue;
                  }
                  __privateGet(this, _selectedEditors).add(editor2);
                  editor2.select();
                }
                __privateMethod(this, _dispatchUpdateStates, dispatchUpdateStates_fn).call(this, {
                  hasSelectedEditor: true
                });
              };
              __publicField(AnnotationEditorUIManager, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], _AnnotationEditorUIManager.prototype.selectAll], [["ctrl+c", "mac+meta+c"], _AnnotationEditorUIManager.prototype.copy], [["ctrl+v", "mac+meta+v"], _AnnotationEditorUIManager.prototype.paste], [["ctrl+x", "mac+meta+x"], _AnnotationEditorUIManager.prototype.cut], [["ctrl+z", "mac+meta+z"], _AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], _AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], _AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], _AnnotationEditorUIManager.prototype.unselectAll]]));
              exports2.AnnotationEditorUIManager = AnnotationEditorUIManager;
            },
            /* 8 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.StatTimer = exports2.RenderingCancelledException = exports2.PixelsPerInch = exports2.PageViewport = exports2.PDFDateString = exports2.DOMStandardFontDataFactory = exports2.DOMSVGFactory = exports2.DOMCanvasFactory = exports2.DOMCMapReaderFactory = exports2.AnnotationPrefix = void 0;
              exports2.deprecated = deprecated;
              exports2.getColorValues = getColorValues;
              exports2.getCurrentTransform = getCurrentTransform;
              exports2.getCurrentTransformInverse = getCurrentTransformInverse;
              exports2.getFilenameFromUrl = getFilenameFromUrl;
              exports2.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
              exports2.getRGB = getRGB;
              exports2.getXfaPageViewport = getXfaPageViewport;
              exports2.isDataScheme = isDataScheme;
              exports2.isPdfFile = isPdfFile;
              exports2.isValidFetchUrl = isValidFetchUrl;
              exports2.loadScript = loadScript;
              var _base_factory = __w_pdfjs_require__2(9);
              var _util2 = __w_pdfjs_require__2(1);
              const SVG_NS = "http://www.w3.org/2000/svg";
              const AnnotationPrefix = "pdfjs_internal_id_";
              exports2.AnnotationPrefix = AnnotationPrefix;
              const _PixelsPerInch = class {
              };
              let PixelsPerInch = _PixelsPerInch;
              __publicField(PixelsPerInch, "CSS", 96);
              __publicField(PixelsPerInch, "PDF", 72);
              __publicField(PixelsPerInch, "PDF_TO_CSS_UNITS", _PixelsPerInch.CSS / _PixelsPerInch.PDF);
              exports2.PixelsPerInch = PixelsPerInch;
              class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
                constructor({
                  ownerDocument = globalThis.document
                } = {}) {
                  super();
                  this._document = ownerDocument;
                }
                _createCanvas(width2, height2) {
                  const canvas = this._document.createElement("canvas");
                  canvas.width = width2;
                  canvas.height = height2;
                  return canvas;
                }
              }
              exports2.DOMCanvasFactory = DOMCanvasFactory;
              async function fetchData(url2, asTypedArray = false) {
                if (isValidFetchUrl(url2, document.baseURI)) {
                  const response = await fetch(url2);
                  if (!response.ok) {
                    throw new Error(response.statusText);
                  }
                  return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util2.stringToBytes)(await response.text());
                }
                return new Promise((resolve, reject) => {
                  const request = new XMLHttpRequest();
                  request.open("GET", url2, true);
                  if (asTypedArray) {
                    request.responseType = "arraybuffer";
                  }
                  request.onreadystatechange = () => {
                    if (request.readyState !== XMLHttpRequest.DONE) {
                      return;
                    }
                    if (request.status === 200 || request.status === 0) {
                      let data;
                      if (asTypedArray && request.response) {
                        data = new Uint8Array(request.response);
                      } else if (!asTypedArray && request.responseText) {
                        data = (0, _util2.stringToBytes)(request.responseText);
                      }
                      if (data) {
                        resolve(data);
                        return;
                      }
                    }
                    reject(new Error(request.statusText));
                  };
                  request.send(null);
                });
              }
              class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url2, compressionType) {
                  return fetchData(url2, this.isCompressed).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.DOMCMapReaderFactory = DOMCMapReaderFactory;
              class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url2) {
                  return fetchData(url2, true);
                }
              }
              exports2.DOMStandardFontDataFactory = DOMStandardFontDataFactory;
              class DOMSVGFactory extends _base_factory.BaseSVGFactory {
                _createSVG(type2) {
                  return document.createElementNS(SVG_NS, type2);
                }
              }
              exports2.DOMSVGFactory = DOMSVGFactory;
              class PageViewport {
                constructor({
                  viewBox,
                  scale: scale8,
                  rotation,
                  offsetX = 0,
                  offsetY = 0,
                  dontFlip = false
                }) {
                  this.viewBox = viewBox;
                  this.scale = scale8;
                  this.rotation = rotation;
                  this.offsetX = offsetX;
                  this.offsetY = offsetY;
                  const centerX = (viewBox[2] + viewBox[0]) / 2;
                  const centerY = (viewBox[3] + viewBox[1]) / 2;
                  let rotateA, rotateB, rotateC, rotateD;
                  rotation %= 360;
                  if (rotation < 0) {
                    rotation += 360;
                  }
                  switch (rotation) {
                    case 180:
                      rotateA = -1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = 1;
                      break;
                    case 90:
                      rotateA = 0;
                      rotateB = 1;
                      rotateC = 1;
                      rotateD = 0;
                      break;
                    case 270:
                      rotateA = 0;
                      rotateB = -1;
                      rotateC = -1;
                      rotateD = 0;
                      break;
                    case 0:
                      rotateA = 1;
                      rotateB = 0;
                      rotateC = 0;
                      rotateD = -1;
                      break;
                    default:
                      throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
                  }
                  if (dontFlip) {
                    rotateC = -rotateC;
                    rotateD = -rotateD;
                  }
                  let offsetCanvasX, offsetCanvasY;
                  let width2, height2;
                  if (rotateA === 0) {
                    offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale8 + offsetX;
                    offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale8 + offsetY;
                    width2 = Math.abs(viewBox[3] - viewBox[1]) * scale8;
                    height2 = Math.abs(viewBox[2] - viewBox[0]) * scale8;
                  } else {
                    offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale8 + offsetX;
                    offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale8 + offsetY;
                    width2 = Math.abs(viewBox[2] - viewBox[0]) * scale8;
                    height2 = Math.abs(viewBox[3] - viewBox[1]) * scale8;
                  }
                  this.transform = [rotateA * scale8, rotateB * scale8, rotateC * scale8, rotateD * scale8, offsetCanvasX - rotateA * scale8 * centerX - rotateC * scale8 * centerY, offsetCanvasY - rotateB * scale8 * centerX - rotateD * scale8 * centerY];
                  this.width = width2;
                  this.height = height2;
                }
                clone({
                  scale: scale8 = this.scale,
                  rotation = this.rotation,
                  offsetX = this.offsetX,
                  offsetY = this.offsetY,
                  dontFlip = false
                } = {}) {
                  return new PageViewport({
                    viewBox: this.viewBox.slice(),
                    scale: scale8,
                    rotation,
                    offsetX,
                    offsetY,
                    dontFlip
                  });
                }
                convertToViewportPoint(x, y) {
                  return _util2.Util.applyTransform([x, y], this.transform);
                }
                convertToViewportRectangle(rect) {
                  const topLeft = _util2.Util.applyTransform([rect[0], rect[1]], this.transform);
                  const bottomRight = _util2.Util.applyTransform([rect[2], rect[3]], this.transform);
                  return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
                }
                convertToPdfPoint(x, y) {
                  return _util2.Util.applyInverseTransform([x, y], this.transform);
                }
              }
              exports2.PageViewport = PageViewport;
              class RenderingCancelledException extends _util2.BaseException {
                constructor(msg, type2) {
                  super(msg, "RenderingCancelledException");
                  this.type = type2;
                }
              }
              exports2.RenderingCancelledException = RenderingCancelledException;
              function isDataScheme(url2) {
                const ii = url2.length;
                let i = 0;
                while (i < ii && url2[i].trim() === "") {
                  i++;
                }
                return url2.substring(i, i + 5).toLowerCase() === "data:";
              }
              function isPdfFile(filename) {
                return typeof filename === "string" && /\.pdf$/i.test(filename);
              }
              function getFilenameFromUrl(url2) {
                const anchor = url2.indexOf("#");
                const query = url2.indexOf("?");
                const end2 = Math.min(anchor > 0 ? anchor : url2.length, query > 0 ? query : url2.length);
                return url2.substring(url2.lastIndexOf("/", end2) + 1, end2);
              }
              function getPdfFilenameFromUrl(url2, defaultFilename = "document.pdf") {
                if (typeof url2 !== "string") {
                  return defaultFilename;
                }
                if (isDataScheme(url2)) {
                  (0, _util2.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
                  return defaultFilename;
                }
                const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
                const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
                const splitURI = reURI.exec(url2);
                let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);
                if (suggestedFilename) {
                  suggestedFilename = suggestedFilename[0];
                  if (suggestedFilename.includes("%")) {
                    try {
                      suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
                    } catch (ex) {
                    }
                  }
                }
                return suggestedFilename || defaultFilename;
              }
              class StatTimer {
                constructor() {
                  this.started = /* @__PURE__ */ Object.create(null);
                  this.times = [];
                }
                time(name3) {
                  if (name3 in this.started) {
                    (0, _util2.warn)(`Timer is already running for ${name3}`);
                  }
                  this.started[name3] = Date.now();
                }
                timeEnd(name3) {
                  if (!(name3 in this.started)) {
                    (0, _util2.warn)(`Timer has not been started for ${name3}`);
                  }
                  this.times.push({
                    name: name3,
                    start: this.started[name3],
                    end: Date.now()
                  });
                  delete this.started[name3];
                }
                toString() {
                  const outBuf = [];
                  let longest = 0;
                  for (const time of this.times) {
                    const name3 = time.name;
                    if (name3.length > longest) {
                      longest = name3.length;
                    }
                  }
                  for (const time of this.times) {
                    const duration = time.end - time.start;
                    outBuf.push(`${time.name.padEnd(longest)} ${duration}ms
`);
                  }
                  return outBuf.join("");
                }
              }
              exports2.StatTimer = StatTimer;
              function isValidFetchUrl(url2, baseUrl) {
                try {
                  const {
                    protocol
                  } = baseUrl ? new URL(url2, baseUrl) : new URL(url2);
                  return protocol === "http:" || protocol === "https:";
                } catch (ex) {
                  return false;
                }
              }
              function loadScript(src2, removeScriptElement = false) {
                return new Promise((resolve, reject) => {
                  const script = document.createElement("script");
                  script.src = src2;
                  script.onload = function(evt) {
                    if (removeScriptElement) {
                      script.remove();
                    }
                    resolve(evt);
                  };
                  script.onerror = function() {
                    reject(new Error(`Cannot load script at: ${script.src}`));
                  };
                  (document.head || document.documentElement).append(script);
                });
              }
              function deprecated(details) {
                console.log("Deprecated API usage: " + details);
              }
              let pdfDateStringRegex;
              class PDFDateString {
                static toDateObject(input) {
                  if (!input || typeof input !== "string") {
                    return null;
                  }
                  if (!pdfDateStringRegex) {
                    pdfDateStringRegex = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
                  }
                  const matches = pdfDateStringRegex.exec(input);
                  if (!matches) {
                    return null;
                  }
                  const year = parseInt(matches[1], 10);
                  let month = parseInt(matches[2], 10);
                  month = month >= 1 && month <= 12 ? month - 1 : 0;
                  let day = parseInt(matches[3], 10);
                  day = day >= 1 && day <= 31 ? day : 1;
                  let hour = parseInt(matches[4], 10);
                  hour = hour >= 0 && hour <= 23 ? hour : 0;
                  let minute = parseInt(matches[5], 10);
                  minute = minute >= 0 && minute <= 59 ? minute : 0;
                  let second = parseInt(matches[6], 10);
                  second = second >= 0 && second <= 59 ? second : 0;
                  const universalTimeRelation = matches[7] || "Z";
                  let offsetHour = parseInt(matches[8], 10);
                  offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
                  let offsetMinute = parseInt(matches[9], 10) || 0;
                  offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
                  if (universalTimeRelation === "-") {
                    hour += offsetHour;
                    minute += offsetMinute;
                  } else if (universalTimeRelation === "+") {
                    hour -= offsetHour;
                    minute -= offsetMinute;
                  }
                  return new Date(Date.UTC(year, month, day, hour, minute, second));
                }
              }
              exports2.PDFDateString = PDFDateString;
              function getXfaPageViewport(xfaPage, {
                scale: scale8 = 1,
                rotation = 0
              }) {
                const {
                  width: width2,
                  height: height2
                } = xfaPage.attributes.style;
                const viewBox = [0, 0, parseInt(width2), parseInt(height2)];
                return new PageViewport({
                  viewBox,
                  scale: scale8,
                  rotation
                });
              }
              function getRGB(color2) {
                if (color2.startsWith("#")) {
                  const colorRGB = parseInt(color2.slice(1), 16);
                  return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
                }
                if (color2.startsWith("rgb(")) {
                  return color2.slice(4, -1).split(",").map((x) => parseInt(x));
                }
                if (color2.startsWith("rgba(")) {
                  return color2.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
                }
                (0, _util2.warn)(`Not a valid color format: "${color2}"`);
                return [0, 0, 0];
              }
              function getColorValues(colors) {
                const span = document.createElement("span");
                span.style.visibility = "hidden";
                document.body.append(span);
                for (const name3 of colors.keys()) {
                  span.style.color = name3;
                  const computedColor = window.getComputedStyle(span).color;
                  colors.set(name3, getRGB(computedColor));
                }
                span.remove();
              }
              function getCurrentTransform(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e: e2,
                  f: f2
                } = ctx.getTransform();
                return [a, b, c, d, e2, f2];
              }
              function getCurrentTransformInverse(ctx) {
                const {
                  a,
                  b,
                  c,
                  d,
                  e: e2,
                  f: f2
                } = ctx.getTransform().invertSelf();
                return [a, b, c, d, e2, f2];
              }
            },
            /* 9 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.BaseStandardFontDataFactory = exports2.BaseSVGFactory = exports2.BaseCanvasFactory = exports2.BaseCMapReaderFactory = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseCanvasFactory {
                constructor() {
                  if (this.constructor === BaseCanvasFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCanvasFactory.");
                  }
                }
                create(width2, height2) {
                  if (width2 <= 0 || height2 <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  const canvas = this._createCanvas(width2, height2);
                  return {
                    canvas,
                    context: canvas.getContext("2d")
                  };
                }
                reset(canvasAndContext, width2, height2) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  if (width2 <= 0 || height2 <= 0) {
                    throw new Error("Invalid canvas size");
                  }
                  canvasAndContext.canvas.width = width2;
                  canvasAndContext.canvas.height = height2;
                }
                destroy(canvasAndContext) {
                  if (!canvasAndContext.canvas) {
                    throw new Error("Canvas is not specified");
                  }
                  canvasAndContext.canvas.width = 0;
                  canvasAndContext.canvas.height = 0;
                  canvasAndContext.canvas = null;
                  canvasAndContext.context = null;
                }
                _createCanvas(width2, height2) {
                  (0, _util2.unreachable)("Abstract method `_createCanvas` called.");
                }
              }
              exports2.BaseCanvasFactory = BaseCanvasFactory;
              class BaseCMapReaderFactory {
                constructor({
                  baseUrl = null,
                  isCompressed = false
                }) {
                  if (this.constructor === BaseCMapReaderFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseCMapReaderFactory.");
                  }
                  this.baseUrl = baseUrl;
                  this.isCompressed = isCompressed;
                }
                async fetch({
                  name: name3
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
                  }
                  if (!name3) {
                    throw new Error("CMap name must be specified.");
                  }
                  const url2 = this.baseUrl + name3 + (this.isCompressed ? ".bcmap" : "");
                  const compressionType = this.isCompressed ? _util2.CMapCompressionType.BINARY : _util2.CMapCompressionType.NONE;
                  return this._fetchData(url2, compressionType).catch((reason) => {
                    throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url2}`);
                  });
                }
                _fetchData(url2, compressionType) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseCMapReaderFactory = BaseCMapReaderFactory;
              class BaseStandardFontDataFactory {
                constructor({
                  baseUrl = null
                }) {
                  if (this.constructor === BaseStandardFontDataFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
                  }
                  this.baseUrl = baseUrl;
                }
                async fetch({
                  filename
                }) {
                  if (!this.baseUrl) {
                    throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
                  }
                  if (!filename) {
                    throw new Error("Font filename must be specified.");
                  }
                  const url2 = `${this.baseUrl}${filename}`;
                  return this._fetchData(url2).catch((reason) => {
                    throw new Error(`Unable to load font data at: ${url2}`);
                  });
                }
                _fetchData(url2) {
                  (0, _util2.unreachable)("Abstract method `_fetchData` called.");
                }
              }
              exports2.BaseStandardFontDataFactory = BaseStandardFontDataFactory;
              class BaseSVGFactory {
                constructor() {
                  if (this.constructor === BaseSVGFactory) {
                    (0, _util2.unreachable)("Cannot initialize BaseSVGFactory.");
                  }
                }
                create(width2, height2, skipDimensions = false) {
                  if (width2 <= 0 || height2 <= 0) {
                    throw new Error("Invalid SVG dimensions");
                  }
                  const svg = this._createSVG("svg:svg");
                  svg.setAttribute("version", "1.1");
                  if (!skipDimensions) {
                    svg.setAttribute("width", `${width2}px`);
                    svg.setAttribute("height", `${height2}px`);
                  }
                  svg.setAttribute("preserveAspectRatio", "none");
                  svg.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
                  return svg;
                }
                createElement(type2) {
                  if (typeof type2 !== "string") {
                    throw new Error("Invalid SVG element type");
                  }
                  return this._createSVG(type2);
                }
                _createSVG(type2) {
                  (0, _util2.unreachable)("Abstract method `_createSVG` called.");
                }
              }
              exports2.BaseSVGFactory = BaseSVGFactory;
            },
            /* 10 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MurmurHash3_64 = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const SEED = 3285377520;
              const MASK_HIGH = 4294901760;
              const MASK_LOW = 65535;
              class MurmurHash3_64 {
                constructor(seed) {
                  this.h1 = seed ? seed & 4294967295 : SEED;
                  this.h2 = seed ? seed & 4294967295 : SEED;
                }
                update(input) {
                  let data, length8;
                  if (typeof input === "string") {
                    data = new Uint8Array(input.length * 2);
                    length8 = 0;
                    for (let i = 0, ii = input.length; i < ii; i++) {
                      const code = input.charCodeAt(i);
                      if (code <= 255) {
                        data[length8++] = code;
                      } else {
                        data[length8++] = code >>> 8;
                        data[length8++] = code & 255;
                      }
                    }
                  } else if ((0, _util2.isArrayBuffer)(input)) {
                    data = input.slice();
                    length8 = data.byteLength;
                  } else {
                    throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
                  }
                  const blockCounts = length8 >> 2;
                  const tailLength = length8 - blockCounts * 4;
                  const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
                  let k1 = 0, k2 = 0;
                  let h1 = this.h1, h2 = this.h2;
                  const C1 = 3432918353, C2 = 461845907;
                  const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
                  for (let i = 0; i < blockCounts; i++) {
                    if (i & 1) {
                      k1 = dataUint32[i];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      h1 ^= k1;
                      h1 = h1 << 13 | h1 >>> 19;
                      h1 = h1 * 5 + 3864292196;
                    } else {
                      k2 = dataUint32[i];
                      k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                      k2 = k2 << 15 | k2 >>> 17;
                      k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                      h2 ^= k2;
                      h2 = h2 << 13 | h2 >>> 19;
                      h2 = h2 * 5 + 3864292196;
                    }
                  }
                  k1 = 0;
                  switch (tailLength) {
                    case 3:
                      k1 ^= data[blockCounts * 4 + 2] << 16;
                    case 2:
                      k1 ^= data[blockCounts * 4 + 1] << 8;
                    case 1:
                      k1 ^= data[blockCounts * 4];
                      k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                      k1 = k1 << 15 | k1 >>> 17;
                      k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                      if (blockCounts & 1) {
                        h1 ^= k1;
                      } else {
                        h2 ^= k1;
                      }
                  }
                  this.h1 = h1;
                  this.h2 = h2;
                }
                hexdigest() {
                  let h1 = this.h1, h2 = this.h2;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
                  h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
                  h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
                  h1 ^= h2 >>> 1;
                  const hex1 = (h1 >>> 0).toString(16), hex2 = (h2 >>> 0).toString(16);
                  return hex1.padStart(8, "0") + hex2.padStart(8, "0");
                }
              }
              exports2.MurmurHash3_64 = MurmurHash3_64;
            },
            /* 11 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FontLoader = exports2.FontFaceObject = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class BaseFontLoader {
                constructor({
                  docId,
                  onUnsupportedFeature,
                  ownerDocument = globalThis.document,
                  styleElement = null
                }) {
                  if (this.constructor === BaseFontLoader) {
                    (0, _util2.unreachable)("Cannot initialize BaseFontLoader.");
                  }
                  this.docId = docId;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this._document = ownerDocument;
                  this.nativeFontFaces = [];
                  this.styleElement = null;
                }
                addNativeFontFace(nativeFontFace) {
                  this.nativeFontFaces.push(nativeFontFace);
                  this._document.fonts.add(nativeFontFace);
                }
                insertRule(rule2) {
                  let styleElement = this.styleElement;
                  if (!styleElement) {
                    styleElement = this.styleElement = this._document.createElement("style");
                    styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;
                    this._document.documentElement.getElementsByTagName("head")[0].append(styleElement);
                  }
                  const styleSheet = styleElement.sheet;
                  styleSheet.insertRule(rule2, styleSheet.cssRules.length);
                }
                clear() {
                  for (const nativeFontFace of this.nativeFontFaces) {
                    this._document.fonts.delete(nativeFontFace);
                  }
                  this.nativeFontFaces.length = 0;
                  if (this.styleElement) {
                    this.styleElement.remove();
                    this.styleElement = null;
                  }
                }
                async bind(font2) {
                  if (font2.attached || font2.missingFile) {
                    return;
                  }
                  font2.attached = true;
                  if (this.isFontLoadingAPISupported) {
                    const nativeFontFace = font2.createNativeFontFace();
                    if (nativeFontFace) {
                      this.addNativeFontFace(nativeFontFace);
                      try {
                        await nativeFontFace.loaded;
                      } catch (ex) {
                        this._onUnsupportedFeature({
                          featureId: _util2.UNSUPPORTED_FEATURES.errorFontLoadNative
                        });
                        (0, _util2.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                        font2.disableFontFace = true;
                        throw ex;
                      }
                    }
                    return;
                  }
                  const rule2 = font2.createFontFaceRule();
                  if (rule2) {
                    this.insertRule(rule2);
                    if (this.isSyncFontLoadingSupported) {
                      return;
                    }
                    await new Promise((resolve) => {
                      const request = this._queueLoadingCallback(resolve);
                      this._prepareFontLoadEvent([rule2], [font2], request);
                    });
                  }
                }
                _queueLoadingCallback(callback) {
                  (0, _util2.unreachable)("Abstract method `_queueLoadingCallback`.");
                }
                get isFontLoadingAPISupported() {
                  const hasFonts = !!this._document?.fonts;
                  return (0, _util2.shadow)(this, "isFontLoadingAPISupported", hasFonts);
                }
                get isSyncFontLoadingSupported() {
                  (0, _util2.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
                }
                get _loadTestFont() {
                  (0, _util2.unreachable)("Abstract method `_loadTestFont`.");
                }
                _prepareFontLoadEvent(rules, fontsToLoad, request) {
                  (0, _util2.unreachable)("Abstract method `_prepareFontLoadEvent`.");
                }
              }
              let FontLoader;
              exports2.FontLoader = FontLoader;
              {
                exports2.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
                  constructor(params) {
                    super(params);
                    this.loadingContext = {
                      requests: [],
                      nextRequestId: 0
                    };
                    this.loadTestFontId = 0;
                  }
                  get isSyncFontLoadingSupported() {
                    let supported = false;
                    if (typeof navigator === "undefined") {
                      supported = true;
                    } else {
                      const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);
                      if (m?.[1] >= 14) {
                        supported = true;
                      }
                    }
                    return (0, _util2.shadow)(this, "isSyncFontLoadingSupported", supported);
                  }
                  _queueLoadingCallback(callback) {
                    function completeRequest() {
                      (0, _util2.assert)(!request.done, "completeRequest() cannot be called twice.");
                      request.done = true;
                      while (context.requests.length > 0 && context.requests[0].done) {
                        const otherRequest = context.requests.shift();
                        setTimeout(otherRequest.callback, 0);
                      }
                    }
                    const context = this.loadingContext;
                    const request = {
                      id: `pdfjs-font-loading-${context.nextRequestId++}`,
                      done: false,
                      complete: completeRequest,
                      callback
                    };
                    context.requests.push(request);
                    return request;
                  }
                  get _loadTestFont() {
                    const getLoadTestFont = function() {
                      return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                    };
                    return (0, _util2.shadow)(this, "_loadTestFont", getLoadTestFont());
                  }
                  _prepareFontLoadEvent(rules, fonts, request) {
                    function int32(data2, offset) {
                      return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
                    }
                    function spliceString(s, offset, remove, insert) {
                      const chunk1 = s.substring(0, offset);
                      const chunk2 = s.substring(offset + remove);
                      return chunk1 + insert + chunk2;
                    }
                    let i, ii;
                    const canvas = this._document.createElement("canvas");
                    canvas.width = 1;
                    canvas.height = 1;
                    const ctx = canvas.getContext("2d");
                    let called = 0;
                    function isFontReady(name3, callback) {
                      called++;
                      if (called > 30) {
                        (0, _util2.warn)("Load test font never loaded.");
                        callback();
                        return;
                      }
                      ctx.font = "30px " + name3;
                      ctx.fillText(".", 0, 20);
                      const imageData = ctx.getImageData(0, 0, 1, 1);
                      if (imageData.data[3] > 0) {
                        callback();
                        return;
                      }
                      setTimeout(isFontReady.bind(null, name3, callback));
                    }
                    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
                    let data = this._loadTestFont;
                    const COMMENT_OFFSET = 976;
                    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                    const CFF_CHECKSUM_OFFSET = 16;
                    const XXXX_VALUE = 1482184792;
                    let checksum = int32(data, CFF_CHECKSUM_OFFSET);
                    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                    }
                    if (i < loadTestFontId.length) {
                      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                    }
                    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util2.string32)(checksum));
                    const url2 = `url(data:font/opentype;base64,${btoa(data)});`;
                    const rule2 = `@font-face {font-family:"${loadTestFontId}";src:${url2}}`;
                    this.insertRule(rule2);
                    const names = [];
                    for (const font2 of fonts) {
                      names.push(font2.loadedName);
                    }
                    names.push(loadTestFontId);
                    const div4 = this._document.createElement("div");
                    div4.style.visibility = "hidden";
                    div4.style.width = div4.style.height = "10px";
                    div4.style.position = "absolute";
                    div4.style.top = div4.style.left = "0px";
                    for (const name3 of names) {
                      const span = this._document.createElement("span");
                      span.textContent = "Hi";
                      span.style.fontFamily = name3;
                      div4.append(span);
                    }
                    this._document.body.append(div4);
                    isFontReady(loadTestFontId, () => {
                      div4.remove();
                      request.complete();
                    });
                  }
                };
              }
              class FontFaceObject {
                constructor(translatedData, {
                  isEvalSupported = true,
                  disableFontFace = false,
                  ignoreErrors = false,
                  onUnsupportedFeature,
                  fontRegistry = null
                }) {
                  this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
                  for (const i in translatedData) {
                    this[i] = translatedData[i];
                  }
                  this.isEvalSupported = isEvalSupported !== false;
                  this.disableFontFace = disableFontFace === true;
                  this.ignoreErrors = ignoreErrors === true;
                  this._onUnsupportedFeature = onUnsupportedFeature;
                  this.fontRegistry = fontRegistry;
                }
                createNativeFontFace() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  let nativeFontFace;
                  if (!this.cssFontInfo) {
                    nativeFontFace = new FontFace(this.loadedName, this.data, {});
                  } else {
                    const css = {
                      weight: this.cssFontInfo.fontWeight
                    };
                    if (this.cssFontInfo.italicAngle) {
                      css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
                    }
                    nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this);
                  }
                  return nativeFontFace;
                }
                createFontFaceRule() {
                  if (!this.data || this.disableFontFace) {
                    return null;
                  }
                  const data = (0, _util2.bytesToString)(this.data);
                  const url2 = `url(data:${this.mimetype};base64,${btoa(data)});`;
                  let rule2;
                  if (!this.cssFontInfo) {
                    rule2 = `@font-face {font-family:"${this.loadedName}";src:${url2}}`;
                  } else {
                    let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
                    if (this.cssFontInfo.italicAngle) {
                      css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
                    }
                    rule2 = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url2}}`;
                  }
                  if (this.fontRegistry) {
                    this.fontRegistry.registerFont(this, url2);
                  }
                  return rule2;
                }
                getPathGenerator(objs, character) {
                  if (this.compiledGlyphs[character] !== void 0) {
                    return this.compiledGlyphs[character];
                  }
                  let cmds;
                  try {
                    cmds = objs.get(this.loadedName + "_path_" + character);
                  } catch (ex) {
                    if (!this.ignoreErrors) {
                      throw ex;
                    }
                    this._onUnsupportedFeature({
                      featureId: _util2.UNSUPPORTED_FEATURES.errorFontGetPath
                    });
                    (0, _util2.warn)(`getPathGenerator - ignoring character: "${ex}".`);
                    return this.compiledGlyphs[character] = function(c, size4) {
                    };
                  }
                  if (this.isEvalSupported && _util2.FeatureTest.isEvalSupported) {
                    const jsBuf = [];
                    for (const current of cmds) {
                      const args = current.args !== void 0 ? current.args.join(",") : "";
                      jsBuf.push("c.", current.cmd, "(", args, ");\n");
                    }
                    return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
                  }
                  return this.compiledGlyphs[character] = function(c, size4) {
                    for (const current of cmds) {
                      if (current.cmd === "scale") {
                        current.args = [size4, -size4];
                      }
                      c[current.cmd].apply(c, current.args);
                    }
                  };
                }
              }
              exports2.FontFaceObject = FontFaceObject;
            },
            /* 12 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _restoreInitialState, restoreInitialState_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.CanvasGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _util2 = __w_pdfjs_require__2(1);
              var _pattern_helper = __w_pdfjs_require__2(13);
              var _image_utils = __w_pdfjs_require__2(14);
              var _is_node2 = __w_pdfjs_require__2(3);
              const MIN_FONT_SIZE = 16;
              const MAX_FONT_SIZE = 100;
              const MAX_GROUP_SIZE = 4096;
              const EXECUTION_TIME = 15;
              const EXECUTION_STEPS = 10;
              const MAX_SIZE_TO_COMPILE = _is_node2.isNodeJS && typeof Path2D === "undefined" ? -1 : 1e3;
              const FULL_CHUNK_HEIGHT = 16;
              function mirrorContextOperations(ctx, destCtx) {
                if (ctx._removeMirroring) {
                  throw new Error("Context is already forwarding operations.");
                }
                ctx.__originalSave = ctx.save;
                ctx.__originalRestore = ctx.restore;
                ctx.__originalRotate = ctx.rotate;
                ctx.__originalScale = ctx.scale;
                ctx.__originalTranslate = ctx.translate;
                ctx.__originalTransform = ctx.transform;
                ctx.__originalSetTransform = ctx.setTransform;
                ctx.__originalResetTransform = ctx.resetTransform;
                ctx.__originalClip = ctx.clip;
                ctx.__originalMoveTo = ctx.moveTo;
                ctx.__originalLineTo = ctx.lineTo;
                ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
                ctx.__originalRect = ctx.rect;
                ctx.__originalClosePath = ctx.closePath;
                ctx.__originalBeginPath = ctx.beginPath;
                ctx._removeMirroring = () => {
                  ctx.save = ctx.__originalSave;
                  ctx.restore = ctx.__originalRestore;
                  ctx.rotate = ctx.__originalRotate;
                  ctx.scale = ctx.__originalScale;
                  ctx.translate = ctx.__originalTranslate;
                  ctx.transform = ctx.__originalTransform;
                  ctx.setTransform = ctx.__originalSetTransform;
                  ctx.resetTransform = ctx.__originalResetTransform;
                  ctx.clip = ctx.__originalClip;
                  ctx.moveTo = ctx.__originalMoveTo;
                  ctx.lineTo = ctx.__originalLineTo;
                  ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
                  ctx.rect = ctx.__originalRect;
                  ctx.closePath = ctx.__originalClosePath;
                  ctx.beginPath = ctx.__originalBeginPath;
                  delete ctx._removeMirroring;
                };
                ctx.save = function ctxSave() {
                  destCtx.save();
                  this.__originalSave();
                };
                ctx.restore = function ctxRestore() {
                  destCtx.restore();
                  this.__originalRestore();
                };
                ctx.translate = function ctxTranslate(x, y) {
                  destCtx.translate(x, y);
                  this.__originalTranslate(x, y);
                };
                ctx.scale = function ctxScale(x, y) {
                  destCtx.scale(x, y);
                  this.__originalScale(x, y);
                };
                ctx.transform = function ctxTransform(a, b, c, d, e2, f2) {
                  destCtx.transform(a, b, c, d, e2, f2);
                  this.__originalTransform(a, b, c, d, e2, f2);
                };
                ctx.setTransform = function ctxSetTransform(a, b, c, d, e2, f2) {
                  destCtx.setTransform(a, b, c, d, e2, f2);
                  this.__originalSetTransform(a, b, c, d, e2, f2);
                };
                ctx.resetTransform = function ctxResetTransform() {
                  destCtx.resetTransform();
                  this.__originalResetTransform();
                };
                ctx.rotate = function ctxRotate(angle5) {
                  destCtx.rotate(angle5);
                  this.__originalRotate(angle5);
                };
                ctx.clip = function ctxRotate(rule2) {
                  destCtx.clip(rule2);
                  this.__originalClip(rule2);
                };
                ctx.moveTo = function(x, y) {
                  destCtx.moveTo(x, y);
                  this.__originalMoveTo(x, y);
                };
                ctx.lineTo = function(x, y) {
                  destCtx.lineTo(x, y);
                  this.__originalLineTo(x, y);
                };
                ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
                  destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                  this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
                };
                ctx.rect = function(x, y, width2, height2) {
                  destCtx.rect(x, y, width2, height2);
                  this.__originalRect(x, y, width2, height2);
                };
                ctx.closePath = function() {
                  destCtx.closePath();
                  this.__originalClosePath();
                };
                ctx.beginPath = function() {
                  destCtx.beginPath();
                  this.__originalBeginPath();
                };
              }
              class CachedCanvases {
                constructor(canvasFactory) {
                  this.canvasFactory = canvasFactory;
                  this.cache = /* @__PURE__ */ Object.create(null);
                }
                getCanvas(id2, width2, height2) {
                  let canvasEntry;
                  if (this.cache[id2] !== void 0) {
                    canvasEntry = this.cache[id2];
                    this.canvasFactory.reset(canvasEntry, width2, height2);
                  } else {
                    canvasEntry = this.canvasFactory.create(width2, height2);
                    this.cache[id2] = canvasEntry;
                  }
                  return canvasEntry;
                }
                delete(id2) {
                  delete this.cache[id2];
                }
                clear() {
                  for (const id2 in this.cache) {
                    const canvasEntry = this.cache[id2];
                    this.canvasFactory.destroy(canvasEntry);
                    delete this.cache[id2];
                  }
                }
              }
              function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
                const [a, b, c, d, tx, ty] = (0, _display_utils2.getCurrentTransform)(ctx);
                if (b === 0 && c === 0) {
                  const tlX = destX * a + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destY * d + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destX + destW) * a + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destY + destH) * d + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rWidth, rHeight];
                }
                if (a === 0 && d === 0) {
                  const tlX = destY * c + tx;
                  const rTlX = Math.round(tlX);
                  const tlY = destX * b + ty;
                  const rTlY = Math.round(tlY);
                  const brX = (destY + destH) * c + tx;
                  const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
                  const brY = (destX + destW) * b + ty;
                  const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
                  ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
                  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
                  ctx.setTransform(a, b, c, d, tx, ty);
                  return [rHeight, rWidth];
                }
                ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
                const scaleX = Math.hypot(a, b);
                const scaleY = Math.hypot(c, d);
                return [scaleX * destW, scaleY * destH];
              }
              function compileType3Glyph(imgData) {
                const {
                  width: width2,
                  height: height2
                } = imgData;
                if (width2 > MAX_SIZE_TO_COMPILE || height2 > MAX_SIZE_TO_COMPILE) {
                  return null;
                }
                const POINT_TO_PROCESS_LIMIT = 1e3;
                const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
                const width1 = width2 + 1;
                let points = new Uint8Array(width1 * (height2 + 1));
                let i, j, j0;
                const lineSize = width2 + 7 & ~7;
                let data = new Uint8Array(lineSize * height2), pos = 0;
                for (const elem of imgData.data) {
                  let mask = 128;
                  while (mask > 0) {
                    data[pos++] = elem & mask ? 0 : 255;
                    mask >>= 1;
                  }
                }
                let count = 0;
                pos = 0;
                if (data[pos] !== 0) {
                  points[0] = 1;
                  ++count;
                }
                for (j = 1; j < width2; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j] = data[pos] ? 2 : 1;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j] = 2;
                  ++count;
                }
                for (i = 1; i < height2; i++) {
                  pos = i * lineSize;
                  j0 = i * width1;
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0] = data[pos] ? 1 : 8;
                    ++count;
                  }
                  let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);
                  for (j = 1; j < width2; j++) {
                    sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);
                    if (POINT_TYPES[sum]) {
                      points[j0 + j] = POINT_TYPES[sum];
                      ++count;
                    }
                    pos++;
                  }
                  if (data[pos - lineSize] !== data[pos]) {
                    points[j0 + j] = data[pos] ? 2 : 4;
                    ++count;
                  }
                  if (count > POINT_TO_PROCESS_LIMIT) {
                    return null;
                  }
                }
                pos = lineSize * (height2 - 1);
                j0 = i * width1;
                if (data[pos] !== 0) {
                  points[j0] = 8;
                  ++count;
                }
                for (j = 1; j < width2; j++) {
                  if (data[pos] !== data[pos + 1]) {
                    points[j0 + j] = data[pos] ? 4 : 8;
                    ++count;
                  }
                  pos++;
                }
                if (data[pos] !== 0) {
                  points[j0 + j] = 4;
                  ++count;
                }
                if (count > POINT_TO_PROCESS_LIMIT) {
                  return null;
                }
                const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
                const path = new Path2D();
                for (i = 0; count && i <= height2; i++) {
                  let p = i * width1;
                  const end2 = p + width2;
                  while (p < end2 && !points[p]) {
                    p++;
                  }
                  if (p === end2) {
                    continue;
                  }
                  path.moveTo(p % width1, i);
                  const p0 = p;
                  let type2 = points[p];
                  do {
                    const step2 = steps[type2];
                    do {
                      p += step2;
                    } while (!points[p]);
                    const pp = points[p];
                    if (pp !== 5 && pp !== 10) {
                      type2 = pp;
                      points[p] = 0;
                    } else {
                      type2 = pp & 51 * type2 >> 4;
                      points[p] &= type2 >> 2 | type2 << 2;
                    }
                    path.lineTo(p % width1, p / width1 | 0);
                    if (!points[p]) {
                      --count;
                    }
                  } while (p0 !== p);
                  --i;
                }
                data = null;
                points = null;
                const drawOutline = function(c) {
                  c.save();
                  c.scale(1 / width2, -1 / height2);
                  c.translate(0, -height2);
                  c.fill(path);
                  c.beginPath();
                  c.restore();
                };
                return drawOutline;
              }
              class CanvasExtraState {
                constructor(width2, height2) {
                  this.alphaIsShape = false;
                  this.fontSize = 0;
                  this.fontSizeScale = 1;
                  this.textMatrix = _util2.IDENTITY_MATRIX;
                  this.textMatrixScale = 1;
                  this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                  this.leading = 0;
                  this.x = 0;
                  this.y = 0;
                  this.lineX = 0;
                  this.lineY = 0;
                  this.charSpacing = 0;
                  this.wordSpacing = 0;
                  this.textHScale = 1;
                  this.textRenderingMode = _util2.TextRenderingMode.FILL;
                  this.textRise = 0;
                  this.fillColor = "#000000";
                  this.strokeColor = "#000000";
                  this.patternFill = false;
                  this.fillAlpha = 1;
                  this.strokeAlpha = 1;
                  this.lineWidth = 1;
                  this.activeSMask = null;
                  this.transferMaps = null;
                  this.startNewPathAndClipBox([0, 0, width2, height2]);
                }
                clone() {
                  const clone9 = Object.create(this);
                  clone9.clipBox = this.clipBox.slice();
                  return clone9;
                }
                setCurrentPoint(x, y) {
                  this.x = x;
                  this.y = y;
                }
                updatePathMinMax(transform2, x, y) {
                  [x, y] = _util2.Util.applyTransform([x, y], transform2);
                  this.minX = Math.min(this.minX, x);
                  this.minY = Math.min(this.minY, y);
                  this.maxX = Math.max(this.maxX, x);
                  this.maxY = Math.max(this.maxY, y);
                }
                updateRectMinMax(transform2, rect) {
                  const p1 = _util2.Util.applyTransform(rect, transform2);
                  const p2 = _util2.Util.applyTransform(rect.slice(2), transform2);
                  this.minX = Math.min(this.minX, p1[0], p2[0]);
                  this.minY = Math.min(this.minY, p1[1], p2[1]);
                  this.maxX = Math.max(this.maxX, p1[0], p2[0]);
                  this.maxY = Math.max(this.maxY, p1[1], p2[1]);
                }
                updateScalingPathMinMax(transform2, minMax) {
                  _util2.Util.scaleMinMax(transform2, minMax);
                  this.minX = Math.min(this.minX, minMax[0]);
                  this.maxX = Math.max(this.maxX, minMax[1]);
                  this.minY = Math.min(this.minY, minMax[2]);
                  this.maxY = Math.max(this.maxY, minMax[3]);
                }
                updateCurvePathMinMax(transform2, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
                  const box = _util2.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);
                  if (minMax) {
                    minMax[0] = Math.min(minMax[0], box[0], box[2]);
                    minMax[1] = Math.max(minMax[1], box[0], box[2]);
                    minMax[2] = Math.min(minMax[2], box[1], box[3]);
                    minMax[3] = Math.max(minMax[3], box[1], box[3]);
                    return;
                  }
                  this.updateRectMinMax(transform2, box);
                }
                getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform2 = null) {
                  const box = [this.minX, this.minY, this.maxX, this.maxY];
                  if (pathType === _pattern_helper.PathType.STROKE) {
                    if (!transform2) {
                      (0, _util2.unreachable)("Stroke bounding box must include transform.");
                    }
                    const scale8 = _util2.Util.singularValueDecompose2dScale(transform2);
                    const xStrokePad = scale8[0] * this.lineWidth / 2;
                    const yStrokePad = scale8[1] * this.lineWidth / 2;
                    box[0] -= xStrokePad;
                    box[1] -= yStrokePad;
                    box[2] += xStrokePad;
                    box[3] += yStrokePad;
                  }
                  return box;
                }
                updateClipFromPath() {
                  const intersect = _util2.Util.intersect(this.clipBox, this.getPathBoundingBox());
                  this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
                }
                isEmptyClip() {
                  return this.minX === Infinity;
                }
                startNewPathAndClipBox(box) {
                  this.clipBox = box;
                  this.minX = Infinity;
                  this.minY = Infinity;
                  this.maxX = 0;
                  this.maxY = 0;
                }
                getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform2 = null) {
                  return _util2.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform2));
                }
              }
              function putBinaryImageData(ctx, imgData, transferMaps = null) {
                if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
                  ctx.putImageData(imgData, 0, 0);
                  return;
                }
                const height2 = imgData.height, width2 = imgData.width;
                const partialChunkHeight = height2 % FULL_CHUNK_HEIGHT;
                const fullChunks = (height2 - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width2, FULL_CHUNK_HEIGHT);
                let srcPos = 0, destPos;
                const src2 = imgData.data;
                const dest = chunkImgData.data;
                let i, j, thisChunkHeight, elemsInThisChunk;
                let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;
                if (transferMaps) {
                  switch (transferMaps.length) {
                    case 1:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[0];
                      transferMapBlue = transferMaps[0];
                      transferMapGray = transferMaps[0];
                      break;
                    case 4:
                      transferMapRed = transferMaps[0];
                      transferMapGreen = transferMaps[1];
                      transferMapBlue = transferMaps[2];
                      transferMapGray = transferMaps[3];
                      break;
                  }
                }
                if (imgData.kind === _util2.ImageKind.GRAYSCALE_1BPP) {
                  const srcLength = src2.byteLength;
                  const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
                  const dest32DataLength = dest32.length;
                  const fullSrcDiff = width2 + 7 >> 3;
                  let white2 = 4294967295;
                  let black2 = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                  if (transferMapGray) {
                    if (transferMapGray[0] === 255 && transferMapGray[255] === 0) {
                      [white2, black2] = [black2, white2];
                    }
                  }
                  for (i = 0; i < totalChunks; i++) {
                    thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                    destPos = 0;
                    for (j = 0; j < thisChunkHeight; j++) {
                      const srcDiff = srcLength - srcPos;
                      let k = 0;
                      const kEnd = srcDiff > fullSrcDiff ? width2 : srcDiff * 8 - 7;
                      const kEndUnrolled = kEnd & ~7;
                      let mask = 0;
                      let srcByte = 0;
                      for (; k < kEndUnrolled; k += 8) {
                        srcByte = src2[srcPos++];
                        dest32[destPos++] = srcByte & 128 ? white2 : black2;
                        dest32[destPos++] = srcByte & 64 ? white2 : black2;
                        dest32[destPos++] = srcByte & 32 ? white2 : black2;
                        dest32[destPos++] = srcByte & 16 ? white2 : black2;
                        dest32[destPos++] = srcByte & 8 ? white2 : black2;
                        dest32[destPos++] = srcByte & 4 ? white2 : black2;
                        dest32[destPos++] = srcByte & 2 ? white2 : black2;
                        dest32[destPos++] = srcByte & 1 ? white2 : black2;
                      }
                      for (; k < kEnd; k++) {
                        if (mask === 0) {
                          srcByte = src2[srcPos++];
                          mask = 128;
                        }
                        dest32[destPos++] = srcByte & mask ? white2 : black2;
                        mask >>= 1;
                      }
                    }
                    while (destPos < dest32DataLength) {
                      dest32[destPos++] = 0;
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGBA_32BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  j = 0;
                  elemsInThisChunk = width2 * FULL_CHUNK_HEIGHT * 4;
                  for (i = 0; i < fullChunks; i++) {
                    dest.set(src2.subarray(srcPos, srcPos + elemsInThisChunk));
                    srcPos += elemsInThisChunk;
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                    j += FULL_CHUNK_HEIGHT;
                  }
                  if (i < totalChunks) {
                    elemsInThisChunk = width2 * partialChunkHeight * 4;
                    dest.set(src2.subarray(srcPos, srcPos + elemsInThisChunk));
                    if (hasTransferMaps) {
                      for (let k = 0; k < elemsInThisChunk; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, j);
                  }
                } else if (imgData.kind === _util2.ImageKind.RGB_24BPP) {
                  const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
                  thisChunkHeight = FULL_CHUNK_HEIGHT;
                  elemsInThisChunk = width2 * thisChunkHeight;
                  for (i = 0; i < totalChunks; i++) {
                    if (i >= fullChunks) {
                      thisChunkHeight = partialChunkHeight;
                      elemsInThisChunk = width2 * thisChunkHeight;
                    }
                    destPos = 0;
                    for (j = elemsInThisChunk; j--; ) {
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = src2[srcPos++];
                      dest[destPos++] = 255;
                    }
                    if (hasTransferMaps) {
                      for (let k = 0; k < destPos; k += 4) {
                        if (transferMapRed) {
                          dest[k + 0] = transferMapRed[dest[k + 0]];
                        }
                        if (transferMapGreen) {
                          dest[k + 1] = transferMapGreen[dest[k + 1]];
                        }
                        if (transferMapBlue) {
                          dest[k + 2] = transferMapBlue[dest[k + 2]];
                        }
                      }
                    }
                    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                  }
                } else {
                  throw new Error(`bad image kind: ${imgData.kind}`);
                }
              }
              function putBinaryImageMask(ctx, imgData) {
                if (imgData.bitmap) {
                  ctx.drawImage(imgData.bitmap, 0, 0);
                  return;
                }
                const height2 = imgData.height, width2 = imgData.width;
                const partialChunkHeight = height2 % FULL_CHUNK_HEIGHT;
                const fullChunks = (height2 - partialChunkHeight) / FULL_CHUNK_HEIGHT;
                const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
                const chunkImgData = ctx.createImageData(width2, FULL_CHUNK_HEIGHT);
                let srcPos = 0;
                const src2 = imgData.data;
                const dest = chunkImgData.data;
                for (let i = 0; i < totalChunks; i++) {
                  const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
                  ({
                    srcPos
                  } = (0, _image_utils.applyMaskImageData)({
                    src: src2,
                    srcPos,
                    dest,
                    width: width2,
                    height: thisChunkHeight
                  }));
                  ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
                }
              }
              function copyCtxState(sourceCtx, destCtx) {
                const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];
                for (let i = 0, ii = properties.length; i < ii; i++) {
                  const property = properties[i];
                  if (sourceCtx[property] !== void 0) {
                    destCtx[property] = sourceCtx[property];
                  }
                }
                if (sourceCtx.setLineDash !== void 0) {
                  destCtx.setLineDash(sourceCtx.getLineDash());
                  destCtx.lineDashOffset = sourceCtx.lineDashOffset;
                }
              }
              function resetCtxToDefault(ctx, foregroundColor) {
                ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
                ctx.fillRule = "nonzero";
                ctx.globalAlpha = 1;
                ctx.lineWidth = 1;
                ctx.lineCap = "butt";
                ctx.lineJoin = "miter";
                ctx.miterLimit = 10;
                ctx.globalCompositeOperation = "source-over";
                ctx.font = "10px sans-serif";
                if (ctx.setLineDash !== void 0) {
                  ctx.setLineDash([]);
                  ctx.lineDashOffset = 0;
                }
              }
              function composeSMaskBackdrop(bytes, r0, g0, b0) {
                const length8 = bytes.length;
                for (let i = 3; i < length8; i += 4) {
                  const alpha = bytes[i];
                  if (alpha === 0) {
                    bytes[i - 3] = r0;
                    bytes[i - 2] = g0;
                    bytes[i - 1] = b0;
                  } else if (alpha < 255) {
                    const alpha_ = 255 - alpha;
                    bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
                    bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
                    bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
                  }
                }
              }
              function composeSMaskAlpha(maskData, layerData, transferMap) {
                const length8 = maskData.length;
                const scale8 = 1 / 255;
                for (let i = 3; i < length8; i += 4) {
                  const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
                  layerData[i] = layerData[i] * alpha * scale8 | 0;
                }
              }
              function composeSMaskLuminosity(maskData, layerData, transferMap) {
                const length8 = maskData.length;
                for (let i = 3; i < length8; i += 4) {
                  const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
                  layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
                }
              }
              function genericComposeSMask(maskCtx, layerCtx, width2, height2, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
                const hasBackdrop = !!backdrop;
                const r0 = hasBackdrop ? backdrop[0] : 0;
                const g0 = hasBackdrop ? backdrop[1] : 0;
                const b0 = hasBackdrop ? backdrop[2] : 0;
                let composeFn;
                if (subtype === "Luminosity") {
                  composeFn = composeSMaskLuminosity;
                } else {
                  composeFn = composeSMaskAlpha;
                }
                const PIXELS_TO_PROCESS = 1048576;
                const chunkSize = Math.min(height2, Math.ceil(PIXELS_TO_PROCESS / width2));
                for (let row = 0; row < height2; row += chunkSize) {
                  const chunkHeight = Math.min(chunkSize, height2 - row);
                  const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width2, chunkHeight);
                  const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width2, chunkHeight);
                  if (hasBackdrop) {
                    composeSMaskBackdrop(maskData.data, r0, g0, b0);
                  }
                  composeFn(maskData.data, layerData.data, transferMap);
                  layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
                }
              }
              function composeSMask(ctx, smask, layerCtx, layerBox) {
                const layerOffsetX = layerBox[0];
                const layerOffsetY = layerBox[1];
                const layerWidth = layerBox[2] - layerOffsetX;
                const layerHeight = layerBox[3] - layerOffsetY;
                if (layerWidth === 0 || layerHeight === 0) {
                  return;
                }
                genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
                ctx.save();
                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = "source-over";
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.drawImage(layerCtx.canvas, 0, 0);
                ctx.restore();
              }
              function getImageSmoothingEnabled(transform2, interpolate) {
                const scale8 = _util2.Util.singularValueDecompose2dScale(transform2);
                scale8[0] = Math.fround(scale8[0]);
                scale8[1] = Math.fround(scale8[1]);
                const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils2.PixelsPerInch.PDF_TO_CSS_UNITS);
                if (interpolate !== void 0) {
                  return interpolate;
                } else if (scale8[0] <= actualScale || scale8[1] <= actualScale) {
                  return true;
                }
                return false;
              }
              const LINE_CAP_STYLES = ["butt", "round", "square"];
              const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
              const NORMAL_CLIP = {};
              const EO_CLIP = {};
              const _CanvasGraphics = class {
                constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
                  __privateAdd(this, _restoreInitialState);
                  this.ctx = canvasCtx;
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.stateStack = [];
                  this.pendingClip = null;
                  this.pendingEOFill = false;
                  this.res = null;
                  this.xobjs = null;
                  this.commonObjs = commonObjs;
                  this.objs = objs;
                  this.canvasFactory = canvasFactory;
                  this.imageLayer = imageLayer;
                  this.groupStack = [];
                  this.processingType3 = null;
                  this.baseTransform = null;
                  this.baseTransformStack = [];
                  this.groupLevel = 0;
                  this.smaskStack = [];
                  this.smaskCounter = 0;
                  this.tempSMask = null;
                  this.suspendedCtx = null;
                  this.contentVisible = true;
                  this.markedContentStack = [];
                  this.optionalContentConfig = optionalContentConfig;
                  this.cachedCanvases = new CachedCanvases(this.canvasFactory);
                  this.cachedPatterns = /* @__PURE__ */ new Map();
                  this.annotationCanvasMap = annotationCanvasMap;
                  this.viewportScale = 1;
                  this.outputScaleX = 1;
                  this.outputScaleY = 1;
                  this.backgroundColor = pageColors?.background || null;
                  this.foregroundColor = pageColors?.foreground || null;
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  this._cachedBitmapsMap = /* @__PURE__ */ new Map();
                }
                getObject(data, fallback = null) {
                  if (typeof data === "string") {
                    return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
                  }
                  return fallback;
                }
                beginDrawing({
                  transform: transform2,
                  viewport,
                  transparency = false,
                  background = null
                }) {
                  const width2 = this.ctx.canvas.width;
                  const height2 = this.ctx.canvas.height;
                  const defaultBackgroundColor = background || "#ffffff";
                  this.ctx.save();
                  if (this.foregroundColor && this.backgroundColor) {
                    this.ctx.fillStyle = this.foregroundColor;
                    const fg = this.foregroundColor = this.ctx.fillStyle;
                    this.ctx.fillStyle = this.backgroundColor;
                    const bg = this.backgroundColor = this.ctx.fillStyle;
                    let isValidDefaultBg = true;
                    let defaultBg = defaultBackgroundColor;
                    this.ctx.fillStyle = defaultBackgroundColor;
                    defaultBg = this.ctx.fillStyle;
                    isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);
                    if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
                      this.foregroundColor = this.backgroundColor = null;
                    } else {
                      const [rB, gB, bB] = (0, _display_utils2.getRGB)(defaultBg);
                      const newComp = (x) => {
                        x /= 255;
                        return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
                      };
                      const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));
                      this.selectColor = (r, g, b) => {
                        const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
                        return Math.round(lumC) === lumB ? bg : fg;
                      };
                    }
                  }
                  this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
                  this.ctx.fillRect(0, 0, width2, height2);
                  this.ctx.restore();
                  if (transparency) {
                    const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width2, height2);
                    this.compositeCtx = this.ctx;
                    this.transparentCanvas = transparentCanvas.canvas;
                    this.ctx = transparentCanvas.context;
                    this.ctx.save();
                    this.ctx.transform(...(0, _display_utils2.getCurrentTransform)(this.compositeCtx));
                  }
                  this.ctx.save();
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  if (transform2) {
                    this.ctx.transform(...transform2);
                    this.outputScaleX = transform2[0];
                    this.outputScaleY = transform2[0];
                  }
                  this.ctx.transform(...viewport.transform);
                  this.viewportScale = viewport.scale;
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (this.imageLayer) {
                    (0, _display_utils2.deprecated)("The `imageLayer` functionality will be removed in the future.");
                    this.imageLayer.beginLayout();
                  }
                }
                executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
                  const argsArray = operatorList.argsArray;
                  const fnArray = operatorList.fnArray;
                  let i = executionStartIdx || 0;
                  const argsArrayLen = argsArray.length;
                  if (argsArrayLen === i) {
                    return i;
                  }
                  const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
                  const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
                  let steps = 0;
                  const commonObjs = this.commonObjs;
                  const objs = this.objs;
                  let fnId;
                  while (true) {
                    if (stepper !== void 0 && i === stepper.nextBreakPoint) {
                      stepper.breakIt(i, continueCallback);
                      return i;
                    }
                    fnId = fnArray[i];
                    if (fnId !== _util2.OPS.dependency) {
                      this[fnId].apply(this, argsArray[i]);
                    } else {
                      for (const depObjId of argsArray[i]) {
                        const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                        if (!objsPool.has(depObjId)) {
                          objsPool.get(depObjId, continueCallback);
                          return i;
                        }
                      }
                    }
                    i++;
                    if (i === argsArrayLen) {
                      return i;
                    }
                    if (chunkOperations && ++steps > EXECUTION_STEPS) {
                      if (Date.now() > endTime) {
                        continueCallback();
                        return i;
                      }
                      steps = 0;
                    }
                  }
                }
                endDrawing() {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  this.cachedCanvases.clear();
                  this.cachedPatterns.clear();
                  for (const cache of this._cachedBitmapsMap.values()) {
                    for (const canvas of cache.values()) {
                      if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                        canvas.width = canvas.height = 0;
                      }
                    }
                    cache.clear();
                  }
                  this._cachedBitmapsMap.clear();
                  if (this.imageLayer) {
                    this.imageLayer.endLayout();
                  }
                }
                _scaleImage(img, inverseTransform) {
                  const width2 = img.width;
                  const height2 = img.height;
                  let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
                  let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
                  let paintWidth = width2, paintHeight = height2;
                  let tmpCanvasId = "prescale1";
                  let tmpCanvas, tmpCtx;
                  while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                    let newWidth = paintWidth, newHeight = paintHeight;
                    if (widthScale > 2 && paintWidth > 1) {
                      newWidth = Math.ceil(paintWidth / 2);
                      widthScale /= paintWidth / newWidth;
                    }
                    if (heightScale > 2 && paintHeight > 1) {
                      newHeight = Math.ceil(paintHeight / 2);
                      heightScale /= paintHeight / newHeight;
                    }
                    tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                    tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, newWidth, newHeight);
                    tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                    img = tmpCanvas.canvas;
                    paintWidth = newWidth;
                    paintHeight = newHeight;
                    tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
                  }
                  return {
                    img,
                    paintWidth,
                    paintHeight
                  };
                }
                _createMaskCanvas(img) {
                  const ctx = this.ctx;
                  const {
                    width: width2,
                    height: height2
                  } = img;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  let cache, cacheKey, scaled, maskCanvas;
                  if ((img.bitmap || img.data) && img.count > 1) {
                    const mainKey = img.bitmap || img.data.buffer;
                    const withoutTranslation = currentTransform.slice(0, 4);
                    cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
                    cache = this._cachedBitmapsMap.get(mainKey);
                    if (!cache) {
                      cache = /* @__PURE__ */ new Map();
                      this._cachedBitmapsMap.set(mainKey, cache);
                    }
                    const cachedImage = cache.get(cacheKey);
                    if (cachedImage && !isPatternFill) {
                      const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                      const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                      return {
                        canvas: cachedImage,
                        offsetX: offsetX2,
                        offsetY: offsetY2
                      };
                    }
                    scaled = cachedImage;
                  }
                  if (!scaled) {
                    maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width2, height2);
                    putBinaryImageMask(maskCanvas.context, img);
                  }
                  let maskToCanvas = _util2.Util.transform(currentTransform, [1 / width2, 0, 0, -1 / height2, 0, 0]);
                  maskToCanvas = _util2.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height2]);
                  const cord1 = _util2.Util.applyTransform([0, 0], maskToCanvas);
                  const cord2 = _util2.Util.applyTransform([width2, height2], maskToCanvas);
                  const rect = _util2.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);
                  const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
                  const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
                  const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
                  const fillCtx = fillCanvas.context;
                  const offsetX = Math.min(cord1[0], cord2[0]);
                  const offsetY = Math.min(cord1[1], cord2[1]);
                  fillCtx.translate(-offsetX, -offsetY);
                  fillCtx.transform(...maskToCanvas);
                  if (!scaled) {
                    scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils2.getCurrentTransformInverse)(fillCtx));
                    scaled = scaled.img;
                    if (cache && isPatternFill) {
                      cache.set(cacheKey, scaled);
                    }
                  }
                  fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(fillCtx), img.interpolate);
                  drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width2, height2);
                  fillCtx.globalCompositeOperation = "source-in";
                  const inverse4 = _util2.Util.transform((0, _display_utils2.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
                  fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse4, _pattern_helper.PathType.FILL) : fillColor;
                  fillCtx.fillRect(0, 0, width2, height2);
                  if (cache && !isPatternFill) {
                    this.cachedCanvases.delete("fillCanvas");
                    cache.set(cacheKey, fillCanvas.canvas);
                  }
                  return {
                    canvas: fillCanvas.canvas,
                    offsetX: Math.round(offsetX),
                    offsetY: Math.round(offsetY)
                  };
                }
                setLineWidth(width2) {
                  if (width2 !== this.current.lineWidth) {
                    this._cachedScaleForStroking = null;
                  }
                  this.current.lineWidth = width2;
                  this.ctx.lineWidth = width2;
                }
                setLineCap(style) {
                  this.ctx.lineCap = LINE_CAP_STYLES[style];
                }
                setLineJoin(style) {
                  this.ctx.lineJoin = LINE_JOIN_STYLES[style];
                }
                setMiterLimit(limit) {
                  this.ctx.miterLimit = limit;
                }
                setDash(dashArray, dashPhase) {
                  const ctx = this.ctx;
                  if (ctx.setLineDash !== void 0) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashPhase;
                  }
                }
                setRenderingIntent(intent) {
                }
                setFlatness(flatness) {
                }
                setGState(states) {
                  for (let i = 0, ii = states.length; i < ii; i++) {
                    const state = states[i];
                    const key = state[0];
                    const value2 = state[1];
                    switch (key) {
                      case "LW":
                        this.setLineWidth(value2);
                        break;
                      case "LC":
                        this.setLineCap(value2);
                        break;
                      case "LJ":
                        this.setLineJoin(value2);
                        break;
                      case "ML":
                        this.setMiterLimit(value2);
                        break;
                      case "D":
                        this.setDash(value2[0], value2[1]);
                        break;
                      case "RI":
                        this.setRenderingIntent(value2);
                        break;
                      case "FL":
                        this.setFlatness(value2);
                        break;
                      case "Font":
                        this.setFont(value2[0], value2[1]);
                        break;
                      case "CA":
                        this.current.strokeAlpha = state[1];
                        break;
                      case "ca":
                        this.current.fillAlpha = state[1];
                        this.ctx.globalAlpha = state[1];
                        break;
                      case "BM":
                        this.ctx.globalCompositeOperation = value2;
                        break;
                      case "SMask":
                        this.current.activeSMask = value2 ? this.tempSMask : null;
                        this.tempSMask = null;
                        this.checkSMaskState();
                        break;
                      case "TR":
                        this.current.transferMaps = value2;
                    }
                  }
                }
                get inSMaskMode() {
                  return !!this.suspendedCtx;
                }
                checkSMaskState() {
                  const inSMaskMode = this.inSMaskMode;
                  if (this.current.activeSMask && !inSMaskMode) {
                    this.beginSMaskMode();
                  } else if (!this.current.activeSMask && inSMaskMode) {
                    this.endSMaskMode();
                  }
                }
                beginSMaskMode() {
                  if (this.inSMaskMode) {
                    throw new Error("beginSMaskMode called while already in smask mode");
                  }
                  const drawnWidth = this.ctx.canvas.width;
                  const drawnHeight = this.ctx.canvas.height;
                  const cacheId = "smaskGroupAt" + this.groupLevel;
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  this.suspendedCtx = this.ctx;
                  this.ctx = scratchCanvas.context;
                  const ctx = this.ctx;
                  ctx.setTransform(...(0, _display_utils2.getCurrentTransform)(this.suspendedCtx));
                  copyCtxState(this.suspendedCtx, ctx);
                  mirrorContextOperations(ctx, this.suspendedCtx);
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                }
                endSMaskMode() {
                  if (!this.inSMaskMode) {
                    throw new Error("endSMaskMode called while not in smask mode");
                  }
                  this.ctx._removeMirroring();
                  copyCtxState(this.ctx, this.suspendedCtx);
                  this.ctx = this.suspendedCtx;
                  this.suspendedCtx = null;
                }
                compose(dirtyBox) {
                  if (!this.current.activeSMask) {
                    return;
                  }
                  if (!dirtyBox) {
                    dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
                  } else {
                    dirtyBox[0] = Math.floor(dirtyBox[0]);
                    dirtyBox[1] = Math.floor(dirtyBox[1]);
                    dirtyBox[2] = Math.ceil(dirtyBox[2]);
                    dirtyBox[3] = Math.ceil(dirtyBox[3]);
                  }
                  const smask = this.current.activeSMask;
                  const suspendedCtx = this.suspendedCtx;
                  composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                  this.ctx.restore();
                }
                save() {
                  if (this.inSMaskMode) {
                    copyCtxState(this.ctx, this.suspendedCtx);
                    this.suspendedCtx.save();
                  } else {
                    this.ctx.save();
                  }
                  const old = this.current;
                  this.stateStack.push(old);
                  this.current = old.clone();
                }
                restore() {
                  if (this.stateStack.length === 0 && this.inSMaskMode) {
                    this.endSMaskMode();
                  }
                  if (this.stateStack.length !== 0) {
                    this.current = this.stateStack.pop();
                    if (this.inSMaskMode) {
                      this.suspendedCtx.restore();
                      copyCtxState(this.suspendedCtx, this.ctx);
                    } else {
                      this.ctx.restore();
                    }
                    this.checkSMaskState();
                    this.pendingClip = null;
                    this._cachedScaleForStroking = null;
                    this._cachedGetSinglePixelWidth = null;
                  }
                }
                transform(a, b, c, d, e2, f2) {
                  this.ctx.transform(a, b, c, d, e2, f2);
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                }
                constructPath(ops, args, minMax) {
                  const ctx = this.ctx;
                  const current = this.current;
                  let x = current.x, y = current.y;
                  let startX, startY;
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
                  const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;
                  for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
                    switch (ops[i] | 0) {
                      case _util2.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        const width2 = args[j++];
                        const height2 = args[j++];
                        const xw = x + width2;
                        const yh = y + height2;
                        ctx.moveTo(x, y);
                        if (width2 === 0 || height2 === 0) {
                          ctx.lineTo(xw, yh);
                        } else {
                          ctx.lineTo(xw, y);
                          ctx.lineTo(xw, yh);
                          ctx.lineTo(x, yh);
                        }
                        if (!isScalingMatrix) {
                          current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
                        }
                        ctx.closePath();
                        break;
                      case _util2.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.moveTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        ctx.lineTo(x, y);
                        if (!isScalingMatrix) {
                          current.updatePathMinMax(currentTransform, x, y);
                        }
                        break;
                      case _util2.OPS.curveTo:
                        startX = x;
                        startY = y;
                        x = args[j + 4];
                        y = args[j + 5];
                        ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
                        j += 6;
                        break;
                      case _util2.OPS.curveTo2:
                        startX = x;
                        startY = y;
                        ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;
                      case _util2.OPS.curveTo3:
                        startX = x;
                        startY = y;
                        x = args[j + 2];
                        y = args[j + 3];
                        ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                        current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
                        j += 4;
                        break;
                      case _util2.OPS.closePath:
                        ctx.closePath();
                        break;
                    }
                  }
                  if (isScalingMatrix) {
                    current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
                  }
                  current.setCurrentPoint(x, y);
                }
                closePath() {
                  this.ctx.closePath();
                }
                stroke(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const strokeColor = this.current.strokeColor;
                  ctx.globalAlpha = this.current.strokeAlpha;
                  if (this.contentVisible) {
                    if (typeof strokeColor === "object" && strokeColor?.getPattern) {
                      ctx.save();
                      ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
                      this.rescaleAndStroke(false);
                      ctx.restore();
                    } else {
                      this.rescaleAndStroke(true);
                    }
                  }
                  if (consumePath) {
                    this.consumePath(this.current.getClippedPathBoundingBox());
                  }
                  ctx.globalAlpha = this.current.fillAlpha;
                }
                closeStroke() {
                  this.closePath();
                  this.stroke();
                }
                fill(consumePath) {
                  consumePath = typeof consumePath !== "undefined" ? consumePath : true;
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  let needRestore = false;
                  if (isPatternFill) {
                    ctx.save();
                    ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    needRestore = true;
                  }
                  const intersect = this.current.getClippedPathBoundingBox();
                  if (this.contentVisible && intersect !== null) {
                    if (this.pendingEOFill) {
                      ctx.fill("evenodd");
                      this.pendingEOFill = false;
                    } else {
                      ctx.fill();
                    }
                  }
                  if (needRestore) {
                    ctx.restore();
                  }
                  if (consumePath) {
                    this.consumePath(intersect);
                  }
                }
                eoFill() {
                  this.pendingEOFill = true;
                  this.fill();
                }
                fillStroke() {
                  this.fill(false);
                  this.stroke(false);
                  this.consumePath();
                }
                eoFillStroke() {
                  this.pendingEOFill = true;
                  this.fillStroke();
                }
                closeFillStroke() {
                  this.closePath();
                  this.fillStroke();
                }
                closeEOFillStroke() {
                  this.pendingEOFill = true;
                  this.closePath();
                  this.fillStroke();
                }
                endPath() {
                  this.consumePath();
                }
                clip() {
                  this.pendingClip = NORMAL_CLIP;
                }
                eoClip() {
                  this.pendingClip = EO_CLIP;
                }
                beginText() {
                  this.current.textMatrix = _util2.IDENTITY_MATRIX;
                  this.current.textMatrixScale = 1;
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                endText() {
                  const paths = this.pendingTextPaths;
                  const ctx = this.ctx;
                  if (paths === void 0) {
                    ctx.beginPath();
                    return;
                  }
                  ctx.save();
                  ctx.beginPath();
                  for (const path of paths) {
                    ctx.setTransform(...path.transform);
                    ctx.translate(path.x, path.y);
                    path.addToPath(ctx, path.fontSize);
                  }
                  ctx.restore();
                  ctx.clip();
                  ctx.beginPath();
                  delete this.pendingTextPaths;
                }
                setCharSpacing(spacing) {
                  this.current.charSpacing = spacing;
                }
                setWordSpacing(spacing) {
                  this.current.wordSpacing = spacing;
                }
                setHScale(scale8) {
                  this.current.textHScale = scale8 / 100;
                }
                setLeading(leading) {
                  this.current.leading = -leading;
                }
                setFont(fontRefName, size4) {
                  const fontObj = this.commonObjs.get(fontRefName);
                  const current = this.current;
                  if (!fontObj) {
                    throw new Error(`Can't find font for ${fontRefName}`);
                  }
                  current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                    (0, _util2.warn)("Invalid font matrix for font " + fontRefName);
                  }
                  if (size4 < 0) {
                    size4 = -size4;
                    current.fontDirection = -1;
                  } else {
                    current.fontDirection = 1;
                  }
                  this.current.font = fontObj;
                  this.current.fontSize = size4;
                  if (fontObj.isType3Font) {
                    return;
                  }
                  const name3 = fontObj.loadedName || "sans-serif";
                  let bold = "normal";
                  if (fontObj.black) {
                    bold = "900";
                  } else if (fontObj.bold) {
                    bold = "bold";
                  }
                  const italic = fontObj.italic ? "italic" : "normal";
                  const typeface = `"${name3}", ${fontObj.fallbackName}`;
                  let browserFontSize = size4;
                  if (size4 < MIN_FONT_SIZE) {
                    browserFontSize = MIN_FONT_SIZE;
                  } else if (size4 > MAX_FONT_SIZE) {
                    browserFontSize = MAX_FONT_SIZE;
                  }
                  this.current.fontSizeScale = size4 / browserFontSize;
                  this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
                }
                setTextRenderingMode(mode) {
                  this.current.textRenderingMode = mode;
                }
                setTextRise(rise) {
                  this.current.textRise = rise;
                }
                moveText(x, y) {
                  this.current.x = this.current.lineX += x;
                  this.current.y = this.current.lineY += y;
                }
                setLeadingMoveText(x, y) {
                  this.setLeading(-y);
                  this.moveText(x, y);
                }
                setTextMatrix(a, b, c, d, e2, f2) {
                  this.current.textMatrix = [a, b, c, d, e2, f2];
                  this.current.textMatrixScale = Math.hypot(a, b);
                  this.current.x = this.current.lineX = 0;
                  this.current.y = this.current.lineY = 0;
                }
                nextLine() {
                  this.moveText(0, this.current.leading);
                }
                paintChar(character, x, y, patternTransform) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font2 = current.font;
                  const textRenderingMode = current.textRenderingMode;
                  const fontSize2 = current.fontSize / current.fontSizeScale;
                  const fillStrokeMode = textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                  const isAddToPathSet = !!(textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG);
                  const patternFill = current.patternFill && !font2.missingFile;
                  let addToPath;
                  if (font2.disableFontFace || isAddToPathSet || patternFill) {
                    addToPath = font2.getPathGenerator(this.commonObjs, character);
                  }
                  if (font2.disableFontFace || patternFill) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.beginPath();
                    addToPath(ctx, fontSize2);
                    if (patternTransform) {
                      ctx.setTransform(...patternTransform);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fill();
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.stroke();
                    }
                    ctx.restore();
                  } else {
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.fillText(character, x, y);
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      ctx.strokeText(character, x, y);
                    }
                  }
                  if (isAddToPathSet) {
                    const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                    paths.push({
                      transform: (0, _display_utils2.getCurrentTransform)(ctx),
                      x,
                      y,
                      fontSize: fontSize2,
                      addToPath
                    });
                  }
                }
                get isFontSubpixelAAEnabled() {
                  const {
                    context: ctx
                  } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
                  ctx.scale(1.5, 1);
                  ctx.fillText("I", 0, 10);
                  const data = ctx.getImageData(0, 0, 10, 10).data;
                  let enabled = false;
                  for (let i = 3; i < data.length; i += 4) {
                    if (data[i] > 0 && data[i] < 255) {
                      enabled = true;
                      break;
                    }
                  }
                  return (0, _util2.shadow)(this, "isFontSubpixelAAEnabled", enabled);
                }
                showText(glyphs) {
                  const current = this.current;
                  const font2 = current.font;
                  if (font2.isType3Font) {
                    return this.showType3Text(glyphs);
                  }
                  const fontSize2 = current.fontSize;
                  if (fontSize2 === 0) {
                    return void 0;
                  }
                  const ctx = this.ctx;
                  const fontSizeScale = current.fontSizeScale;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const fontDirection = current.fontDirection;
                  const textHScale = current.textHScale * fontDirection;
                  const glyphsLength = glyphs.length;
                  const vertical = font2.vertical;
                  const spacingDir = vertical ? 1 : -1;
                  const defaultVMetrics = font2.defaultVMetrics;
                  const widthAdvanceScale = fontSize2 * current.fontMatrix[0];
                  const simpleFillText = current.textRenderingMode === _util2.TextRenderingMode.FILL && !font2.disableFontFace && !current.patternFill;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y + current.textRise);
                  if (fontDirection > 0) {
                    ctx.scale(textHScale, -1);
                  } else {
                    ctx.scale(textHScale, 1);
                  }
                  let patternTransform;
                  if (current.patternFill) {
                    ctx.save();
                    const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
                    patternTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                    ctx.restore();
                    ctx.fillStyle = pattern;
                  }
                  let lineWidth = current.lineWidth;
                  const scale8 = current.textMatrixScale;
                  if (scale8 === 0 || lineWidth === 0) {
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      lineWidth = this.getSinglePixelWidth();
                    }
                  } else {
                    lineWidth /= scale8;
                  }
                  if (fontSizeScale !== 1) {
                    ctx.scale(fontSizeScale, fontSizeScale);
                    lineWidth /= fontSizeScale;
                  }
                  ctx.lineWidth = lineWidth;
                  let x = 0, i;
                  for (i = 0; i < glyphsLength; ++i) {
                    const glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      x += spacingDir * glyph * fontSize2 / 1e3;
                      continue;
                    }
                    let restoreNeeded = false;
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const character = glyph.fontChar;
                    const accent = glyph.accent;
                    let scaledX, scaledY;
                    let width2 = glyph.width;
                    if (vertical) {
                      const vmetric = glyph.vmetric || defaultVMetrics;
                      const vx = -(glyph.vmetric ? vmetric[1] : width2 * 0.5) * widthAdvanceScale;
                      const vy = vmetric[2] * widthAdvanceScale;
                      width2 = vmetric ? -vmetric[0] : width2;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }
                    if (font2.remeasure && width2 > 0) {
                      const measuredWidth = ctx.measureText(character).width * 1e3 / fontSize2 * fontSizeScale;
                      if (width2 < measuredWidth && this.isFontSubpixelAAEnabled) {
                        const characterScaleX = width2 / measuredWidth;
                        restoreNeeded = true;
                        ctx.save();
                        ctx.scale(characterScaleX, 1);
                        scaledX /= characterScaleX;
                      } else if (width2 !== measuredWidth) {
                        scaledX += (width2 - measuredWidth) / 2e3 * fontSize2 / fontSizeScale;
                      }
                    }
                    if (this.contentVisible && (glyph.isInFont || font2.missingFile)) {
                      if (simpleFillText && !accent) {
                        ctx.fillText(character, scaledX, scaledY);
                      } else {
                        this.paintChar(character, scaledX, scaledY, patternTransform);
                        if (accent) {
                          const scaledAccentX = scaledX + fontSize2 * accent.offset.x / fontSizeScale;
                          const scaledAccentY = scaledY - fontSize2 * accent.offset.y / fontSizeScale;
                          this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
                        }
                      }
                    }
                    let charWidth;
                    if (vertical) {
                      charWidth = width2 * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width2 * widthAdvanceScale + spacing * fontDirection;
                    }
                    x += charWidth;
                    if (restoreNeeded) {
                      ctx.restore();
                    }
                  }
                  if (vertical) {
                    current.y -= x;
                  } else {
                    current.x += x * textHScale;
                  }
                  ctx.restore();
                  this.compose();
                  return void 0;
                }
                showType3Text(glyphs) {
                  const ctx = this.ctx;
                  const current = this.current;
                  const font2 = current.font;
                  const fontSize2 = current.fontSize;
                  const fontDirection = current.fontDirection;
                  const spacingDir = font2.vertical ? 1 : -1;
                  const charSpacing = current.charSpacing;
                  const wordSpacing = current.wordSpacing;
                  const textHScale = current.textHScale * fontDirection;
                  const fontMatrix = current.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                  const glyphsLength = glyphs.length;
                  const isTextInvisible = current.textRenderingMode === _util2.TextRenderingMode.INVISIBLE;
                  let i, glyph, width2, spacingLength;
                  if (isTextInvisible || fontSize2 === 0) {
                    return;
                  }
                  this._cachedScaleForStroking = null;
                  this._cachedGetSinglePixelWidth = null;
                  ctx.save();
                  ctx.transform(...current.textMatrix);
                  ctx.translate(current.x, current.y);
                  ctx.scale(textHScale, fontDirection);
                  for (i = 0; i < glyphsLength; ++i) {
                    glyph = glyphs[i];
                    if (typeof glyph === "number") {
                      spacingLength = spacingDir * glyph * fontSize2 / 1e3;
                      this.ctx.translate(spacingLength, 0);
                      current.x += spacingLength * textHScale;
                      continue;
                    }
                    const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    const operatorList = font2.charProcOperatorList[glyph.operatorListId];
                    if (!operatorList) {
                      (0, _util2.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
                      continue;
                    }
                    if (this.contentVisible) {
                      this.processingType3 = glyph;
                      this.save();
                      ctx.scale(fontSize2, fontSize2);
                      ctx.transform(...fontMatrix);
                      this.executeOperatorList(operatorList);
                      this.restore();
                    }
                    const transformed = _util2.Util.applyTransform([glyph.width, 0], fontMatrix);
                    width2 = transformed[0] * fontSize2 + spacing;
                    ctx.translate(width2, 0);
                    current.x += width2 * textHScale;
                  }
                  ctx.restore();
                  this.processingType3 = null;
                }
                setCharWidth(xWidth, yWidth) {
                }
                setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
                  this.ctx.rect(llx, lly, urx - llx, ury - lly);
                  this.ctx.clip();
                  this.endPath();
                }
                getColorN_Pattern(IR) {
                  let pattern;
                  if (IR[0] === "TilingPattern") {
                    const color2 = IR[1];
                    const baseTransform = this.baseTransform || (0, _display_utils2.getCurrentTransform)(this.ctx);
                    const canvasGraphicsFactory = {
                      createCanvasGraphics: (ctx) => {
                        return new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
                      }
                    };
                    pattern = new _pattern_helper.TilingPattern(IR, color2, this.ctx, canvasGraphicsFactory, baseTransform);
                  } else {
                    pattern = this._getPattern(IR[1], IR[2]);
                  }
                  return pattern;
                }
                setStrokeColorN() {
                  this.current.strokeColor = this.getColorN_Pattern(arguments);
                }
                setFillColorN() {
                  this.current.fillColor = this.getColorN_Pattern(arguments);
                  this.current.patternFill = true;
                }
                setStrokeRGBColor(r, g, b) {
                  const color2 = this.selectColor?.(r, g, b) || _util2.Util.makeHexColor(r, g, b);
                  this.ctx.strokeStyle = color2;
                  this.current.strokeColor = color2;
                }
                setFillRGBColor(r, g, b) {
                  const color2 = this.selectColor?.(r, g, b) || _util2.Util.makeHexColor(r, g, b);
                  this.ctx.fillStyle = color2;
                  this.current.fillColor = color2;
                  this.current.patternFill = false;
                }
                _getPattern(objId, matrix = null) {
                  let pattern;
                  if (this.cachedPatterns.has(objId)) {
                    pattern = this.cachedPatterns.get(objId);
                  } else {
                    pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
                    this.cachedPatterns.set(objId, pattern);
                  }
                  if (matrix) {
                    pattern.matrix = matrix;
                  }
                  return pattern;
                }
                shadingFill(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  this.save();
                  const pattern = this._getPattern(objId);
                  ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
                  const inv = (0, _display_utils2.getCurrentTransformInverse)(ctx);
                  if (inv) {
                    const canvas = ctx.canvas;
                    const width2 = canvas.width;
                    const height2 = canvas.height;
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height2], inv);
                    const ul = _util2.Util.applyTransform([width2, 0], inv);
                    const ur = _util2.Util.applyTransform([width2, height2], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
                  } else {
                    this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
                  }
                  this.compose(this.current.getClippedPathBoundingBox());
                  this.restore();
                }
                beginInlineImage() {
                  (0, _util2.unreachable)("Should not call beginInlineImage");
                }
                beginImageData() {
                  (0, _util2.unreachable)("Should not call beginImageData");
                }
                paintFormXObjectBegin(matrix, bbox) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  this.baseTransformStack.push(this.baseTransform);
                  if (Array.isArray(matrix) && matrix.length === 6) {
                    this.transform(...matrix);
                  }
                  this.baseTransform = (0, _display_utils2.getCurrentTransform)(this.ctx);
                  if (bbox) {
                    const width2 = bbox[2] - bbox[0];
                    const height2 = bbox[3] - bbox[1];
                    this.ctx.rect(bbox[0], bbox[1], width2, height2);
                    this.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(this.ctx), bbox);
                    this.clip();
                    this.endPath();
                  }
                }
                paintFormXObjectEnd() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.restore();
                  this.baseTransform = this.baseTransformStack.pop();
                }
                beginGroup(group2) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.save();
                  if (this.inSMaskMode) {
                    this.endSMaskMode();
                    this.current.activeSMask = null;
                  }
                  const currentCtx = this.ctx;
                  if (!group2.isolated) {
                    (0, _util2.info)("TODO: Support non-isolated groups.");
                  }
                  if (group2.knockout) {
                    (0, _util2.warn)("Knockout groups not supported.");
                  }
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(currentCtx);
                  if (group2.matrix) {
                    currentCtx.transform(...group2.matrix);
                  }
                  if (!group2.bbox) {
                    throw new Error("Bounding box is required.");
                  }
                  let bounds = _util2.Util.getAxialAlignedBoundingBox(group2.bbox, (0, _display_utils2.getCurrentTransform)(currentCtx));
                  const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
                  bounds = _util2.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
                  const offsetX = Math.floor(bounds[0]);
                  const offsetY = Math.floor(bounds[1]);
                  let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
                  let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
                  let scaleX = 1, scaleY = 1;
                  if (drawnWidth > MAX_GROUP_SIZE) {
                    scaleX = drawnWidth / MAX_GROUP_SIZE;
                    drawnWidth = MAX_GROUP_SIZE;
                  }
                  if (drawnHeight > MAX_GROUP_SIZE) {
                    scaleY = drawnHeight / MAX_GROUP_SIZE;
                    drawnHeight = MAX_GROUP_SIZE;
                  }
                  this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
                  let cacheId = "groupAt" + this.groupLevel;
                  if (group2.smask) {
                    cacheId += "_smask_" + this.smaskCounter++ % 2;
                  }
                  const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
                  const groupCtx = scratchCanvas.context;
                  groupCtx.scale(1 / scaleX, 1 / scaleY);
                  groupCtx.translate(-offsetX, -offsetY);
                  groupCtx.transform(...currentTransform);
                  if (group2.smask) {
                    this.smaskStack.push({
                      canvas: scratchCanvas.canvas,
                      context: groupCtx,
                      offsetX,
                      offsetY,
                      scaleX,
                      scaleY,
                      subtype: group2.smask.subtype,
                      backdrop: group2.smask.backdrop,
                      transferMap: group2.smask.transferMap || null,
                      startTransformInverse: null
                    });
                  } else {
                    currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                    currentCtx.translate(offsetX, offsetY);
                    currentCtx.scale(scaleX, scaleY);
                    currentCtx.save();
                  }
                  copyCtxState(currentCtx, groupCtx);
                  this.ctx = groupCtx;
                  this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
                  this.groupStack.push(currentCtx);
                  this.groupLevel++;
                }
                endGroup(group2) {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.groupLevel--;
                  const groupCtx = this.ctx;
                  const ctx = this.groupStack.pop();
                  this.ctx = ctx;
                  this.ctx.imageSmoothingEnabled = false;
                  if (group2.smask) {
                    this.tempSMask = this.smaskStack.pop();
                    this.restore();
                  } else {
                    this.ctx.restore();
                    const currentMtx = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    this.restore();
                    this.ctx.save();
                    this.ctx.setTransform(...currentMtx);
                    const dirtyBox = _util2.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);
                    this.ctx.drawImage(groupCtx.canvas, 0, 0);
                    this.ctx.restore();
                    this.compose(dirtyBox);
                  }
                }
                beginAnnotation(id2, rect, transform2, matrix, hasOwnCanvas) {
                  __privateMethod(this, _restoreInitialState, restoreInitialState_fn).call(this);
                  resetCtxToDefault(this.ctx, this.foregroundColor);
                  this.ctx.save();
                  this.save();
                  if (this.baseTransform) {
                    this.ctx.setTransform(...this.baseTransform);
                  }
                  if (Array.isArray(rect) && rect.length === 4) {
                    const width2 = rect[2] - rect[0];
                    const height2 = rect[3] - rect[1];
                    if (hasOwnCanvas && this.annotationCanvasMap) {
                      transform2 = transform2.slice();
                      transform2[4] -= rect[0];
                      transform2[5] -= rect[1];
                      rect = rect.slice();
                      rect[0] = rect[1] = 0;
                      rect[2] = width2;
                      rect[3] = height2;
                      const [scaleX, scaleY] = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(this.ctx));
                      const {
                        viewportScale
                      } = this;
                      const canvasWidth = Math.ceil(width2 * this.outputScaleX * viewportScale);
                      const canvasHeight = Math.ceil(height2 * this.outputScaleY * viewportScale);
                      this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                      const {
                        canvas,
                        context
                      } = this.annotationCanvas;
                      this.annotationCanvasMap.set(id2, canvas);
                      this.annotationCanvas.savedCtx = this.ctx;
                      this.ctx = context;
                      this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height2 * scaleY);
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                    } else {
                      resetCtxToDefault(this.ctx, this.foregroundColor);
                      this.ctx.rect(rect[0], rect[1], width2, height2);
                      this.ctx.clip();
                      this.endPath();
                    }
                  }
                  this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
                  this.transform(...transform2);
                  this.transform(...matrix);
                }
                endAnnotation() {
                  if (this.annotationCanvas) {
                    this.ctx = this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas.savedCtx;
                    delete this.annotationCanvas;
                  }
                }
                paintImageMaskXObject(img) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const count = img.count;
                  img = this.getObject(img.data, img);
                  img.count = count;
                  const ctx = this.ctx;
                  const glyph = this.processingType3;
                  if (glyph) {
                    if (glyph.compiled === void 0) {
                      glyph.compiled = compileType3Glyph(img);
                    }
                    if (glyph.compiled) {
                      glyph.compiled(ctx);
                      return;
                    }
                  }
                  const mask = this._createMaskCanvas(img);
                  const maskCanvas = mask.canvas;
                  ctx.save();
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  img = this.getObject(img.data, img);
                  const ctx = this.ctx;
                  ctx.save();
                  const currentTransform = (0, _display_utils2.getCurrentTransform)(ctx);
                  ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
                  const mask = this._createMaskCanvas(img);
                  ctx.setTransform(1, 0, 0, 1, 0, 0);
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    const trans2 = _util2.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
                    const [x, y] = _util2.Util.applyTransform([0, 0], trans2);
                    ctx.drawImage(mask.canvas, x, y);
                  }
                  ctx.restore();
                  this.compose();
                }
                paintImageMaskXObjectGroup(images) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const fillColor = this.current.fillColor;
                  const isPatternFill = this.current.patternFill;
                  for (const image2 of images) {
                    const {
                      data,
                      width: width2,
                      height: height2,
                      transform: transform2
                    } = image2;
                    const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width2, height2);
                    const maskCtx = maskCanvas.context;
                    maskCtx.save();
                    const img = this.getObject(data, image2);
                    putBinaryImageMask(maskCtx, img);
                    maskCtx.globalCompositeOperation = "source-in";
                    maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils2.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
                    maskCtx.fillRect(0, 0, width2, height2);
                    maskCtx.restore();
                    ctx.save();
                    ctx.transform(...transform2);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width2, height2, 0, -1, 1, 1);
                    ctx.restore();
                  }
                  this.compose();
                }
                paintImageXObject(objId) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  this.paintInlineImageXObject(imgData);
                }
                paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const imgData = this.getObject(objId);
                  if (!imgData) {
                    (0, _util2.warn)("Dependent image isn't ready yet");
                    return;
                  }
                  const width2 = imgData.width;
                  const height2 = imgData.height;
                  const map = [];
                  for (let i = 0, ii = positions.length; i < ii; i += 2) {
                    map.push({
                      transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                      x: 0,
                      y: 0,
                      w: width2,
                      h: height2
                    });
                  }
                  this.paintInlineImageXObjectGroup(imgData, map);
                }
                paintInlineImageXObject(imgData) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const width2 = imgData.width;
                  const height2 = imgData.height;
                  const ctx = this.ctx;
                  this.save();
                  ctx.scale(1 / width2, -1 / height2);
                  let imgToPaint;
                  if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                    imgToPaint = imgData;
                  } else {
                    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width2, height2);
                    const tmpCtx = tmpCanvas.context;
                    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                    imgToPaint = tmpCanvas.canvas;
                  }
                  const scaled = this._scaleImage(imgToPaint, (0, _display_utils2.getCurrentTransformInverse)(ctx));
                  ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils2.getCurrentTransform)(ctx), imgData.interpolate);
                  const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height2, width2, height2);
                  if (this.imageLayer) {
                    const [left2, top2] = _util2.Util.applyTransform([0, -height2], (0, _display_utils2.getCurrentTransform)(this.ctx));
                    this.imageLayer.appendImage({
                      imgData,
                      left: left2,
                      top: top2,
                      width: rWidth,
                      height: rHeight
                    });
                  }
                  this.compose();
                  this.restore();
                }
                paintInlineImageXObjectGroup(imgData, map) {
                  if (!this.contentVisible) {
                    return;
                  }
                  const ctx = this.ctx;
                  const w = imgData.width;
                  const h = imgData.height;
                  const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
                  const tmpCtx = tmpCanvas.context;
                  putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                  for (const entry of map) {
                    ctx.save();
                    ctx.transform(...entry.transform);
                    ctx.scale(1, -1);
                    drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
                    if (this.imageLayer) {
                      const [left2, top2] = _util2.Util.applyTransform([entry.x, entry.y], (0, _display_utils2.getCurrentTransform)(this.ctx));
                      this.imageLayer.appendImage({
                        imgData,
                        left: left2,
                        top: top2,
                        width: w,
                        height: h
                      });
                    }
                    ctx.restore();
                  }
                  this.compose();
                }
                paintSolidColorImageMask() {
                  if (!this.contentVisible) {
                    return;
                  }
                  this.ctx.fillRect(0, 0, 1, 1);
                  this.compose();
                }
                markPoint(tag2) {
                }
                markPointProps(tag2, properties) {
                }
                beginMarkedContent(tag2) {
                  this.markedContentStack.push({
                    visible: true
                  });
                }
                beginMarkedContentProps(tag2, properties) {
                  if (tag2 === "OC") {
                    this.markedContentStack.push({
                      visible: this.optionalContentConfig.isVisible(properties)
                    });
                  } else {
                    this.markedContentStack.push({
                      visible: true
                    });
                  }
                  this.contentVisible = this.isContentVisible();
                }
                endMarkedContent() {
                  this.markedContentStack.pop();
                  this.contentVisible = this.isContentVisible();
                }
                beginCompat() {
                }
                endCompat() {
                }
                consumePath(clipBox) {
                  const isEmpty = this.current.isEmptyClip();
                  if (this.pendingClip) {
                    this.current.updateClipFromPath();
                  }
                  if (!this.pendingClip) {
                    this.compose(clipBox);
                  }
                  const ctx = this.ctx;
                  if (this.pendingClip) {
                    if (!isEmpty) {
                      if (this.pendingClip === EO_CLIP) {
                        ctx.clip("evenodd");
                      } else {
                        ctx.clip();
                      }
                    }
                    this.pendingClip = null;
                  }
                  this.current.startNewPathAndClipBox(this.current.clipBox);
                  ctx.beginPath();
                }
                getSinglePixelWidth() {
                  if (!this._cachedGetSinglePixelWidth) {
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    if (m[1] === 0 && m[2] === 0) {
                      this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[2]);
                      const normY = Math.hypot(m[1], m[3]);
                      this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
                    }
                  }
                  return this._cachedGetSinglePixelWidth;
                }
                getScaleForStroking() {
                  if (!this._cachedScaleForStroking) {
                    const {
                      lineWidth
                    } = this.current;
                    const m = (0, _display_utils2.getCurrentTransform)(this.ctx);
                    let scaleX, scaleY;
                    if (m[1] === 0 && m[2] === 0) {
                      const normX = Math.abs(m[0]);
                      const normY = Math.abs(m[3]);
                      if (lineWidth === 0) {
                        scaleX = 1 / normX;
                        scaleY = 1 / normY;
                      } else {
                        const scaledXLineWidth = normX * lineWidth;
                        const scaledYLineWidth = normY * lineWidth;
                        scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                        scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                      }
                    } else {
                      const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                      const normX = Math.hypot(m[0], m[1]);
                      const normY = Math.hypot(m[2], m[3]);
                      if (lineWidth === 0) {
                        scaleX = normY / absDet;
                        scaleY = normX / absDet;
                      } else {
                        const baseArea = lineWidth * absDet;
                        scaleX = normY > baseArea ? normY / baseArea : 1;
                        scaleY = normX > baseArea ? normX / baseArea : 1;
                      }
                    }
                    this._cachedScaleForStroking = [scaleX, scaleY];
                  }
                  return this._cachedScaleForStroking;
                }
                rescaleAndStroke(saveRestore) {
                  const {
                    ctx
                  } = this;
                  const {
                    lineWidth
                  } = this.current;
                  const [scaleX, scaleY] = this.getScaleForStroking();
                  ctx.lineWidth = lineWidth || 1;
                  if (scaleX === 1 && scaleY === 1) {
                    ctx.stroke();
                    return;
                  }
                  let savedMatrix, savedDashes, savedDashOffset;
                  if (saveRestore) {
                    savedMatrix = (0, _display_utils2.getCurrentTransform)(ctx);
                    savedDashes = ctx.getLineDash().slice();
                    savedDashOffset = ctx.lineDashOffset;
                  }
                  ctx.scale(scaleX, scaleY);
                  const scale8 = Math.max(scaleX, scaleY);
                  ctx.setLineDash(ctx.getLineDash().map((x) => x / scale8));
                  ctx.lineDashOffset /= scale8;
                  ctx.stroke();
                  if (saveRestore) {
                    ctx.setTransform(...savedMatrix);
                    ctx.setLineDash(savedDashes);
                    ctx.lineDashOffset = savedDashOffset;
                  }
                }
                isContentVisible() {
                  for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
                    if (!this.markedContentStack[i].visible) {
                      return false;
                    }
                  }
                  return true;
                }
              };
              let CanvasGraphics = _CanvasGraphics;
              _restoreInitialState = new WeakSet();
              restoreInitialState_fn = function() {
                while (this.stateStack.length || this.inSMaskMode) {
                  this.restore();
                }
                this.ctx.restore();
                if (this.transparentCanvas) {
                  this.ctx = this.compositeCtx;
                  this.ctx.save();
                  this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                  this.ctx.drawImage(this.transparentCanvas, 0, 0);
                  this.ctx.restore();
                  this.transparentCanvas = null;
                }
              };
              exports2.CanvasGraphics = CanvasGraphics;
              for (const op in _util2.OPS) {
                if (CanvasGraphics.prototype[op] !== void 0) {
                  CanvasGraphics.prototype[_util2.OPS[op]] = CanvasGraphics.prototype[op];
                }
              }
            },
            /* 13 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TilingPattern = exports2.PathType = void 0;
              exports2.getShadingPattern = getShadingPattern;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _is_node2 = __w_pdfjs_require__2(3);
              const PathType = {
                FILL: "Fill",
                STROKE: "Stroke",
                SHADING: "Shading"
              };
              exports2.PathType = PathType;
              function applyBoundingBox(ctx, bbox) {
                if (!bbox || _is_node2.isNodeJS) {
                  return;
                }
                const width2 = bbox[2] - bbox[0];
                const height2 = bbox[3] - bbox[1];
                const region = new Path2D();
                region.rect(bbox[0], bbox[1], width2, height2);
                ctx.clip(region);
              }
              class BaseShadingPattern {
                constructor() {
                  if (this.constructor === BaseShadingPattern) {
                    (0, _util2.unreachable)("Cannot initialize BaseShadingPattern.");
                  }
                }
                getPattern() {
                  (0, _util2.unreachable)("Abstract method `getPattern` called.");
                }
              }
              class RadialAxialShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._type = IR[1];
                  this._bbox = IR[2];
                  this._colorStops = IR[3];
                  this._p0 = IR[4];
                  this._p1 = IR[5];
                  this._r0 = IR[6];
                  this._r1 = IR[7];
                  this.matrix = null;
                }
                _createGradient(ctx) {
                  let grad;
                  if (this._type === "axial") {
                    grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
                  } else if (this._type === "radial") {
                    grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
                  }
                  for (const colorStop of this._colorStops) {
                    grad.addColorStop(colorStop[0], colorStop[1]);
                  }
                  return grad;
                }
                getPattern(ctx, owner, inverse4, pathType) {
                  let pattern;
                  if (pathType === PathType.STROKE || pathType === PathType.FILL) {
                    const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils2.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
                    const width2 = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
                    const height2 = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
                    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width2, height2, true);
                    const tmpCtx = tmpCanvas.context;
                    tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.beginPath();
                    tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                    tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
                    inverse4 = _util2.Util.transform(inverse4, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
                    tmpCtx.transform(...owner.baseTransform);
                    if (this.matrix) {
                      tmpCtx.transform(...this.matrix);
                    }
                    applyBoundingBox(tmpCtx, this._bbox);
                    tmpCtx.fillStyle = this._createGradient(tmpCtx);
                    tmpCtx.fill();
                    pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
                    const domMatrix = new DOMMatrix(inverse4);
                    try {
                      pattern.setTransform(domMatrix);
                    } catch (ex) {
                      (0, _util2.warn)(`RadialAxialShadingPattern.getPattern: "${ex?.message}".`);
                    }
                  } else {
                    applyBoundingBox(ctx, this._bbox);
                    pattern = this._createGradient(ctx);
                  }
                  return pattern;
                }
              }
              function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
                const coords = context.coords, colors = context.colors;
                const bytes = data.data, rowSize = data.width * 4;
                let tmp;
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                if (coords[p2 + 1] > coords[p3 + 1]) {
                  tmp = p2;
                  p2 = p3;
                  p3 = tmp;
                  tmp = c2;
                  c2 = c3;
                  c3 = tmp;
                }
                if (coords[p1 + 1] > coords[p2 + 1]) {
                  tmp = p1;
                  p1 = p2;
                  p2 = tmp;
                  tmp = c1;
                  c1 = c2;
                  c2 = tmp;
                }
                const x1 = (coords[p1] + context.offsetX) * context.scaleX;
                const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
                const x2 = (coords[p2] + context.offsetX) * context.scaleX;
                const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
                const x3 = (coords[p3] + context.offsetX) * context.scaleX;
                const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
                if (y1 >= y3) {
                  return;
                }
                const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
                const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
                const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
                const minY = Math.round(y1), maxY = Math.round(y3);
                let xa, car, cag, cab;
                let xb, cbr, cbg, cbb;
                for (let y = minY; y <= maxY; y++) {
                  if (y < y2) {
                    let k2;
                    if (y < y1) {
                      k2 = 0;
                    } else {
                      k2 = (y1 - y) / (y1 - y2);
                    }
                    xa = x1 - (x1 - x2) * k2;
                    car = c1r - (c1r - c2r) * k2;
                    cag = c1g - (c1g - c2g) * k2;
                    cab = c1b - (c1b - c2b) * k2;
                  } else {
                    let k2;
                    if (y > y3) {
                      k2 = 1;
                    } else if (y2 === y3) {
                      k2 = 0;
                    } else {
                      k2 = (y2 - y) / (y2 - y3);
                    }
                    xa = x2 - (x2 - x3) * k2;
                    car = c2r - (c2r - c3r) * k2;
                    cag = c2g - (c2g - c3g) * k2;
                    cab = c2b - (c2b - c3b) * k2;
                  }
                  let k;
                  if (y < y1) {
                    k = 0;
                  } else if (y > y3) {
                    k = 1;
                  } else {
                    k = (y1 - y) / (y1 - y3);
                  }
                  xb = x1 - (x1 - x3) * k;
                  cbr = c1r - (c1r - c3r) * k;
                  cbg = c1g - (c1g - c3g) * k;
                  cbb = c1b - (c1b - c3b) * k;
                  const x1_ = Math.round(Math.min(xa, xb));
                  const x2_ = Math.round(Math.max(xa, xb));
                  let j = rowSize * y + x1_ * 4;
                  for (let x = x1_; x <= x2_; x++) {
                    k = (xa - x) / (xa - xb);
                    if (k < 0) {
                      k = 0;
                    } else if (k > 1) {
                      k = 1;
                    }
                    bytes[j++] = car - (car - cbr) * k | 0;
                    bytes[j++] = cag - (cag - cbg) * k | 0;
                    bytes[j++] = cab - (cab - cbb) * k | 0;
                    bytes[j++] = 255;
                  }
                }
              }
              function drawFigure(data, figure, context) {
                const ps = figure.coords;
                const cs = figure.colors;
                let i, ii;
                switch (figure.type) {
                  case "lattice":
                    const verticesPerRow = figure.verticesPerRow;
                    const rows = Math.floor(ps.length / verticesPerRow) - 1;
                    const cols = verticesPerRow - 1;
                    for (i = 0; i < rows; i++) {
                      let q = i * verticesPerRow;
                      for (let j = 0; j < cols; j++, q++) {
                        drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                        drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                      }
                    }
                    break;
                  case "triangles":
                    for (i = 0, ii = ps.length; i < ii; i += 3) {
                      drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
                    }
                    break;
                  default:
                    throw new Error("illegal figure");
                }
              }
              class MeshShadingPattern extends BaseShadingPattern {
                constructor(IR) {
                  super();
                  this._coords = IR[2];
                  this._colors = IR[3];
                  this._figures = IR[4];
                  this._bounds = IR[5];
                  this._bbox = IR[7];
                  this._background = IR[8];
                  this.matrix = null;
                }
                _createMeshCanvas(combinedScale, backgroundColor2, cachedCanvases) {
                  const EXPECTED_SCALE = 1.1;
                  const MAX_PATTERN_SIZE = 3e3;
                  const BORDER_SIZE = 2;
                  const offsetX = Math.floor(this._bounds[0]);
                  const offsetY = Math.floor(this._bounds[1]);
                  const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
                  const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
                  const width2 = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const height2 = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
                  const scaleX = boundsWidth / width2;
                  const scaleY = boundsHeight / height2;
                  const context = {
                    coords: this._coords,
                    colors: this._colors,
                    offsetX: -offsetX,
                    offsetY: -offsetY,
                    scaleX: 1 / scaleX,
                    scaleY: 1 / scaleY
                  };
                  const paddedWidth = width2 + BORDER_SIZE * 2;
                  const paddedHeight = height2 + BORDER_SIZE * 2;
                  const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
                  const tmpCtx = tmpCanvas.context;
                  const data = tmpCtx.createImageData(width2, height2);
                  if (backgroundColor2) {
                    const bytes = data.data;
                    for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                      bytes[i] = backgroundColor2[0];
                      bytes[i + 1] = backgroundColor2[1];
                      bytes[i + 2] = backgroundColor2[2];
                      bytes[i + 3] = 255;
                    }
                  }
                  for (const figure of this._figures) {
                    drawFigure(data, figure, context);
                  }
                  tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
                  const canvas = tmpCanvas.canvas;
                  return {
                    canvas,
                    offsetX: offsetX - BORDER_SIZE * scaleX,
                    offsetY: offsetY - BORDER_SIZE * scaleY,
                    scaleX,
                    scaleY
                  };
                }
                getPattern(ctx, owner, inverse4, pathType) {
                  applyBoundingBox(ctx, this._bbox);
                  let scale8;
                  if (pathType === PathType.SHADING) {
                    scale8 = _util2.Util.singularValueDecompose2dScale((0, _display_utils2.getCurrentTransform)(ctx));
                  } else {
                    scale8 = _util2.Util.singularValueDecompose2dScale(owner.baseTransform);
                    if (this.matrix) {
                      const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                      scale8 = [scale8[0] * matrixScale[0], scale8[1] * matrixScale[1]];
                    }
                  }
                  const temporaryPatternCanvas = this._createMeshCanvas(scale8, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
                  if (pathType !== PathType.SHADING) {
                    ctx.setTransform(...owner.baseTransform);
                    if (this.matrix) {
                      ctx.transform(...this.matrix);
                    }
                  }
                  ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
                  return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
                }
              }
              class DummyShadingPattern extends BaseShadingPattern {
                getPattern() {
                  return "hotpink";
                }
              }
              function getShadingPattern(IR) {
                switch (IR[0]) {
                  case "RadialAxial":
                    return new RadialAxialShadingPattern(IR);
                  case "Mesh":
                    return new MeshShadingPattern(IR);
                  case "Dummy":
                    return new DummyShadingPattern();
                }
                throw new Error(`Unknown IR type: ${IR[0]}`);
              }
              const PaintType = {
                COLORED: 1,
                UNCOLORED: 2
              };
              class TilingPattern {
                static get MAX_PATTERN_SIZE() {
                  return (0, _util2.shadow)(this, "MAX_PATTERN_SIZE", 3e3);
                }
                constructor(IR, color2, ctx, canvasGraphicsFactory, baseTransform) {
                  this.operatorList = IR[2];
                  this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
                  this.bbox = IR[4];
                  this.xstep = IR[5];
                  this.ystep = IR[6];
                  this.paintType = IR[7];
                  this.tilingType = IR[8];
                  this.color = color2;
                  this.ctx = ctx;
                  this.canvasGraphicsFactory = canvasGraphicsFactory;
                  this.baseTransform = baseTransform;
                }
                createPatternCanvas(owner) {
                  const operatorList = this.operatorList;
                  const bbox = this.bbox;
                  const xstep = this.xstep;
                  const ystep = this.ystep;
                  const paintType = this.paintType;
                  const tilingType = this.tilingType;
                  const color2 = this.color;
                  const canvasGraphicsFactory = this.canvasGraphicsFactory;
                  (0, _util2.info)("TilingType: " + tilingType);
                  const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
                  const matrixScale = _util2.Util.singularValueDecompose2dScale(this.matrix);
                  const curMatrixScale = _util2.Util.singularValueDecompose2dScale(this.baseTransform);
                  const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
                  const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
                  const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
                  const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
                  const tmpCtx = tmpCanvas.context;
                  const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
                  graphics.groupLevel = owner.groupLevel;
                  this.setFillAndStrokeStyleToContext(graphics, paintType, color2);
                  let adjustedX0 = x0;
                  let adjustedY0 = y0;
                  let adjustedX1 = x1;
                  let adjustedY1 = y1;
                  if (x0 < 0) {
                    adjustedX0 = 0;
                    adjustedX1 += Math.abs(x0);
                  }
                  if (y0 < 0) {
                    adjustedY0 = 0;
                    adjustedY1 += Math.abs(y0);
                  }
                  tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
                  graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
                  tmpCtx.save();
                  this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
                  graphics.baseTransform = (0, _display_utils2.getCurrentTransform)(graphics.ctx);
                  graphics.executeOperatorList(operatorList);
                  graphics.endDrawing();
                  return {
                    canvas: tmpCanvas.canvas,
                    scaleX: dimx.scale,
                    scaleY: dimy.scale,
                    offsetX: adjustedX0,
                    offsetY: adjustedY0
                  };
                }
                getSizeAndScale(step2, realOutputSize, scale8) {
                  step2 = Math.abs(step2);
                  const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
                  let size4 = Math.ceil(step2 * scale8);
                  if (size4 >= maxSize) {
                    size4 = maxSize;
                  } else {
                    scale8 = size4 / step2;
                  }
                  return {
                    scale: scale8,
                    size: size4
                  };
                }
                clipBbox(graphics, x0, y0, x1, y1) {
                  const bboxWidth = x1 - x0;
                  const bboxHeight = y1 - y0;
                  graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
                  graphics.current.updateRectMinMax((0, _display_utils2.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
                  graphics.clip();
                  graphics.endPath();
                }
                setFillAndStrokeStyleToContext(graphics, paintType, color2) {
                  const context = graphics.ctx, current = graphics.current;
                  switch (paintType) {
                    case PaintType.COLORED:
                      const ctx = this.ctx;
                      context.fillStyle = ctx.fillStyle;
                      context.strokeStyle = ctx.strokeStyle;
                      current.fillColor = ctx.fillStyle;
                      current.strokeColor = ctx.strokeStyle;
                      break;
                    case PaintType.UNCOLORED:
                      const cssColor = _util2.Util.makeHexColor(color2[0], color2[1], color2[2]);
                      context.fillStyle = cssColor;
                      context.strokeStyle = cssColor;
                      current.fillColor = cssColor;
                      current.strokeColor = cssColor;
                      break;
                    default:
                      throw new _util2.FormatError(`Unsupported paint type: ${paintType}`);
                  }
                }
                getPattern(ctx, owner, inverse4, pathType) {
                  let matrix = inverse4;
                  if (pathType !== PathType.SHADING) {
                    matrix = _util2.Util.transform(matrix, owner.baseTransform);
                    if (this.matrix) {
                      matrix = _util2.Util.transform(matrix, this.matrix);
                    }
                  }
                  const temporaryPatternCanvas = this.createPatternCanvas(owner);
                  let domMatrix = new DOMMatrix(matrix);
                  domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
                  domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
                  const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
                  try {
                    pattern.setTransform(domMatrix);
                  } catch (ex) {
                    (0, _util2.warn)(`TilingPattern.getPattern: "${ex?.message}".`);
                  }
                  return pattern;
                }
              }
              exports2.TilingPattern = TilingPattern;
            },
            /* 14 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.applyMaskImageData = applyMaskImageData;
              var _util2 = __w_pdfjs_require__2(1);
              function applyMaskImageData({
                src: src2,
                srcPos = 0,
                dest,
                destPos = 0,
                width: width2,
                height: height2,
                inverseDecode = false
              }) {
                const opaque = _util2.FeatureTest.isLittleEndian ? 4278190080 : 255;
                const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
                const widthInSource = width2 >> 3;
                const widthRemainder = width2 & 7;
                const srcLength = src2.length;
                dest = new Uint32Array(dest.buffer);
                for (let i = 0; i < height2; i++) {
                  for (const max5 = srcPos + widthInSource; srcPos < max5; srcPos++) {
                    const elem2 = srcPos < srcLength ? src2[srcPos] : 255;
                    dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
                    dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
                  }
                  if (widthRemainder === 0) {
                    continue;
                  }
                  const elem = srcPos < srcLength ? src2[srcPos++] : 255;
                  for (let j = 0; j < widthRemainder; j++) {
                    dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
                  }
                }
                return {
                  srcPos,
                  destPos
                };
              }
            },
            /* 15 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.GlobalWorkerOptions = void 0;
              const GlobalWorkerOptions = /* @__PURE__ */ Object.create(null);
              exports2.GlobalWorkerOptions = GlobalWorkerOptions;
              GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === void 0 ? null : GlobalWorkerOptions.workerPort;
              GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === void 0 ? "" : GlobalWorkerOptions.workerSrc;
            },
            /* 16 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.MessageHandler = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const CallbackKind = {
                UNKNOWN: 0,
                DATA: 1,
                ERROR: 2
              };
              const StreamKind = {
                UNKNOWN: 0,
                CANCEL: 1,
                CANCEL_COMPLETE: 2,
                CLOSE: 3,
                ENQUEUE: 4,
                ERROR: 5,
                PULL: 6,
                PULL_COMPLETE: 7,
                START_COMPLETE: 8
              };
              function wrapReason(reason) {
                if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
                  (0, _util2.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
                }
                switch (reason.name) {
                  case "AbortException":
                    return new _util2.AbortException(reason.message);
                  case "MissingPDFException":
                    return new _util2.MissingPDFException(reason.message);
                  case "PasswordException":
                    return new _util2.PasswordException(reason.message, reason.code);
                  case "UnexpectedResponseException":
                    return new _util2.UnexpectedResponseException(reason.message, reason.status);
                  case "UnknownErrorException":
                    return new _util2.UnknownErrorException(reason.message, reason.details);
                  default:
                    return new _util2.UnknownErrorException(reason.message, reason.toString());
                }
              }
              class MessageHandler {
                constructor(sourceName, targetName, comObj) {
                  this.sourceName = sourceName;
                  this.targetName = targetName;
                  this.comObj = comObj;
                  this.callbackId = 1;
                  this.streamId = 1;
                  this.streamSinks = /* @__PURE__ */ Object.create(null);
                  this.streamControllers = /* @__PURE__ */ Object.create(null);
                  this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
                  this.actionHandler = /* @__PURE__ */ Object.create(null);
                  this._onComObjOnMessage = (event) => {
                    const data = event.data;
                    if (data.targetName !== this.sourceName) {
                      return;
                    }
                    if (data.stream) {
                      this._processStreamMessage(data);
                      return;
                    }
                    if (data.callback) {
                      const callbackId = data.callbackId;
                      const capability = this.callbackCapabilities[callbackId];
                      if (!capability) {
                        throw new Error(`Cannot resolve callback ${callbackId}`);
                      }
                      delete this.callbackCapabilities[callbackId];
                      if (data.callback === CallbackKind.DATA) {
                        capability.resolve(data.data);
                      } else if (data.callback === CallbackKind.ERROR) {
                        capability.reject(wrapReason(data.reason));
                      } else {
                        throw new Error("Unexpected callback case");
                      }
                      return;
                    }
                    const action = this.actionHandler[data.action];
                    if (!action) {
                      throw new Error(`Unknown action from worker: ${data.action}`);
                    }
                    if (data.callbackId) {
                      const cbSourceName = this.sourceName;
                      const cbTargetName = data.sourceName;
                      new Promise(function(resolve) {
                        resolve(action(data.data));
                      }).then(function(result) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.DATA,
                          callbackId: data.callbackId,
                          data: result
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName: cbSourceName,
                          targetName: cbTargetName,
                          callback: CallbackKind.ERROR,
                          callbackId: data.callbackId,
                          reason: wrapReason(reason)
                        });
                      });
                      return;
                    }
                    if (data.streamId) {
                      this._createStreamSink(data);
                      return;
                    }
                    action(data.data);
                  };
                  comObj.addEventListener("message", this._onComObjOnMessage);
                }
                on(actionName, handler) {
                  const ah = this.actionHandler;
                  if (ah[actionName]) {
                    throw new Error(`There is already an actionName called "${actionName}"`);
                  }
                  ah[actionName] = handler;
                }
                send(actionName, data, transfers) {
                  this.comObj.postMessage({
                    sourceName: this.sourceName,
                    targetName: this.targetName,
                    action: actionName,
                    data
                  }, transfers);
                }
                sendWithPromise(actionName, data, transfers) {
                  const callbackId = this.callbackId++;
                  const capability = (0, _util2.createPromiseCapability)();
                  this.callbackCapabilities[callbackId] = capability;
                  try {
                    this.comObj.postMessage({
                      sourceName: this.sourceName,
                      targetName: this.targetName,
                      action: actionName,
                      callbackId,
                      data
                    }, transfers);
                  } catch (ex) {
                    capability.reject(ex);
                  }
                  return capability.promise;
                }
                sendWithStream(actionName, data, queueingStrategy, transfers) {
                  const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
                  return new ReadableStream({
                    start: (controller) => {
                      const startCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId] = {
                        controller,
                        startCall: startCapability,
                        pullCall: null,
                        cancelCall: null,
                        isClosed: false
                      };
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        action: actionName,
                        streamId,
                        data,
                        desiredSize: controller.desiredSize
                      }, transfers);
                      return startCapability.promise;
                    },
                    pull: (controller) => {
                      const pullCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].pullCall = pullCapability;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.PULL,
                        streamId,
                        desiredSize: controller.desiredSize
                      });
                      return pullCapability.promise;
                    },
                    cancel: (reason) => {
                      (0, _util2.assert)(reason instanceof Error, "cancel must have a valid reason");
                      const cancelCapability = (0, _util2.createPromiseCapability)();
                      this.streamControllers[streamId].cancelCall = cancelCapability;
                      this.streamControllers[streamId].isClosed = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CANCEL,
                        streamId,
                        reason: wrapReason(reason)
                      });
                      return cancelCapability.promise;
                    }
                  }, queueingStrategy);
                }
                _createStreamSink(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const self2 = this, action = this.actionHandler[data.action];
                  const streamSink = {
                    enqueue(chunk, size4 = 1, transfers) {
                      if (this.isCancelled) {
                        return;
                      }
                      const lastDesiredSize = this.desiredSize;
                      this.desiredSize -= size4;
                      if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                        this.sinkCapability = (0, _util2.createPromiseCapability)();
                        this.ready = this.sinkCapability.promise;
                      }
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ENQUEUE,
                        streamId,
                        chunk
                      }, transfers);
                    },
                    close() {
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.CLOSE,
                        streamId
                      });
                      delete self2.streamSinks[streamId];
                    },
                    error(reason) {
                      (0, _util2.assert)(reason instanceof Error, "error must have a valid reason");
                      if (this.isCancelled) {
                        return;
                      }
                      this.isCancelled = true;
                      comObj.postMessage({
                        sourceName,
                        targetName,
                        stream: StreamKind.ERROR,
                        streamId,
                        reason: wrapReason(reason)
                      });
                    },
                    sinkCapability: (0, _util2.createPromiseCapability)(),
                    onPull: null,
                    onCancel: null,
                    isCancelled: false,
                    desiredSize: data.desiredSize,
                    ready: null
                  };
                  streamSink.sinkCapability.resolve();
                  streamSink.ready = streamSink.sinkCapability.promise;
                  this.streamSinks[streamId] = streamSink;
                  new Promise(function(resolve) {
                    resolve(action(data.data, streamSink));
                  }).then(function() {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      success: true
                    });
                  }, function(reason) {
                    comObj.postMessage({
                      sourceName,
                      targetName,
                      stream: StreamKind.START_COMPLETE,
                      streamId,
                      reason: wrapReason(reason)
                    });
                  });
                }
                _processStreamMessage(data) {
                  const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
                  const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
                  switch (data.stream) {
                    case StreamKind.START_COMPLETE:
                      if (data.success) {
                        streamController.startCall.resolve();
                      } else {
                        streamController.startCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL_COMPLETE:
                      if (data.success) {
                        streamController.pullCall.resolve();
                      } else {
                        streamController.pullCall.reject(wrapReason(data.reason));
                      }
                      break;
                    case StreamKind.PULL:
                      if (!streamSink) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                        break;
                      }
                      if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                        streamSink.sinkCapability.resolve();
                      }
                      streamSink.desiredSize = data.desiredSize;
                      new Promise(function(resolve) {
                        resolve(streamSink.onPull && streamSink.onPull());
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.PULL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      break;
                    case StreamKind.ENQUEUE:
                      (0, _util2.assert)(streamController, "enqueue should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.controller.enqueue(data.chunk);
                      break;
                    case StreamKind.CLOSE:
                      (0, _util2.assert)(streamController, "close should have stream controller");
                      if (streamController.isClosed) {
                        break;
                      }
                      streamController.isClosed = true;
                      streamController.controller.close();
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.ERROR:
                      (0, _util2.assert)(streamController, "error should have stream controller");
                      streamController.controller.error(wrapReason(data.reason));
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL_COMPLETE:
                      if (data.success) {
                        streamController.cancelCall.resolve();
                      } else {
                        streamController.cancelCall.reject(wrapReason(data.reason));
                      }
                      this._deleteStreamController(streamController, streamId);
                      break;
                    case StreamKind.CANCEL:
                      if (!streamSink) {
                        break;
                      }
                      new Promise(function(resolve) {
                        resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                      }).then(function() {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          success: true
                        });
                      }, function(reason) {
                        comObj.postMessage({
                          sourceName,
                          targetName,
                          stream: StreamKind.CANCEL_COMPLETE,
                          streamId,
                          reason: wrapReason(reason)
                        });
                      });
                      streamSink.sinkCapability.reject(wrapReason(data.reason));
                      streamSink.isCancelled = true;
                      delete this.streamSinks[streamId];
                      break;
                    default:
                      throw new Error("Unexpected stream case");
                  }
                }
                async _deleteStreamController(streamController, streamId) {
                  await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
                  delete this.streamControllers[streamId];
                }
                destroy() {
                  this.comObj.removeEventListener("message", this._onComObjOnMessage);
                }
              }
              exports2.MessageHandler = MessageHandler;
            },
            /* 17 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _metadataMap, _data;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.Metadata = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              class Metadata {
                constructor({
                  parsedData,
                  rawData
                }) {
                  __privateAdd(this, _metadataMap, void 0);
                  __privateAdd(this, _data, void 0);
                  __privateSet(this, _metadataMap, parsedData);
                  __privateSet(this, _data, rawData);
                }
                getRaw() {
                  return __privateGet(this, _data);
                }
                get(name3) {
                  return __privateGet(this, _metadataMap).get(name3) ?? null;
                }
                getAll() {
                  return (0, _util2.objectFromMap)(__privateGet(this, _metadataMap));
                }
                has(name3) {
                  return __privateGet(this, _metadataMap).has(name3);
                }
              }
              _metadataMap = new WeakMap();
              _data = new WeakMap();
              exports2.Metadata = Metadata;
            },
            /* 18 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _visible, _cachedHasInitialVisibility, _groups, _initialVisibility, _order, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.OptionalContentConfig = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              const INTERNAL = Symbol("INTERNAL");
              class OptionalContentGroup {
                constructor(name3, intent) {
                  __privateAdd(this, _visible, true);
                  this.name = name3;
                  this.intent = intent;
                }
                get visible() {
                  return __privateGet(this, _visible);
                }
                _setVisible(internal, visible) {
                  if (internal !== INTERNAL) {
                    (0, _util2.unreachable)("Internal method `_setVisible` called.");
                  }
                  __privateSet(this, _visible, visible);
                }
              }
              _visible = new WeakMap();
              class OptionalContentConfig {
                constructor(data) {
                  __privateAdd(this, _evaluateVisibilityExpression);
                  __privateAdd(this, _cachedHasInitialVisibility, true);
                  __privateAdd(this, _groups, /* @__PURE__ */ new Map());
                  __privateAdd(this, _initialVisibility, null);
                  __privateAdd(this, _order, null);
                  this.name = null;
                  this.creator = null;
                  if (data === null) {
                    return;
                  }
                  this.name = data.name;
                  this.creator = data.creator;
                  __privateSet(this, _order, data.order);
                  for (const group2 of data.groups) {
                    __privateGet(this, _groups).set(group2.id, new OptionalContentGroup(group2.name, group2.intent));
                  }
                  if (data.baseState === "OFF") {
                    for (const group2 of __privateGet(this, _groups).values()) {
                      group2._setVisible(INTERNAL, false);
                    }
                  }
                  for (const on of data.on) {
                    __privateGet(this, _groups).get(on)._setVisible(INTERNAL, true);
                  }
                  for (const off of data.off) {
                    __privateGet(this, _groups).get(off)._setVisible(INTERNAL, false);
                  }
                  __privateSet(this, _initialVisibility, /* @__PURE__ */ new Map());
                  for (const [id2, group2] of __privateGet(this, _groups)) {
                    __privateGet(this, _initialVisibility).set(id2, group2.visible);
                  }
                }
                isVisible(group2) {
                  if (__privateGet(this, _groups).size === 0) {
                    return true;
                  }
                  if (!group2) {
                    (0, _util2.warn)("Optional content group not defined.");
                    return true;
                  }
                  if (group2.type === "OCG") {
                    if (!__privateGet(this, _groups).has(group2.id)) {
                      (0, _util2.warn)(`Optional content group not found: ${group2.id}`);
                      return true;
                    }
                    return __privateGet(this, _groups).get(group2.id).visible;
                  } else if (group2.type === "OCMD") {
                    if (group2.expression) {
                      return __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, group2.expression);
                    }
                    if (!group2.policy || group2.policy === "AnyOn") {
                      for (const id2 of group2.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id2).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group2.policy === "AllOn") {
                      for (const id2 of group2.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id2).visible) {
                          return false;
                        }
                      }
                      return true;
                    } else if (group2.policy === "AnyOff") {
                      for (const id2 of group2.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (!__privateGet(this, _groups).get(id2).visible) {
                          return true;
                        }
                      }
                      return false;
                    } else if (group2.policy === "AllOff") {
                      for (const id2 of group2.ids) {
                        if (!__privateGet(this, _groups).has(id2)) {
                          (0, _util2.warn)(`Optional content group not found: ${id2}`);
                          return true;
                        }
                        if (__privateGet(this, _groups).get(id2).visible) {
                          return false;
                        }
                      }
                      return true;
                    }
                    (0, _util2.warn)(`Unknown optional content policy ${group2.policy}.`);
                    return true;
                  }
                  (0, _util2.warn)(`Unknown group type ${group2.type}.`);
                  return true;
                }
                setVisibility(id2, visible = true) {
                  if (!__privateGet(this, _groups).has(id2)) {
                    (0, _util2.warn)(`Optional content group not found: ${id2}`);
                    return;
                  }
                  __privateGet(this, _groups).get(id2)._setVisible(INTERNAL, !!visible);
                  __privateSet(this, _cachedHasInitialVisibility, null);
                }
                get hasInitialVisibility() {
                  if (__privateGet(this, _cachedHasInitialVisibility) !== null) {
                    return __privateGet(this, _cachedHasInitialVisibility);
                  }
                  for (const [id2, group2] of __privateGet(this, _groups)) {
                    const visible = __privateGet(this, _initialVisibility).get(id2);
                    if (group2.visible !== visible) {
                      return __privateSet(this, _cachedHasInitialVisibility, false);
                    }
                  }
                  return __privateSet(this, _cachedHasInitialVisibility, true);
                }
                getOrder() {
                  if (!__privateGet(this, _groups).size) {
                    return null;
                  }
                  if (__privateGet(this, _order)) {
                    return __privateGet(this, _order).slice();
                  }
                  return [...__privateGet(this, _groups).keys()];
                }
                getGroups() {
                  return __privateGet(this, _groups).size > 0 ? (0, _util2.objectFromMap)(__privateGet(this, _groups)) : null;
                }
                getGroup(id2) {
                  return __privateGet(this, _groups).get(id2) || null;
                }
              }
              _cachedHasInitialVisibility = new WeakMap();
              _groups = new WeakMap();
              _initialVisibility = new WeakMap();
              _order = new WeakMap();
              _evaluateVisibilityExpression = new WeakSet();
              evaluateVisibilityExpression_fn = function(array) {
                const length8 = array.length;
                if (length8 < 2) {
                  return true;
                }
                const operator = array[0];
                for (let i = 1; i < length8; i++) {
                  const element = array[i];
                  let state;
                  if (Array.isArray(element)) {
                    state = __privateMethod(this, _evaluateVisibilityExpression, evaluateVisibilityExpression_fn).call(this, element);
                  } else if (__privateGet(this, _groups).has(element)) {
                    state = __privateGet(this, _groups).get(element).visible;
                  } else {
                    (0, _util2.warn)(`Optional content group not found: ${element}`);
                    return true;
                  }
                  switch (operator) {
                    case "And":
                      if (!state) {
                        return false;
                      }
                      break;
                    case "Or":
                      if (state) {
                        return true;
                      }
                      break;
                    case "Not":
                      return !state;
                    default:
                      return true;
                  }
                }
                return operator === "And";
              };
              exports2.OptionalContentConfig = OptionalContentConfig;
            },
            /* 19 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFDataTransportStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              class PDFDataTransportStream {
                constructor(params, pdfDataRangeTransport) {
                  (0, _util2.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
                  this._queuedChunks = [];
                  this._progressiveDone = params.progressiveDone || false;
                  this._contentDispositionFilename = params.contentDispositionFilename || null;
                  const initialData = params.initialData;
                  if (initialData?.length > 0) {
                    const buffer = new Uint8Array(initialData).buffer;
                    this._queuedChunks.push(buffer);
                  }
                  this._pdfDataRangeTransport = pdfDataRangeTransport;
                  this._isStreamingSupported = !params.disableStream;
                  this._isRangeSupported = !params.disableRange;
                  this._contentLength = params.length;
                  this._fullRequestReader = null;
                  this._rangeReaders = [];
                  this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
                    this._onReceiveData({
                      begin,
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
                    this._onProgress({
                      loaded,
                      total
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveReadListener((chunk) => {
                    this._onReceiveData({
                      chunk
                    });
                  });
                  this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                    this._onProgressiveDone();
                  });
                  this._pdfDataRangeTransport.transportReady();
                }
                _onReceiveData(args) {
                  const buffer = new Uint8Array(args.chunk).buffer;
                  if (args.begin === void 0) {
                    if (this._fullRequestReader) {
                      this._fullRequestReader._enqueue(buffer);
                    } else {
                      this._queuedChunks.push(buffer);
                    }
                  } else {
                    const found = this._rangeReaders.some(function(rangeReader) {
                      if (rangeReader._begin !== args.begin) {
                        return false;
                      }
                      rangeReader._enqueue(buffer);
                      return true;
                    });
                    (0, _util2.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
                  }
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                _onProgress(evt) {
                  if (evt.total === void 0) {
                    const firstReader = this._rangeReaders[0];
                    if (firstReader?.onProgress) {
                      firstReader.onProgress({
                        loaded: evt.loaded
                      });
                    }
                  } else {
                    const fullReader = this._fullRequestReader;
                    if (fullReader?.onProgress) {
                      fullReader.onProgress({
                        loaded: evt.loaded,
                        total: evt.total
                      });
                    }
                  }
                }
                _onProgressiveDone() {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.progressiveDone();
                  }
                  this._progressiveDone = true;
                }
                _removeRangeReader(reader) {
                  const i = this._rangeReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
                  const queuedChunks = this._queuedChunks;
                  this._queuedChunks = null;
                  return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
                }
                getRangeReader(begin, end2) {
                  if (end2 <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFDataTransportStreamRangeReader(this, begin, end2);
                  this._pdfDataRangeTransport.requestDataRange(begin, end2);
                  this._rangeReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                  this._pdfDataRangeTransport.abort();
                }
              }
              exports2.PDFDataTransportStream = PDFDataTransportStream;
              class PDFDataTransportStreamReader {
                constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
                  this._stream = stream;
                  this._done = progressiveDone || false;
                  this._filename = (0, _display_utils2.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
                  this._queuedChunks = queuedChunks || [];
                  this._loaded = 0;
                  for (const chunk of this._queuedChunks) {
                    this._loaded += chunk.byteLength;
                  }
                  this._requests = [];
                  this._headersReady = Promise.resolve();
                  stream._fullRequestReader = this;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunks.push(chunk);
                  }
                  this._loaded += chunk.byteLength;
                }
                get headersReady() {
                  return this._headersReady;
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._stream._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._stream._isStreamingSupported;
                }
                get contentLength() {
                  return this._stream._contentLength;
                }
                async read() {
                  if (this._queuedChunks.length > 0) {
                    const chunk = this._queuedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                progressiveDone() {
                  if (this._done) {
                    return;
                  }
                  this._done = true;
                }
              }
              class PDFDataTransportStreamRangeReader {
                constructor(stream, begin, end2) {
                  this._stream = stream;
                  this._begin = begin;
                  this._end = end2;
                  this._queuedChunk = null;
                  this._requests = [];
                  this._done = false;
                  this.onProgress = null;
                }
                _enqueue(chunk) {
                  if (this._done) {
                    return;
                  }
                  if (this._requests.length === 0) {
                    this._queuedChunk = chunk;
                  } else {
                    const requestsCapability = this._requests.shift();
                    requestsCapability.resolve({
                      value: chunk,
                      done: false
                    });
                    for (const requestCapability of this._requests) {
                      requestCapability.resolve({
                        value: void 0,
                        done: true
                      });
                    }
                    this._requests.length = 0;
                  }
                  this._done = true;
                  this._stream._removeRangeReader(this);
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._queuedChunk) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._stream._removeRangeReader(this);
                }
              }
            },
            /* 20 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaText = void 0;
              class XfaText {
                static textContent(xfa) {
                  const items = [];
                  const output = {
                    items,
                    styles: /* @__PURE__ */ Object.create(null)
                  };
                  function walk(node) {
                    if (!node) {
                      return;
                    }
                    let str5 = null;
                    const name3 = node.name;
                    if (name3 === "#text") {
                      str5 = node.value;
                    } else if (!XfaText.shouldBuildText(name3)) {
                      return;
                    } else if (node?.attributes?.textContent) {
                      str5 = node.attributes.textContent;
                    } else if (node.value) {
                      str5 = node.value;
                    }
                    if (str5 !== null) {
                      items.push({
                        str: str5
                      });
                    }
                    if (!node.children) {
                      return;
                    }
                    for (const child of node.children) {
                      walk(child);
                    }
                  }
                  walk(xfa);
                  return output;
                }
                static shouldBuildText(name3) {
                  return !(name3 === "textarea" || name3 === "input" || name3 === "option" || name3 === "select");
                }
              }
              exports2.XfaText = XfaText;
            },
            /* 21 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.NodeStandardFontDataFactory = exports2.NodeCanvasFactory = exports2.NodeCMapReaderFactory = void 0;
              var _base_factory = __w_pdfjs_require__2(9);
              ;
              const fetchData = function(url2) {
                return new Promise((resolve, reject) => {
                  const fs = require_fs();
                  fs.readFile(url2, (error, data) => {
                    if (error || !data) {
                      reject(new Error(error));
                      return;
                    }
                    resolve(new Uint8Array(data));
                  });
                });
              };
              class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
                _createCanvas(width2, height2) {
                  const Canvas2 = require_canvas();
                  return Canvas2.createCanvas(width2, height2);
                }
              }
              exports2.NodeCanvasFactory = NodeCanvasFactory;
              class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
                _fetchData(url2, compressionType) {
                  return fetchData(url2).then((data) => {
                    return {
                      cMapData: data,
                      compressionType
                    };
                  });
                }
              }
              exports2.NodeCMapReaderFactory = NodeCMapReaderFactory;
              class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
                _fetchData(url2) {
                  return fetchData(url2);
                }
              }
              exports2.NodeStandardFontDataFactory = NodeStandardFontDataFactory;
            },
            /* 22 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _accessibilityManager, _allowClick, _boundPointerup, _boundPointerdown, _editors, _hadPointerDown, _isCleaningUp, _uiManager, _changeParent, changeParent_fn, _createNewEditor, createNewEditor_fn, _createAndAddNewEditor, createAndAddNewEditor_fn, _cleanup, cleanup_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationEditorLayer = void 0;
              var _tools = __w_pdfjs_require__2(7);
              var _util2 = __w_pdfjs_require__2(1);
              var _freetext = __w_pdfjs_require__2(23);
              var _ink = __w_pdfjs_require__2(24);
              const _AnnotationEditorLayer = class {
                constructor(options) {
                  __privateAdd(this, _changeParent);
                  __privateAdd(this, _createNewEditor);
                  __privateAdd(this, _createAndAddNewEditor);
                  __privateAdd(this, _cleanup);
                  __privateAdd(this, _accessibilityManager, void 0);
                  __privateAdd(this, _allowClick, false);
                  __privateAdd(this, _boundPointerup, this.pointerup.bind(this));
                  __privateAdd(this, _boundPointerdown, this.pointerdown.bind(this));
                  __privateAdd(this, _editors, /* @__PURE__ */ new Map());
                  __privateAdd(this, _hadPointerDown, false);
                  __privateAdd(this, _isCleaningUp, false);
                  __privateAdd(this, _uiManager, void 0);
                  if (!_AnnotationEditorLayer._initialized) {
                    _AnnotationEditorLayer._initialized = true;
                    _freetext.FreeTextEditor.initialize(options.l10n);
                    _ink.InkEditor.initialize(options.l10n);
                    options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
                  }
                  __privateSet(this, _uiManager, options.uiManager);
                  this.annotationStorage = options.annotationStorage;
                  this.pageIndex = options.pageIndex;
                  this.div = options.div;
                  __privateSet(this, _accessibilityManager, options.accessibilityManager);
                  __privateGet(this, _uiManager).addLayer(this);
                }
                updateToolbar(mode) {
                  __privateGet(this, _uiManager).updateToolbar(mode);
                }
                updateMode(mode = __privateGet(this, _uiManager).getMode()) {
                  __privateMethod(this, _cleanup, cleanup_fn).call(this);
                  if (mode === _util2.AnnotationEditorType.INK) {
                    this.addInkEditorIfNeeded(false);
                    this.disableClick();
                  } else {
                    this.enableClick();
                  }
                  __privateGet(this, _uiManager).unselectAll();
                }
                addInkEditorIfNeeded(isCommitting) {
                  if (!isCommitting && __privateGet(this, _uiManager).getMode() !== _util2.AnnotationEditorType.INK) {
                    return;
                  }
                  if (!isCommitting) {
                    for (const editor3 of __privateGet(this, _editors).values()) {
                      if (editor3.isEmpty()) {
                        editor3.setInBackground();
                        return;
                      }
                    }
                  }
                  const editor2 = __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, {
                    offsetX: 0,
                    offsetY: 0
                  });
                  editor2.setInBackground();
                }
                setEditingState(isEditing) {
                  __privateGet(this, _uiManager).setEditingState(isEditing);
                }
                addCommands(params) {
                  __privateGet(this, _uiManager).addCommands(params);
                }
                enable() {
                  this.div.style.pointerEvents = "auto";
                  for (const editor2 of __privateGet(this, _editors).values()) {
                    editor2.enableEditing();
                  }
                }
                disable() {
                  this.div.style.pointerEvents = "none";
                  for (const editor2 of __privateGet(this, _editors).values()) {
                    editor2.disableEditing();
                  }
                }
                setActiveEditor(editor2) {
                  const currentActive = __privateGet(this, _uiManager).getActive();
                  if (currentActive === editor2) {
                    return;
                  }
                  __privateGet(this, _uiManager).setActiveEditor(editor2);
                }
                enableClick() {
                  this.div.addEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.addEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                disableClick() {
                  this.div.removeEventListener("pointerdown", __privateGet(this, _boundPointerdown));
                  this.div.removeEventListener("pointerup", __privateGet(this, _boundPointerup));
                }
                attach(editor2) {
                  __privateGet(this, _editors).set(editor2.id, editor2);
                }
                detach(editor2) {
                  __privateGet(this, _editors).delete(editor2.id);
                  __privateGet(this, _accessibilityManager)?.removePointerInTextLayer(editor2.contentDiv);
                }
                remove(editor2) {
                  __privateGet(this, _uiManager).removeEditor(editor2);
                  this.detach(editor2);
                  this.annotationStorage.remove(editor2.id);
                  editor2.div.style.display = "none";
                  setTimeout(() => {
                    editor2.div.style.display = "";
                    editor2.div.remove();
                    editor2.isAttachedToDOM = false;
                    if (document.activeElement === document.body) {
                      __privateGet(this, _uiManager).focusMainContainer();
                    }
                  }, 0);
                  if (!__privateGet(this, _isCleaningUp)) {
                    this.addInkEditorIfNeeded(false);
                  }
                }
                add(editor2) {
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor2);
                  __privateGet(this, _uiManager).addEditor(editor2);
                  this.attach(editor2);
                  if (!editor2.isAttachedToDOM) {
                    const div4 = editor2.render();
                    this.div.append(div4);
                    editor2.isAttachedToDOM = true;
                  }
                  this.moveEditorInDOM(editor2);
                  editor2.onceAdded();
                  this.addToAnnotationStorage(editor2);
                }
                moveEditorInDOM(editor2) {
                  __privateGet(this, _accessibilityManager)?.moveElementInDOM(this.div, editor2.div, editor2.contentDiv, true);
                }
                addToAnnotationStorage(editor2) {
                  if (!editor2.isEmpty() && !this.annotationStorage.has(editor2.id)) {
                    this.annotationStorage.setValue(editor2.id, editor2);
                  }
                }
                addOrRebuild(editor2) {
                  if (editor2.needsToBeRebuilt()) {
                    editor2.rebuild();
                  } else {
                    this.add(editor2);
                  }
                }
                addANewEditor(editor2) {
                  const cmd = () => {
                    this.addOrRebuild(editor2);
                  };
                  const undo = () => {
                    editor2.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: true
                  });
                }
                addUndoableEditor(editor2) {
                  const cmd = () => {
                    this.addOrRebuild(editor2);
                  };
                  const undo = () => {
                    editor2.remove();
                  };
                  this.addCommands({
                    cmd,
                    undo,
                    mustExec: false
                  });
                }
                getNextId() {
                  return __privateGet(this, _uiManager).getId();
                }
                deserialize(data) {
                  switch (data.annotationType) {
                    case _util2.AnnotationEditorType.FREETEXT:
                      return _freetext.FreeTextEditor.deserialize(data, this);
                    case _util2.AnnotationEditorType.INK:
                      return _ink.InkEditor.deserialize(data, this);
                  }
                  return null;
                }
                setSelected(editor2) {
                  __privateGet(this, _uiManager).setSelected(editor2);
                }
                toggleSelected(editor2) {
                  __privateGet(this, _uiManager).toggleSelected(editor2);
                }
                isSelected(editor2) {
                  return __privateGet(this, _uiManager).isSelected(editor2);
                }
                unselect(editor2) {
                  __privateGet(this, _uiManager).unselect(editor2);
                }
                pointerup(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  if (!__privateGet(this, _hadPointerDown)) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, false);
                  if (!__privateGet(this, _allowClick)) {
                    __privateSet(this, _allowClick, true);
                    return;
                  }
                  __privateMethod(this, _createAndAddNewEditor, createAndAddNewEditor_fn).call(this, event);
                }
                pointerdown(event) {
                  const isMac = _tools.KeyboardManager.platform.isMac;
                  if (event.button !== 0 || event.ctrlKey && isMac) {
                    return;
                  }
                  if (event.target !== this.div) {
                    return;
                  }
                  __privateSet(this, _hadPointerDown, true);
                  const editor2 = __privateGet(this, _uiManager).getActive();
                  __privateSet(this, _allowClick, !editor2 || editor2.isEmpty());
                }
                drop(event) {
                  const id2 = event.dataTransfer.getData("text/plain");
                  const editor2 = __privateGet(this, _uiManager).getEditor(id2);
                  if (!editor2) {
                    return;
                  }
                  event.preventDefault();
                  event.dataTransfer.dropEffect = "move";
                  __privateMethod(this, _changeParent, changeParent_fn).call(this, editor2);
                  const rect = this.div.getBoundingClientRect();
                  const endX = event.clientX - rect.x;
                  const endY = event.clientY - rect.y;
                  editor2.translate(endX - editor2.startX, endY - editor2.startY);
                  this.moveEditorInDOM(editor2);
                  editor2.div.focus();
                }
                dragover(event) {
                  event.preventDefault();
                }
                destroy() {
                  if (__privateGet(this, _uiManager).getActive()?.parent === this) {
                    __privateGet(this, _uiManager).setActiveEditor(null);
                  }
                  for (const editor2 of __privateGet(this, _editors).values()) {
                    __privateGet(this, _accessibilityManager)?.removePointerInTextLayer(editor2.contentDiv);
                    editor2.isAttachedToDOM = false;
                    editor2.div.remove();
                    editor2.parent = null;
                  }
                  this.div = null;
                  __privateGet(this, _editors).clear();
                  __privateGet(this, _uiManager).removeLayer(this);
                }
                render(parameters) {
                  this.viewport = parameters.viewport;
                  (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
                  this.setDimensions();
                  for (const editor2 of __privateGet(this, _uiManager).getEditors(this.pageIndex)) {
                    this.add(editor2);
                  }
                  this.updateMode();
                }
                update(parameters) {
                  this.viewport = parameters.viewport;
                  this.setDimensions();
                  this.updateMode();
                }
                get scaleFactor() {
                  return this.viewport.scale;
                }
                get pageDimensions() {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const width2 = pageURx - pageLLx;
                  const height2 = pageURy - pageLLy;
                  return [width2, height2];
                }
                get viewportBaseDimensions() {
                  const {
                    width: width2,
                    height: height2,
                    rotation
                  } = this.viewport;
                  return rotation % 180 === 0 ? [width2, height2] : [height2, width2];
                }
                setDimensions() {
                  const {
                    width: width2,
                    height: height2,
                    rotation
                  } = this.viewport;
                  const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width2) + "px", heightStr = Math.floor(height2) + "px";
                  this.div.style.width = flipOrientation ? heightStr : widthStr;
                  this.div.style.height = flipOrientation ? widthStr : heightStr;
                  this.div.setAttribute("data-main-rotation", rotation);
                }
              };
              let AnnotationEditorLayer = _AnnotationEditorLayer;
              _accessibilityManager = new WeakMap();
              _allowClick = new WeakMap();
              _boundPointerup = new WeakMap();
              _boundPointerdown = new WeakMap();
              _editors = new WeakMap();
              _hadPointerDown = new WeakMap();
              _isCleaningUp = new WeakMap();
              _uiManager = new WeakMap();
              _changeParent = new WeakSet();
              changeParent_fn = function(editor2) {
                if (editor2.parent === this) {
                  return;
                }
                this.attach(editor2);
                editor2.pageIndex = this.pageIndex;
                editor2.parent?.detach(editor2);
                editor2.parent = this;
                if (editor2.div && editor2.isAttachedToDOM) {
                  editor2.div.remove();
                  this.div.append(editor2.div);
                }
              };
              _createNewEditor = new WeakSet();
              createNewEditor_fn = function(params) {
                switch (__privateGet(this, _uiManager).getMode()) {
                  case _util2.AnnotationEditorType.FREETEXT:
                    return new _freetext.FreeTextEditor(params);
                  case _util2.AnnotationEditorType.INK:
                    return new _ink.InkEditor(params);
                }
                return null;
              };
              _createAndAddNewEditor = new WeakSet();
              createAndAddNewEditor_fn = function(event) {
                const id2 = this.getNextId();
                const editor2 = __privateMethod(this, _createNewEditor, createNewEditor_fn).call(this, {
                  parent: this,
                  id: id2,
                  x: event.offsetX,
                  y: event.offsetY
                });
                if (editor2) {
                  this.add(editor2);
                }
                return editor2;
              };
              _cleanup = new WeakSet();
              cleanup_fn = function() {
                __privateSet(this, _isCleaningUp, true);
                for (const editor2 of __privateGet(this, _editors).values()) {
                  if (editor2.isEmpty()) {
                    editor2.remove();
                  }
                }
                __privateSet(this, _isCleaningUp, false);
              };
              __publicField(AnnotationEditorLayer, "_initialized", false);
              exports2.AnnotationEditorLayer = AnnotationEditorLayer;
            },
            /* 23 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _boundEditorDivBlur, _boundEditorDivFocus, _boundEditorDivKeydown, _color, _content, _hasAlreadyBeenCommitted, _fontSize, _updateFontSize, updateFontSize_fn, _updateColor, updateColor_fn, _extractText, extractText_fn, _setEditorDimensions, setEditorDimensions_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.FreeTextEditor = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _tools = __w_pdfjs_require__2(7);
              var _editor = __w_pdfjs_require__2(6);
              const _FreeTextEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "freeTextEditor"
                  });
                  __privateAdd(this, _updateFontSize);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _extractText);
                  __privateAdd(this, _setEditorDimensions);
                  __privateAdd(this, _boundEditorDivBlur, this.editorDivBlur.bind(this));
                  __privateAdd(this, _boundEditorDivFocus, this.editorDivFocus.bind(this));
                  __privateAdd(this, _boundEditorDivKeydown, this.editorDivKeydown.bind(this));
                  __privateAdd(this, _color, void 0);
                  __privateAdd(this, _content, "");
                  __privateAdd(this, _hasAlreadyBeenCommitted, false);
                  __privateAdd(this, _fontSize, void 0);
                  __privateSet(this, _color, params.color || _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor);
                  __privateSet(this, _fontSize, params.fontSize || _FreeTextEditor._defaultFontSize);
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map((str5) => [str5, l10n.get(str5)]));
                  const style = getComputedStyle(document.documentElement);
                  this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
                }
                static updateDefaultParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      _FreeTextEditor._defaultFontSize = value2;
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      _FreeTextEditor._defaultColor = value2;
                      break;
                  }
                }
                updateParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.FREETEXT_SIZE:
                      __privateMethod(this, _updateFontSize, updateFontSize_fn).call(this, value2);
                      break;
                    case _util2.AnnotationEditorParamsType.FREETEXT_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value2);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.FREETEXT_SIZE, __privateGet(this, _fontSize)], [_util2.AnnotationEditorParamsType.FREETEXT_COLOR, __privateGet(this, _color)]];
                }
                getInitialTranslation() {
                  return [-_FreeTextEditor._internalPadding * this.parent.scaleFactor, -(_FreeTextEditor._internalPadding + __privateGet(this, _fontSize)) * this.parent.scaleFactor];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                  }
                }
                enableEditMode() {
                  if (this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(false);
                  this.parent.updateToolbar(_util2.AnnotationEditorType.FREETEXT);
                  super.enableEditMode();
                  this.enableEditing();
                  this.overlayDiv.classList.remove("enabled");
                  this.editorDiv.contentEditable = true;
                  this.div.draggable = false;
                  this.editorDiv.addEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.addEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.addEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                }
                disableEditMode() {
                  if (!this.isInEditMode()) {
                    return;
                  }
                  this.parent.setEditingState(true);
                  super.disableEditMode();
                  this.disableEditing();
                  this.overlayDiv.classList.add("enabled");
                  this.editorDiv.contentEditable = false;
                  this.div.draggable = true;
                  this.editorDiv.removeEventListener("keydown", __privateGet(this, _boundEditorDivKeydown));
                  this.editorDiv.removeEventListener("focus", __privateGet(this, _boundEditorDivFocus));
                  this.editorDiv.removeEventListener("blur", __privateGet(this, _boundEditorDivBlur));
                  this.div.focus();
                  this.isEditing = false;
                }
                focusin(event) {
                  super.focusin(event);
                  if (event.target !== this.editorDiv) {
                    this.editorDiv.focus();
                  }
                }
                onceAdded() {
                  if (this.width) {
                    return;
                  }
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                isEmpty() {
                  return !this.editorDiv || this.editorDiv.innerText.trim() === "";
                }
                remove() {
                  this.isEditing = false;
                  this.parent.setEditingState(true);
                  super.remove();
                }
                commit() {
                  super.commit();
                  if (!__privateGet(this, _hasAlreadyBeenCommitted)) {
                    __privateSet(this, _hasAlreadyBeenCommitted, true);
                    this.parent.addUndoableEditor(this);
                  }
                  this.disableEditMode();
                  __privateSet(this, _content, __privateMethod(this, _extractText, extractText_fn).call(this).trimEnd());
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                }
                shouldGetKeyboardEvents() {
                  return this.isInEditMode();
                }
                dblclick(event) {
                  this.enableEditMode();
                  this.editorDiv.focus();
                }
                keydown(event) {
                  if (event.target === this.div && event.key === "Enter") {
                    this.enableEditMode();
                    this.editorDiv.focus();
                  }
                }
                editorDivKeydown(event) {
                  _FreeTextEditor._keyboardManager.exec(this, event);
                }
                editorDivFocus(event) {
                  this.isEditing = true;
                }
                editorDivBlur(event) {
                  this.isEditing = false;
                }
                disableEditing() {
                  this.editorDiv.setAttribute("role", "comment");
                  this.editorDiv.removeAttribute("aria-multiline");
                }
                enableEditing() {
                  this.editorDiv.setAttribute("role", "textbox");
                  this.editorDiv.setAttribute("aria-multiline", true);
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  this.editorDiv = document.createElement("div");
                  this.editorDiv.className = "internal";
                  this.editorDiv.setAttribute("id", `${this.id}-editor`);
                  this.enableEditing();
                  _FreeTextEditor._l10nPromise.get("editor_free_text_aria_label").then((msg) => this.editorDiv?.setAttribute("aria-label", msg));
                  _FreeTextEditor._l10nPromise.get("free_text_default_content").then((msg) => this.editorDiv?.setAttribute("default-content", msg));
                  this.editorDiv.contentEditable = true;
                  const {
                    style
                  } = this.editorDiv;
                  style.fontSize = `calc(${__privateGet(this, _fontSize)}px * var(--scale-factor))`;
                  style.color = __privateGet(this, _color);
                  this.div.append(this.editorDiv);
                  this.overlayDiv = document.createElement("div");
                  this.overlayDiv.classList.add("overlay", "enabled");
                  this.div.append(this.overlayDiv);
                  (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    for (const line of __privateGet(this, _content).split("\n")) {
                      const div4 = document.createElement("div");
                      div4.append(line ? document.createTextNode(line) : document.createElement("br"));
                      this.editorDiv.append(div4);
                    }
                    this.div.draggable = true;
                    this.editorDiv.contentEditable = false;
                  } else {
                    this.div.draggable = false;
                    this.editorDiv.contentEditable = true;
                  }
                  return this.div;
                }
                get contentDiv() {
                  return this.editorDiv;
                }
                static deserialize(data, parent) {
                  const editor2 = super.deserialize(data, parent);
                  __privateSet(editor2, _fontSize, data.fontSize);
                  __privateSet(editor2, _color, _util2.Util.makeHexColor(...data.color));
                  __privateSet(editor2, _content, data.value);
                  return editor2;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const padding2 = _FreeTextEditor._internalPadding * this.parent.scaleFactor;
                  const rect = this.getRect(padding2, padding2);
                  const color2 = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);
                  return {
                    annotationType: _util2.AnnotationEditorType.FREETEXT,
                    color: color2,
                    fontSize: __privateGet(this, _fontSize),
                    value: __privateGet(this, _content),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let FreeTextEditor = _FreeTextEditor;
              _boundEditorDivBlur = new WeakMap();
              _boundEditorDivFocus = new WeakMap();
              _boundEditorDivKeydown = new WeakMap();
              _color = new WeakMap();
              _content = new WeakMap();
              _hasAlreadyBeenCommitted = new WeakMap();
              _fontSize = new WeakMap();
              _updateFontSize = new WeakSet();
              updateFontSize_fn = function(fontSize2) {
                const setFontsize = (size4) => {
                  this.editorDiv.style.fontSize = `calc(${size4}px * var(--scale-factor))`;
                  this.translate(0, -(size4 - __privateGet(this, _fontSize)) * this.parent.scaleFactor);
                  __privateSet(this, _fontSize, size4);
                  __privateMethod(this, _setEditorDimensions, setEditorDimensions_fn).call(this);
                };
                const savedFontsize = __privateGet(this, _fontSize);
                this.parent.addCommands({
                  cmd: () => {
                    setFontsize(fontSize2);
                  },
                  undo: () => {
                    setFontsize(savedFontsize);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_SIZE,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color2) {
                const savedColor = __privateGet(this, _color);
                this.parent.addCommands({
                  cmd: () => {
                    __privateSet(this, _color, color2);
                    this.editorDiv.style.color = color2;
                  },
                  undo: () => {
                    __privateSet(this, _color, savedColor);
                    this.editorDiv.style.color = savedColor;
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.FREETEXT_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _extractText = new WeakSet();
              extractText_fn = function() {
                const divs = this.editorDiv.getElementsByTagName("div");
                if (divs.length === 0) {
                  return this.editorDiv.innerText;
                }
                const buffer = [];
                for (let i = 0, ii = divs.length; i < ii; i++) {
                  const div4 = divs[i];
                  const first = div4.firstChild;
                  if (first?.nodeName === "#text") {
                    buffer.push(first.data);
                  } else {
                    buffer.push("");
                  }
                }
                return buffer.join("\n");
              };
              _setEditorDimensions = new WeakSet();
              setEditorDimensions_fn = function() {
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                const rect = this.div.getBoundingClientRect();
                this.width = rect.width / parentWidth;
                this.height = rect.height / parentHeight;
              };
              __publicField(FreeTextEditor, "_freeTextDefaultContent", "");
              __publicField(FreeTextEditor, "_l10nPromise");
              __publicField(FreeTextEditor, "_internalPadding", 0);
              __publicField(FreeTextEditor, "_defaultColor", null);
              __publicField(FreeTextEditor, "_defaultFontSize", 10);
              __publicField(FreeTextEditor, "_keyboardManager", new _tools.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], _FreeTextEditor.prototype.commitOrRemove]]));
              __publicField(FreeTextEditor, "_type", "freetext");
              exports2.FreeTextEditor = FreeTextEditor;
            },
            /* 24 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _aspectRatio, _baseHeight, _baseWidth, _boundCanvasPointermove, _boundCanvasPointerleave, _boundCanvasPointerup, _boundCanvasPointerdown, _disableEditing, _isCanvasInitialized, _lastPoint, _observer, _realWidth, _realHeight, _requestFrameCallback, _updateThickness, updateThickness_fn, _updateColor, updateColor_fn, _updateOpacity, updateOpacity_fn, _getInitialBBox, getInitialBBox_fn, _setStroke, setStroke_fn, _startDrawing, startDrawing_fn, _draw, draw_fn, _stopDrawing, stopDrawing_fn, _redraw, redraw_fn, _endDrawing, endDrawing_fn, _createCanvas, createCanvas_fn, _createObserver, createObserver_fn, _setCanvasDims, setCanvasDims_fn, _setScaleFactor, setScaleFactor_fn, _updateTransform, updateTransform_fn, _buildPath2D, buildPath2D_fn, _serializePaths, serializePaths_fn, _extractPointsOnBezier, extractPointsOnBezier_fn, _isAlmostFlat, isAlmostFlat_fn, _getBbox, getBbox_fn, _getPadding, getPadding_fn, _fitToContent, fitToContent_fn, _setMinDims, setMinDims_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.InkEditor = void 0;
              Object.defineProperty(exports2, "fitCurve", {
                enumerable: true,
                get: function() {
                  return _pdfjsFitCurve.fitCurve;
                }
              });
              var _util2 = __w_pdfjs_require__2(1);
              var _editor = __w_pdfjs_require__2(6);
              var _pdfjsFitCurve = __w_pdfjs_require__2(25);
              var _tools = __w_pdfjs_require__2(7);
              const RESIZER_SIZE = 16;
              const _InkEditor = class extends _editor.AnnotationEditor {
                constructor(params) {
                  super({
                    ...params,
                    name: "inkEditor"
                  });
                  __privateAdd(this, _updateThickness);
                  __privateAdd(this, _updateColor);
                  __privateAdd(this, _updateOpacity);
                  __privateAdd(this, _getInitialBBox);
                  __privateAdd(this, _setStroke);
                  __privateAdd(this, _startDrawing);
                  __privateAdd(this, _draw);
                  __privateAdd(this, _stopDrawing);
                  __privateAdd(this, _redraw);
                  __privateAdd(this, _endDrawing);
                  __privateAdd(this, _createCanvas);
                  __privateAdd(this, _createObserver);
                  __privateAdd(this, _setCanvasDims);
                  __privateAdd(this, _setScaleFactor);
                  __privateAdd(this, _updateTransform);
                  __privateAdd(this, _serializePaths);
                  __privateAdd(this, _extractPointsOnBezier);
                  __privateAdd(this, _isAlmostFlat);
                  __privateAdd(this, _getBbox);
                  __privateAdd(this, _getPadding);
                  __privateAdd(this, _fitToContent);
                  __privateAdd(this, _setMinDims);
                  __privateAdd(this, _aspectRatio, 0);
                  __privateAdd(this, _baseHeight, 0);
                  __privateAdd(this, _baseWidth, 0);
                  __privateAdd(this, _boundCanvasPointermove, this.canvasPointermove.bind(this));
                  __privateAdd(this, _boundCanvasPointerleave, this.canvasPointerleave.bind(this));
                  __privateAdd(this, _boundCanvasPointerup, this.canvasPointerup.bind(this));
                  __privateAdd(this, _boundCanvasPointerdown, this.canvasPointerdown.bind(this));
                  __privateAdd(this, _disableEditing, false);
                  __privateAdd(this, _isCanvasInitialized, false);
                  __privateAdd(this, _lastPoint, null);
                  __privateAdd(this, _observer, null);
                  __privateAdd(this, _realWidth, 0);
                  __privateAdd(this, _realHeight, 0);
                  __privateAdd(this, _requestFrameCallback, null);
                  this.color = params.color || null;
                  this.thickness = params.thickness || null;
                  this.opacity = params.opacity || null;
                  this.paths = [];
                  this.bezierPath2D = [];
                  this.currentPath = [];
                  this.scaleFactor = 1;
                  this.translationX = this.translationY = 0;
                  this.x = 0;
                  this.y = 0;
                }
                static initialize(l10n) {
                  this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map((str5) => [str5, l10n.get(str5)]));
                }
                static updateDefaultParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      _InkEditor._defaultThickness = value2;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      _InkEditor._defaultColor = value2;
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      _InkEditor._defaultOpacity = value2 / 100;
                      break;
                  }
                }
                updateParams(type2, value2) {
                  switch (type2) {
                    case _util2.AnnotationEditorParamsType.INK_THICKNESS:
                      __privateMethod(this, _updateThickness, updateThickness_fn).call(this, value2);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_COLOR:
                      __privateMethod(this, _updateColor, updateColor_fn).call(this, value2);
                      break;
                    case _util2.AnnotationEditorParamsType.INK_OPACITY:
                      __privateMethod(this, _updateOpacity, updateOpacity_fn).call(this, value2);
                      break;
                  }
                }
                static get defaultPropertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(_InkEditor._defaultOpacity * 100)]];
                }
                get propertiesToUpdate() {
                  return [[_util2.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || _InkEditor._defaultThickness], [_util2.AnnotationEditorParamsType.INK_COLOR, this.color || _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util2.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? _InkEditor._defaultOpacity))]];
                }
                rebuild() {
                  super.rebuild();
                  if (this.div === null) {
                    return;
                  }
                  if (!this.canvas) {
                    __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                    __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  }
                  if (!this.isAttachedToDOM) {
                    this.parent.add(this);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  }
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                }
                remove() {
                  if (this.canvas === null) {
                    return;
                  }
                  if (!this.isEmpty()) {
                    this.commit();
                  }
                  this.canvas.width = this.canvas.height = 0;
                  this.canvas.remove();
                  this.canvas = null;
                  __privateGet(this, _observer).disconnect();
                  __privateSet(this, _observer, null);
                  super.remove();
                }
                enableEditMode() {
                  if (__privateGet(this, _disableEditing) || this.canvas === null) {
                    return;
                  }
                  super.enableEditMode();
                  this.div.draggable = false;
                  this.canvas.addEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                  this.canvas.addEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                }
                disableEditMode() {
                  if (!this.isInEditMode() || this.canvas === null) {
                    return;
                  }
                  super.disableEditMode();
                  this.div.draggable = !this.isEmpty();
                  this.div.classList.remove("editing");
                  this.canvas.removeEventListener("pointerdown", __privateGet(this, _boundCanvasPointerdown));
                  this.canvas.removeEventListener("pointerup", __privateGet(this, _boundCanvasPointerup));
                }
                onceAdded() {
                  this.div.draggable = !this.isEmpty();
                }
                isEmpty() {
                  return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
                }
                commit() {
                  if (__privateGet(this, _disableEditing)) {
                    return;
                  }
                  super.commit();
                  this.isEditing = false;
                  this.disableEditMode();
                  this.setInForeground();
                  __privateSet(this, _disableEditing, true);
                  this.div.classList.add("disabled");
                  __privateMethod(this, _fitToContent, fitToContent_fn).call(this, true);
                  this.parent.addInkEditorIfNeeded(true);
                  this.parent.moveEditorInDOM(this);
                  this.div.focus();
                }
                focusin(event) {
                  super.focusin(event);
                  this.enableEditMode();
                }
                canvasPointerdown(event) {
                  if (event.button !== 0 || !this.isInEditMode() || __privateGet(this, _disableEditing)) {
                    return;
                  }
                  this.setInForeground();
                  if (event.type !== "mouse") {
                    this.div.focus();
                  }
                  event.stopPropagation();
                  this.canvas.addEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                  this.canvas.addEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                  __privateMethod(this, _startDrawing, startDrawing_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointermove(event) {
                  event.stopPropagation();
                  __privateMethod(this, _draw, draw_fn).call(this, event.offsetX, event.offsetY);
                }
                canvasPointerup(event) {
                  if (event.button !== 0) {
                    return;
                  }
                  if (this.isInEditMode() && this.currentPath.length !== 0) {
                    event.stopPropagation();
                    __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                    this.setInBackground();
                  }
                }
                canvasPointerleave(event) {
                  __privateMethod(this, _endDrawing, endDrawing_fn).call(this, event);
                  this.setInBackground();
                }
                render() {
                  if (this.div) {
                    return this.div;
                  }
                  let baseX, baseY;
                  if (this.width) {
                    baseX = this.x;
                    baseY = this.y;
                  }
                  super.render();
                  _InkEditor._l10nPromise.get("editor_ink_aria_label").then((msg) => this.div?.setAttribute("aria-label", msg));
                  const [x, y, w, h] = __privateMethod(this, _getInitialBBox, getInitialBBox_fn).call(this);
                  this.setAt(x, y, 0, 0);
                  this.setDims(w, h);
                  __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                  if (this.width) {
                    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
                    __privateSet(this, _isCanvasInitialized, true);
                    __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                    this.setDims(this.width * parentWidth, this.height * parentHeight);
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                    __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                    this.div.classList.add("disabled");
                  } else {
                    this.div.classList.add("editing");
                    this.enableEditMode();
                  }
                  __privateMethod(this, _createObserver, createObserver_fn).call(this);
                  return this.div;
                }
                setDimensions(width2, height2) {
                  const roundedWidth = Math.round(width2);
                  const roundedHeight = Math.round(height2);
                  if (__privateGet(this, _realWidth) === roundedWidth && __privateGet(this, _realHeight) === roundedHeight) {
                    return;
                  }
                  __privateSet(this, _realWidth, roundedWidth);
                  __privateSet(this, _realHeight, roundedHeight);
                  this.canvas.style.visibility = "hidden";
                  if (__privateGet(this, _aspectRatio) && Math.abs(__privateGet(this, _aspectRatio) - width2 / height2) > 0.01) {
                    height2 = Math.ceil(width2 / __privateGet(this, _aspectRatio));
                    this.setDims(width2, height2);
                  }
                  const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                  this.width = width2 / parentWidth;
                  this.height = height2 / parentHeight;
                  if (__privateGet(this, _disableEditing)) {
                    __privateMethod(this, _setScaleFactor, setScaleFactor_fn).call(this, width2, height2);
                  }
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  this.canvas.style.visibility = "visible";
                }
                static deserialize(data, parent) {
                  var _a, _b;
                  const editor2 = super.deserialize(data, parent);
                  editor2.thickness = data.thickness;
                  editor2.color = _util2.Util.makeHexColor(...data.color);
                  editor2.opacity = data.opacity;
                  const [pageWidth, pageHeight] = parent.pageDimensions;
                  const width2 = editor2.width * pageWidth;
                  const height2 = editor2.height * pageHeight;
                  const scaleFactor = parent.scaleFactor;
                  const padding2 = data.thickness / 2;
                  __privateSet(editor2, _aspectRatio, width2 / height2);
                  __privateSet(editor2, _disableEditing, true);
                  __privateSet(editor2, _realWidth, Math.round(width2));
                  __privateSet(editor2, _realHeight, Math.round(height2));
                  for (const {
                    bezier: bezier3
                  } of data.paths) {
                    const path = [];
                    editor2.paths.push(path);
                    let p0 = scaleFactor * (bezier3[0] - padding2);
                    let p1 = scaleFactor * (height2 - bezier3[1] - padding2);
                    for (let i = 2, ii = bezier3.length; i < ii; i += 6) {
                      const p10 = scaleFactor * (bezier3[i] - padding2);
                      const p11 = scaleFactor * (height2 - bezier3[i + 1] - padding2);
                      const p20 = scaleFactor * (bezier3[i + 2] - padding2);
                      const p21 = scaleFactor * (height2 - bezier3[i + 3] - padding2);
                      const p30 = scaleFactor * (bezier3[i + 4] - padding2);
                      const p31 = scaleFactor * (height2 - bezier3[i + 5] - padding2);
                      path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
                      p0 = p30;
                      p1 = p31;
                    }
                    const path2D = __privateMethod(this, _buildPath2D, buildPath2D_fn).call(this, path);
                    editor2.bezierPath2D.push(path2D);
                  }
                  const bbox = __privateMethod(_a = editor2, _getBbox, getBbox_fn).call(_a);
                  __privateSet(editor2, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                  __privateSet(editor2, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                  __privateMethod(_b = editor2, _setScaleFactor, setScaleFactor_fn).call(_b, width2, height2);
                  return editor2;
                }
                serialize() {
                  if (this.isEmpty()) {
                    return null;
                  }
                  const rect = this.getRect(0, 0);
                  const height2 = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];
                  const color2 = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
                  return {
                    annotationType: _util2.AnnotationEditorType.INK,
                    color: color2,
                    thickness: this.thickness,
                    opacity: this.opacity,
                    paths: __privateMethod(this, _serializePaths, serializePaths_fn).call(this, this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height2),
                    pageIndex: this.parent.pageIndex,
                    rect,
                    rotation: this.rotation
                  };
                }
              };
              let InkEditor = _InkEditor;
              _aspectRatio = new WeakMap();
              _baseHeight = new WeakMap();
              _baseWidth = new WeakMap();
              _boundCanvasPointermove = new WeakMap();
              _boundCanvasPointerleave = new WeakMap();
              _boundCanvasPointerup = new WeakMap();
              _boundCanvasPointerdown = new WeakMap();
              _disableEditing = new WeakMap();
              _isCanvasInitialized = new WeakMap();
              _lastPoint = new WeakMap();
              _observer = new WeakMap();
              _realWidth = new WeakMap();
              _realHeight = new WeakMap();
              _requestFrameCallback = new WeakMap();
              _updateThickness = new WeakSet();
              updateThickness_fn = function(thickness) {
                const savedThickness = this.thickness;
                this.parent.addCommands({
                  cmd: () => {
                    this.thickness = thickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  undo: () => {
                    this.thickness = savedThickness;
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_THICKNESS,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateColor = new WeakSet();
              updateColor_fn = function(color2) {
                const savedColor = this.color;
                this.parent.addCommands({
                  cmd: () => {
                    this.color = color2;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.color = savedColor;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_COLOR,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _updateOpacity = new WeakSet();
              updateOpacity_fn = function(opacity2) {
                opacity2 /= 100;
                const savedOpacity = this.opacity;
                this.parent.addCommands({
                  cmd: () => {
                    this.opacity = opacity2;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  undo: () => {
                    this.opacity = savedOpacity;
                    __privateMethod(this, _redraw, redraw_fn).call(this);
                  },
                  mustExec: true,
                  type: _util2.AnnotationEditorParamsType.INK_OPACITY,
                  overwriteIfSameType: true,
                  keepUndo: true
                });
              };
              _getInitialBBox = new WeakSet();
              getInitialBBox_fn = function() {
                const {
                  width: width2,
                  height: height2,
                  rotation
                } = this.parent.viewport;
                switch (rotation) {
                  case 90:
                    return [0, width2, width2, height2];
                  case 180:
                    return [width2, height2, width2, height2];
                  case 270:
                    return [height2, 0, width2, height2];
                  default:
                    return [0, 0, width2, height2];
                }
              };
              _setStroke = new WeakSet();
              setStroke_fn = function() {
                this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;
                this.ctx.lineCap = "round";
                this.ctx.lineJoin = "round";
                this.ctx.miterLimit = 10;
                this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;
              };
              _startDrawing = new WeakSet();
              startDrawing_fn = function(x, y) {
                this.isEditing = true;
                if (!__privateGet(this, _isCanvasInitialized)) {
                  __privateSet(this, _isCanvasInitialized, true);
                  __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                  this.thickness ||= _InkEditor._defaultThickness;
                  this.color ||= _InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
                  this.opacity ??= _InkEditor._defaultOpacity;
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _lastPoint, null);
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);
                __privateSet(this, _requestFrameCallback, () => {
                  if (!__privateGet(this, _requestFrameCallback)) {
                    return;
                  }
                  if (__privateGet(this, _lastPoint)) {
                    if (this.isEmpty()) {
                      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } else {
                      __privateMethod(this, _redraw, redraw_fn).call(this);
                    }
                    this.ctx.lineTo(...__privateGet(this, _lastPoint));
                    __privateSet(this, _lastPoint, null);
                    this.ctx.stroke();
                  }
                  window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
                });
                window.requestAnimationFrame(__privateGet(this, _requestFrameCallback));
              };
              _draw = new WeakSet();
              draw_fn = function(x, y) {
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x === lastX && y === lastY) {
                  return;
                }
                this.currentPath.push([x, y]);
                __privateSet(this, _lastPoint, [x, y]);
              };
              _stopDrawing = new WeakSet();
              stopDrawing_fn = function(x, y) {
                var _a;
                this.ctx.closePath();
                __privateSet(this, _requestFrameCallback, null);
                x = Math.min(Math.max(x, 0), this.canvas.width);
                y = Math.min(Math.max(y, 0), this.canvas.height);
                const [lastX, lastY] = this.currentPath.at(-1);
                if (x !== lastX || y !== lastY) {
                  this.currentPath.push([x, y]);
                }
                let bezier3;
                if (this.currentPath.length !== 1) {
                  bezier3 = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);
                } else {
                  const xy = [x, y];
                  bezier3 = [[xy, xy.slice(), xy.slice(), xy]];
                }
                const path2D = __privateMethod(_a = _InkEditor, _buildPath2D, buildPath2D_fn).call(_a, bezier3);
                this.currentPath.length = 0;
                const cmd = () => {
                  this.paths.push(bezier3);
                  this.bezierPath2D.push(path2D);
                  this.rebuild();
                };
                const undo = () => {
                  this.paths.pop();
                  this.bezierPath2D.pop();
                  if (this.paths.length === 0) {
                    this.remove();
                  } else {
                    if (!this.canvas) {
                      __privateMethod(this, _createCanvas, createCanvas_fn).call(this);
                      __privateMethod(this, _createObserver, createObserver_fn).call(this);
                    }
                    __privateMethod(this, _fitToContent, fitToContent_fn).call(this);
                  }
                };
                this.parent.addCommands({
                  cmd,
                  undo,
                  mustExec: true
                });
              };
              _redraw = new WeakSet();
              redraw_fn = function() {
                if (this.isEmpty()) {
                  __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                  return;
                }
                __privateMethod(this, _setStroke, setStroke_fn).call(this);
                const {
                  canvas,
                  ctx
                } = this;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
                for (const path of this.bezierPath2D) {
                  ctx.stroke(path);
                }
              };
              _endDrawing = new WeakSet();
              endDrawing_fn = function(event) {
                __privateMethod(this, _stopDrawing, stopDrawing_fn).call(this, event.offsetX, event.offsetY);
                this.canvas.removeEventListener("pointerleave", __privateGet(this, _boundCanvasPointerleave));
                this.canvas.removeEventListener("pointermove", __privateGet(this, _boundCanvasPointermove));
                this.parent.addToAnnotationStorage(this);
              };
              _createCanvas = new WeakSet();
              createCanvas_fn = function() {
                this.canvas = document.createElement("canvas");
                this.canvas.width = this.canvas.height = 0;
                this.canvas.className = "inkEditorCanvas";
                _InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((msg) => this.canvas?.setAttribute("aria-label", msg));
                this.div.append(this.canvas);
                this.ctx = this.canvas.getContext("2d");
              };
              _createObserver = new WeakSet();
              createObserver_fn = function() {
                __privateSet(this, _observer, new ResizeObserver((entries) => {
                  const rect = entries[0].contentRect;
                  if (rect.width && rect.height) {
                    this.setDimensions(rect.width, rect.height);
                  }
                }));
                __privateGet(this, _observer).observe(this.div);
              };
              _setCanvasDims = new WeakSet();
              setCanvasDims_fn = function() {
                if (!__privateGet(this, _isCanvasInitialized)) {
                  return;
                }
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.canvas.width = Math.ceil(this.width * parentWidth);
                this.canvas.height = Math.ceil(this.height * parentHeight);
                __privateMethod(this, _updateTransform, updateTransform_fn).call(this);
              };
              _setScaleFactor = new WeakSet();
              setScaleFactor_fn = function(width2, height2) {
                const padding2 = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                const scaleFactorW = (width2 - padding2) / __privateGet(this, _baseWidth);
                const scaleFactorH = (height2 - padding2) / __privateGet(this, _baseHeight);
                this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
              };
              _updateTransform = new WeakSet();
              updateTransform_fn = function() {
                const padding2 = __privateMethod(this, _getPadding, getPadding_fn).call(this) / 2;
                this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding2, this.translationY * this.scaleFactor + padding2);
              };
              _buildPath2D = new WeakSet();
              buildPath2D_fn = function(bezier3) {
                const path2D = new Path2D();
                for (let i = 0, ii = bezier3.length; i < ii; i++) {
                  const [first, control1, control2, second] = bezier3[i];
                  if (i === 0) {
                    path2D.moveTo(...first);
                  }
                  path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
                }
                return path2D;
              };
              _serializePaths = new WeakSet();
              serializePaths_fn = function(s, tx, ty, h) {
                const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;
                const paths = [];
                const padding2 = this.thickness / 2;
                let buffer, points;
                for (const bezier3 of this.paths) {
                  buffer = [];
                  points = [];
                  for (let i = 0, ii = bezier3.length; i < ii; i++) {
                    const [first, control1, control2, second] = bezier3[i];
                    const p10 = s * (first[0] + tx) + padding2;
                    const p11 = h - s * (first[1] + ty) - padding2;
                    const p20 = s * (control1[0] + tx) + padding2;
                    const p21 = h - s * (control1[1] + ty) - padding2;
                    const p30 = s * (control2[0] + tx) + padding2;
                    const p31 = h - s * (control2[1] + ty) - padding2;
                    const p40 = s * (second[0] + tx) + padding2;
                    const p41 = h - s * (second[1] + ty) - padding2;
                    if (i === 0) {
                      buffer.push(p10, p11);
                      points.push(p10, p11);
                    }
                    buffer.push(p20, p21, p30, p31, p40, p41);
                    __privateMethod(this, _extractPointsOnBezier, extractPointsOnBezier_fn).call(this, p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);
                  }
                  paths.push({
                    bezier: buffer,
                    points
                  });
                }
                return paths;
              };
              _extractPointsOnBezier = new WeakSet();
              extractPointsOnBezier_fn = function(p10, p11, p20, p21, p30, p31, p40, p41, n2, points) {
                if (__privateMethod(this, _isAlmostFlat, isAlmostFlat_fn).call(this, p10, p11, p20, p21, p30, p31, p40, p41)) {
                  points.push(p40, p41);
                  return;
                }
                for (let i = 1; i < n2 - 1; i++) {
                  const t2 = i / n2;
                  const mt = 1 - t2;
                  let q10 = t2 * p10 + mt * p20;
                  let q11 = t2 * p11 + mt * p21;
                  let q20 = t2 * p20 + mt * p30;
                  let q21 = t2 * p21 + mt * p31;
                  const q30 = t2 * p30 + mt * p40;
                  const q31 = t2 * p31 + mt * p41;
                  q10 = t2 * q10 + mt * q20;
                  q11 = t2 * q11 + mt * q21;
                  q20 = t2 * q20 + mt * q30;
                  q21 = t2 * q21 + mt * q31;
                  q10 = t2 * q10 + mt * q20;
                  q11 = t2 * q11 + mt * q21;
                  points.push(q10, q11);
                }
                points.push(p40, p41);
              };
              _isAlmostFlat = new WeakSet();
              isAlmostFlat_fn = function(p10, p11, p20, p21, p30, p31, p40, p41) {
                const tol = 10;
                const ax = (3 * p20 - 2 * p10 - p40) ** 2;
                const ay = (3 * p21 - 2 * p11 - p41) ** 2;
                const bx = (3 * p30 - p10 - 2 * p40) ** 2;
                const by = (3 * p31 - p11 - 2 * p41) ** 2;
                return Math.max(ax, bx) + Math.max(ay, by) <= tol;
              };
              _getBbox = new WeakSet();
              getBbox_fn = function() {
                let xMin = Infinity;
                let xMax = -Infinity;
                let yMin = Infinity;
                let yMax = -Infinity;
                for (const path of this.paths) {
                  for (const [first, control1, control2, second] of path) {
                    const bbox = _util2.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);
                    xMin = Math.min(xMin, bbox[0]);
                    yMin = Math.min(yMin, bbox[1]);
                    xMax = Math.max(xMax, bbox[2]);
                    yMax = Math.max(yMax, bbox[3]);
                  }
                }
                return [xMin, yMin, xMax, yMax];
              };
              _getPadding = new WeakSet();
              getPadding_fn = function() {
                return __privateGet(this, _disableEditing) ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
              };
              _fitToContent = new WeakSet();
              fitToContent_fn = function(firstTime = false) {
                if (this.isEmpty()) {
                  return;
                }
                if (!__privateGet(this, _disableEditing)) {
                  __privateMethod(this, _redraw, redraw_fn).call(this);
                  return;
                }
                const bbox = __privateMethod(this, _getBbox, getBbox_fn).call(this);
                const padding2 = __privateMethod(this, _getPadding, getPadding_fn).call(this);
                __privateSet(this, _baseWidth, Math.max(RESIZER_SIZE, bbox[2] - bbox[0]));
                __privateSet(this, _baseHeight, Math.max(RESIZER_SIZE, bbox[3] - bbox[1]));
                const width2 = Math.ceil(padding2 + __privateGet(this, _baseWidth) * this.scaleFactor);
                const height2 = Math.ceil(padding2 + __privateGet(this, _baseHeight) * this.scaleFactor);
                const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
                this.width = width2 / parentWidth;
                this.height = height2 / parentHeight;
                __privateSet(this, _aspectRatio, width2 / height2);
                __privateMethod(this, _setMinDims, setMinDims_fn).call(this);
                const prevTranslationX = this.translationX;
                const prevTranslationY = this.translationY;
                this.translationX = -bbox[0];
                this.translationY = -bbox[1];
                __privateMethod(this, _setCanvasDims, setCanvasDims_fn).call(this);
                __privateMethod(this, _redraw, redraw_fn).call(this);
                __privateSet(this, _realWidth, width2);
                __privateSet(this, _realHeight, height2);
                this.setDims(width2, height2);
                const unscaledPadding = firstTime ? padding2 / this.scaleFactor / 2 : 0;
                this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
              };
              _setMinDims = new WeakSet();
              setMinDims_fn = function() {
                const {
                  style
                } = this.div;
                if (__privateGet(this, _aspectRatio) >= 1) {
                  style.minHeight = `${RESIZER_SIZE}px`;
                  style.minWidth = `${Math.round(__privateGet(this, _aspectRatio) * RESIZER_SIZE)}px`;
                } else {
                  style.minWidth = `${RESIZER_SIZE}px`;
                  style.minHeight = `${Math.round(RESIZER_SIZE / __privateGet(this, _aspectRatio))}px`;
                }
              };
              __privateAdd(InkEditor, _buildPath2D);
              __publicField(InkEditor, "_defaultColor", null);
              __publicField(InkEditor, "_defaultOpacity", 1);
              __publicField(InkEditor, "_defaultThickness", 1);
              __publicField(InkEditor, "_l10nPromise");
              __publicField(InkEditor, "_type", "ink");
              exports2.InkEditor = InkEditor;
            },
            /* 25 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.fitCurve = void 0;
              const fitCurve = __w_pdfjs_require__2(26);
              exports2.fitCurve = fitCurve;
            },
            /* 26 */
            /***/
            (module2) => {
              function fitCurve(points, maxError, progressCallback) {
                if (!Array.isArray(points)) {
                  throw new TypeError("First argument should be an array");
                }
                points.forEach((point) => {
                  if (!Array.isArray(point) || point.some((item) => typeof item !== "number") || point.length !== points[0].length) {
                    throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
                  }
                });
                points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));
                if (points.length < 2) {
                  return [];
                }
                const len6 = points.length;
                const leftTangent = createTangent(points[1], points[0]);
                const rightTangent = createTangent(points[len6 - 2], points[len6 - 1]);
                return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
              }
              function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
                const MaxIterations = 20;
                var bezCurve, u2, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist4, i;
                if (points.length === 2) {
                  dist4 = maths.vectorLen(maths.subtract(points[0], points[1])) / 3;
                  bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist4)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist4)), points[1]];
                  return [bezCurve];
                }
                u2 = chordLengthParameterize(points);
                [bezCurve, maxError, splitPoint] = generateAndReport(points, u2, u2, leftTangent, rightTangent, progressCallback);
                if (maxError === 0 || maxError < error) {
                  return [bezCurve];
                }
                if (maxError < error * error) {
                  uPrime = u2;
                  prevErr = maxError;
                  prevSplit = splitPoint;
                  for (i = 0; i < MaxIterations; i++) {
                    uPrime = reparameterize(bezCurve, points, uPrime);
                    [bezCurve, maxError, splitPoint] = generateAndReport(points, u2, uPrime, leftTangent, rightTangent, progressCallback);
                    if (maxError < error) {
                      return [bezCurve];
                    } else if (splitPoint === prevSplit) {
                      let errChange = maxError / prevErr;
                      if (errChange > 0.9999 && errChange < 1.0001) {
                        break;
                      }
                    }
                    prevErr = maxError;
                    prevSplit = splitPoint;
                  }
                }
                beziers = [];
                centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);
                if (centerVector.every((val) => val === 0)) {
                  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
                  [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
                }
                toCenterTangent = maths.normalize(centerVector);
                fromCenterTangent = maths.mulItems(toCenterTangent, -1);
                beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
                beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
                return beziers;
              }
              ;
              function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
                var bezCurve, maxError, splitPoint;
                bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
                [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);
                if (progressCallback) {
                  progressCallback({
                    bez: bezCurve,
                    points,
                    params: paramsOrig,
                    maxErr: maxError,
                    maxPoint: splitPoint
                  });
                }
                return [bezCurve, maxError, splitPoint];
              }
              function generateBezier(points, parameters, leftTangent, rightTangent) {
                var bezCurve, A3, a, C2, X, det_C0_C1, det_C0_X, det_X_C1, alpha_l, alpha_r, epsilon, segLength, i, len6, tmp, u2, ux, firstPoint = points[0], lastPoint = points[points.length - 1];
                bezCurve = [firstPoint, null, null, lastPoint];
                A3 = maths.zeros_Xx2x2(parameters.length);
                for (i = 0, len6 = parameters.length; i < len6; i++) {
                  u2 = parameters[i];
                  ux = 1 - u2;
                  a = A3[i];
                  a[0] = maths.mulItems(leftTangent, 3 * u2 * (ux * ux));
                  a[1] = maths.mulItems(rightTangent, 3 * ux * (u2 * u2));
                }
                C2 = [[0, 0], [0, 0]];
                X = [0, 0];
                for (i = 0, len6 = points.length; i < len6; i++) {
                  u2 = parameters[i];
                  a = A3[i];
                  C2[0][0] += maths.dot(a[0], a[0]);
                  C2[0][1] += maths.dot(a[0], a[1]);
                  C2[1][0] += maths.dot(a[0], a[1]);
                  C2[1][1] += maths.dot(a[1], a[1]);
                  tmp = maths.subtract(points[i], bezier3.q([firstPoint, firstPoint, lastPoint, lastPoint], u2));
                  X[0] += maths.dot(a[0], tmp);
                  X[1] += maths.dot(a[1], tmp);
                }
                det_C0_C1 = C2[0][0] * C2[1][1] - C2[1][0] * C2[0][1];
                det_C0_X = C2[0][0] * X[1] - C2[1][0] * X[0];
                det_X_C1 = X[0] * C2[1][1] - X[1] * C2[0][1];
                alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
                alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
                segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
                epsilon = 1e-6 * segLength;
                if (alpha_l < epsilon || alpha_r < epsilon) {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3));
                } else {
                  bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
                  bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
                }
                return bezCurve;
              }
              ;
              function reparameterize(bezier4, points, parameters) {
                return parameters.map((p, i) => newtonRaphsonRootFind(bezier4, points[i], p));
              }
              ;
              function newtonRaphsonRootFind(bez, point, u2) {
                var d = maths.subtract(bezier3.q(bez, u2), point), qprime = bezier3.qprime(bez, u2), numerator = maths.mulMatrix(d, qprime), denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier3.qprimeprime(bez, u2));
                if (denominator === 0) {
                  return u2;
                } else {
                  return u2 - numerator / denominator;
                }
              }
              ;
              function chordLengthParameterize(points) {
                var u2 = [], currU, prevU, prevP;
                points.forEach((p, i) => {
                  currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
                  u2.push(currU);
                  prevU = currU;
                  prevP = p;
                });
                u2 = u2.map((x) => x / prevU);
                return u2;
              }
              ;
              function computeMaxError(points, bez, parameters) {
                var dist4, maxDist, splitPoint, v, i, count, point, t2;
                maxDist = 0;
                splitPoint = Math.floor(points.length / 2);
                const t_distMap = mapTtoRelativeDistances(bez, 10);
                for (i = 0, count = points.length; i < count; i++) {
                  point = points[i];
                  t2 = find_t(bez, parameters[i], t_distMap, 10);
                  v = maths.subtract(bezier3.q(bez, t2), point);
                  dist4 = v[0] * v[0] + v[1] * v[1];
                  if (dist4 > maxDist) {
                    maxDist = dist4;
                    splitPoint = i;
                  }
                }
                return [maxDist, splitPoint];
              }
              ;
              var mapTtoRelativeDistances = function(bez, B_parts) {
                var B_t_curr;
                var B_t_dist = [0];
                var B_t_prev = bez[0];
                var sumLen = 0;
                for (var i = 1; i <= B_parts; i++) {
                  B_t_curr = bezier3.q(bez, i / B_parts);
                  sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
                  B_t_dist.push(sumLen);
                  B_t_prev = B_t_curr;
                }
                B_t_dist = B_t_dist.map((x) => x / sumLen);
                return B_t_dist;
              };
              function find_t(bez, param, t_distMap, B_parts) {
                if (param < 0) {
                  return 0;
                }
                if (param > 1) {
                  return 1;
                }
                var lenMax, lenMin, tMax, tMin, t2;
                for (var i = 1; i <= B_parts; i++) {
                  if (param <= t_distMap[i]) {
                    tMin = (i - 1) / B_parts;
                    tMax = i / B_parts;
                    lenMin = t_distMap[i - 1];
                    lenMax = t_distMap[i];
                    t2 = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
                    break;
                  }
                }
                return t2;
              }
              function createTangent(pointA, pointB) {
                return maths.normalize(maths.subtract(pointA, pointB));
              }
              class maths {
                static zeros_Xx2x2(x) {
                  var zs = [];
                  while (x--) {
                    zs.push([0, 0]);
                  }
                  return zs;
                }
                static mulItems(items, multiplier) {
                  return items.map((x) => x * multiplier);
                }
                static mulMatrix(m1, m2) {
                  return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);
                }
                static subtract(arr1, arr2) {
                  return arr1.map((x1, i) => x1 - arr2[i]);
                }
                static addArrays(arr1, arr2) {
                  return arr1.map((x1, i) => x1 + arr2[i]);
                }
                static addItems(items, addition) {
                  return items.map((x) => x + addition);
                }
                static sum(items) {
                  return items.reduce((sum, x) => sum + x);
                }
                static dot(m1, m2) {
                  return maths.mulMatrix(m1, m2);
                }
                static vectorLen(v) {
                  return Math.hypot(...v);
                }
                static divItems(items, divisor) {
                  return items.map((x) => x / divisor);
                }
                static squareItems(items) {
                  return items.map((x) => x * x);
                }
                static normalize(v) {
                  return this.divItems(v, this.vectorLen(v));
                }
              }
              class bezier3 {
                static q(ctrlPoly, t2) {
                  var tx = 1 - t2;
                  var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx), pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t2), pC = maths.mulItems(ctrlPoly[2], 3 * tx * t2 * t2), pD = maths.mulItems(ctrlPoly[3], t2 * t2 * t2);
                  return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
                }
                static qprime(ctrlPoly, t2) {
                  var tx = 1 - t2;
                  var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx), pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t2), pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t2 * t2);
                  return maths.addArrays(maths.addArrays(pA, pB), pC);
                }
                static qprimeprime(ctrlPoly, t2) {
                  return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1 - t2)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t2));
                }
              }
              module2.exports = fitCurve;
              module2.exports.fitCubic = fitCubic;
              module2.exports.createTangent = createTangent;
            },
            /* 27 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              var _appendElement, appendElement_fn, _setDimensions, setDimensions_fn, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn;
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.AnnotationLayer = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _annotation_storage2 = __w_pdfjs_require__2(5);
              var _scripting_utils = __w_pdfjs_require__2(28);
              var _xfa_layer = __w_pdfjs_require__2(29);
              const DEFAULT_TAB_INDEX = 1e3;
              const DEFAULT_FONT_SIZE = 9;
              const GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
              function getRectDims(rect) {
                return {
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              }
              class AnnotationElementFactory {
                static create(parameters) {
                  const subtype = parameters.data.annotationType;
                  switch (subtype) {
                    case _util2.AnnotationType.LINK:
                      return new LinkAnnotationElement(parameters);
                    case _util2.AnnotationType.TEXT:
                      return new TextAnnotationElement(parameters);
                    case _util2.AnnotationType.WIDGET:
                      const fieldType = parameters.data.fieldType;
                      switch (fieldType) {
                        case "Tx":
                          return new TextWidgetAnnotationElement(parameters);
                        case "Btn":
                          if (parameters.data.radioButton) {
                            return new RadioButtonWidgetAnnotationElement(parameters);
                          } else if (parameters.data.checkBox) {
                            return new CheckboxWidgetAnnotationElement(parameters);
                          }
                          return new PushButtonWidgetAnnotationElement(parameters);
                        case "Ch":
                          return new ChoiceWidgetAnnotationElement(parameters);
                      }
                      return new WidgetAnnotationElement(parameters);
                    case _util2.AnnotationType.POPUP:
                      return new PopupAnnotationElement(parameters);
                    case _util2.AnnotationType.FREETEXT:
                      return new FreeTextAnnotationElement(parameters);
                    case _util2.AnnotationType.LINE:
                      return new LineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUARE:
                      return new SquareAnnotationElement(parameters);
                    case _util2.AnnotationType.CIRCLE:
                      return new CircleAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYLINE:
                      return new PolylineAnnotationElement(parameters);
                    case _util2.AnnotationType.CARET:
                      return new CaretAnnotationElement(parameters);
                    case _util2.AnnotationType.INK:
                      return new InkAnnotationElement(parameters);
                    case _util2.AnnotationType.POLYGON:
                      return new PolygonAnnotationElement(parameters);
                    case _util2.AnnotationType.HIGHLIGHT:
                      return new HighlightAnnotationElement(parameters);
                    case _util2.AnnotationType.UNDERLINE:
                      return new UnderlineAnnotationElement(parameters);
                    case _util2.AnnotationType.SQUIGGLY:
                      return new SquigglyAnnotationElement(parameters);
                    case _util2.AnnotationType.STRIKEOUT:
                      return new StrikeOutAnnotationElement(parameters);
                    case _util2.AnnotationType.STAMP:
                      return new StampAnnotationElement(parameters);
                    case _util2.AnnotationType.FILEATTACHMENT:
                      return new FileAttachmentAnnotationElement(parameters);
                    default:
                      return new AnnotationElement(parameters);
                  }
                }
              }
              class AnnotationElement {
                constructor(parameters, {
                  isRenderable = false,
                  ignoreBorder = false,
                  createQuadrilaterals = false
                } = {}) {
                  this.isRenderable = isRenderable;
                  this.data = parameters.data;
                  this.layer = parameters.layer;
                  this.page = parameters.page;
                  this.viewport = parameters.viewport;
                  this.linkService = parameters.linkService;
                  this.downloadManager = parameters.downloadManager;
                  this.imageResourcesPath = parameters.imageResourcesPath;
                  this.renderForms = parameters.renderForms;
                  this.svgFactory = parameters.svgFactory;
                  this.annotationStorage = parameters.annotationStorage;
                  this.enableScripting = parameters.enableScripting;
                  this.hasJSActions = parameters.hasJSActions;
                  this._fieldObjects = parameters.fieldObjects;
                  this._mouseState = parameters.mouseState;
                  if (isRenderable) {
                    this.container = this._createContainer(ignoreBorder);
                  }
                  if (createQuadrilaterals) {
                    this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
                  }
                }
                _createContainer(ignoreBorder = false) {
                  const data = this.data, page = this.page, viewport = this.viewport;
                  const container = document.createElement("section");
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(data.rect);
                  const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  container.setAttribute("data-annotation-id", data.id);
                  const rect = _util2.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
                  if (!ignoreBorder && data.borderStyle.width > 0) {
                    container.style.borderWidth = `${data.borderStyle.width}px`;
                    const horizontalRadius = data.borderStyle.horizontalCornerRadius;
                    const verticalRadius = data.borderStyle.verticalCornerRadius;
                    if (horizontalRadius > 0 || verticalRadius > 0) {
                      const radius2 = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
                      container.style.borderRadius = radius2;
                    } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                      const radius2 = `calc(${width2}px * var(--scale-factor)) / calc(${height2}px * var(--scale-factor))`;
                      container.style.borderRadius = radius2;
                    }
                    switch (data.borderStyle.style) {
                      case _util2.AnnotationBorderStyleType.SOLID:
                        container.style.borderStyle = "solid";
                        break;
                      case _util2.AnnotationBorderStyleType.DASHED:
                        container.style.borderStyle = "dashed";
                        break;
                      case _util2.AnnotationBorderStyleType.BEVELED:
                        (0, _util2.warn)("Unimplemented border style: beveled");
                        break;
                      case _util2.AnnotationBorderStyleType.INSET:
                        (0, _util2.warn)("Unimplemented border style: inset");
                        break;
                      case _util2.AnnotationBorderStyleType.UNDERLINE:
                        container.style.borderBottomStyle = "solid";
                        break;
                      default:
                        break;
                    }
                    const borderColor = data.borderColor || null;
                    if (borderColor) {
                      container.style.borderColor = _util2.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
                    } else {
                      container.style.borderWidth = 0;
                    }
                  }
                  container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;
                  container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;
                  const {
                    rotation
                  } = data;
                  if (data.hasOwnCanvas || rotation === 0) {
                    container.style.width = `${100 * width2 / pageWidth}%`;
                    container.style.height = `${100 * height2 / pageHeight}%`;
                  } else {
                    this.setRotation(rotation, container);
                  }
                  return container;
                }
                setRotation(angle5, container = this.container) {
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(this.data.rect);
                  let elementWidth, elementHeight;
                  if (angle5 % 180 === 0) {
                    elementWidth = 100 * width2 / pageWidth;
                    elementHeight = 100 * height2 / pageHeight;
                  } else {
                    elementWidth = 100 * height2 / pageWidth;
                    elementHeight = 100 * width2 / pageHeight;
                  }
                  container.style.width = `${elementWidth}%`;
                  container.style.height = `${elementHeight}%`;
                  container.setAttribute("data-main-rotation", (360 - angle5) % 360);
                }
                get _commonActions() {
                  const setColor = (jsName, styleName, event) => {
                    const color2 = event.detail[jsName];
                    event.target.style[styleName] = _scripting_utils.ColorConverters[`${color2[0]}_HTML`](color2.slice(1));
                  };
                  return (0, _util2.shadow)(this, "_commonActions", {
                    display: (event) => {
                      const hidden = event.detail.display % 2 === 1;
                      this.container.style.visibility = hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden,
                        print: event.detail.display === 0 || event.detail.display === 3
                      });
                    },
                    print: (event) => {
                      this.annotationStorage.setValue(this.data.id, {
                        print: event.detail.print
                      });
                    },
                    hidden: (event) => {
                      this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
                      this.annotationStorage.setValue(this.data.id, {
                        hidden: event.detail.hidden
                      });
                    },
                    focus: (event) => {
                      setTimeout(() => event.target.focus({
                        preventScroll: false
                      }), 0);
                    },
                    userName: (event) => {
                      event.target.title = event.detail.userName;
                    },
                    readonly: (event) => {
                      if (event.detail.readonly) {
                        event.target.setAttribute("readonly", "");
                      } else {
                        event.target.removeAttribute("readonly");
                      }
                    },
                    required: (event) => {
                      this._setRequired(event.target, event.detail.required);
                    },
                    bgColor: (event) => {
                      setColor("bgColor", "backgroundColor", event);
                    },
                    fillColor: (event) => {
                      setColor("fillColor", "backgroundColor", event);
                    },
                    fgColor: (event) => {
                      setColor("fgColor", "color", event);
                    },
                    textColor: (event) => {
                      setColor("textColor", "color", event);
                    },
                    borderColor: (event) => {
                      setColor("borderColor", "borderColor", event);
                    },
                    strokeColor: (event) => {
                      setColor("strokeColor", "borderColor", event);
                    },
                    rotation: (event) => {
                      const angle5 = event.detail.rotation;
                      this.setRotation(angle5);
                      this.annotationStorage.setValue(this.data.id, {
                        rotation: angle5
                      });
                    }
                  });
                }
                _dispatchEventFromSandbox(actions, jsEvent) {
                  const commonActions = this._commonActions;
                  for (const name3 of Object.keys(jsEvent.detail)) {
                    const action = actions[name3] || commonActions[name3];
                    if (action) {
                      action(jsEvent);
                    }
                  }
                }
                _setDefaultPropertiesFromJS(element) {
                  if (!this.enableScripting) {
                    return;
                  }
                  const storedData = this.annotationStorage.getRawValue(this.data.id);
                  if (!storedData) {
                    return;
                  }
                  const commonActions = this._commonActions;
                  for (const [actionName, detail] of Object.entries(storedData)) {
                    const action = commonActions[actionName];
                    if (action) {
                      const eventProxy = {
                        detail: {
                          [actionName]: detail
                        },
                        target: element
                      };
                      action(eventProxy);
                      delete storedData[actionName];
                    }
                  }
                }
                _createQuadrilaterals(ignoreBorder = false) {
                  if (!this.data.quadPoints) {
                    return null;
                  }
                  const quadrilaterals = [];
                  const savedRect = this.data.rect;
                  for (const quadPoint of this.data.quadPoints) {
                    this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                    quadrilaterals.push(this._createContainer(ignoreBorder));
                  }
                  this.data.rect = savedRect;
                  return quadrilaterals;
                }
                _createPopup(trigger, data) {
                  let container = this.container;
                  if (this.quadrilaterals) {
                    trigger = trigger || this.quadrilaterals;
                    container = this.quadrilaterals[0];
                  }
                  if (!trigger) {
                    trigger = document.createElement("div");
                    trigger.className = "popupTriggerArea";
                    container.append(trigger);
                  }
                  const popupElement = new PopupElement({
                    container,
                    trigger,
                    color: data.color,
                    titleObj: data.titleObj,
                    modificationDate: data.modificationDate,
                    contentsObj: data.contentsObj,
                    richText: data.richText,
                    hideWrapper: true
                  });
                  const popup = popupElement.render();
                  popup.style.left = "100%";
                  container.append(popup);
                }
                _renderQuadrilaterals(className2) {
                  for (const quadrilateral of this.quadrilaterals) {
                    quadrilateral.className = className2;
                  }
                  return this.quadrilaterals;
                }
                render() {
                  (0, _util2.unreachable)("Abstract method `AnnotationElement.render` called");
                }
                _getElementsByName(name3, skipId = null) {
                  const fields = [];
                  if (this._fieldObjects) {
                    const fieldObj = this._fieldObjects[name3];
                    if (fieldObj) {
                      for (const {
                        page,
                        id: id2,
                        exportValues
                      } of fieldObj) {
                        if (page === -1) {
                          continue;
                        }
                        if (id2 === skipId) {
                          continue;
                        }
                        const exportValue = typeof exportValues === "string" ? exportValues : null;
                        const domElement = document.querySelector(`[data-element-id="${id2}"]`);
                        if (domElement && !GetElementsByNameSet.has(domElement)) {
                          (0, _util2.warn)(`_getElementsByName - element not allowed: ${id2}`);
                          continue;
                        }
                        fields.push({
                          id: id2,
                          exportValue,
                          domElement
                        });
                      }
                    }
                    return fields;
                  }
                  for (const domElement of document.getElementsByName(name3)) {
                    const {
                      id: id2,
                      exportValue
                    } = domElement;
                    if (id2 === skipId) {
                      continue;
                    }
                    if (!GetElementsByNameSet.has(domElement)) {
                      continue;
                    }
                    fields.push({
                      id: id2,
                      exportValue,
                      domElement
                    });
                  }
                  return fields;
                }
                static get platform() {
                  const platform = typeof navigator !== "undefined" ? navigator.platform : "";
                  return (0, _util2.shadow)(this, "platform", {
                    isWin: platform.includes("Win"),
                    isMac: platform.includes("Mac")
                  });
                }
              }
              class LinkAnnotationElement extends AnnotationElement {
                constructor(parameters, options = null) {
                  super(parameters, {
                    isRenderable: true,
                    ignoreBorder: !!options?.ignoreBorder,
                    createQuadrilaterals: true
                  });
                  this.isTooltipOnly = parameters.data.isTooltipOnly;
                }
                render() {
                  const {
                    data,
                    linkService
                  } = this;
                  const link = document.createElement("a");
                  link.setAttribute("data-element-id", data.id);
                  let isBound = false;
                  if (data.url) {
                    linkService.addLinkAttributes(link, data.url, data.newWindow);
                    isBound = true;
                  } else if (data.action) {
                    this._bindNamedAction(link, data.action);
                    isBound = true;
                  } else if (data.dest) {
                    this._bindLink(link, data.dest);
                    isBound = true;
                  } else {
                    if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                      this._bindJSAction(link, data);
                      isBound = true;
                    }
                    if (data.resetForm) {
                      this._bindResetFormAction(link, data.resetForm);
                      isBound = true;
                    } else if (this.isTooltipOnly && !isBound) {
                      this._bindLink(link, "");
                      isBound = true;
                    }
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
                      const linkElement = index === 0 ? link : link.cloneNode();
                      quadrilateral.append(linkElement);
                      return quadrilateral;
                    });
                  }
                  this.container.className = "linkAnnotation";
                  if (isBound) {
                    this.container.append(link);
                  }
                  return this.container;
                }
                _bindLink(link, destination) {
                  link.href = this.linkService.getDestinationHash(destination);
                  link.onclick = () => {
                    if (destination) {
                      this.linkService.goToDestination(destination);
                    }
                    return false;
                  };
                  if (destination || destination === "") {
                    link.className = "internalLink";
                  }
                }
                _bindNamedAction(link, action) {
                  link.href = this.linkService.getAnchorUrl("");
                  link.onclick = () => {
                    this.linkService.executeNamedAction(action);
                    return false;
                  };
                  link.className = "internalLink";
                }
                _bindJSAction(link, data) {
                  link.href = this.linkService.getAnchorUrl("");
                  const map = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
                  for (const name3 of Object.keys(data.actions)) {
                    const jsName = map.get(name3);
                    if (!jsName) {
                      continue;
                    }
                    link[jsName] = () => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: data.id,
                          name: name3
                        }
                      });
                      return false;
                    };
                  }
                  if (!link.onclick) {
                    link.onclick = () => false;
                  }
                  link.className = "internalLink";
                }
                _bindResetFormAction(link, resetForm) {
                  const otherClickAction = link.onclick;
                  if (!otherClickAction) {
                    link.href = this.linkService.getAnchorUrl("");
                  }
                  link.className = "internalLink";
                  if (!this._fieldObjects) {
                    (0, _util2.warn)(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
                    if (!otherClickAction) {
                      link.onclick = () => false;
                    }
                    return;
                  }
                  link.onclick = () => {
                    if (otherClickAction) {
                      otherClickAction();
                    }
                    const {
                      fields: resetFormFields,
                      refs: resetFormRefs,
                      include
                    } = resetForm;
                    const allFields = [];
                    if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                      const fieldIds = new Set(resetFormRefs);
                      for (const fieldName of resetFormFields) {
                        const fields = this._fieldObjects[fieldName] || [];
                        for (const {
                          id: id2
                        } of fields) {
                          fieldIds.add(id2);
                        }
                      }
                      for (const fields of Object.values(this._fieldObjects)) {
                        for (const field of fields) {
                          if (fieldIds.has(field.id) === include) {
                            allFields.push(field);
                          }
                        }
                      }
                    } else {
                      for (const fields of Object.values(this._fieldObjects)) {
                        allFields.push(...fields);
                      }
                    }
                    const storage = this.annotationStorage;
                    const allIds = [];
                    for (const field of allFields) {
                      const {
                        id: id2
                      } = field;
                      allIds.push(id2);
                      switch (field.type) {
                        case "text": {
                          const value2 = field.defaultValue || "";
                          storage.setValue(id2, {
                            value: value2
                          });
                          break;
                        }
                        case "checkbox":
                        case "radiobutton": {
                          const value2 = field.defaultValue === field.exportValues;
                          storage.setValue(id2, {
                            value: value2
                          });
                          break;
                        }
                        case "combobox":
                        case "listbox": {
                          const value2 = field.defaultValue || "";
                          storage.setValue(id2, {
                            value: value2
                          });
                          break;
                        }
                        default:
                          continue;
                      }
                      const domElement = document.querySelector(`[data-element-id="${id2}"]`);
                      if (!domElement) {
                        continue;
                      } else if (!GetElementsByNameSet.has(domElement)) {
                        (0, _util2.warn)(`_bindResetFormAction - element not allowed: ${id2}`);
                        continue;
                      }
                      domElement.dispatchEvent(new Event("resetform"));
                    }
                    if (this.enableScripting) {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: "app",
                          ids: allIds,
                          name: "ResetForm"
                        }
                      });
                    }
                    return false;
                  };
                }
              }
              class TextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  this.container.className = "textAnnotation";
                  const image2 = document.createElement("img");
                  image2.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
                  image2.alt = "[{{type}} Annotation]";
                  image2.dataset.l10nId = "text_annotation_type";
                  image2.dataset.l10nArgs = JSON.stringify({
                    type: this.data.name
                  });
                  if (!this.data.hasPopup) {
                    this._createPopup(image2, this.data);
                  }
                  this.container.append(image2);
                  return this.container;
                }
              }
              class WidgetAnnotationElement extends AnnotationElement {
                render() {
                  if (this.data.alternativeText) {
                    this.container.title = this.data.alternativeText;
                  }
                  return this.container;
                }
                _getKeyModifier(event) {
                  const {
                    isWin,
                    isMac
                  } = AnnotationElement.platform;
                  return isWin && event.ctrlKey || isMac && event.metaKey;
                }
                _setEventListener(element, baseName, eventName, valueGetter) {
                  if (baseName.includes("mouse")) {
                    element.addEventListener(baseName, (event) => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event),
                          shift: event.shiftKey,
                          modifier: this._getKeyModifier(event)
                        }
                      });
                    });
                  } else {
                    element.addEventListener(baseName, (event) => {
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: this.data.id,
                          name: eventName,
                          value: valueGetter(event)
                        }
                      });
                    });
                  }
                }
                _setEventListeners(element, names, getter) {
                  for (const [baseName, eventName] of names) {
                    if (eventName === "Action" || this.data.actions?.[eventName]) {
                      this._setEventListener(element, baseName, eventName, getter);
                    }
                  }
                }
                _setBackgroundColor(element) {
                  const color2 = this.data.backgroundColor || null;
                  element.style.backgroundColor = color2 === null ? "transparent" : _util2.Util.makeHexColor(color2[0], color2[1], color2[2]);
                }
                _setTextStyle(element) {
                  const TEXT_ALIGNMENT = ["left", "center", "right"];
                  const {
                    fontColor
                  } = this.data.defaultAppearanceData;
                  const fontSize2 = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
                  const style = element.style;
                  let computedFontSize;
                  if (this.data.multiLine) {
                    const height2 = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    const numberOfLines = Math.round(height2 / (_util2.LINE_FACTOR * fontSize2)) || 1;
                    const lineHeight = height2 / numberOfLines;
                    computedFontSize = Math.min(fontSize2, Math.round(lineHeight / _util2.LINE_FACTOR));
                  } else {
                    const height2 = Math.abs(this.data.rect[3] - this.data.rect[1]);
                    computedFontSize = Math.min(fontSize2, Math.round(height2 / _util2.LINE_FACTOR));
                  }
                  style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
                  style.color = _util2.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
                  if (this.data.textAlignment !== null) {
                    style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
                  }
                }
                _setRequired(element, isRequired) {
                  if (isRequired) {
                    element.setAttribute("required", true);
                  } else {
                    element.removeAttribute("required");
                  }
                  element.setAttribute("aria-required", isRequired);
                }
              }
              class TextWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
                  super(parameters, {
                    isRenderable
                  });
                }
                setPropertyOnSiblings(base, key, value2, keyInStorage) {
                  const storage = this.annotationStorage;
                  for (const element of this._getElementsByName(base.name, base.id)) {
                    if (element.domElement) {
                      element.domElement[key] = value2;
                    }
                    storage.setValue(element.id, {
                      [keyInStorage]: value2
                    });
                  }
                }
                render() {
                  const storage = this.annotationStorage;
                  const id2 = this.data.id;
                  this.container.className = "textWidgetAnnotation";
                  let element = null;
                  if (this.renderForms) {
                    const storedData = storage.getValue(id2, {
                      value: this.data.fieldValue
                    });
                    let textContent = storedData.formattedValue || storedData.value || "";
                    const maxLen = storage.getValue(id2, {
                      charLimit: this.data.maxLen
                    }).charLimit;
                    if (maxLen && textContent.length > maxLen) {
                      textContent = textContent.slice(0, maxLen);
                    }
                    const elementData = {
                      userValue: textContent,
                      formattedValue: null,
                      valueOnFocus: ""
                    };
                    if (this.data.multiLine) {
                      element = document.createElement("textarea");
                      element.textContent = textContent;
                      if (this.data.doNotScroll) {
                        element.style.overflowY = "hidden";
                      }
                    } else {
                      element = document.createElement("input");
                      element.type = "text";
                      element.setAttribute("value", textContent);
                      if (this.data.doNotScroll) {
                        element.style.overflowX = "hidden";
                      }
                    }
                    GetElementsByNameSet.add(element);
                    element.setAttribute("data-element-id", id2);
                    element.disabled = this.data.readOnly;
                    element.name = this.data.fieldName;
                    element.tabIndex = DEFAULT_TAB_INDEX;
                    this._setRequired(element, this.data.required);
                    if (maxLen) {
                      element.maxLength = maxLen;
                    }
                    element.addEventListener("input", (event) => {
                      storage.setValue(id2, {
                        value: event.target.value
                      });
                      this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                    });
                    element.addEventListener("resetform", (event) => {
                      const defaultValue = this.data.defaultFieldValue ?? "";
                      element.value = elementData.userValue = defaultValue;
                      elementData.formattedValue = null;
                    });
                    let blurListener = (event) => {
                      const {
                        formattedValue
                      } = elementData;
                      if (formattedValue !== null && formattedValue !== void 0) {
                        event.target.value = formattedValue;
                      }
                      event.target.scrollLeft = 0;
                    };
                    if (this.enableScripting && this.hasJSActions) {
                      element.addEventListener("focus", (event) => {
                        if (elementData.userValue) {
                          event.target.value = elementData.userValue;
                        }
                        elementData.valueOnFocus = event.target.value;
                      });
                      element.addEventListener("updatefromsandbox", (jsEvent) => {
                        const actions = {
                          value(event) {
                            elementData.userValue = event.detail.value ?? "";
                            storage.setValue(id2, {
                              value: elementData.userValue.toString()
                            });
                            event.target.value = elementData.userValue;
                          },
                          formattedValue(event) {
                            const {
                              formattedValue
                            } = event.detail;
                            elementData.formattedValue = formattedValue;
                            if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                              event.target.value = formattedValue;
                            }
                            storage.setValue(id2, {
                              formattedValue
                            });
                          },
                          selRange(event) {
                            event.target.setSelectionRange(...event.detail.selRange);
                          },
                          charLimit: (event) => {
                            const {
                              charLimit
                            } = event.detail;
                            const {
                              target
                            } = event;
                            if (charLimit === 0) {
                              target.removeAttribute("maxLength");
                              return;
                            }
                            target.setAttribute("maxLength", charLimit);
                            let value2 = elementData.userValue;
                            if (!value2 || value2.length <= charLimit) {
                              return;
                            }
                            value2 = value2.slice(0, charLimit);
                            target.value = elementData.userValue = value2;
                            storage.setValue(id2, {
                              value: value2
                            });
                            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                              source: this,
                              detail: {
                                id: id2,
                                name: "Keystroke",
                                value: value2,
                                willCommit: true,
                                commitKey: 1,
                                selStart: target.selectionStart,
                                selEnd: target.selectionEnd
                              }
                            });
                          }
                        };
                        this._dispatchEventFromSandbox(actions, jsEvent);
                      });
                      element.addEventListener("keydown", (event) => {
                        let commitKey = -1;
                        if (event.key === "Escape") {
                          commitKey = 0;
                        } else if (event.key === "Enter") {
                          commitKey = 2;
                        } else if (event.key === "Tab") {
                          commitKey = 3;
                        }
                        if (commitKey === -1) {
                          return;
                        }
                        const {
                          value: value2
                        } = event.target;
                        if (elementData.valueOnFocus === value2) {
                          return;
                        }
                        elementData.userValue = value2;
                        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: id2,
                            name: "Keystroke",
                            value: value2,
                            willCommit: true,
                            commitKey,
                            selStart: event.target.selectionStart,
                            selEnd: event.target.selectionEnd
                          }
                        });
                      });
                      const _blurListener = blurListener;
                      blurListener = null;
                      element.addEventListener("blur", (event) => {
                        const {
                          value: value2
                        } = event.target;
                        elementData.userValue = value2;
                        if (this._mouseState.isDown && elementData.valueOnFocus !== value2) {
                          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id: id2,
                              name: "Keystroke",
                              value: value2,
                              willCommit: true,
                              commitKey: 1,
                              selStart: event.target.selectionStart,
                              selEnd: event.target.selectionEnd
                            }
                          });
                        }
                        _blurListener(event);
                      });
                      if (this.data.actions?.Keystroke) {
                        element.addEventListener("beforeinput", (event) => {
                          const {
                            data,
                            target
                          } = event;
                          const {
                            value: value2,
                            selectionStart,
                            selectionEnd
                          } = target;
                          let selStart = selectionStart, selEnd = selectionEnd;
                          switch (event.inputType) {
                            case "deleteWordBackward": {
                              const match = value2.substring(0, selectionStart).match(/\w*[^\w]*$/);
                              if (match) {
                                selStart -= match[0].length;
                              }
                              break;
                            }
                            case "deleteWordForward": {
                              const match = value2.substring(selectionStart).match(/^[^\w]*\w*/);
                              if (match) {
                                selEnd += match[0].length;
                              }
                              break;
                            }
                            case "deleteContentBackward":
                              if (selectionStart === selectionEnd) {
                                selStart -= 1;
                              }
                              break;
                            case "deleteContentForward":
                              if (selectionStart === selectionEnd) {
                                selEnd += 1;
                              }
                              break;
                          }
                          event.preventDefault();
                          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                            source: this,
                            detail: {
                              id: id2,
                              name: "Keystroke",
                              value: value2,
                              change: data || "",
                              willCommit: false,
                              selStart,
                              selEnd
                            }
                          });
                        });
                      }
                      this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
                    }
                    if (blurListener) {
                      element.addEventListener("blur", blurListener);
                    }
                    if (this.data.comb) {
                      const fieldWidth = this.data.rect[2] - this.data.rect[0];
                      const combWidth = fieldWidth / maxLen;
                      element.classList.add("comb");
                      element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
                    }
                  } else {
                    element = document.createElement("div");
                    element.textContent = this.data.fieldValue;
                    element.style.verticalAlign = "middle";
                    element.style.display = "table-cell";
                  }
                  this._setTextStyle(element);
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id2 = data.id;
                  let value2 = storage.getValue(id2, {
                    value: data.exportValue === data.fieldValue
                  }).value;
                  if (typeof value2 === "string") {
                    value2 = value2 !== "Off";
                    storage.setValue(id2, {
                      value: value2
                    });
                  }
                  this.container.className = "buttonWidgetAnnotation checkBox";
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id2);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "checkbox";
                  element.name = data.fieldName;
                  if (value2) {
                    element.setAttribute("checked", true);
                  }
                  element.setAttribute("exportValue", data.exportValue);
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name: name3,
                      checked: checked2
                    } = event.target;
                    for (const checkbox of this._getElementsByName(name3, id2)) {
                      const curChecked = checked2 && checkbox.exportValue === data.exportValue;
                      if (checkbox.domElement) {
                        checkbox.domElement.checked = curChecked;
                      }
                      storage.setValue(checkbox.id, {
                        value: curChecked
                      });
                    }
                    storage.setValue(id2, {
                      value: checked2
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue || "Off";
                    event.target.checked = defaultValue === data.exportValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          event.target.checked = event.detail.value !== "Off";
                          storage.setValue(id2, {
                            value: event.target.checked
                          });
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "buttonWidgetAnnotation radioButton";
                  const storage = this.annotationStorage;
                  const data = this.data;
                  const id2 = data.id;
                  let value2 = storage.getValue(id2, {
                    value: data.fieldValue === data.buttonValue
                  }).value;
                  if (typeof value2 === "string") {
                    value2 = value2 !== data.buttonValue;
                    storage.setValue(id2, {
                      value: value2
                    });
                  }
                  const element = document.createElement("input");
                  GetElementsByNameSet.add(element);
                  element.setAttribute("data-element-id", id2);
                  element.disabled = data.readOnly;
                  this._setRequired(element, this.data.required);
                  element.type = "radio";
                  element.name = data.fieldName;
                  if (value2) {
                    element.setAttribute("checked", true);
                  }
                  element.tabIndex = DEFAULT_TAB_INDEX;
                  element.addEventListener("change", (event) => {
                    const {
                      name: name3,
                      checked: checked2
                    } = event.target;
                    for (const radio of this._getElementsByName(name3, id2)) {
                      storage.setValue(radio.id, {
                        value: false
                      });
                    }
                    storage.setValue(id2, {
                      value: checked2
                    });
                  });
                  element.addEventListener("resetform", (event) => {
                    const defaultValue = data.defaultFieldValue;
                    event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
                  });
                  if (this.enableScripting && this.hasJSActions) {
                    const pdfButtonValue = data.buttonValue;
                    element.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value: (event) => {
                          const checked2 = pdfButtonValue === event.detail.value;
                          for (const radio of this._getElementsByName(event.target.name)) {
                            const curChecked = checked2 && radio.id === id2;
                            if (radio.domElement) {
                              radio.domElement.checked = curChecked;
                            }
                            storage.setValue(radio.id, {
                              value: curChecked
                            });
                          }
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
                  }
                  this._setBackgroundColor(element);
                  this._setDefaultPropertiesFromJS(element);
                  this.container.append(element);
                  return this.container;
                }
              }
              class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    ignoreBorder: parameters.data.hasAppearance
                  });
                }
                render() {
                  const container = super.render();
                  container.className = "buttonWidgetAnnotation pushButton";
                  if (this.data.alternativeText) {
                    container.title = this.data.alternativeText;
                  }
                  const linkElement = container.lastChild;
                  if (this.enableScripting && this.hasJSActions && linkElement) {
                    this._setDefaultPropertiesFromJS(linkElement);
                    linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      this._dispatchEventFromSandbox({}, jsEvent);
                    });
                  }
                  return container;
                }
              }
              class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: parameters.renderForms
                  });
                }
                render() {
                  this.container.className = "choiceWidgetAnnotation";
                  const storage = this.annotationStorage;
                  const id2 = this.data.id;
                  const storedData = storage.getValue(id2, {
                    value: this.data.fieldValue
                  });
                  const selectElement = document.createElement("select");
                  GetElementsByNameSet.add(selectElement);
                  selectElement.setAttribute("data-element-id", id2);
                  selectElement.disabled = this.data.readOnly;
                  this._setRequired(selectElement, this.data.required);
                  selectElement.name = this.data.fieldName;
                  selectElement.tabIndex = DEFAULT_TAB_INDEX;
                  let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
                  if (!this.data.combo) {
                    selectElement.size = this.data.options.length;
                    if (this.data.multiSelect) {
                      selectElement.multiple = true;
                    }
                  }
                  selectElement.addEventListener("resetform", (event) => {
                    const defaultValue = this.data.defaultFieldValue;
                    for (const option of selectElement.options) {
                      option.selected = option.value === defaultValue;
                    }
                  });
                  for (const option of this.data.options) {
                    const optionElement = document.createElement("option");
                    optionElement.textContent = option.displayValue;
                    optionElement.value = option.exportValue;
                    if (storedData.value.includes(option.exportValue)) {
                      optionElement.setAttribute("selected", true);
                      addAnEmptyEntry = false;
                    }
                    selectElement.append(optionElement);
                  }
                  let removeEmptyEntry = null;
                  if (addAnEmptyEntry) {
                    const noneOptionElement = document.createElement("option");
                    noneOptionElement.value = " ";
                    noneOptionElement.setAttribute("hidden", true);
                    noneOptionElement.setAttribute("selected", true);
                    selectElement.prepend(noneOptionElement);
                    removeEmptyEntry = () => {
                      noneOptionElement.remove();
                      selectElement.removeEventListener("input", removeEmptyEntry);
                      removeEmptyEntry = null;
                    };
                    selectElement.addEventListener("input", removeEmptyEntry);
                  }
                  const getValue = (event, isExport) => {
                    const name3 = isExport ? "value" : "textContent";
                    const options = event.target.options;
                    if (!event.target.multiple) {
                      return options.selectedIndex === -1 ? null : options[options.selectedIndex][name3];
                    }
                    return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name3]);
                  };
                  const getItems = (event) => {
                    const options = event.target.options;
                    return Array.prototype.map.call(options, (option) => {
                      return {
                        displayValue: option.textContent,
                        exportValue: option.value
                      };
                    });
                  };
                  if (this.enableScripting && this.hasJSActions) {
                    selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
                      const actions = {
                        value(event) {
                          removeEmptyEntry?.();
                          const value2 = event.detail.value;
                          const values = new Set(Array.isArray(value2) ? value2 : [value2]);
                          for (const option of selectElement.options) {
                            option.selected = values.has(option.value);
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true)
                          });
                        },
                        multipleSelection(event) {
                          selectElement.multiple = true;
                        },
                        remove(event) {
                          const options = selectElement.options;
                          const index = event.detail.remove;
                          options[index].selected = false;
                          selectElement.remove(index);
                          if (options.length > 0) {
                            const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                            if (i === -1) {
                              options[0].selected = true;
                            }
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        clear(event) {
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          storage.setValue(id2, {
                            value: null,
                            items: []
                          });
                        },
                        insert(event) {
                          const {
                            index,
                            displayValue,
                            exportValue
                          } = event.detail.insert;
                          const selectChild = selectElement.children[index];
                          const optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          if (selectChild) {
                            selectChild.before(optionElement);
                          } else {
                            selectElement.append(optionElement);
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        items(event) {
                          const {
                            items
                          } = event.detail;
                          while (selectElement.length !== 0) {
                            selectElement.remove(0);
                          }
                          for (const item of items) {
                            const {
                              displayValue,
                              exportValue
                            } = item;
                            const optionElement = document.createElement("option");
                            optionElement.textContent = displayValue;
                            optionElement.value = exportValue;
                            selectElement.append(optionElement);
                          }
                          if (selectElement.options.length > 0) {
                            selectElement.options[0].selected = true;
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true),
                            items: getItems(event)
                          });
                        },
                        indices(event) {
                          const indices = new Set(event.detail.indices);
                          for (const option of event.target.options) {
                            option.selected = indices.has(option.index);
                          }
                          storage.setValue(id2, {
                            value: getValue(event, true)
                          });
                        },
                        editable(event) {
                          event.target.disabled = !event.detail.editable;
                        }
                      };
                      this._dispatchEventFromSandbox(actions, jsEvent);
                    });
                    selectElement.addEventListener("input", (event) => {
                      const exportValue = getValue(event, true);
                      const value2 = getValue(event, false);
                      storage.setValue(id2, {
                        value: exportValue
                      });
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id: id2,
                          name: "Keystroke",
                          value: value2,
                          changeEx: exportValue,
                          willCommit: true,
                          commitKey: 1,
                          keyDown: false
                        }
                      });
                    });
                    this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], (event) => event.target.checked);
                  } else {
                    selectElement.addEventListener("input", function(event) {
                      storage.setValue(id2, {
                        value: getValue(event, true)
                      });
                    });
                  }
                  if (this.data.combo) {
                    this._setTextStyle(selectElement);
                  } else {
                  }
                  this._setBackgroundColor(selectElement);
                  this._setDefaultPropertiesFromJS(selectElement);
                  this.container.append(selectElement);
                  return this.container;
                }
              }
              class PopupAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable
                  });
                }
                render() {
                  const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
                  this.container.className = "popupAnnotation";
                  if (IGNORE_TYPES.includes(this.data.parentType)) {
                    return this.container;
                  }
                  const selector = `[data-annotation-id="${this.data.parentId}"]`;
                  const parentElements = this.layer.querySelectorAll(selector);
                  if (parentElements.length === 0) {
                    return this.container;
                  }
                  const popup = new PopupElement({
                    container: this.container,
                    trigger: Array.from(parentElements),
                    color: this.data.color,
                    titleObj: this.data.titleObj,
                    modificationDate: this.data.modificationDate,
                    contentsObj: this.data.contentsObj,
                    richText: this.data.richText
                  });
                  const page = this.page;
                  const rect = _util2.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);
                  const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
                  const popupTop = rect[1];
                  const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
                  const pageWidth = pageURx - pageLLx;
                  const pageHeight = pageURy - pageLLy;
                  this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;
                  this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;
                  this.container.append(popup.render());
                  return this.container;
                }
              }
              class PopupElement {
                constructor(parameters) {
                  this.container = parameters.container;
                  this.trigger = parameters.trigger;
                  this.color = parameters.color;
                  this.titleObj = parameters.titleObj;
                  this.modificationDate = parameters.modificationDate;
                  this.contentsObj = parameters.contentsObj;
                  this.richText = parameters.richText;
                  this.hideWrapper = parameters.hideWrapper || false;
                  this.pinned = false;
                }
                render() {
                  const BACKGROUND_ENLIGHT = 0.7;
                  const wrapper = document.createElement("div");
                  wrapper.className = "popupWrapper";
                  this.hideElement = this.hideWrapper ? wrapper : this.container;
                  this.hideElement.hidden = true;
                  const popup = document.createElement("div");
                  popup.className = "popup";
                  const color2 = this.color;
                  if (color2) {
                    const r = BACKGROUND_ENLIGHT * (255 - color2[0]) + color2[0];
                    const g = BACKGROUND_ENLIGHT * (255 - color2[1]) + color2[1];
                    const b = BACKGROUND_ENLIGHT * (255 - color2[2]) + color2[2];
                    popup.style.backgroundColor = _util2.Util.makeHexColor(r | 0, g | 0, b | 0);
                  }
                  const title2 = document.createElement("h1");
                  title2.dir = this.titleObj.dir;
                  title2.textContent = this.titleObj.str;
                  popup.append(title2);
                  const dateObject = _display_utils2.PDFDateString.toDateObject(this.modificationDate);
                  if (dateObject) {
                    const modificationDate = document.createElement("span");
                    modificationDate.className = "popupDate";
                    modificationDate.textContent = "{{date}}, {{time}}";
                    modificationDate.dataset.l10nId = "annotation_date_string";
                    modificationDate.dataset.l10nArgs = JSON.stringify({
                      date: dateObject.toLocaleDateString(),
                      time: dateObject.toLocaleTimeString()
                    });
                    popup.append(modificationDate);
                  }
                  if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {
                    _xfa_layer.XfaLayer.render({
                      xfaHtml: this.richText.html,
                      intent: "richText",
                      div: popup
                    });
                    popup.lastChild.className = "richText popupContent";
                  } else {
                    const contents = this._formatContents(this.contentsObj);
                    popup.append(contents);
                  }
                  if (!Array.isArray(this.trigger)) {
                    this.trigger = [this.trigger];
                  }
                  for (const element of this.trigger) {
                    element.addEventListener("click", this._toggle.bind(this));
                    element.addEventListener("mouseover", this._show.bind(this, false));
                    element.addEventListener("mouseout", this._hide.bind(this, false));
                  }
                  popup.addEventListener("click", this._hide.bind(this, true));
                  wrapper.append(popup);
                  return wrapper;
                }
                _formatContents({
                  str: str5,
                  dir
                }) {
                  const p = document.createElement("p");
                  p.className = "popupContent";
                  p.dir = dir;
                  const lines = str5.split(/(?:\r\n?|\n)/);
                  for (let i = 0, ii = lines.length; i < ii; ++i) {
                    const line = lines[i];
                    p.append(document.createTextNode(line));
                    if (i < ii - 1) {
                      p.append(document.createElement("br"));
                    }
                  }
                  return p;
                }
                _toggle() {
                  if (this.pinned) {
                    this._hide(true);
                  } else {
                    this._show(true);
                  }
                }
                _show(pin = false) {
                  if (pin) {
                    this.pinned = true;
                  }
                  if (this.hideElement.hidden) {
                    this.hideElement.hidden = false;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1e3;
                  }
                }
                _hide(unpin = true) {
                  if (unpin) {
                    this.pinned = false;
                  }
                  if (!this.hideElement.hidden && !this.pinned) {
                    this.hideElement.hidden = true;
                    this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1e3;
                  }
                }
              }
              class FreeTextAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.textContent = parameters.data.textContent;
                }
                render() {
                  this.container.className = "freeTextAnnotation";
                  if (this.textContent) {
                    const content = document.createElement("div");
                    content.className = "annotationTextContent";
                    content.setAttribute("role", "comment");
                    for (const line of this.textContent) {
                      const lineSpan = document.createElement("span");
                      lineSpan.textContent = line;
                      content.append(lineSpan);
                    }
                    this.container.append(content);
                  }
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class LineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "lineAnnotation";
                  const data = this.data;
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height2, true);
                  const line = this.svgFactory.createElement("svg:line");
                  line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
                  line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
                  line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
                  line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
                  line.setAttribute("stroke-width", data.borderStyle.width || 1);
                  line.setAttribute("stroke", "transparent");
                  line.setAttribute("fill", "transparent");
                  svg.append(line);
                  this.container.append(svg);
                  this._createPopup(line, data);
                  return this.container;
                }
              }
              class SquareAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "squareAnnotation";
                  const data = this.data;
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height2, true);
                  const borderWidth = data.borderStyle.width;
                  const square = this.svgFactory.createElement("svg:rect");
                  square.setAttribute("x", borderWidth / 2);
                  square.setAttribute("y", borderWidth / 2);
                  square.setAttribute("width", width2 - borderWidth);
                  square.setAttribute("height", height2 - borderWidth);
                  square.setAttribute("stroke-width", borderWidth || 1);
                  square.setAttribute("stroke", "transparent");
                  square.setAttribute("fill", "transparent");
                  svg.append(square);
                  this.container.append(svg);
                  this._createPopup(square, data);
                  return this.container;
                }
              }
              class CircleAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "circleAnnotation";
                  const data = this.data;
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height2, true);
                  const borderWidth = data.borderStyle.width;
                  const circle = this.svgFactory.createElement("svg:ellipse");
                  circle.setAttribute("cx", width2 / 2);
                  circle.setAttribute("cy", height2 / 2);
                  circle.setAttribute("rx", width2 / 2 - borderWidth / 2);
                  circle.setAttribute("ry", height2 / 2 - borderWidth / 2);
                  circle.setAttribute("stroke-width", borderWidth || 1);
                  circle.setAttribute("stroke", "transparent");
                  circle.setAttribute("fill", "transparent");
                  svg.append(circle);
                  this.container.append(svg);
                  this._createPopup(circle, data);
                  return this.container;
                }
              }
              class PolylineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "polylineAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height2, true);
                  let points = [];
                  for (const coordinate of data.vertices) {
                    const x = coordinate.x - data.rect[0];
                    const y = data.rect[3] - coordinate.y;
                    points.push(x + "," + y);
                  }
                  points = points.join(" ");
                  const polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "transparent");
                  svg.append(polyline);
                  this.container.append(svg);
                  this._createPopup(polyline, data);
                  return this.container;
                }
              }
              class PolygonAnnotationElement extends PolylineAnnotationElement {
                constructor(parameters) {
                  super(parameters);
                  this.containerClassName = "polygonAnnotation";
                  this.svgElementName = "svg:polygon";
                }
              }
              class CaretAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "caretAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class InkAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                  this.containerClassName = "inkAnnotation";
                  this.svgElementName = "svg:polyline";
                }
                render() {
                  this.container.className = this.containerClassName;
                  const data = this.data;
                  const {
                    width: width2,
                    height: height2
                  } = getRectDims(data.rect);
                  const svg = this.svgFactory.create(width2, height2, true);
                  for (const inkList of data.inkLists) {
                    let points = [];
                    for (const coordinate of inkList) {
                      const x = coordinate.x - data.rect[0];
                      const y = data.rect[3] - coordinate.y;
                      points.push(`${x},${y}`);
                    }
                    points = points.join(" ");
                    const polyline = this.svgFactory.createElement(this.svgElementName);
                    polyline.setAttribute("points", points);
                    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                    polyline.setAttribute("stroke", "transparent");
                    polyline.setAttribute("fill", "transparent");
                    this._createPopup(polyline, data);
                    svg.append(polyline);
                  }
                  this.container.append(svg);
                  return this.container;
                }
              }
              class HighlightAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("highlightAnnotation");
                  }
                  this.container.className = "highlightAnnotation";
                  return this.container;
                }
              }
              class UnderlineAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("underlineAnnotation");
                  }
                  this.container.className = "underlineAnnotation";
                  return this.container;
                }
              }
              class SquigglyAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("squigglyAnnotation");
                  }
                  this.container.className = "squigglyAnnotation";
                  return this.container;
                }
              }
              class StrikeOutAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true,
                    createQuadrilaterals: true
                  });
                }
                render() {
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  if (this.quadrilaterals) {
                    return this._renderQuadrilaterals("strikeoutAnnotation");
                  }
                  this.container.className = "strikeoutAnnotation";
                  return this.container;
                }
              }
              class StampAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
                  super(parameters, {
                    isRenderable,
                    ignoreBorder: true
                  });
                }
                render() {
                  this.container.className = "stampAnnotation";
                  if (!this.data.hasPopup) {
                    this._createPopup(null, this.data);
                  }
                  return this.container;
                }
              }
              class FileAttachmentAnnotationElement extends AnnotationElement {
                constructor(parameters) {
                  super(parameters, {
                    isRenderable: true
                  });
                  const {
                    filename,
                    content
                  } = this.data.file;
                  this.filename = (0, _display_utils2.getFilenameFromUrl)(filename);
                  this.content = content;
                  this.linkService.eventBus?.dispatch("fileattachmentannotation", {
                    source: this,
                    filename,
                    content
                  });
                }
                render() {
                  this.container.className = "fileAttachmentAnnotation";
                  const trigger = document.createElement("div");
                  trigger.className = "popupTriggerArea";
                  trigger.addEventListener("dblclick", this._download.bind(this));
                  if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {
                    this._createPopup(trigger, this.data);
                  }
                  this.container.append(trigger);
                  return this.container;
                }
                _download() {
                  this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
                }
              }
              const _AnnotationLayer = class {
                static render(parameters) {
                  var _a, _b;
                  const {
                    annotations,
                    div: div4,
                    viewport,
                    accessibilityManager
                  } = parameters;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, div4, viewport);
                  let zIndex = 0;
                  for (const data of annotations) {
                    if (data.annotationType !== _util2.AnnotationType.POPUP) {
                      const {
                        width: width2,
                        height: height2
                      } = getRectDims(data.rect);
                      if (width2 <= 0 || height2 <= 0) {
                        continue;
                      }
                    }
                    const element = AnnotationElementFactory.create({
                      data,
                      layer: div4,
                      page: parameters.page,
                      viewport,
                      linkService: parameters.linkService,
                      downloadManager: parameters.downloadManager,
                      imageResourcesPath: parameters.imageResourcesPath || "",
                      renderForms: parameters.renderForms !== false,
                      svgFactory: new _display_utils2.DOMSVGFactory(),
                      annotationStorage: parameters.annotationStorage || new _annotation_storage2.AnnotationStorage(),
                      enableScripting: parameters.enableScripting,
                      hasJSActions: parameters.hasJSActions,
                      fieldObjects: parameters.fieldObjects,
                      mouseState: parameters.mouseState || {
                        isDown: false
                      }
                    });
                    if (element.isRenderable) {
                      const rendered = element.render();
                      if (data.hidden) {
                        rendered.style.visibility = "hidden";
                      }
                      if (Array.isArray(rendered)) {
                        for (const renderedElement of rendered) {
                          renderedElement.style.zIndex = zIndex++;
                          __privateMethod(_a = _AnnotationLayer, _appendElement, appendElement_fn).call(_a, renderedElement, data.id, div4, accessibilityManager);
                        }
                      } else {
                        rendered.style.zIndex = zIndex++;
                        if (element instanceof PopupAnnotationElement) {
                          div4.prepend(rendered);
                        } else {
                          __privateMethod(_b = _AnnotationLayer, _appendElement, appendElement_fn).call(_b, rendered, data.id, div4, accessibilityManager);
                        }
                      }
                    }
                  }
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div4, parameters.annotationCanvasMap);
                }
                static update(parameters) {
                  const {
                    annotationCanvasMap,
                    div: div4,
                    viewport
                  } = parameters;
                  __privateMethod(this, _setDimensions, setDimensions_fn).call(this, div4, viewport);
                  __privateMethod(this, _setAnnotationCanvasMap, setAnnotationCanvasMap_fn).call(this, div4, annotationCanvasMap);
                  div4.hidden = false;
                }
              };
              let AnnotationLayer = _AnnotationLayer;
              _appendElement = new WeakSet();
              appendElement_fn = function(element, id2, div4, accessibilityManager) {
                const contentElement = element.firstChild || element;
                contentElement.id = `${_display_utils2.AnnotationPrefix}${id2}`;
                div4.append(element);
                accessibilityManager?.moveElementInDOM(div4, element, contentElement, false);
              };
              _setDimensions = new WeakSet();
              setDimensions_fn = function(div4, {
                width: width2,
                height: height2,
                rotation
              }) {
                const {
                  style
                } = div4;
                const flipOrientation = rotation % 180 !== 0, widthStr = Math.floor(width2) + "px", heightStr = Math.floor(height2) + "px";
                style.width = flipOrientation ? heightStr : widthStr;
                style.height = flipOrientation ? widthStr : heightStr;
                div4.setAttribute("data-main-rotation", rotation);
              };
              _setAnnotationCanvasMap = new WeakSet();
              setAnnotationCanvasMap_fn = function(div4, annotationCanvasMap) {
                if (!annotationCanvasMap) {
                  return;
                }
                for (const [id2, canvas] of annotationCanvasMap) {
                  const element = div4.querySelector(`[data-annotation-id="${id2}"]`);
                  if (!element) {
                    continue;
                  }
                  const {
                    firstChild
                  } = element;
                  if (!firstChild) {
                    element.append(canvas);
                  } else if (firstChild.nodeName === "CANVAS") {
                    firstChild.replaceWith(canvas);
                  } else {
                    firstChild.before(canvas);
                  }
                }
                annotationCanvasMap.clear();
              };
              __privateAdd(AnnotationLayer, _appendElement);
              __privateAdd(AnnotationLayer, _setDimensions);
              __privateAdd(AnnotationLayer, _setAnnotationCanvasMap);
              exports2.AnnotationLayer = AnnotationLayer;
            },
            /* 28 */
            /***/
            (__unused_webpack_module2, exports2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.ColorConverters = void 0;
              function makeColorComp(n2) {
                return Math.floor(Math.max(0, Math.min(1, n2)) * 255).toString(16).padStart(2, "0");
              }
              class ColorConverters {
                static CMYK_G([c, y, m, k]) {
                  return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
                }
                static G_CMYK([g]) {
                  return ["CMYK", 0, 0, 0, 1 - g];
                }
                static G_RGB([g]) {
                  return ["RGB", g, g, g];
                }
                static G_HTML([g]) {
                  const G = makeColorComp(g);
                  return `#${G}${G}${G}`;
                }
                static RGB_G([r, g, b]) {
                  return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
                }
                static RGB_HTML([r, g, b]) {
                  const R2 = makeColorComp(r);
                  const G = makeColorComp(g);
                  const B2 = makeColorComp(b);
                  return `#${R2}${G}${B2}`;
                }
                static T_HTML() {
                  return "#00000000";
                }
                static CMYK_RGB([c, y, m, k]) {
                  return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
                }
                static CMYK_HTML(components) {
                  const rgb2 = this.CMYK_RGB(components).slice(1);
                  return this.RGB_HTML(rgb2);
                }
                static RGB_CMYK([r, g, b]) {
                  const c = 1 - r;
                  const m = 1 - g;
                  const y = 1 - b;
                  const k = Math.min(c, m, y);
                  return ["CMYK", c, m, y, k];
                }
              }
              exports2.ColorConverters = ColorConverters;
            },
            /* 29 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.XfaLayer = void 0;
              var _xfa_text2 = __w_pdfjs_require__2(20);
              class XfaLayer {
                static setupStorage(html, id2, element, storage, intent) {
                  const storedData = storage.getValue(id2, {
                    value: null
                  });
                  switch (element.name) {
                    case "textarea":
                      if (storedData.value !== null) {
                        html.textContent = storedData.value;
                      }
                      if (intent === "print") {
                        break;
                      }
                      html.addEventListener("input", (event) => {
                        storage.setValue(id2, {
                          value: event.target.value
                        });
                      });
                      break;
                    case "input":
                      if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                        if (storedData.value === element.attributes.xfaOn) {
                          html.setAttribute("checked", true);
                        } else if (storedData.value === element.attributes.xfaOff) {
                          html.removeAttribute("checked");
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("change", (event) => {
                          storage.setValue(id2, {
                            value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                          });
                        });
                      } else {
                        if (storedData.value !== null) {
                          html.setAttribute("value", storedData.value);
                        }
                        if (intent === "print") {
                          break;
                        }
                        html.addEventListener("input", (event) => {
                          storage.setValue(id2, {
                            value: event.target.value
                          });
                        });
                      }
                      break;
                    case "select":
                      if (storedData.value !== null) {
                        for (const option of element.children) {
                          if (option.attributes.value === storedData.value) {
                            option.attributes.selected = true;
                          }
                        }
                      }
                      html.addEventListener("input", (event) => {
                        const options = event.target.options;
                        const value2 = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                        storage.setValue(id2, {
                          value: value2
                        });
                      });
                      break;
                  }
                }
                static setAttributes({
                  html,
                  element,
                  storage = null,
                  intent,
                  linkService
                }) {
                  const {
                    attributes
                  } = element;
                  const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
                  if (attributes.type === "radio") {
                    attributes.name = `${attributes.name}-${intent}`;
                  }
                  for (const [key, value2] of Object.entries(attributes)) {
                    if (value2 === null || value2 === void 0) {
                      continue;
                    }
                    switch (key) {
                      case "class":
                        if (value2.length) {
                          html.setAttribute(key, value2.join(" "));
                        }
                        break;
                      case "dataId":
                        break;
                      case "id":
                        html.setAttribute("data-element-id", value2);
                        break;
                      case "style":
                        Object.assign(html.style, value2);
                        break;
                      case "textContent":
                        html.textContent = value2;
                        break;
                      default:
                        if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                          html.setAttribute(key, value2);
                        }
                    }
                  }
                  if (isHTMLAnchorElement) {
                    linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
                  }
                  if (storage && attributes.dataId) {
                    this.setupStorage(html, attributes.dataId, element, storage);
                  }
                }
                static render(parameters) {
                  const storage = parameters.annotationStorage;
                  const linkService = parameters.linkService;
                  const root = parameters.xfaHtml;
                  const intent = parameters.intent || "display";
                  const rootHtml = document.createElement(root.name);
                  if (root.attributes) {
                    this.setAttributes({
                      html: rootHtml,
                      element: root,
                      intent,
                      linkService
                    });
                  }
                  const stack = [[root, -1, rootHtml]];
                  const rootDiv = parameters.div;
                  rootDiv.append(rootHtml);
                  if (parameters.viewport) {
                    const transform2 = `matrix(${parameters.viewport.transform.join(",")})`;
                    rootDiv.style.transform = transform2;
                  }
                  if (intent !== "richText") {
                    rootDiv.setAttribute("class", "xfaLayer xfaFont");
                  }
                  const textDivs = [];
                  while (stack.length > 0) {
                    const [parent, i, html] = stack.at(-1);
                    if (i + 1 === parent.children.length) {
                      stack.pop();
                      continue;
                    }
                    const child = parent.children[++stack.at(-1)[1]];
                    if (child === null) {
                      continue;
                    }
                    const {
                      name: name3
                    } = child;
                    if (name3 === "#text") {
                      const node = document.createTextNode(child.value);
                      textDivs.push(node);
                      html.append(node);
                      continue;
                    }
                    let childHtml;
                    if (child?.attributes?.xmlns) {
                      childHtml = document.createElementNS(child.attributes.xmlns, name3);
                    } else {
                      childHtml = document.createElement(name3);
                    }
                    html.append(childHtml);
                    if (child.attributes) {
                      this.setAttributes({
                        html: childHtml,
                        element: child,
                        storage,
                        intent,
                        linkService
                      });
                    }
                    if (child.children && child.children.length > 0) {
                      stack.push([child, -1, childHtml]);
                    } else if (child.value) {
                      const node = document.createTextNode(child.value);
                      if (_xfa_text2.XfaText.shouldBuildText(name3)) {
                        textDivs.push(node);
                      }
                      childHtml.append(node);
                    }
                  }
                  for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
                    el.setAttribute("readOnly", true);
                  }
                  return {
                    textDivs
                  };
                }
                static update(parameters) {
                  const transform2 = `matrix(${parameters.viewport.transform.join(",")})`;
                  parameters.div.style.transform = transform2;
                  parameters.div.hidden = false;
                }
              }
              exports2.XfaLayer = XfaLayer;
            },
            /* 30 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.TextLayerRenderTask = void 0;
              exports2.renderTextLayer = renderTextLayer;
              var _util2 = __w_pdfjs_require__2(1);
              var _display_utils2 = __w_pdfjs_require__2(8);
              const MAX_TEXT_DIVS_TO_RENDER = 1e5;
              const DEFAULT_FONT_SIZE = 30;
              const DEFAULT_FONT_ASCENT = 0.8;
              const ascentCache = /* @__PURE__ */ new Map();
              const AllWhitespaceRegexp = /^\s+$/g;
              function getAscent(fontFamily, ctx) {
                const cachedAscent = ascentCache.get(fontFamily);
                if (cachedAscent) {
                  return cachedAscent;
                }
                ctx.save();
                ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
                const metrics = ctx.measureText("");
                let ascent = metrics.fontBoundingBoxAscent;
                let descent = Math.abs(metrics.fontBoundingBoxDescent);
                if (ascent) {
                  ctx.restore();
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ctx.strokeStyle = "red";
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("g", 0, 0);
                let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                descent = 0;
                for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
                  if (pixels[i] > 0) {
                    descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
                ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
                pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
                ascent = 0;
                for (let i = 0, ii = pixels.length; i < ii; i += 4) {
                  if (pixels[i] > 0) {
                    ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
                    break;
                  }
                }
                ctx.restore();
                if (ascent) {
                  const ratio = ascent / (ascent + descent);
                  ascentCache.set(fontFamily, ratio);
                  return ratio;
                }
                ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
                return DEFAULT_FONT_ASCENT;
              }
              function appendText(task, geom4, styles, ctx) {
                const textDiv = document.createElement("span");
                const textDivProperties = task._enhanceTextSelection ? {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom4.str !== "",
                  hasEOL: geom4.hasEOL,
                  originalTransform: null,
                  paddingBottom: 0,
                  paddingLeft: 0,
                  paddingRight: 0,
                  paddingTop: 0,
                  scale: 1,
                  fontSize: 0
                } : {
                  angle: 0,
                  canvasWidth: 0,
                  hasText: geom4.str !== "",
                  hasEOL: geom4.hasEOL,
                  fontSize: 0
                };
                task._textDivs.push(textDiv);
                const tx = _util2.Util.transform(task._viewport.transform, geom4.transform);
                let angle5 = Math.atan2(tx[1], tx[0]);
                const style = styles[geom4.fontName];
                if (style.vertical) {
                  angle5 += Math.PI / 2;
                }
                const fontHeight = Math.hypot(tx[2], tx[3]);
                const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
                let left2, top2;
                if (angle5 === 0) {
                  left2 = tx[4];
                  top2 = tx[5] - fontAscent;
                } else {
                  left2 = tx[4] + fontAscent * Math.sin(angle5);
                  top2 = tx[5] - fontAscent * Math.cos(angle5);
                }
                textDiv.style.left = `${left2}px`;
                textDiv.style.top = `${top2}px`;
                textDiv.style.fontSize = `${fontHeight}px`;
                textDiv.style.fontFamily = style.fontFamily;
                textDivProperties.fontSize = fontHeight;
                textDiv.setAttribute("role", "presentation");
                textDiv.textContent = geom4.str;
                textDiv.dir = geom4.dir;
                if (task._fontInspectorEnabled) {
                  textDiv.dataset.fontName = geom4.fontName;
                }
                if (angle5 !== 0) {
                  textDivProperties.angle = angle5 * (180 / Math.PI);
                }
                let shouldScaleText = false;
                if (geom4.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom4.str)) {
                  shouldScaleText = true;
                } else if (geom4.str !== " " && geom4.transform[0] !== geom4.transform[3]) {
                  const absScaleX = Math.abs(geom4.transform[0]), absScaleY = Math.abs(geom4.transform[3]);
                  if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                    shouldScaleText = true;
                  }
                }
                if (shouldScaleText) {
                  if (style.vertical) {
                    textDivProperties.canvasWidth = geom4.height * task._viewport.scale;
                  } else {
                    textDivProperties.canvasWidth = geom4.width * task._viewport.scale;
                  }
                }
                task._textDivProperties.set(textDiv, textDivProperties);
                if (task._textContentStream) {
                  task._layoutText(textDiv);
                }
                if (task._enhanceTextSelection && textDivProperties.hasText) {
                  let angleCos = 1, angleSin = 0;
                  if (angle5 !== 0) {
                    angleCos = Math.cos(angle5);
                    angleSin = Math.sin(angle5);
                  }
                  const divWidth = (style.vertical ? geom4.height : geom4.width) * task._viewport.scale;
                  const divHeight = fontHeight;
                  let m, b;
                  if (angle5 !== 0) {
                    m = [angleCos, angleSin, -angleSin, angleCos, left2, top2];
                    b = _util2.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
                  } else {
                    b = [left2, top2, left2 + divWidth, top2 + divHeight];
                  }
                  task._bounds.push({
                    left: b[0],
                    top: b[1],
                    right: b[2],
                    bottom: b[3],
                    div: textDiv,
                    size: [divWidth, divHeight],
                    m
                  });
                }
              }
              function render(task) {
                if (task._canceled) {
                  return;
                }
                const textDivs = task._textDivs;
                const capability = task._capability;
                const textDivsLength = textDivs.length;
                if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
                  task._renderingDone = true;
                  capability.resolve();
                  return;
                }
                if (!task._textContentStream) {
                  for (let i = 0; i < textDivsLength; i++) {
                    task._layoutText(textDivs[i]);
                  }
                }
                task._renderingDone = true;
                capability.resolve();
              }
              function findPositiveMin(ts, offset, count) {
                let result = 0;
                for (let i = 0; i < count; i++) {
                  const t2 = ts[offset++];
                  if (t2 > 0) {
                    result = result ? Math.min(t2, result) : t2;
                  }
                }
                return result;
              }
              function expand(task) {
                const bounds = task._bounds;
                const viewport = task._viewport;
                const expanded = expandBounds(viewport.width, viewport.height, bounds);
                for (let i = 0; i < expanded.length; i++) {
                  const div4 = bounds[i].div;
                  const divProperties = task._textDivProperties.get(div4);
                  if (divProperties.angle === 0) {
                    divProperties.paddingLeft = bounds[i].left - expanded[i].left;
                    divProperties.paddingTop = bounds[i].top - expanded[i].top;
                    divProperties.paddingRight = expanded[i].right - bounds[i].right;
                    divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;
                    task._textDivProperties.set(div4, divProperties);
                    continue;
                  }
                  const e2 = expanded[i], b = bounds[i];
                  const m = b.m, c = m[0], s = m[1];
                  const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
                  const ts = new Float64Array(64);
                  for (let j = 0, jj = points.length; j < jj; j++) {
                    const t2 = _util2.Util.applyTransform(points[j], m);
                    ts[j + 0] = c && (e2.left - t2[0]) / c;
                    ts[j + 4] = s && (e2.top - t2[1]) / s;
                    ts[j + 8] = c && (e2.right - t2[0]) / c;
                    ts[j + 12] = s && (e2.bottom - t2[1]) / s;
                    ts[j + 16] = s && (e2.left - t2[0]) / -s;
                    ts[j + 20] = c && (e2.top - t2[1]) / c;
                    ts[j + 24] = s && (e2.right - t2[0]) / -s;
                    ts[j + 28] = c && (e2.bottom - t2[1]) / c;
                    ts[j + 32] = c && (e2.left - t2[0]) / -c;
                    ts[j + 36] = s && (e2.top - t2[1]) / -s;
                    ts[j + 40] = c && (e2.right - t2[0]) / -c;
                    ts[j + 44] = s && (e2.bottom - t2[1]) / -s;
                    ts[j + 48] = s && (e2.left - t2[0]) / s;
                    ts[j + 52] = c && (e2.top - t2[1]) / -c;
                    ts[j + 56] = s && (e2.right - t2[0]) / s;
                    ts[j + 60] = c && (e2.bottom - t2[1]) / -c;
                  }
                  const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
                  divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
                  divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
                  divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
                  divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;
                  task._textDivProperties.set(div4, divProperties);
                }
              }
              function expandBounds(width2, height2, boxes) {
                const bounds = boxes.map(function(box, i) {
                  return {
                    x1: box.left,
                    y1: box.top,
                    x2: box.right,
                    y2: box.bottom,
                    index: i,
                    x1New: void 0,
                    x2New: void 0
                  };
                });
                expandBoundsLTR(width2, bounds);
                const expanded = new Array(boxes.length);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i] = {
                    left: b.x1New,
                    top: 0,
                    right: b.x2New,
                    bottom: 0
                  };
                }
                boxes.map(function(box, i) {
                  const e2 = expanded[i], b = bounds[i];
                  b.x1 = box.top;
                  b.y1 = width2 - e2.right;
                  b.x2 = box.bottom;
                  b.y2 = width2 - e2.left;
                  b.index = i;
                  b.x1New = void 0;
                  b.x2New = void 0;
                });
                expandBoundsLTR(height2, bounds);
                for (const b of bounds) {
                  const i = b.index;
                  expanded[i].top = b.x1New;
                  expanded[i].bottom = b.x2New;
                }
                return expanded;
              }
              function expandBoundsLTR(width2, bounds) {
                bounds.sort(function(a, b) {
                  return a.x1 - b.x1 || a.index - b.index;
                });
                const fakeBoundary = {
                  x1: -Infinity,
                  y1: -Infinity,
                  x2: 0,
                  y2: Infinity,
                  index: -1,
                  x1New: 0,
                  x2New: 0
                };
                const horizon = [{
                  start: -Infinity,
                  end: Infinity,
                  boundary: fakeBoundary
                }];
                for (const boundary of bounds) {
                  let i = 0;
                  while (i < horizon.length && horizon[i].end <= boundary.y1) {
                    i++;
                  }
                  let j = horizon.length - 1;
                  while (j >= 0 && horizon[j].start >= boundary.y2) {
                    j--;
                  }
                  let horizonPart, affectedBoundary;
                  let q, k, maxXNew = -Infinity;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    let xNew;
                    if (affectedBoundary.x2 > boundary.x1) {
                      xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
                    } else if (affectedBoundary.x2New === void 0) {
                      xNew = (affectedBoundary.x2 + boundary.x1) / 2;
                    } else {
                      xNew = affectedBoundary.x2New;
                    }
                    if (xNew > maxXNew) {
                      maxXNew = xNew;
                    }
                  }
                  boundary.x1New = maxXNew;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New === void 0) {
                      if (affectedBoundary.x2 > boundary.x1) {
                        if (affectedBoundary.index > boundary.index) {
                          affectedBoundary.x2New = affectedBoundary.x2;
                        }
                      } else {
                        affectedBoundary.x2New = maxXNew;
                      }
                    } else if (affectedBoundary.x2New > maxXNew) {
                      affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
                    }
                  }
                  const changedHorizon = [];
                  let lastBoundary = null;
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;
                    if (lastBoundary === useBoundary) {
                      changedHorizon.at(-1).end = horizonPart.end;
                    } else {
                      changedHorizon.push({
                        start: horizonPart.start,
                        end: horizonPart.end,
                        boundary: useBoundary
                      });
                      lastBoundary = useBoundary;
                    }
                  }
                  if (horizon[i].start < boundary.y1) {
                    changedHorizon[0].start = boundary.y1;
                    changedHorizon.unshift({
                      start: horizon[i].start,
                      end: boundary.y1,
                      boundary: horizon[i].boundary
                    });
                  }
                  if (boundary.y2 < horizon[j].end) {
                    changedHorizon.at(-1).end = boundary.y2;
                    changedHorizon.push({
                      start: boundary.y2,
                      end: horizon[j].end,
                      boundary: horizon[j].boundary
                    });
                  }
                  for (q = i; q <= j; q++) {
                    horizonPart = horizon[q];
                    affectedBoundary = horizonPart.boundary;
                    if (affectedBoundary.x2New !== void 0) {
                      continue;
                    }
                    let used = false;
                    for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
                      used = horizon[k].boundary === affectedBoundary;
                    }
                    for (k = 0; !used && k < changedHorizon.length; k++) {
                      used = changedHorizon[k].boundary === affectedBoundary;
                    }
                    if (!used) {
                      affectedBoundary.x2New = maxXNew;
                    }
                  }
                  Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);
                }
                for (const horizonPart of horizon) {
                  const affectedBoundary = horizonPart.boundary;
                  if (affectedBoundary.x2New === void 0) {
                    affectedBoundary.x2New = Math.max(width2, affectedBoundary.x2);
                  }
                }
              }
              class TextLayerRenderTask {
                constructor({
                  textContent,
                  textContentStream,
                  container,
                  viewport,
                  textDivs,
                  textContentItemsStr,
                  enhanceTextSelection
                }) {
                  if (enhanceTextSelection) {
                    (0, _display_utils2.deprecated)("The `enhanceTextSelection` functionality will be removed in the future.");
                  }
                  this._textContent = textContent;
                  this._textContentStream = textContentStream;
                  this._container = container;
                  this._document = container.ownerDocument;
                  this._viewport = viewport;
                  this._textDivs = textDivs || [];
                  this._textContentItemsStr = textContentItemsStr || [];
                  this._enhanceTextSelection = !!enhanceTextSelection;
                  this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
                  this._reader = null;
                  this._layoutTextLastFontSize = null;
                  this._layoutTextLastFontFamily = null;
                  this._layoutTextCtx = null;
                  this._textDivProperties = /* @__PURE__ */ new WeakMap();
                  this._renderingDone = false;
                  this._canceled = false;
                  this._capability = (0, _util2.createPromiseCapability)();
                  this._renderTimer = null;
                  this._bounds = [];
                  this._devicePixelRatio = globalThis.devicePixelRatio || 1;
                  this._capability.promise.finally(() => {
                    if (!this._enhanceTextSelection) {
                      this._textDivProperties = null;
                    }
                    if (this._layoutTextCtx) {
                      this._layoutTextCtx.canvas.width = 0;
                      this._layoutTextCtx.canvas.height = 0;
                      this._layoutTextCtx = null;
                    }
                  }).catch(() => {
                  });
                }
                get promise() {
                  return this._capability.promise;
                }
                cancel() {
                  this._canceled = true;
                  if (this._reader) {
                    this._reader.cancel(new _util2.AbortException("TextLayer task cancelled.")).catch(() => {
                    });
                    this._reader = null;
                  }
                  if (this._renderTimer !== null) {
                    clearTimeout(this._renderTimer);
                    this._renderTimer = null;
                  }
                  this._capability.reject(new Error("TextLayer task cancelled."));
                }
                _processItems(items, styleCache) {
                  for (let i = 0, len6 = items.length; i < len6; i++) {
                    if (items[i].str === void 0) {
                      if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                        const parent = this._container;
                        this._container = document.createElement("span");
                        this._container.classList.add("markedContent");
                        if (items[i].id !== null) {
                          this._container.setAttribute("id", `${items[i].id}`);
                        }
                        parent.append(this._container);
                      } else if (items[i].type === "endMarkedContent") {
                        this._container = this._container.parentNode;
                      }
                      continue;
                    }
                    this._textContentItemsStr.push(items[i].str);
                    appendText(this, items[i], styleCache, this._layoutTextCtx);
                  }
                }
                _layoutText(textDiv) {
                  const textDivProperties = this._textDivProperties.get(textDiv);
                  let transform2 = "";
                  if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                    const {
                      fontFamily
                    } = textDiv.style;
                    const {
                      fontSize: fontSize2
                    } = textDivProperties;
                    if (fontSize2 !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                      this._layoutTextCtx.font = `${fontSize2 * this._devicePixelRatio}px ${fontFamily}`;
                      this._layoutTextLastFontSize = fontSize2;
                      this._layoutTextLastFontFamily = fontFamily;
                    }
                    const {
                      width: width2
                    } = this._layoutTextCtx.measureText(textDiv.textContent);
                    if (width2 > 0) {
                      const scale8 = this._devicePixelRatio * textDivProperties.canvasWidth / width2;
                      if (this._enhanceTextSelection) {
                        textDivProperties.scale = scale8;
                      }
                      transform2 = `scaleX(${scale8})`;
                    }
                  }
                  if (textDivProperties.angle !== 0) {
                    transform2 = `rotate(${textDivProperties.angle}deg) ${transform2}`;
                  }
                  if (transform2.length > 0) {
                    if (this._enhanceTextSelection) {
                      textDivProperties.originalTransform = transform2;
                    }
                    textDiv.style.transform = transform2;
                  }
                  if (textDivProperties.hasText) {
                    this._container.append(textDiv);
                  }
                  if (textDivProperties.hasEOL) {
                    const br = document.createElement("br");
                    br.setAttribute("role", "presentation");
                    this._container.append(br);
                  }
                }
                _render(timeout = 0) {
                  const capability = (0, _util2.createPromiseCapability)();
                  let styleCache = /* @__PURE__ */ Object.create(null);
                  const canvas = this._document.createElement("canvas");
                  canvas.height = canvas.width = DEFAULT_FONT_SIZE;
                  this._layoutTextCtx = canvas.getContext("2d", {
                    alpha: false
                  });
                  if (this._textContent) {
                    const textItems = this._textContent.items;
                    const textStyles = this._textContent.styles;
                    this._processItems(textItems, textStyles);
                    capability.resolve();
                  } else if (this._textContentStream) {
                    const pump = () => {
                      this._reader.read().then(({
                        value: value2,
                        done
                      }) => {
                        if (done) {
                          capability.resolve();
                          return;
                        }
                        Object.assign(styleCache, value2.styles);
                        this._processItems(value2.items, styleCache);
                        pump();
                      }, capability.reject);
                    };
                    this._reader = this._textContentStream.getReader();
                    pump();
                  } else {
                    throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
                  }
                  capability.promise.then(() => {
                    styleCache = null;
                    if (!timeout) {
                      render(this);
                    } else {
                      this._renderTimer = setTimeout(() => {
                        render(this);
                        this._renderTimer = null;
                      }, timeout);
                    }
                  }, this._capability.reject);
                }
                expandTextDivs(expandDivs = false) {
                  if (!this._enhanceTextSelection || !this._renderingDone) {
                    return;
                  }
                  if (this._bounds !== null) {
                    expand(this);
                    this._bounds = null;
                  }
                  const transformBuf = [], paddingBuf = [];
                  for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
                    const div4 = this._textDivs[i];
                    const divProps = this._textDivProperties.get(div4);
                    if (!divProps.hasText) {
                      continue;
                    }
                    if (expandDivs) {
                      transformBuf.length = 0;
                      paddingBuf.length = 0;
                      if (divProps.originalTransform) {
                        transformBuf.push(divProps.originalTransform);
                      }
                      if (divProps.paddingTop > 0) {
                        paddingBuf.push(`${divProps.paddingTop}px`);
                        transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingRight > 0) {
                        paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingBottom > 0) {
                        paddingBuf.push(`${divProps.paddingBottom}px`);
                      } else {
                        paddingBuf.push(0);
                      }
                      if (divProps.paddingLeft > 0) {
                        paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
                        transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
                      } else {
                        paddingBuf.push(0);
                      }
                      div4.style.padding = paddingBuf.join(" ");
                      if (transformBuf.length) {
                        div4.style.transform = transformBuf.join(" ");
                      }
                    } else {
                      div4.style.padding = null;
                      div4.style.transform = divProps.originalTransform;
                    }
                  }
                }
              }
              exports2.TextLayerRenderTask = TextLayerRenderTask;
              function renderTextLayer(renderParameters) {
                const task = new TextLayerRenderTask({
                  textContent: renderParameters.textContent,
                  textContentStream: renderParameters.textContentStream,
                  container: renderParameters.container,
                  viewport: renderParameters.viewport,
                  textDivs: renderParameters.textDivs,
                  textContentItemsStr: renderParameters.textContentItemsStr,
                  enhanceTextSelection: renderParameters.enhanceTextSelection
                });
                task._render(renderParameters.timeout);
                return task;
              }
            },
            /* 31 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.SVGGraphics = void 0;
              var _display_utils2 = __w_pdfjs_require__2(8);
              var _util2 = __w_pdfjs_require__2(1);
              var _is_node2 = __w_pdfjs_require__2(3);
              let SVGGraphics = class {
                constructor() {
                  (0, _util2.unreachable)("Not implemented: SVGGraphics");
                }
              };
              exports2.SVGGraphics = SVGGraphics;
              {
                let opListToTree = function(opList) {
                  let opTree = [];
                  const tmp = [];
                  for (const opListElement of opList) {
                    if (opListElement.fn === "save") {
                      opTree.push({
                        fnId: 92,
                        fn: "group",
                        items: []
                      });
                      tmp.push(opTree);
                      opTree = opTree.at(-1).items;
                      continue;
                    }
                    if (opListElement.fn === "restore") {
                      opTree = tmp.pop();
                    } else {
                      opTree.push(opListElement);
                    }
                  }
                  return opTree;
                }, pf = function(value2) {
                  if (Number.isInteger(value2)) {
                    return value2.toString();
                  }
                  const s = value2.toFixed(10);
                  let i = s.length - 1;
                  if (s[i] !== "0") {
                    return s;
                  }
                  do {
                    i--;
                  } while (s[i] === "0");
                  return s.substring(0, s[i] === "." ? i : i + 1);
                }, pm = function(m) {
                  if (m[4] === 0 && m[5] === 0) {
                    if (m[1] === 0 && m[2] === 0) {
                      if (m[0] === 1 && m[3] === 1) {
                        return "";
                      }
                      return `scale(${pf(m[0])} ${pf(m[3])})`;
                    }
                    if (m[0] === m[3] && m[1] === -m[2]) {
                      const a = Math.acos(m[0]) * 180 / Math.PI;
                      return `rotate(${pf(a)})`;
                    }
                  } else {
                    if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                      return `translate(${pf(m[4])} ${pf(m[5])})`;
                    }
                  }
                  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ${pf(m[5])})`;
                };
                const SVG_DEFAULTS = {
                  fontStyle: "normal",
                  fontWeight: "normal",
                  fillColor: "#000000"
                };
                const XML_NS = "http://www.w3.org/XML/1998/namespace";
                const XLINK_NS = "http://www.w3.org/1999/xlink";
                const LINE_CAP_STYLES = ["butt", "round", "square"];
                const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
                const createObjectURL = function(data, contentType = "", forceDataSchema = false) {
                  if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
                    return URL.createObjectURL(new Blob([data], {
                      type: contentType
                    }));
                  }
                  const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                  let buffer = `data:${contentType};base64,`;
                  for (let i = 0, ii = data.length; i < ii; i += 3) {
                    const b1 = data[i] & 255;
                    const b2 = data[i + 1] & 255;
                    const b3 = data[i + 2] & 255;
                    const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4;
                    const d3 = i + 1 < ii ? (b2 & 15) << 2 | b3 >> 6 : 64;
                    const d4 = i + 2 < ii ? b3 & 63 : 64;
                    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
                  }
                  return buffer;
                };
                const convertImgDataToPng = function() {
                  const PNG_HEADER = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
                  const CHUNK_WRAPPER_SIZE = 12;
                  const crcTable = new Int32Array(256);
                  for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let h = 0; h < 8; h++) {
                      if (c & 1) {
                        c = 3988292384 ^ c >> 1 & 2147483647;
                      } else {
                        c = c >> 1 & 2147483647;
                      }
                    }
                    crcTable[i] = c;
                  }
                  function crc32(data, start2, end2) {
                    let crc = -1;
                    for (let i = start2; i < end2; i++) {
                      const a = (crc ^ data[i]) & 255;
                      const b = crcTable[a];
                      crc = crc >>> 8 ^ b;
                    }
                    return crc ^ -1;
                  }
                  function writePngChunk(type2, body, data, offset) {
                    let p = offset;
                    const len6 = body.length;
                    data[p] = len6 >> 24 & 255;
                    data[p + 1] = len6 >> 16 & 255;
                    data[p + 2] = len6 >> 8 & 255;
                    data[p + 3] = len6 & 255;
                    p += 4;
                    data[p] = type2.charCodeAt(0) & 255;
                    data[p + 1] = type2.charCodeAt(1) & 255;
                    data[p + 2] = type2.charCodeAt(2) & 255;
                    data[p + 3] = type2.charCodeAt(3) & 255;
                    p += 4;
                    data.set(body, p);
                    p += body.length;
                    const crc = crc32(data, offset + 4, p);
                    data[p] = crc >> 24 & 255;
                    data[p + 1] = crc >> 16 & 255;
                    data[p + 2] = crc >> 8 & 255;
                    data[p + 3] = crc & 255;
                  }
                  function adler32(data, start2, end2) {
                    let a = 1;
                    let b = 0;
                    for (let i = start2; i < end2; ++i) {
                      a = (a + (data[i] & 255)) % 65521;
                      b = (b + a) % 65521;
                    }
                    return b << 16 | a;
                  }
                  function deflateSync(literals) {
                    if (!_is_node2.isNodeJS) {
                      return deflateSyncUncompressed(literals);
                    }
                    try {
                      let input;
                      if (parseInt(process.versions.node) >= 8) {
                        input = literals;
                      } else {
                        input = Buffer.from(literals);
                      }
                      const output = require_zlib().deflateSync(input, {
                        level: 9
                      });
                      return output instanceof Uint8Array ? output : new Uint8Array(output);
                    } catch (e2) {
                      (0, _util2.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e2);
                    }
                    return deflateSyncUncompressed(literals);
                  }
                  function deflateSyncUncompressed(literals) {
                    let len6 = literals.length;
                    const maxBlockLength = 65535;
                    const deflateBlocks = Math.ceil(len6 / maxBlockLength);
                    const idat = new Uint8Array(2 + len6 + deflateBlocks * 5 + 4);
                    let pi = 0;
                    idat[pi++] = 120;
                    idat[pi++] = 156;
                    let pos = 0;
                    while (len6 > maxBlockLength) {
                      idat[pi++] = 0;
                      idat[pi++] = 255;
                      idat[pi++] = 255;
                      idat[pi++] = 0;
                      idat[pi++] = 0;
                      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                      pi += maxBlockLength;
                      pos += maxBlockLength;
                      len6 -= maxBlockLength;
                    }
                    idat[pi++] = 1;
                    idat[pi++] = len6 & 255;
                    idat[pi++] = len6 >> 8 & 255;
                    idat[pi++] = ~len6 & 65535 & 255;
                    idat[pi++] = (~len6 & 65535) >> 8 & 255;
                    idat.set(literals.subarray(pos), pi);
                    pi += literals.length - pos;
                    const adler = adler32(literals, 0, literals.length);
                    idat[pi++] = adler >> 24 & 255;
                    idat[pi++] = adler >> 16 & 255;
                    idat[pi++] = adler >> 8 & 255;
                    idat[pi++] = adler & 255;
                    return idat;
                  }
                  function encode(imgData, kind, forceDataSchema, isMask) {
                    const width2 = imgData.width;
                    const height2 = imgData.height;
                    let bitDepth, colorType, lineSize;
                    const bytes = imgData.data;
                    switch (kind) {
                      case _util2.ImageKind.GRAYSCALE_1BPP:
                        colorType = 0;
                        bitDepth = 1;
                        lineSize = width2 + 7 >> 3;
                        break;
                      case _util2.ImageKind.RGB_24BPP:
                        colorType = 2;
                        bitDepth = 8;
                        lineSize = width2 * 3;
                        break;
                      case _util2.ImageKind.RGBA_32BPP:
                        colorType = 6;
                        bitDepth = 8;
                        lineSize = width2 * 4;
                        break;
                      default:
                        throw new Error("invalid format");
                    }
                    const literals = new Uint8Array((1 + lineSize) * height2);
                    let offsetLiterals = 0, offsetBytes = 0;
                    for (let y = 0; y < height2; ++y) {
                      literals[offsetLiterals++] = 0;
                      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                      offsetBytes += lineSize;
                      offsetLiterals += lineSize;
                    }
                    if (kind === _util2.ImageKind.GRAYSCALE_1BPP && isMask) {
                      offsetLiterals = 0;
                      for (let y = 0; y < height2; y++) {
                        offsetLiterals++;
                        for (let i = 0; i < lineSize; i++) {
                          literals[offsetLiterals++] ^= 255;
                        }
                      }
                    }
                    const ihdr = new Uint8Array([width2 >> 24 & 255, width2 >> 16 & 255, width2 >> 8 & 255, width2 & 255, height2 >> 24 & 255, height2 >> 16 & 255, height2 >> 8 & 255, height2 & 255, bitDepth, colorType, 0, 0, 0]);
                    const idat = deflateSync(literals);
                    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
                    const data = new Uint8Array(pngLength);
                    let offset = 0;
                    data.set(PNG_HEADER, offset);
                    offset += PNG_HEADER.length;
                    writePngChunk("IHDR", ihdr, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + ihdr.length;
                    writePngChunk("IDATA", idat, data, offset);
                    offset += CHUNK_WRAPPER_SIZE + idat.length;
                    writePngChunk("IEND", new Uint8Array(0), data, offset);
                    return createObjectURL(data, "image/png", forceDataSchema);
                  }
                  return function convertImgDataToPng2(imgData, forceDataSchema, isMask) {
                    const kind = imgData.kind === void 0 ? _util2.ImageKind.GRAYSCALE_1BPP : imgData.kind;
                    return encode(imgData, kind, forceDataSchema, isMask);
                  };
                }();
                class SVGExtraState {
                  constructor() {
                    this.fontSizeScale = 1;
                    this.fontWeight = SVG_DEFAULTS.fontWeight;
                    this.fontSize = 0;
                    this.textMatrix = _util2.IDENTITY_MATRIX;
                    this.fontMatrix = _util2.FONT_IDENTITY_MATRIX;
                    this.leading = 0;
                    this.textRenderingMode = _util2.TextRenderingMode.FILL;
                    this.textMatrixScale = 1;
                    this.x = 0;
                    this.y = 0;
                    this.lineX = 0;
                    this.lineY = 0;
                    this.charSpacing = 0;
                    this.wordSpacing = 0;
                    this.textHScale = 1;
                    this.textRise = 0;
                    this.fillColor = SVG_DEFAULTS.fillColor;
                    this.strokeColor = "#000000";
                    this.fillAlpha = 1;
                    this.strokeAlpha = 1;
                    this.lineWidth = 1;
                    this.lineJoin = "";
                    this.lineCap = "";
                    this.miterLimit = 0;
                    this.dashArray = [];
                    this.dashPhase = 0;
                    this.dependencies = [];
                    this.activeClipUrl = null;
                    this.clipGroup = null;
                    this.maskId = "";
                  }
                  clone() {
                    return Object.create(this);
                  }
                  setCurrentPoint(x, y) {
                    this.x = x;
                    this.y = y;
                  }
                }
                let clipCount = 0;
                let maskCount = 0;
                let shadingCount = 0;
                exports2.SVGGraphics = SVGGraphics = class {
                  constructor(commonObjs, objs, forceDataSchema = false) {
                    (0, _display_utils2.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
                    this.svgFactory = new _display_utils2.DOMSVGFactory();
                    this.current = new SVGExtraState();
                    this.transformMatrix = _util2.IDENTITY_MATRIX;
                    this.transformStack = [];
                    this.extraStack = [];
                    this.commonObjs = commonObjs;
                    this.objs = objs;
                    this.pendingClip = null;
                    this.pendingEOFill = false;
                    this.embedFonts = false;
                    this.embeddedFonts = /* @__PURE__ */ Object.create(null);
                    this.cssStyle = null;
                    this.forceDataSchema = !!forceDataSchema;
                    this._operatorIdMapping = [];
                    for (const op in _util2.OPS) {
                      this._operatorIdMapping[_util2.OPS[op]] = op;
                    }
                  }
                  save() {
                    this.transformStack.push(this.transformMatrix);
                    const old = this.current;
                    this.extraStack.push(old);
                    this.current = old.clone();
                  }
                  restore() {
                    this.transformMatrix = this.transformStack.pop();
                    this.current = this.extraStack.pop();
                    this.pendingClip = null;
                    this.tgrp = null;
                  }
                  group(items) {
                    this.save();
                    this.executeOpTree(items);
                    this.restore();
                  }
                  loadDependencies(operatorList) {
                    const fnArray = operatorList.fnArray;
                    const argsArray = operatorList.argsArray;
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      if (fnArray[i] !== _util2.OPS.dependency) {
                        continue;
                      }
                      for (const obj2 of argsArray[i]) {
                        const objsPool = obj2.startsWith("g_") ? this.commonObjs : this.objs;
                        const promise = new Promise((resolve) => {
                          objsPool.get(obj2, resolve);
                        });
                        this.current.dependencies.push(promise);
                      }
                    }
                    return Promise.all(this.current.dependencies);
                  }
                  transform(a, b, c, d, e2, f2) {
                    const transformMatrix = [a, b, c, d, e2, f2];
                    this.transformMatrix = _util2.Util.transform(this.transformMatrix, transformMatrix);
                    this.tgrp = null;
                  }
                  getSVG(operatorList, viewport) {
                    this.viewport = viewport;
                    const svgElement = this._initialize(viewport);
                    return this.loadDependencies(operatorList).then(() => {
                      this.transformMatrix = _util2.IDENTITY_MATRIX;
                      this.executeOpTree(this.convertOpList(operatorList));
                      return svgElement;
                    });
                  }
                  convertOpList(operatorList) {
                    const operatorIdMapping = this._operatorIdMapping;
                    const argsArray = operatorList.argsArray;
                    const fnArray = operatorList.fnArray;
                    const opList = [];
                    for (let i = 0, ii = fnArray.length; i < ii; i++) {
                      const fnId = fnArray[i];
                      opList.push({
                        fnId,
                        fn: operatorIdMapping[fnId],
                        args: argsArray[i]
                      });
                    }
                    return opListToTree(opList);
                  }
                  executeOpTree(opTree) {
                    for (const opTreeElement of opTree) {
                      const fn = opTreeElement.fn;
                      const fnId = opTreeElement.fnId;
                      const args = opTreeElement.args;
                      switch (fnId | 0) {
                        case _util2.OPS.beginText:
                          this.beginText();
                          break;
                        case _util2.OPS.dependency:
                          break;
                        case _util2.OPS.setLeading:
                          this.setLeading(args);
                          break;
                        case _util2.OPS.setLeadingMoveText:
                          this.setLeadingMoveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setFont:
                          this.setFont(args);
                          break;
                        case _util2.OPS.showText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.showSpacedText:
                          this.showText(args[0]);
                          break;
                        case _util2.OPS.endText:
                          this.endText();
                          break;
                        case _util2.OPS.moveText:
                          this.moveText(args[0], args[1]);
                          break;
                        case _util2.OPS.setCharSpacing:
                          this.setCharSpacing(args[0]);
                          break;
                        case _util2.OPS.setWordSpacing:
                          this.setWordSpacing(args[0]);
                          break;
                        case _util2.OPS.setHScale:
                          this.setHScale(args[0]);
                          break;
                        case _util2.OPS.setTextMatrix:
                          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.setTextRise:
                          this.setTextRise(args[0]);
                          break;
                        case _util2.OPS.setTextRenderingMode:
                          this.setTextRenderingMode(args[0]);
                          break;
                        case _util2.OPS.setLineWidth:
                          this.setLineWidth(args[0]);
                          break;
                        case _util2.OPS.setLineJoin:
                          this.setLineJoin(args[0]);
                          break;
                        case _util2.OPS.setLineCap:
                          this.setLineCap(args[0]);
                          break;
                        case _util2.OPS.setMiterLimit:
                          this.setMiterLimit(args[0]);
                          break;
                        case _util2.OPS.setFillRGBColor:
                          this.setFillRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeRGBColor:
                          this.setStrokeRGBColor(args[0], args[1], args[2]);
                          break;
                        case _util2.OPS.setStrokeColorN:
                          this.setStrokeColorN(args);
                          break;
                        case _util2.OPS.setFillColorN:
                          this.setFillColorN(args);
                          break;
                        case _util2.OPS.shadingFill:
                          this.shadingFill(args[0]);
                          break;
                        case _util2.OPS.setDash:
                          this.setDash(args[0], args[1]);
                          break;
                        case _util2.OPS.setRenderingIntent:
                          this.setRenderingIntent(args[0]);
                          break;
                        case _util2.OPS.setFlatness:
                          this.setFlatness(args[0]);
                          break;
                        case _util2.OPS.setGState:
                          this.setGState(args[0]);
                          break;
                        case _util2.OPS.fill:
                          this.fill();
                          break;
                        case _util2.OPS.eoFill:
                          this.eoFill();
                          break;
                        case _util2.OPS.stroke:
                          this.stroke();
                          break;
                        case _util2.OPS.fillStroke:
                          this.fillStroke();
                          break;
                        case _util2.OPS.eoFillStroke:
                          this.eoFillStroke();
                          break;
                        case _util2.OPS.clip:
                          this.clip("nonzero");
                          break;
                        case _util2.OPS.eoClip:
                          this.clip("evenodd");
                          break;
                        case _util2.OPS.paintSolidColorImageMask:
                          this.paintSolidColorImageMask();
                          break;
                        case _util2.OPS.paintImageXObject:
                          this.paintImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintInlineImageXObject:
                          this.paintInlineImageXObject(args[0]);
                          break;
                        case _util2.OPS.paintImageMaskXObject:
                          this.paintImageMaskXObject(args[0]);
                          break;
                        case _util2.OPS.paintFormXObjectBegin:
                          this.paintFormXObjectBegin(args[0], args[1]);
                          break;
                        case _util2.OPS.paintFormXObjectEnd:
                          this.paintFormXObjectEnd();
                          break;
                        case _util2.OPS.closePath:
                          this.closePath();
                          break;
                        case _util2.OPS.closeStroke:
                          this.closeStroke();
                          break;
                        case _util2.OPS.closeFillStroke:
                          this.closeFillStroke();
                          break;
                        case _util2.OPS.closeEOFillStroke:
                          this.closeEOFillStroke();
                          break;
                        case _util2.OPS.nextLine:
                          this.nextLine();
                          break;
                        case _util2.OPS.transform:
                          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                          break;
                        case _util2.OPS.constructPath:
                          this.constructPath(args[0], args[1]);
                          break;
                        case _util2.OPS.endPath:
                          this.endPath();
                          break;
                        case 92:
                          this.group(opTreeElement.items);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented operator ${fn}`);
                          break;
                      }
                    }
                  }
                  setWordSpacing(wordSpacing) {
                    this.current.wordSpacing = wordSpacing;
                  }
                  setCharSpacing(charSpacing) {
                    this.current.charSpacing = charSpacing;
                  }
                  nextLine() {
                    this.moveText(0, this.current.leading);
                  }
                  setTextMatrix(a, b, c, d, e2, f2) {
                    const current = this.current;
                    current.textMatrix = current.lineMatrix = [a, b, c, d, e2, f2];
                    current.textMatrixScale = Math.hypot(a, b);
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtElement.append(current.tspan);
                  }
                  beginText() {
                    const current = this.current;
                    current.x = current.lineX = 0;
                    current.y = current.lineY = 0;
                    current.textMatrix = _util2.IDENTITY_MATRIX;
                    current.lineMatrix = _util2.IDENTITY_MATRIX;
                    current.textMatrixScale = 1;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.txtElement = this.svgFactory.createElement("svg:text");
                    current.txtgrp = this.svgFactory.createElement("svg:g");
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  moveText(x, y) {
                    const current = this.current;
                    current.x = current.lineX += x;
                    current.y = current.lineY += y;
                    current.xcoords = [];
                    current.ycoords = [];
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                  }
                  showText(glyphs) {
                    const current = this.current;
                    const font2 = current.font;
                    const fontSize2 = current.fontSize;
                    if (fontSize2 === 0) {
                      return;
                    }
                    const fontSizeScale = current.fontSizeScale;
                    const charSpacing = current.charSpacing;
                    const wordSpacing = current.wordSpacing;
                    const fontDirection = current.fontDirection;
                    const textHScale = current.textHScale * fontDirection;
                    const vertical = font2.vertical;
                    const spacingDir = vertical ? 1 : -1;
                    const defaultVMetrics = font2.defaultVMetrics;
                    const widthAdvanceScale = fontSize2 * current.fontMatrix[0];
                    let x = 0;
                    for (const glyph of glyphs) {
                      if (glyph === null) {
                        x += fontDirection * wordSpacing;
                        continue;
                      } else if (typeof glyph === "number") {
                        x += spacingDir * glyph * fontSize2 / 1e3;
                        continue;
                      }
                      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                      const character = glyph.fontChar;
                      let scaledX, scaledY;
                      let width2 = glyph.width;
                      if (vertical) {
                        let vx;
                        const vmetric = glyph.vmetric || defaultVMetrics;
                        vx = glyph.vmetric ? vmetric[1] : width2 * 0.5;
                        vx = -vx * widthAdvanceScale;
                        const vy = vmetric[2] * widthAdvanceScale;
                        width2 = vmetric ? -vmetric[0] : width2;
                        scaledX = vx / fontSizeScale;
                        scaledY = (x + vy) / fontSizeScale;
                      } else {
                        scaledX = x / fontSizeScale;
                        scaledY = 0;
                      }
                      if (glyph.isInFont || font2.missingFile) {
                        current.xcoords.push(current.x + scaledX);
                        if (vertical) {
                          current.ycoords.push(-current.y + scaledY);
                        }
                        current.tspan.textContent += character;
                      } else {
                      }
                      let charWidth;
                      if (vertical) {
                        charWidth = width2 * widthAdvanceScale - spacing * fontDirection;
                      } else {
                        charWidth = width2 * widthAdvanceScale + spacing * fontDirection;
                      }
                      x += charWidth;
                    }
                    current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));
                    if (vertical) {
                      current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                    } else {
                      current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    }
                    if (vertical) {
                      current.y -= x;
                    } else {
                      current.x += x * textHScale;
                    }
                    current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                    current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
                    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                      current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                    }
                    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                      current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                    }
                    const fillStrokeMode = current.textRenderingMode & _util2.TextRenderingMode.FILL_STROKE_MASK;
                    if (fillStrokeMode === _util2.TextRenderingMode.FILL || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                        current.tspan.setAttributeNS(null, "fill", current.fillColor);
                      }
                      if (current.fillAlpha < 1) {
                        current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      }
                    } else if (current.textRenderingMode === _util2.TextRenderingMode.ADD_TO_PATH) {
                      current.tspan.setAttributeNS(null, "fill", "transparent");
                    } else {
                      current.tspan.setAttributeNS(null, "fill", "none");
                    }
                    if (fillStrokeMode === _util2.TextRenderingMode.STROKE || fillStrokeMode === _util2.TextRenderingMode.FILL_STROKE) {
                      const lineWidthScale = 1 / (current.textMatrixScale || 1);
                      this._setStrokeAttributes(current.tspan, lineWidthScale);
                    }
                    let textMatrix = current.textMatrix;
                    if (current.textRise !== 0) {
                      textMatrix = textMatrix.slice();
                      textMatrix[5] += current.textRise;
                    }
                    current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
                    current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                    current.txtElement.append(current.tspan);
                    current.txtgrp.append(current.txtElement);
                    this._ensureTransformGroup().append(current.txtElement);
                  }
                  setLeadingMoveText(x, y) {
                    this.setLeading(-y);
                    this.moveText(x, y);
                  }
                  addFontStyle(fontObj) {
                    if (!fontObj.data) {
                      throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
                    }
                    if (!this.cssStyle) {
                      this.cssStyle = this.svgFactory.createElement("svg:style");
                      this.cssStyle.setAttributeNS(null, "type", "text/css");
                      this.defs.append(this.cssStyle);
                    }
                    const url2 = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                    this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}"; src: url(${url2}); }
`;
                  }
                  setFont(details) {
                    const current = this.current;
                    const fontObj = this.commonObjs.get(details[0]);
                    let size4 = details[1];
                    current.font = fontObj;
                    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                      this.addFontStyle(fontObj);
                      this.embeddedFonts[fontObj.loadedName] = fontObj;
                    }
                    current.fontMatrix = fontObj.fontMatrix || _util2.FONT_IDENTITY_MATRIX;
                    let bold = "normal";
                    if (fontObj.black) {
                      bold = "900";
                    } else if (fontObj.bold) {
                      bold = "bold";
                    }
                    const italic = fontObj.italic ? "italic" : "normal";
                    if (size4 < 0) {
                      size4 = -size4;
                      current.fontDirection = -1;
                    } else {
                      current.fontDirection = 1;
                    }
                    current.fontSize = size4;
                    current.fontFamily = fontObj.loadedName;
                    current.fontWeight = bold;
                    current.fontStyle = italic;
                    current.tspan = this.svgFactory.createElement("svg:tspan");
                    current.tspan.setAttributeNS(null, "y", pf(-current.y));
                    current.xcoords = [];
                    current.ycoords = [];
                  }
                  endText() {
                    const current = this.current;
                    if (current.textRenderingMode & _util2.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
                      current.element = current.txtElement;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  setLineWidth(width2) {
                    if (width2 > 0) {
                      this.current.lineWidth = width2;
                    }
                  }
                  setLineCap(style) {
                    this.current.lineCap = LINE_CAP_STYLES[style];
                  }
                  setLineJoin(style) {
                    this.current.lineJoin = LINE_JOIN_STYLES[style];
                  }
                  setMiterLimit(limit) {
                    this.current.miterLimit = limit;
                  }
                  setStrokeAlpha(strokeAlpha) {
                    this.current.strokeAlpha = strokeAlpha;
                  }
                  setStrokeRGBColor(r, g, b) {
                    this.current.strokeColor = _util2.Util.makeHexColor(r, g, b);
                  }
                  setFillAlpha(fillAlpha) {
                    this.current.fillAlpha = fillAlpha;
                  }
                  setFillRGBColor(r, g, b) {
                    this.current.fillColor = _util2.Util.makeHexColor(r, g, b);
                    this.current.tspan = this.svgFactory.createElement("svg:tspan");
                    this.current.xcoords = [];
                    this.current.ycoords = [];
                  }
                  setStrokeColorN(args) {
                    this.current.strokeColor = this._makeColorN_Pattern(args);
                  }
                  setFillColorN(args) {
                    this.current.fillColor = this._makeColorN_Pattern(args);
                  }
                  shadingFill(args) {
                    const width2 = this.viewport.width;
                    const height2 = this.viewport.height;
                    const inv = _util2.Util.inverseTransform(this.transformMatrix);
                    const bl = _util2.Util.applyTransform([0, 0], inv);
                    const br = _util2.Util.applyTransform([0, height2], inv);
                    const ul = _util2.Util.applyTransform([width2, 0], inv);
                    const ur = _util2.Util.applyTransform([width2, height2], inv);
                    const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                    const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                    const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                    const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", x0);
                    rect.setAttributeNS(null, "y", y0);
                    rect.setAttributeNS(null, "width", x1 - x0);
                    rect.setAttributeNS(null, "height", y1 - y0);
                    rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));
                    if (this.current.fillAlpha < 1) {
                      rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                    }
                    this._ensureTransformGroup().append(rect);
                  }
                  _makeColorN_Pattern(args) {
                    if (args[0] === "TilingPattern") {
                      return this._makeTilingPattern(args);
                    }
                    return this._makeShadingPattern(args);
                  }
                  _makeTilingPattern(args) {
                    const color2 = args[1];
                    const operatorList = args[2];
                    const matrix = args[3] || _util2.IDENTITY_MATRIX;
                    const [x0, y0, x1, y1] = args[4];
                    const xstep = args[5];
                    const ystep = args[6];
                    const paintType = args[7];
                    const tilingId = `shading${shadingCount++}`;
                    const [tx0, ty0, tx1, ty1] = _util2.Util.normalizeRect([..._util2.Util.applyTransform([x0, y0], matrix), ..._util2.Util.applyTransform([x1, y1], matrix)]);
                    const [xscale, yscale] = _util2.Util.singularValueDecompose2dScale(matrix);
                    const txstep = xstep * xscale;
                    const tystep = ystep * yscale;
                    const tiling = this.svgFactory.createElement("svg:pattern");
                    tiling.setAttributeNS(null, "id", tilingId);
                    tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                    tiling.setAttributeNS(null, "width", txstep);
                    tiling.setAttributeNS(null, "height", tystep);
                    tiling.setAttributeNS(null, "x", `${tx0}`);
                    tiling.setAttributeNS(null, "y", `${ty0}`);
                    const svg = this.svg;
                    const transformMatrix = this.transformMatrix;
                    const fillColor = this.current.fillColor;
                    const strokeColor = this.current.strokeColor;
                    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                    this.svg = bbox;
                    this.transformMatrix = matrix;
                    if (paintType === 2) {
                      const cssColor = _util2.Util.makeHexColor(...color2);
                      this.current.fillColor = cssColor;
                      this.current.strokeColor = cssColor;
                    }
                    this.executeOpTree(this.convertOpList(operatorList));
                    this.svg = svg;
                    this.transformMatrix = transformMatrix;
                    this.current.fillColor = fillColor;
                    this.current.strokeColor = strokeColor;
                    tiling.append(bbox.childNodes[0]);
                    this.defs.append(tiling);
                    return `url(#${tilingId})`;
                  }
                  _makeShadingPattern(args) {
                    if (typeof args === "string") {
                      args = this.objs.get(args);
                    }
                    switch (args[0]) {
                      case "RadialAxial":
                        const shadingId = `shading${shadingCount++}`;
                        const colorStops = args[3];
                        let gradient;
                        switch (args[1]) {
                          case "axial":
                            const point0 = args[4];
                            const point1 = args[5];
                            gradient = this.svgFactory.createElement("svg:linearGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "x1", point0[0]);
                            gradient.setAttributeNS(null, "y1", point0[1]);
                            gradient.setAttributeNS(null, "x2", point1[0]);
                            gradient.setAttributeNS(null, "y2", point1[1]);
                            break;
                          case "radial":
                            const focalPoint = args[4];
                            const circlePoint = args[5];
                            const focalRadius = args[6];
                            const circleRadius = args[7];
                            gradient = this.svgFactory.createElement("svg:radialGradient");
                            gradient.setAttributeNS(null, "id", shadingId);
                            gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                            gradient.setAttributeNS(null, "cx", circlePoint[0]);
                            gradient.setAttributeNS(null, "cy", circlePoint[1]);
                            gradient.setAttributeNS(null, "r", circleRadius);
                            gradient.setAttributeNS(null, "fx", focalPoint[0]);
                            gradient.setAttributeNS(null, "fy", focalPoint[1]);
                            gradient.setAttributeNS(null, "fr", focalRadius);
                            break;
                          default:
                            throw new Error(`Unknown RadialAxial type: ${args[1]}`);
                        }
                        for (const colorStop of colorStops) {
                          const stop = this.svgFactory.createElement("svg:stop");
                          stop.setAttributeNS(null, "offset", colorStop[0]);
                          stop.setAttributeNS(null, "stop-color", colorStop[1]);
                          gradient.append(stop);
                        }
                        this.defs.append(gradient);
                        return `url(#${shadingId})`;
                      case "Mesh":
                        (0, _util2.warn)("Unimplemented pattern Mesh");
                        return null;
                      case "Dummy":
                        return "hotpink";
                      default:
                        throw new Error(`Unknown IR type: ${args[0]}`);
                    }
                  }
                  setDash(dashArray, dashPhase) {
                    this.current.dashArray = dashArray;
                    this.current.dashPhase = dashPhase;
                  }
                  constructPath(ops, args) {
                    const current = this.current;
                    let x = current.x, y = current.y;
                    let d = [];
                    let j = 0;
                    for (const op of ops) {
                      switch (op | 0) {
                        case _util2.OPS.rectangle:
                          x = args[j++];
                          y = args[j++];
                          const width2 = args[j++];
                          const height2 = args[j++];
                          const xw = x + width2;
                          const yh = y + height2;
                          d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                          break;
                        case _util2.OPS.moveTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("M", pf(x), pf(y));
                          break;
                        case _util2.OPS.lineTo:
                          x = args[j++];
                          y = args[j++];
                          d.push("L", pf(x), pf(y));
                          break;
                        case _util2.OPS.curveTo:
                          x = args[j + 4];
                          y = args[j + 5];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                          j += 6;
                          break;
                        case _util2.OPS.curveTo2:
                          d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                          x = args[j + 2];
                          y = args[j + 3];
                          j += 4;
                          break;
                        case _util2.OPS.curveTo3:
                          x = args[j + 2];
                          y = args[j + 3];
                          d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                          j += 4;
                          break;
                        case _util2.OPS.closePath:
                          d.push("Z");
                          break;
                      }
                    }
                    d = d.join(" ");
                    if (current.path && ops.length > 0 && ops[0] !== _util2.OPS.rectangle && ops[0] !== _util2.OPS.moveTo) {
                      d = current.path.getAttributeNS(null, "d") + d;
                    } else {
                      current.path = this.svgFactory.createElement("svg:path");
                      this._ensureTransformGroup().append(current.path);
                    }
                    current.path.setAttributeNS(null, "d", d);
                    current.path.setAttributeNS(null, "fill", "none");
                    current.element = current.path;
                    current.setCurrentPoint(x, y);
                  }
                  endPath() {
                    const current = this.current;
                    current.path = null;
                    if (!this.pendingClip) {
                      return;
                    }
                    if (!current.element) {
                      this.pendingClip = null;
                      return;
                    }
                    const clipId = `clippath${clipCount++}`;
                    const clipPath = this.svgFactory.createElement("svg:clipPath");
                    clipPath.setAttributeNS(null, "id", clipId);
                    clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                    const clipElement = current.element.cloneNode(true);
                    if (this.pendingClip === "evenodd") {
                      clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                    } else {
                      clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                    }
                    this.pendingClip = null;
                    clipPath.append(clipElement);
                    this.defs.append(clipPath);
                    if (current.activeClipUrl) {
                      current.clipGroup = null;
                      for (const prev of this.extraStack) {
                        prev.clipGroup = null;
                      }
                      clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                    }
                    current.activeClipUrl = `url(#${clipId})`;
                    this.tgrp = null;
                  }
                  clip(type2) {
                    this.pendingClip = type2;
                  }
                  closePath() {
                    const current = this.current;
                    if (current.path) {
                      const d = `${current.path.getAttributeNS(null, "d")}Z`;
                      current.path.setAttributeNS(null, "d", d);
                    }
                  }
                  setLeading(leading) {
                    this.current.leading = -leading;
                  }
                  setTextRise(textRise) {
                    this.current.textRise = textRise;
                  }
                  setTextRenderingMode(textRenderingMode) {
                    this.current.textRenderingMode = textRenderingMode;
                  }
                  setHScale(scale8) {
                    this.current.textHScale = scale8 / 100;
                  }
                  setRenderingIntent(intent) {
                  }
                  setFlatness(flatness) {
                  }
                  setGState(states) {
                    for (const [key, value2] of states) {
                      switch (key) {
                        case "LW":
                          this.setLineWidth(value2);
                          break;
                        case "LC":
                          this.setLineCap(value2);
                          break;
                        case "LJ":
                          this.setLineJoin(value2);
                          break;
                        case "ML":
                          this.setMiterLimit(value2);
                          break;
                        case "D":
                          this.setDash(value2[0], value2[1]);
                          break;
                        case "RI":
                          this.setRenderingIntent(value2);
                          break;
                        case "FL":
                          this.setFlatness(value2);
                          break;
                        case "Font":
                          this.setFont(value2);
                          break;
                        case "CA":
                          this.setStrokeAlpha(value2);
                          break;
                        case "ca":
                          this.setFillAlpha(value2);
                          break;
                        default:
                          (0, _util2.warn)(`Unimplemented graphic state operator ${key}`);
                          break;
                      }
                    }
                  }
                  fill() {
                    const current = this.current;
                    if (current.element) {
                      current.element.setAttributeNS(null, "fill", current.fillColor);
                      current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                      this.endPath();
                    }
                  }
                  stroke() {
                    const current = this.current;
                    if (current.element) {
                      this._setStrokeAttributes(current.element);
                      current.element.setAttributeNS(null, "fill", "none");
                      this.endPath();
                    }
                  }
                  _setStrokeAttributes(element, lineWidthScale = 1) {
                    const current = this.current;
                    let dashArray = current.dashArray;
                    if (lineWidthScale !== 1 && dashArray.length > 0) {
                      dashArray = dashArray.map(function(value2) {
                        return lineWidthScale * value2;
                      });
                    }
                    element.setAttributeNS(null, "stroke", current.strokeColor);
                    element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                    element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                    element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                    element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                    element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                    element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                    element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
                  }
                  eoFill() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fill();
                  }
                  fillStroke() {
                    this.stroke();
                    this.fill();
                  }
                  eoFillStroke() {
                    if (this.current.element) {
                      this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                    }
                    this.fillStroke();
                  }
                  closeStroke() {
                    this.closePath();
                    this.stroke();
                  }
                  closeFillStroke() {
                    this.closePath();
                    this.fillStroke();
                  }
                  closeEOFillStroke() {
                    this.closePath();
                    this.eoFillStroke();
                  }
                  paintSolidColorImageMask() {
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", "1px");
                    rect.setAttributeNS(null, "height", "1px");
                    rect.setAttributeNS(null, "fill", this.current.fillColor);
                    this._ensureTransformGroup().append(rect);
                  }
                  paintImageXObject(objId) {
                    const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);
                    if (!imgData) {
                      (0, _util2.warn)(`Dependent image with object ID ${objId} is not ready yet`);
                      return;
                    }
                    this.paintInlineImageXObject(imgData);
                  }
                  paintInlineImageXObject(imgData, mask) {
                    const width2 = imgData.width;
                    const height2 = imgData.height;
                    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                    const cliprect = this.svgFactory.createElement("svg:rect");
                    cliprect.setAttributeNS(null, "x", "0");
                    cliprect.setAttributeNS(null, "y", "0");
                    cliprect.setAttributeNS(null, "width", pf(width2));
                    cliprect.setAttributeNS(null, "height", pf(height2));
                    this.current.element = cliprect;
                    this.clip("nonzero");
                    const imgEl = this.svgFactory.createElement("svg:image");
                    imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                    imgEl.setAttributeNS(null, "x", "0");
                    imgEl.setAttributeNS(null, "y", pf(-height2));
                    imgEl.setAttributeNS(null, "width", pf(width2) + "px");
                    imgEl.setAttributeNS(null, "height", pf(height2) + "px");
                    imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width2)} ${pf(-1 / height2)})`);
                    if (mask) {
                      mask.append(imgEl);
                    } else {
                      this._ensureTransformGroup().append(imgEl);
                    }
                  }
                  paintImageMaskXObject(imgData) {
                    const current = this.current;
                    const width2 = imgData.width;
                    const height2 = imgData.height;
                    const fillColor = current.fillColor;
                    current.maskId = `mask${maskCount++}`;
                    const mask = this.svgFactory.createElement("svg:mask");
                    mask.setAttributeNS(null, "id", current.maskId);
                    const rect = this.svgFactory.createElement("svg:rect");
                    rect.setAttributeNS(null, "x", "0");
                    rect.setAttributeNS(null, "y", "0");
                    rect.setAttributeNS(null, "width", pf(width2));
                    rect.setAttributeNS(null, "height", pf(height2));
                    rect.setAttributeNS(null, "fill", fillColor);
                    rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
                    this.defs.append(mask);
                    this._ensureTransformGroup().append(rect);
                    this.paintInlineImageXObject(imgData, mask);
                  }
                  paintFormXObjectBegin(matrix, bbox) {
                    if (Array.isArray(matrix) && matrix.length === 6) {
                      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                    }
                    if (bbox) {
                      const width2 = bbox[2] - bbox[0];
                      const height2 = bbox[3] - bbox[1];
                      const cliprect = this.svgFactory.createElement("svg:rect");
                      cliprect.setAttributeNS(null, "x", bbox[0]);
                      cliprect.setAttributeNS(null, "y", bbox[1]);
                      cliprect.setAttributeNS(null, "width", pf(width2));
                      cliprect.setAttributeNS(null, "height", pf(height2));
                      this.current.element = cliprect;
                      this.clip("nonzero");
                      this.endPath();
                    }
                  }
                  paintFormXObjectEnd() {
                  }
                  _initialize(viewport) {
                    const svg = this.svgFactory.create(viewport.width, viewport.height);
                    const definitions = this.svgFactory.createElement("svg:defs");
                    svg.append(definitions);
                    this.defs = definitions;
                    const rootGroup = this.svgFactory.createElement("svg:g");
                    rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                    svg.append(rootGroup);
                    this.svg = rootGroup;
                    return svg;
                  }
                  _ensureClipGroup() {
                    if (!this.current.clipGroup) {
                      const clipGroup = this.svgFactory.createElement("svg:g");
                      clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                      this.svg.append(clipGroup);
                      this.current.clipGroup = clipGroup;
                    }
                    return this.current.clipGroup;
                  }
                  _ensureTransformGroup() {
                    if (!this.tgrp) {
                      this.tgrp = this.svgFactory.createElement("svg:g");
                      this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));
                      if (this.current.activeClipUrl) {
                        this._ensureClipGroup().append(this.tgrp);
                      } else {
                        this.svg.append(this.tgrp);
                      }
                    }
                    return this.tgrp;
                  }
                };
              }
            },
            /* 32 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNodeStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              const fs = require_fs();
              const http = require_http();
              const https = require_https();
              const url2 = require_url();
              const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
              function parseUrl(sourceUrl) {
                const parsedUrl = url2.parse(sourceUrl);
                if (parsedUrl.protocol === "file:" || parsedUrl.host) {
                  return parsedUrl;
                }
                if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
                  return url2.parse(`file:///${sourceUrl}`);
                }
                if (!parsedUrl.host) {
                  parsedUrl.protocol = "file:";
                }
                return parsedUrl;
              }
              class PDFNodeStream {
                constructor(source) {
                  this.source = source;
                  this.url = parseUrl(source.url);
                  this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
                  this.isFsUrl = this.url.protocol === "file:";
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
                  this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(start2, end2) {
                  if (end2 <= this._progressiveDataLength) {
                    return null;
                  }
                  const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start2, end2) : new PDFNodeStreamRangeReader(this, start2, end2);
                  this._rangeRequestReaders.push(rangeReader);
                  return rangeReader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNodeStream = PDFNodeStream;
              class BaseFullReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  const source = stream.source;
                  this._contentLength = source.length;
                  this._loaded = 0;
                  this._filename = null;
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (!this._isStreamingSupported && this._isRangeSupported) {
                    this._error(new _util2.AbortException("streaming is disabled"));
                  }
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              class BaseRangeReader {
                constructor(stream) {
                  this._url = stream.url;
                  this._done = false;
                  this._storedError = null;
                  this.onProgress = null;
                  this._loaded = 0;
                  this._readableStream = null;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  const source = stream.source;
                  this._isStreamingSupported = !source.disableStream;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  const chunk = this._readableStream.read();
                  if (chunk === null) {
                    this._readCapability = (0, _util2.createPromiseCapability)();
                    return this.read();
                  }
                  this._loaded += chunk.length;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(chunk).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (!this._readableStream) {
                    this._error(reason);
                    return;
                  }
                  this._readableStream.destroy(reason);
                }
                _error(reason) {
                  this._storedError = reason;
                  this._readCapability.resolve();
                }
                _setReadableStream(readableStream) {
                  this._readableStream = readableStream;
                  readableStream.on("readable", () => {
                    this._readCapability.resolve();
                  });
                  readableStream.on("end", () => {
                    readableStream.destroy();
                    this._done = true;
                    this._readCapability.resolve();
                  });
                  readableStream.on("error", (reason) => {
                    this._error(reason);
                  });
                  if (this._storedError) {
                    this._readableStream.destroy(this._storedError);
                  }
                }
              }
              function createRequestOptions(parsedUrl, headers) {
                return {
                  protocol: parsedUrl.protocol,
                  auth: parsedUrl.auth,
                  host: parsedUrl.hostname,
                  port: parsedUrl.port,
                  path: parsedUrl.path,
                  method: "GET",
                  headers
                };
              }
              class PDFNodeStreamFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._headersCapability.resolve();
                    this._setReadableStream(response);
                    const getResponseHeader = (name3) => {
                      return this._readableStream.headers[name3.toLowerCase()];
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                    this._headersCapability.reject(reason);
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamRangeReader extends BaseRangeReader {
                constructor(stream, start2, end2) {
                  super(stream);
                  this._httpHeaders = {};
                  for (const property in stream.httpHeaders) {
                    const value2 = stream.httpHeaders[property];
                    if (typeof value2 === "undefined") {
                      continue;
                    }
                    this._httpHeaders[property] = value2;
                  }
                  this._httpHeaders.Range = `bytes=${start2}-${end2 - 1}`;
                  const handleResponse = (response) => {
                    if (response.statusCode === 404) {
                      const error = new _util2.MissingPDFException(`Missing PDF "${this._url}".`);
                      this._storedError = error;
                      return;
                    }
                    this._setReadableStream(response);
                  };
                  this._request = null;
                  if (this._url.protocol === "http:") {
                    this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  } else {
                    this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
                  }
                  this._request.on("error", (reason) => {
                    this._storedError = reason;
                  });
                  this._request.end();
                }
              }
              class PDFNodeStreamFsFullReader extends BaseFullReader {
                constructor(stream) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  fs.lstat(path, (error, stat) => {
                    if (error) {
                      if (error.code === "ENOENT") {
                        error = new _util2.MissingPDFException(`Missing PDF "${path}".`);
                      }
                      this._storedError = error;
                      this._headersCapability.reject(error);
                      return;
                    }
                    this._contentLength = stat.size;
                    this._setReadableStream(fs.createReadStream(path));
                    this._headersCapability.resolve();
                  });
                }
              }
              class PDFNodeStreamFsRangeReader extends BaseRangeReader {
                constructor(stream, start2, end2) {
                  super(stream);
                  let path = decodeURIComponent(this._url.path);
                  if (fileUriRegex.test(this._url.href)) {
                    path = path.replace(/^\//, "");
                  }
                  this._setReadableStream(fs.createReadStream(path, {
                    start: start2,
                    end: end2 - 1
                  }));
                }
              }
            },
            /* 33 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.createResponseStatusError = createResponseStatusError;
              exports2.extractFilenameFromHeader = extractFilenameFromHeader;
              exports2.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
              exports2.validateResponseStatus = validateResponseStatus;
              var _util2 = __w_pdfjs_require__2(1);
              var _content_disposition = __w_pdfjs_require__2(34);
              var _display_utils2 = __w_pdfjs_require__2(8);
              function validateRangeRequestCapabilities({
                getResponseHeader,
                isHttp,
                rangeChunkSize,
                disableRange
              }) {
                const returnValues = {
                  allowRangeRequests: false,
                  suggestedLength: void 0
                };
                const length8 = parseInt(getResponseHeader("Content-Length"), 10);
                if (!Number.isInteger(length8)) {
                  return returnValues;
                }
                returnValues.suggestedLength = length8;
                if (length8 <= 2 * rangeChunkSize) {
                  return returnValues;
                }
                if (disableRange || !isHttp) {
                  return returnValues;
                }
                if (getResponseHeader("Accept-Ranges") !== "bytes") {
                  return returnValues;
                }
                const contentEncoding = getResponseHeader("Content-Encoding") || "identity";
                if (contentEncoding !== "identity") {
                  return returnValues;
                }
                returnValues.allowRangeRequests = true;
                return returnValues;
              }
              function extractFilenameFromHeader(getResponseHeader) {
                const contentDisposition = getResponseHeader("Content-Disposition");
                if (contentDisposition) {
                  let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);
                  if (filename.includes("%")) {
                    try {
                      filename = decodeURIComponent(filename);
                    } catch (ex) {
                    }
                  }
                  if ((0, _display_utils2.isPdfFile)(filename)) {
                    return filename;
                  }
                }
                return null;
              }
              function createResponseStatusError(status, url2) {
                if (status === 404 || status === 0 && url2.startsWith("file:")) {
                  return new _util2.MissingPDFException('Missing PDF "' + url2 + '".');
                }
                return new _util2.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url2}".`, status);
              }
              function validateResponseStatus(status) {
                return status === 200 || status === 206;
              }
            },
            /* 34 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;
              var _util2 = __w_pdfjs_require__2(1);
              function getFilenameFromContentDispositionHeader(contentDisposition) {
                let needsEncodingFixup = true;
                let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = unescape(filename);
                  filename = rfc5987decode(filename);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                tmp = rfc2231getparam(contentDisposition);
                if (tmp) {
                  const filename = rfc2047decode(tmp);
                  return fixupEncoding(filename);
                }
                tmp = toParamRegExp("filename", "i").exec(contentDisposition);
                if (tmp) {
                  tmp = tmp[1];
                  let filename = rfc2616unquote(tmp);
                  filename = rfc2047decode(filename);
                  return fixupEncoding(filename);
                }
                function toParamRegExp(attributePattern, flags) {
                  return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
                }
                function textdecode(encoding, value2) {
                  if (encoding) {
                    if (!/^[\x00-\xFF]+$/.test(value2)) {
                      return value2;
                    }
                    try {
                      const decoder = new TextDecoder(encoding, {
                        fatal: true
                      });
                      const buffer = (0, _util2.stringToBytes)(value2);
                      value2 = decoder.decode(buffer);
                      needsEncodingFixup = false;
                    } catch (e2) {
                    }
                  }
                  return value2;
                }
                function fixupEncoding(value2) {
                  if (needsEncodingFixup && /[\x80-\xff]/.test(value2)) {
                    value2 = textdecode("utf-8", value2);
                    if (needsEncodingFixup) {
                      value2 = textdecode("iso-8859-1", value2);
                    }
                  }
                  return value2;
                }
                function rfc2231getparam(contentDispositionStr) {
                  const matches = [];
                  let match;
                  const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
                  while ((match = iter.exec(contentDispositionStr)) !== null) {
                    let [, n2, quot, part] = match;
                    n2 = parseInt(n2, 10);
                    if (n2 in matches) {
                      if (n2 === 0) {
                        break;
                      }
                      continue;
                    }
                    matches[n2] = [quot, part];
                  }
                  const parts = [];
                  for (let n2 = 0; n2 < matches.length; ++n2) {
                    if (!(n2 in matches)) {
                      break;
                    }
                    let [quot, part] = matches[n2];
                    part = rfc2616unquote(part);
                    if (quot) {
                      part = unescape(part);
                      if (n2 === 0) {
                        part = rfc5987decode(part);
                      }
                    }
                    parts.push(part);
                  }
                  return parts.join("");
                }
                function rfc2616unquote(value2) {
                  if (value2.startsWith('"')) {
                    const parts = value2.slice(1).split('\\"');
                    for (let i = 0; i < parts.length; ++i) {
                      const quotindex = parts[i].indexOf('"');
                      if (quotindex !== -1) {
                        parts[i] = parts[i].slice(0, quotindex);
                        parts.length = i + 1;
                      }
                      parts[i] = parts[i].replace(/\\(.)/g, "$1");
                    }
                    value2 = parts.join('"');
                  }
                  return value2;
                }
                function rfc5987decode(extvalue) {
                  const encodingend = extvalue.indexOf("'");
                  if (encodingend === -1) {
                    return extvalue;
                  }
                  const encoding = extvalue.slice(0, encodingend);
                  const langvalue = extvalue.slice(encodingend + 1);
                  const value2 = langvalue.replace(/^[^']*'/, "");
                  return textdecode(encoding, value2);
                }
                function rfc2047decode(value2) {
                  if (!value2.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value2)) {
                    return value2;
                  }
                  return value2.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text2) {
                    if (encoding === "q" || encoding === "Q") {
                      text2 = text2.replace(/_/g, " ");
                      text2 = text2.replace(/=([0-9a-fA-F]{2})/g, function(match, hex) {
                        return String.fromCharCode(parseInt(hex, 16));
                      });
                      return textdecode(charset, text2);
                    }
                    try {
                      text2 = atob(text2);
                    } catch (e2) {
                    }
                    return textdecode(charset, text2);
                  });
                }
                return "";
              }
            },
            /* 35 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFNetworkStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              const OK_RESPONSE = 200;
              const PARTIAL_CONTENT_RESPONSE = 206;
              function getArrayBuffer(xhr) {
                const data = xhr.response;
                if (typeof data !== "string") {
                  return data;
                }
                const array = (0, _util2.stringToBytes)(data);
                return array.buffer;
              }
              class NetworkManager {
                constructor(url2, args = {}) {
                  this.url = url2;
                  this.isHttp = /^https?:/i.test(url2);
                  this.httpHeaders = this.isHttp && args.httpHeaders || /* @__PURE__ */ Object.create(null);
                  this.withCredentials = args.withCredentials || false;
                  this.getXhr = args.getXhr || function NetworkManager_getXhr() {
                    return new XMLHttpRequest();
                  };
                  this.currXhrId = 0;
                  this.pendingRequests = /* @__PURE__ */ Object.create(null);
                }
                requestRange(begin, end2, listeners) {
                  const args = {
                    begin,
                    end: end2
                  };
                  for (const prop in listeners) {
                    args[prop] = listeners[prop];
                  }
                  return this.request(args);
                }
                requestFull(listeners) {
                  return this.request(listeners);
                }
                request(args) {
                  const xhr = this.getXhr();
                  const xhrId = this.currXhrId++;
                  const pendingRequest = this.pendingRequests[xhrId] = {
                    xhr
                  };
                  xhr.open("GET", this.url);
                  xhr.withCredentials = this.withCredentials;
                  for (const property in this.httpHeaders) {
                    const value2 = this.httpHeaders[property];
                    if (typeof value2 === "undefined") {
                      continue;
                    }
                    xhr.setRequestHeader(property, value2);
                  }
                  if (this.isHttp && "begin" in args && "end" in args) {
                    xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
                    pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
                  } else {
                    pendingRequest.expectedStatus = OK_RESPONSE;
                  }
                  xhr.responseType = "arraybuffer";
                  if (args.onError) {
                    xhr.onerror = function(evt) {
                      args.onError(xhr.status);
                    };
                  }
                  xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
                  xhr.onprogress = this.onProgress.bind(this, xhrId);
                  pendingRequest.onHeadersReceived = args.onHeadersReceived;
                  pendingRequest.onDone = args.onDone;
                  pendingRequest.onError = args.onError;
                  pendingRequest.onProgress = args.onProgress;
                  xhr.send(null);
                  return xhrId;
                }
                onProgress(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  pendingRequest.onProgress?.(evt);
                }
                onStateChange(xhrId, evt) {
                  const pendingRequest = this.pendingRequests[xhrId];
                  if (!pendingRequest) {
                    return;
                  }
                  const xhr = pendingRequest.xhr;
                  if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                    pendingRequest.onHeadersReceived();
                    delete pendingRequest.onHeadersReceived;
                  }
                  if (xhr.readyState !== 4) {
                    return;
                  }
                  if (!(xhrId in this.pendingRequests)) {
                    return;
                  }
                  delete this.pendingRequests[xhrId];
                  if (xhr.status === 0 && this.isHttp) {
                    pendingRequest.onError?.(xhr.status);
                    return;
                  }
                  const xhrStatus = xhr.status || OK_RESPONSE;
                  const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
                  if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                    pendingRequest.onError?.(xhr.status);
                    return;
                  }
                  const chunk = getArrayBuffer(xhr);
                  if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                    const rangeHeader = xhr.getResponseHeader("Content-Range");
                    const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                    pendingRequest.onDone({
                      begin: parseInt(matches[1], 10),
                      chunk
                    });
                  } else if (chunk) {
                    pendingRequest.onDone({
                      begin: 0,
                      chunk
                    });
                  } else {
                    pendingRequest.onError?.(xhr.status);
                  }
                }
                getRequestXhr(xhrId) {
                  return this.pendingRequests[xhrId].xhr;
                }
                isPendingRequest(xhrId) {
                  return xhrId in this.pendingRequests;
                }
                abortRequest(xhrId) {
                  const xhr = this.pendingRequests[xhrId].xhr;
                  delete this.pendingRequests[xhrId];
                  xhr.abort();
                }
              }
              class PDFNetworkStream {
                constructor(source) {
                  this._source = source;
                  this._manager = new NetworkManager(source.url, {
                    httpHeaders: source.httpHeaders,
                    withCredentials: source.withCredentials
                  });
                  this._rangeChunkSize = source.rangeChunkSize;
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                _onRangeRequestReaderClosed(reader) {
                  const i = this._rangeRequestReaders.indexOf(reader);
                  if (i >= 0) {
                    this._rangeRequestReaders.splice(i, 1);
                  }
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end2) {
                  const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end2);
                  reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  this._fullRequestReader?.cancel(reason);
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFNetworkStream = PDFNetworkStream;
              class PDFNetworkStreamFullRequestReader {
                constructor(manager, source) {
                  this._manager = manager;
                  const args = {
                    onHeadersReceived: this._onHeadersReceived.bind(this),
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = source.url;
                  this._fullRequestId = manager.requestFull(args);
                  this._headersReceivedCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._contentLength = source.length;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._isStreamingSupported = false;
                  this._isRangeSupported = false;
                  this._cachedChunks = [];
                  this._requests = [];
                  this._done = false;
                  this._storedError = void 0;
                  this._filename = null;
                  this.onProgress = null;
                }
                _onHeadersReceived() {
                  const fullRequestXhrId = this._fullRequestId;
                  const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
                  const getResponseHeader = (name3) => {
                    return fullRequestXhr.getResponseHeader(name3);
                  };
                  const {
                    allowRangeRequests,
                    suggestedLength
                  } = (0, _network_utils.validateRangeRequestCapabilities)({
                    getResponseHeader,
                    isHttp: this._manager.isHttp,
                    rangeChunkSize: this._rangeChunkSize,
                    disableRange: this._disableRange
                  });
                  if (allowRangeRequests) {
                    this._isRangeSupported = true;
                  }
                  this._contentLength = suggestedLength || this._contentLength;
                  this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                  if (this._isRangeSupported) {
                    this._manager.abortRequest(fullRequestXhrId);
                  }
                  this._headersReceivedCapability.resolve();
                }
                _onDone(data) {
                  if (data) {
                    if (this._requests.length > 0) {
                      const requestCapability = this._requests.shift();
                      requestCapability.resolve({
                        value: data.chunk,
                        done: false
                      });
                    } else {
                      this._cachedChunks.push(data.chunk);
                    }
                  }
                  this._done = true;
                  if (this._cachedChunks.length > 0) {
                    return;
                  }
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  this._headersReceivedCapability.reject(this._storedError);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._cachedChunks.length = 0;
                }
                _onProgress(evt) {
                  this.onProgress?.({
                    loaded: evt.loaded,
                    total: evt.lengthComputable ? evt.total : this._contentLength
                  });
                }
                get filename() {
                  return this._filename;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get headersReady() {
                  return this._headersReceivedCapability.promise;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._cachedChunks.length > 0) {
                    const chunk = this._cachedChunks.shift();
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  this._headersReceivedCapability.reject(reason);
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._fullRequestId)) {
                    this._manager.abortRequest(this._fullRequestId);
                  }
                  this._fullRequestReader = null;
                }
              }
              class PDFNetworkStreamRangeRequestReader {
                constructor(manager, begin, end2) {
                  this._manager = manager;
                  const args = {
                    onDone: this._onDone.bind(this),
                    onError: this._onError.bind(this),
                    onProgress: this._onProgress.bind(this)
                  };
                  this._url = manager.url;
                  this._requestId = manager.requestRange(begin, end2, args);
                  this._requests = [];
                  this._queuedChunk = null;
                  this._done = false;
                  this._storedError = void 0;
                  this.onProgress = null;
                  this.onClosed = null;
                }
                _close() {
                  this.onClosed?.(this);
                }
                _onDone(data) {
                  const chunk = data.chunk;
                  if (this._requests.length > 0) {
                    const requestCapability = this._requests.shift();
                    requestCapability.resolve({
                      value: chunk,
                      done: false
                    });
                  } else {
                    this._queuedChunk = chunk;
                  }
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  this._close();
                }
                _onError(status) {
                  this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);
                  for (const requestCapability of this._requests) {
                    requestCapability.reject(this._storedError);
                  }
                  this._requests.length = 0;
                  this._queuedChunk = null;
                }
                _onProgress(evt) {
                  if (!this.isStreamingSupported) {
                    this.onProgress?.({
                      loaded: evt.loaded
                    });
                  }
                }
                get isStreamingSupported() {
                  return false;
                }
                async read() {
                  if (this._storedError) {
                    throw this._storedError;
                  }
                  if (this._queuedChunk !== null) {
                    const chunk = this._queuedChunk;
                    this._queuedChunk = null;
                    return {
                      value: chunk,
                      done: false
                    };
                  }
                  if (this._done) {
                    return {
                      value: void 0,
                      done: true
                    };
                  }
                  const requestCapability = (0, _util2.createPromiseCapability)();
                  this._requests.push(requestCapability);
                  return requestCapability.promise;
                }
                cancel(reason) {
                  this._done = true;
                  for (const requestCapability of this._requests) {
                    requestCapability.resolve({
                      value: void 0,
                      done: true
                    });
                  }
                  this._requests.length = 0;
                  if (this._manager.isPendingRequest(this._requestId)) {
                    this._manager.abortRequest(this._requestId);
                  }
                  this._close();
                }
              }
            },
            /* 36 */
            /***/
            (__unused_webpack_module2, exports2, __w_pdfjs_require__2) => {
              Object.defineProperty(exports2, "__esModule", {
                value: true
              });
              exports2.PDFFetchStream = void 0;
              var _util2 = __w_pdfjs_require__2(1);
              var _network_utils = __w_pdfjs_require__2(33);
              ;
              function createFetchOptions(headers, withCredentials, abortController) {
                return {
                  method: "GET",
                  headers,
                  signal: abortController.signal,
                  mode: "cors",
                  credentials: withCredentials ? "include" : "same-origin",
                  redirect: "follow"
                };
              }
              function createHeaders(httpHeaders) {
                const headers = new Headers();
                for (const property in httpHeaders) {
                  const value2 = httpHeaders[property];
                  if (typeof value2 === "undefined") {
                    continue;
                  }
                  headers.append(property, value2);
                }
                return headers;
              }
              class PDFFetchStream {
                constructor(source) {
                  this.source = source;
                  this.isHttp = /^https?:/i.test(source.url);
                  this.httpHeaders = this.isHttp && source.httpHeaders || {};
                  this._fullRequestReader = null;
                  this._rangeRequestReaders = [];
                }
                get _progressiveDataLength() {
                  return this._fullRequestReader?._loaded ?? 0;
                }
                getFullReader() {
                  (0, _util2.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
                  this._fullRequestReader = new PDFFetchStreamReader(this);
                  return this._fullRequestReader;
                }
                getRangeReader(begin, end2) {
                  if (end2 <= this._progressiveDataLength) {
                    return null;
                  }
                  const reader = new PDFFetchStreamRangeReader(this, begin, end2);
                  this._rangeRequestReaders.push(reader);
                  return reader;
                }
                cancelAllRequests(reason) {
                  if (this._fullRequestReader) {
                    this._fullRequestReader.cancel(reason);
                  }
                  for (const reader of this._rangeRequestReaders.slice(0)) {
                    reader.cancel(reason);
                  }
                }
              }
              exports2.PDFFetchStream = PDFFetchStream;
              class PDFFetchStreamReader {
                constructor(stream) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  this._filename = null;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._contentLength = source.length;
                  this._headersCapability = (0, _util2.createPromiseCapability)();
                  this._disableRange = source.disableRange || false;
                  this._rangeChunkSize = source.rangeChunkSize;
                  if (!this._rangeChunkSize && !this._disableRange) {
                    this._disableRange = true;
                  }
                  this._abortController = new AbortController();
                  this._isStreamingSupported = !source.disableStream;
                  this._isRangeSupported = !source.disableRange;
                  this._headers = createHeaders(this._stream.httpHeaders);
                  const url2 = source.url;
                  fetch(url2, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url2);
                    }
                    this._reader = response.body.getReader();
                    this._headersCapability.resolve();
                    const getResponseHeader = (name3) => {
                      return response.headers.get(name3);
                    };
                    const {
                      allowRangeRequests,
                      suggestedLength
                    } = (0, _network_utils.validateRangeRequestCapabilities)({
                      getResponseHeader,
                      isHttp: this._stream.isHttp,
                      rangeChunkSize: this._rangeChunkSize,
                      disableRange: this._disableRange
                    });
                    this._isRangeSupported = allowRangeRequests;
                    this._contentLength = suggestedLength || this._contentLength;
                    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
                    if (!this._isStreamingSupported && this._isRangeSupported) {
                      this.cancel(new _util2.AbortException("Streaming is disabled."));
                    }
                  }).catch(this._headersCapability.reject);
                  this.onProgress = null;
                }
                get headersReady() {
                  return this._headersCapability.promise;
                }
                get filename() {
                  return this._filename;
                }
                get contentLength() {
                  return this._contentLength;
                }
                get isRangeSupported() {
                  return this._isRangeSupported;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._headersCapability.promise;
                  const {
                    value: value2,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: value2,
                      done
                    };
                  }
                  this._loaded += value2.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded,
                      total: this._contentLength
                    });
                  }
                  const buffer = new Uint8Array(value2).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
              class PDFFetchStreamRangeReader {
                constructor(stream, begin, end2) {
                  this._stream = stream;
                  this._reader = null;
                  this._loaded = 0;
                  const source = stream.source;
                  this._withCredentials = source.withCredentials || false;
                  this._readCapability = (0, _util2.createPromiseCapability)();
                  this._isStreamingSupported = !source.disableStream;
                  this._abortController = new AbortController();
                  this._headers = createHeaders(this._stream.httpHeaders);
                  this._headers.append("Range", `bytes=${begin}-${end2 - 1}`);
                  const url2 = source.url;
                  fetch(url2, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then((response) => {
                    if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                      throw (0, _network_utils.createResponseStatusError)(response.status, url2);
                    }
                    this._readCapability.resolve();
                    this._reader = response.body.getReader();
                  }).catch(this._readCapability.reject);
                  this.onProgress = null;
                }
                get isStreamingSupported() {
                  return this._isStreamingSupported;
                }
                async read() {
                  await this._readCapability.promise;
                  const {
                    value: value2,
                    done
                  } = await this._reader.read();
                  if (done) {
                    return {
                      value: value2,
                      done
                    };
                  }
                  this._loaded += value2.byteLength;
                  if (this.onProgress) {
                    this.onProgress({
                      loaded: this._loaded
                    });
                  }
                  const buffer = new Uint8Array(value2).buffer;
                  return {
                    value: buffer,
                    done: false
                  };
                }
                cancel(reason) {
                  if (this._reader) {
                    this._reader.cancel(reason);
                  }
                  this._abortController.abort();
                }
              }
            }
            /******/
          ];
          var __webpack_module_cache__ = {};
          function __w_pdfjs_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __w_pdfjs_require__);
            return module2.exports;
          }
          var __webpack_exports__ = {};
          (() => {
            var exports2 = __webpack_exports__;
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            Object.defineProperty(exports2, "AnnotationEditorLayer", {
              enumerable: true,
              get: function() {
                return _annotation_editor_layer.AnnotationEditorLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorParamsType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorParamsType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorType", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationEditorType;
              }
            });
            Object.defineProperty(exports2, "AnnotationEditorUIManager", {
              enumerable: true,
              get: function() {
                return _tools.AnnotationEditorUIManager;
              }
            });
            Object.defineProperty(exports2, "AnnotationLayer", {
              enumerable: true,
              get: function() {
                return _annotation_layer.AnnotationLayer;
              }
            });
            Object.defineProperty(exports2, "AnnotationMode", {
              enumerable: true,
              get: function() {
                return _util2.AnnotationMode;
              }
            });
            Object.defineProperty(exports2, "CMapCompressionType", {
              enumerable: true,
              get: function() {
                return _util2.CMapCompressionType;
              }
            });
            Object.defineProperty(exports2, "GlobalWorkerOptions", {
              enumerable: true,
              get: function() {
                return _worker_options2.GlobalWorkerOptions;
              }
            });
            Object.defineProperty(exports2, "InvalidPDFException", {
              enumerable: true,
              get: function() {
                return _util2.InvalidPDFException;
              }
            });
            Object.defineProperty(exports2, "LoopbackPort", {
              enumerable: true,
              get: function() {
                return _api.LoopbackPort;
              }
            });
            Object.defineProperty(exports2, "MissingPDFException", {
              enumerable: true,
              get: function() {
                return _util2.MissingPDFException;
              }
            });
            Object.defineProperty(exports2, "OPS", {
              enumerable: true,
              get: function() {
                return _util2.OPS;
              }
            });
            Object.defineProperty(exports2, "PDFDataRangeTransport", {
              enumerable: true,
              get: function() {
                return _api.PDFDataRangeTransport;
              }
            });
            Object.defineProperty(exports2, "PDFDateString", {
              enumerable: true,
              get: function() {
                return _display_utils2.PDFDateString;
              }
            });
            Object.defineProperty(exports2, "PDFWorker", {
              enumerable: true,
              get: function() {
                return _api.PDFWorker;
              }
            });
            Object.defineProperty(exports2, "PasswordResponses", {
              enumerable: true,
              get: function() {
                return _util2.PasswordResponses;
              }
            });
            Object.defineProperty(exports2, "PermissionFlag", {
              enumerable: true,
              get: function() {
                return _util2.PermissionFlag;
              }
            });
            Object.defineProperty(exports2, "PixelsPerInch", {
              enumerable: true,
              get: function() {
                return _display_utils2.PixelsPerInch;
              }
            });
            Object.defineProperty(exports2, "RenderingCancelledException", {
              enumerable: true,
              get: function() {
                return _display_utils2.RenderingCancelledException;
              }
            });
            Object.defineProperty(exports2, "SVGGraphics", {
              enumerable: true,
              get: function() {
                return _svg.SVGGraphics;
              }
            });
            Object.defineProperty(exports2, "UNSUPPORTED_FEATURES", {
              enumerable: true,
              get: function() {
                return _util2.UNSUPPORTED_FEATURES;
              }
            });
            Object.defineProperty(exports2, "UnexpectedResponseException", {
              enumerable: true,
              get: function() {
                return _util2.UnexpectedResponseException;
              }
            });
            Object.defineProperty(exports2, "Util", {
              enumerable: true,
              get: function() {
                return _util2.Util;
              }
            });
            Object.defineProperty(exports2, "VerbosityLevel", {
              enumerable: true,
              get: function() {
                return _util2.VerbosityLevel;
              }
            });
            Object.defineProperty(exports2, "XfaLayer", {
              enumerable: true,
              get: function() {
                return _xfa_layer.XfaLayer;
              }
            });
            Object.defineProperty(exports2, "build", {
              enumerable: true,
              get: function() {
                return _api.build;
              }
            });
            Object.defineProperty(exports2, "createPromiseCapability", {
              enumerable: true,
              get: function() {
                return _util2.createPromiseCapability;
              }
            });
            Object.defineProperty(exports2, "createValidAbsoluteUrl", {
              enumerable: true,
              get: function() {
                return _util2.createValidAbsoluteUrl;
              }
            });
            Object.defineProperty(exports2, "getDocument", {
              enumerable: true,
              get: function() {
                return _api.getDocument;
              }
            });
            Object.defineProperty(exports2, "getFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getPdfFilenameFromUrl", {
              enumerable: true,
              get: function() {
                return _display_utils2.getPdfFilenameFromUrl;
              }
            });
            Object.defineProperty(exports2, "getXfaPageViewport", {
              enumerable: true,
              get: function() {
                return _display_utils2.getXfaPageViewport;
              }
            });
            Object.defineProperty(exports2, "isPdfFile", {
              enumerable: true,
              get: function() {
                return _display_utils2.isPdfFile;
              }
            });
            Object.defineProperty(exports2, "loadScript", {
              enumerable: true,
              get: function() {
                return _display_utils2.loadScript;
              }
            });
            Object.defineProperty(exports2, "renderTextLayer", {
              enumerable: true,
              get: function() {
                return _text_layer.renderTextLayer;
              }
            });
            Object.defineProperty(exports2, "shadow", {
              enumerable: true,
              get: function() {
                return _util2.shadow;
              }
            });
            Object.defineProperty(exports2, "version", {
              enumerable: true,
              get: function() {
                return _api.version;
              }
            });
            var _util2 = __w_pdfjs_require__(1);
            var _api = __w_pdfjs_require__(4);
            var _display_utils2 = __w_pdfjs_require__(8);
            var _annotation_editor_layer = __w_pdfjs_require__(22);
            var _tools = __w_pdfjs_require__(7);
            var _annotation_layer = __w_pdfjs_require__(27);
            var _worker_options2 = __w_pdfjs_require__(15);
            var _is_node2 = __w_pdfjs_require__(3);
            var _text_layer = __w_pdfjs_require__(30);
            var _svg = __w_pdfjs_require__(31);
            var _xfa_layer = __w_pdfjs_require__(29);
            const pdfjsVersion = "2.16.105";
            const pdfjsBuild = "172ccdbe5";
            {
              if (_is_node2.isNodeJS) {
                const {
                  PDFNodeStream
                } = __w_pdfjs_require__(32);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  return new PDFNodeStream(params);
                });
              } else {
                const {
                  PDFNetworkStream
                } = __w_pdfjs_require__(35);
                const {
                  PDFFetchStream
                } = __w_pdfjs_require__(36);
                (0, _api.setPDFNetworkStreamFactory)((params) => {
                  if ((0, _display_utils2.isValidFetchUrl)(params.url)) {
                    return new PDFFetchStream(params);
                  }
                  return new PDFNetworkStream(params);
                });
              }
            }
          })();
          return __webpack_exports__;
        })()
      );
    });
  }
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/typeChecks.ts
function t(o, s, c) {
  return typeof o === s || o instanceof c;
}
function isFunction(obj2) {
  return t(obj2, "function", Function);
}
function isString(obj2) {
  return t(obj2, "string", String);
}
function isBoolean(obj2) {
  return t(obj2, "boolean", Boolean);
}
function isNumber(obj2) {
  return t(obj2, "number", Number);
}
function isBadNumber(num) {
  return isNullOrUndefined(num) || !Number.isFinite(num) || Number.isNaN(num);
}
function isGoodNumber(obj2) {
  return isNumber(obj2) && !isBadNumber(obj2);
}
function isObject(obj2) {
  return isDefined(obj2) && t(obj2, "object", Object);
}
function isDate(obj2) {
  return obj2 instanceof Date;
}
function isArray(obj2) {
  return obj2 instanceof Array;
}
function assertNever(x, msg) {
  throw new Error((msg || "Unexpected object: ") + x);
}
function isNullOrUndefined(obj2) {
  return obj2 === null || obj2 === void 0;
}
function isDefined(obj2) {
  return !isNullOrUndefined(obj2);
}
function isArrayBufferView(obj2) {
  return obj2 instanceof Uint8Array || obj2 instanceof Uint8ClampedArray || obj2 instanceof Int8Array || obj2 instanceof Uint16Array || obj2 instanceof Int16Array || obj2 instanceof Uint32Array || obj2 instanceof Int32Array || obj2 instanceof Float32Array || obj2 instanceof Float64Array || "BigUint64Array" in globalThis && obj2 instanceof globalThis["BigUint64Array"] || "BigInt64Array" in globalThis && obj2 instanceof globalThis["BigInt64Array"];
}
function isArrayBuffer(val) {
  return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
  val.constructor && val.constructor.name === "ArrayBuffer");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/css.ts
function perc(value2) {
  return `${value2}%`;
}
function deg(value2) {
  return `${value2}deg`;
}
function em(value2) {
  return `${value2}em`;
}
function px(value2) {
  return `${value2}px`;
}
function pt(value2) {
  return `${value2}pt`;
}
function fr(value2) {
  return `${value2}fr`;
}
function rgb(...v) {
  return `rgb(${v.join(", ")})`;
}
function hsla(...v) {
  return `hsla(${v.join(", ")})`;
}
function getMonospaceFonts() {
  return "ui-monospace, 'Droid Sans Mono', 'Cascadia Mono', 'Segoe UI Mono', 'Ubuntu Mono', 'Roboto Mono', Menlo, Monaco, Consolas, monospace";
}
var Prop = class {
  constructor(_value) {
    this._value = _value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this.value;
  }
};
var PropSet = class {
  constructor(pre, props, post) {
    this.pre = pre;
    this.props = props;
    this.post = post;
  }
  get value() {
    return this.pre + this.props.map((p) => p.toString()).join("\n") + this.post;
  }
  toString() {
    return this.value;
  }
  applyToSheet(sheet) {
    sheet.insertRule(this.toString(), sheet.cssRules.length);
  }
};
var KeyValueProp = class extends Prop {
  constructor(_name, sep, value2) {
    super(value2);
    this._name = _name;
    this.sep = sep;
  }
  get name() {
    return this._name;
  }
  toString() {
    return this.name + this.sep + this.value + ";";
  }
};
var SelectorPropSet = class extends PropSet {
  constructor(selector, props) {
    super(selector + " {\n", props, "\n}\n");
  }
};
var CssDeclareProp = class extends KeyValueProp {
  constructor(key, value2) {
    super(key, ": ", value2);
  }
};
var CssElementStyleProp = class extends CssDeclareProp {
  constructor(key, value2) {
    super(key.replace(/[A-Z]/g, (m) => `-${m.toLocaleLowerCase()}`), value2.toString());
    this.key = key;
    this.priority = "";
  }
  /**
   * Set the attribute value on an HTMLElement
   * @param elem - the element on which to set the attribute.
   */
  applyToElement(elem) {
    elem.style[this.key] = this.value + this.priority;
  }
  important() {
    this.priority = " !important";
    return this;
  }
  get value() {
    return super.value + this.priority;
  }
};
function isCssElementStyleProp(obj2) {
  return obj2 instanceof CssElementStyleProp;
}
var CssElementStylePropSet = class extends SelectorPropSet {
  constructor(selector, props) {
    super(selector, props);
  }
};
function rule(selector, ...props) {
  return new CssElementStylePropSet(selector, props);
}
function alignItems(v) {
  return new CssElementStyleProp("alignItems", v);
}
function backgroundColor(v) {
  return new CssElementStyleProp("backgroundColor", v);
}
function border(v) {
  return new CssElementStyleProp("border", v);
}
function color(v) {
  return new CssElementStyleProp("color", v);
}
function columnGap(v) {
  return new CssElementStyleProp("columnGap", v);
}
function cursor(v) {
  return new CssElementStyleProp("cursor", v);
}
function display(v) {
  return new CssElementStyleProp("display", v);
}
function flexDirection(v) {
  return new CssElementStyleProp("flexDirection", v);
}
function fontSize(v) {
  return new CssElementStyleProp("fontSize", v);
}
function gap(...v) {
  return new CssElementStyleProp("gap", v.join(" "));
}
function gridAutoFlow(v) {
  return new CssElementStyleProp("gridAutoFlow", v);
}
function gridColumn(vOrColStart, colEnd) {
  if (!isString(vOrColStart)) {
    vOrColStart = [vOrColStart, colEnd].filter(isDefined).join("/");
  }
  return new CssElementStyleProp("gridColumn", vOrColStart);
}
function gridRow(vOrRowStart, rowEnd) {
  if (!isString(vOrRowStart)) {
    vOrRowStart = [vOrRowStart, rowEnd].filter(isDefined).join("/");
  }
  return new CssElementStyleProp("gridRow", vOrRowStart);
}
function gridTemplateColumns(...v) {
  return new CssElementStyleProp("gridTemplateColumns", v.join(" "));
}
function gridTemplateRows(...v) {
  return new CssElementStyleProp("gridTemplateRows", v.join(" "));
}
function height(v) {
  return new CssElementStyleProp("height", v);
}
function left(v) {
  return new CssElementStyleProp("left", v);
}
function margin(...v) {
  return new CssElementStyleProp("margin", v.join(" "));
}
function maxWidth(v) {
  return new CssElementStyleProp("maxWidth", v);
}
function opacity(v) {
  return new CssElementStyleProp("opacity", v);
}
function overflow(...v) {
  return new CssElementStyleProp("overflow", v.join(" "));
}
function padding(...v) {
  return new CssElementStyleProp("padding", v.join(" "));
}
function paddingRight(v) {
  return new CssElementStyleProp("paddingRight", v);
}
function pointerEvents(v) {
  return new CssElementStyleProp("pointerEvents", v);
}
function textAlign(v) {
  return new CssElementStyleProp("textAlign", v);
}
function textOverflow(v) {
  return new CssElementStyleProp("textOverflow", v);
}
function top(v) {
  return new CssElementStyleProp("top", v);
}
function transform(...v) {
  return new CssElementStyleProp("transform", v.join(" "));
}
function whiteSpace(v) {
  return new CssElementStyleProp("whiteSpace", v);
}
function width(v) {
  return new CssElementStyleProp("width", v);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/Exception.ts
var Exception = class extends Error {
  constructor(message2, innerError = null) {
    super(message2);
    this.innerError = innerError;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/identity.ts
function identity(item) {
  return item;
}
function alwaysTrue() {
  return true;
}
function alwaysFalse() {
  return false;
}
function and(a, b) {
  return a && b;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/arrays.ts
function defaultKeySelector(obj2) {
  return obj2;
}
function arrayBinarySearchByKey(arr, itemKey, keySelector) {
  let left2 = 0;
  let right = arr.length;
  let idx = Math.floor((left2 + right) / 2);
  let found = false;
  while (left2 < right && idx < arr.length) {
    const compareTo = arr[idx];
    const compareToKey = isNullOrUndefined(compareTo) ? null : keySelector(compareTo);
    if (isDefined(compareToKey) && itemKey < compareToKey) {
      right = idx;
    } else {
      if (itemKey === compareToKey) {
        found = true;
      }
      left2 = idx + 1;
    }
    idx = Math.floor((left2 + right) / 2);
  }
  if (!found) {
    idx += 0.5;
  }
  return idx;
}
function arrayBinarySearch(arr, item, keySelector) {
  keySelector = keySelector || defaultKeySelector;
  const itemKey = keySelector(item);
  return arrayBinarySearchByKey(arr, itemKey, keySelector);
}
function arrayClear(arr) {
  return arr.splice(0);
}
function arrayCompare(arr1, arr2) {
  for (let i = 0; i < arr1.length; ++i) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return -1;
}
function arrayInsertAt(arr, item, idx) {
  arr.splice(idx, 0, item);
}
function arrayRemove(arr, value2) {
  const idx = arr.indexOf(value2);
  if (idx > -1) {
    arrayRemoveAt(arr, idx);
    return true;
  }
  return false;
}
function arrayFilter(arr, predicate) {
  for (let i = arr.length - 1; i >= 0; --i) {
    if (predicate(arr[i])) {
      return arrayRemoveAt(arr, i);
    }
  }
  return null;
}
function arrayRemoveByKey(arr, key, getKey) {
  return arrayFilter(arr, (v) => getKey(v) === key);
}
function arrayRemoveAt(arr, idx) {
  return arr.splice(idx, 1)[0];
}
function arrayReplace(arr, ...items) {
  arr.splice(0, arr.length, ...items);
}
function _arrayScan(forward, arr, tests) {
  const start2 = forward ? 0 : arr.length - 1;
  const end2 = forward ? arr.length : -1;
  const inc = forward ? 1 : -1;
  for (const test of tests) {
    for (let i = start2; i != end2; i += inc) {
      const item = arr[i];
      if (test(item)) {
        return item;
      }
    }
  }
  return null;
}
function arrayScan(arr, ...tests) {
  return _arrayScan(true, arr, tests);
}
function arrayScanReverse(arr, ...tests) {
  return _arrayScan(false, arr, tests);
}
function arraySortedInsert(arr, item, keySelector, allowDuplicates) {
  let ks;
  if (isFunction(keySelector)) {
    ks = keySelector;
  } else if (isBoolean(keySelector)) {
    allowDuplicates = keySelector;
  }
  if (isNullOrUndefined(allowDuplicates)) {
    allowDuplicates = true;
  }
  return arraySortedInsertInternal(arr, item, ks, allowDuplicates);
}
function arraySortedInsertInternal(arr, item, ks, allowDuplicates) {
  let idx = arrayBinarySearch(arr, item, ks);
  const found = idx % 1 === 0;
  idx = idx | 0;
  if (!found || allowDuplicates) {
    arrayInsertAt(arr, item, idx);
  }
  return idx;
}
function arraySortByKey(arr, keySelector) {
  const newArr = Array.from(arr);
  arraySortByKeyInPlace(newArr, keySelector);
  return newArr;
}
function arraySortByKeyInPlace(newArr, keySelector) {
  newArr.sort((a, b) => {
    const keyA = keySelector(a);
    const keyB = keySelector(b);
    if (keyA < keyB) {
      return -1;
    } else if (keyA > keyB) {
      return 1;
    } else {
      return 0;
    }
  });
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/EventBase.ts
var EventBase = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.listenerOptions = /* @__PURE__ */ new Map();
  }
  addEventListener(type2, callback, options) {
    if (isFunction(callback)) {
      let listeners = this.listeners.get(type2);
      if (!listeners) {
        listeners = new Array();
        this.listeners.set(type2, listeners);
      }
      if (!listeners.find((c) => c === callback)) {
        listeners.push(callback);
        if (options) {
          this.listenerOptions.set(callback, options);
        }
      }
    }
  }
  removeEventListener(type2, callback) {
    if (isFunction(callback)) {
      const listeners = this.listeners.get(type2);
      if (listeners) {
        this.removeListener(listeners, callback);
      }
    }
  }
  clearEventListeners(type2) {
    for (const [evtName, handlers] of this.listeners) {
      if (isNullOrUndefined(type2) || type2 === evtName) {
        for (const handler of handlers) {
          this.removeEventListener(type2, handler);
        }
        arrayClear(handlers);
        this.listeners.delete(evtName);
      }
    }
  }
  removeListener(listeners, callback) {
    const idx = listeners.findIndex((c) => c === callback);
    if (idx >= 0) {
      arrayRemoveAt(listeners, idx);
      if (this.listenerOptions.has(callback)) {
        this.listenerOptions.delete(callback);
      }
    }
  }
  dispatchEvent(evt) {
    const listeners = this.listeners.get(evt.type);
    if (listeners) {
      for (const callback of listeners) {
        const options = this.listenerOptions.get(callback);
        if (isDefined(options) && !isBoolean(options) && options.once) {
          this.removeListener(listeners, callback);
        }
        callback.call(this, evt);
      }
    }
    return !evt.defaultPrevented;
  }
};
var TypedEvent = class extends Event {
  get type() {
    return super.type;
  }
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
  }
};
var TypedEventBase = class extends EventBase {
  constructor() {
    super(...arguments);
    this.bubblers = /* @__PURE__ */ new Set();
    this.scopes = /* @__PURE__ */ new WeakMap();
  }
  addBubbler(bubbler) {
    this.bubblers.add(bubbler);
  }
  removeBubbler(bubbler) {
    this.bubblers.delete(bubbler);
  }
  addEventListener(type2, callback, options) {
    super.addEventListener(type2, callback, options);
  }
  removeEventListener(type2, callback) {
    super.removeEventListener(type2, callback);
  }
  clearEventListeners(type2) {
    return super.clearEventListeners(type2);
  }
  addScopedEventListener(scope, type2, callback, options) {
    if (!this.scopes.has(scope)) {
      this.scopes.set(scope, []);
    }
    this.scopes.get(scope).push([type2, callback]);
    this.addEventListener(type2, callback, options);
  }
  removeScope(scope) {
    const listeners = this.scopes.get(scope);
    if (listeners) {
      this.scopes.delete(scope);
      for (const [type2, listener] of listeners) {
        this.removeEventListener(type2, listener);
      }
    }
  }
  dispatchEvent(evt) {
    if (!super.dispatchEvent(evt)) {
      return false;
    }
    if (!evt.cancelBubble) {
      for (const bubbler of this.bubblers) {
        if (!bubbler.dispatchEvent(evt)) {
          return false;
        }
      }
    }
    return true;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/Task.ts
var Task = class {
  /**
   * Create a new Task
   *
   * @param autoStart - set to false to require manually starting the Task. Useful
   * for reusable tasks that run on timers.
   */
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.onThens = new Array();
    this.onCatches = new Array();
    this._result = void 0;
    this._error = void 0;
    this._executionState = "waiting";
    this._resultState = "none";
    this.resolve = (value2) => {
      if (this.running) {
        this._result = value2;
        this._resultState = "resolved";
        for (const thenner of this.onThens) {
          thenner(value2);
        }
        this.clear();
        this._executionState = "finished";
      }
    };
    this.reject = (reason) => {
      if (this.running) {
        this._error = reason;
        this._resultState = "errored";
        for (const catcher of this.onCatches) {
          catcher(reason);
        }
        this.clear();
        this._executionState = "finished";
      }
    };
    if (this.autoStart) {
      this.start();
    }
  }
  clear() {
    arrayClear(this.onThens);
    arrayClear(this.onCatches);
  }
  /**
   * If the task was not auto-started, signal that the task is now ready to recieve
   * resolutions or rejections.
   **/
  start() {
    this._executionState = "running";
  }
  /**
   * Creates a resolving callback for a static value.
   * @param value
   */
  resolver(value2) {
    return () => this.resolve(value2);
  }
  resolveOn(target, resolveEvt, value2) {
    const resolver = this.resolver(value2);
    target.addEventListener(resolveEvt, resolver);
    this.finally(() => target.removeEventListener(resolveEvt, resolver));
  }
  /**
   * Get the last result that the task had resolved to, if any is available.
   *
   * If the Task had been rejected, attempting to get the result will rethrow
   * the error that had rejected the task.
   **/
  get result() {
    if (isDefined(this.error)) {
      throw this.error;
    }
    return this._result;
  }
  /**
   * Get the last error that the task had been rejected by, if any.
   **/
  get error() {
    return this._error;
  }
  /**
   * Get the current state of the task.
   **/
  get executionState() {
    return this._executionState;
  }
  /**
   * Returns true when the Task is hasn't started yet.
   **/
  get waiting() {
    return this.executionState === "waiting";
  }
  /**
   * Returns true when the Task is waiting to be resolved or rejected.
   **/
  get started() {
    return this.executionState !== "waiting";
  }
  /**
   * Returns true after the Task has started, but before it has finished.
   **/
  get running() {
    return this.executionState === "running";
  }
  /**
   * Returns true when the Task has been resolved or rejected.
   **/
  get finished() {
    return this.executionState === "finished";
  }
  get resultState() {
    return this._resultState;
  }
  /**
   * Returns true if the Task had been resolved successfully.
   **/
  get resolved() {
    return this.resultState === "resolved";
  }
  /**
   * Returns true if the Task had been rejected, regardless of any
   * reason being given.
   **/
  get errored() {
    return this.resultState === "errored";
  }
  get [Symbol.toStringTag]() {
    return this.toString();
  }
  /**
   * Calling Task.then(), Task.catch(), or Task.finally() creates a new Promise.
   * This method creates that promise and links it with the task.
   **/
  project() {
    return new Promise((resolve, reject) => {
      if (!this.finished) {
        this.onThens.push(resolve);
        this.onCatches.push(reject);
      } else if (this.errored) {
        reject(this.error);
      } else {
        resolve(this.result);
      }
    });
  }
  /**
   * Attach a handler to the task that fires when the task is resolved.
   * 
   * @param onfulfilled
   * @param onrejected
   */
  then(onfulfilled, onrejected) {
    return this.project().then(onfulfilled, onrejected);
  }
  /**
   * Attach a handler that fires when the Task is rejected.
   * 
   * @param onrejected
   */
  catch(onrejected) {
    return this.project().catch(onrejected);
  }
  /**
   * Attach a handler that fires regardless of whether the Task is resolved
   * or rejected.
   * 
   * @param onfinally
   */
  finally(onfinally) {
    return this.project().finally(onfinally);
  }
  /**
   * Resets the Task to an unsignalled state, which is useful for
   * reducing GC pressure when working with lots of tasks.
   **/
  reset() {
    this._reset(this.autoStart);
  }
  restart() {
    this._reset(true);
  }
  _reset(start2) {
    if (this.running) {
      this.reject("Resetting previous invocation");
    }
    this.clear();
    this._result = void 0;
    this._error = void 0;
    this._executionState = "waiting";
    this._resultState = "none";
    if (start2) {
      this.start();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/once.ts
function targetValidateEvent(target, type2) {
  return "on" + type2 in target;
}
function once(target, resolveEvt, rejectEvtOrTimeout, ...rejectEvts) {
  if (isNullOrUndefined(rejectEvts)) {
    rejectEvts = [];
  }
  let timeout = void 0;
  if (isString(rejectEvtOrTimeout)) {
    rejectEvts.unshift(rejectEvtOrTimeout);
  } else if (isNumber(rejectEvtOrTimeout)) {
    timeout = rejectEvtOrTimeout;
  }
  if (!(target instanceof EventBase)) {
    if (!targetValidateEvent(target, resolveEvt)) {
      throw new Exception(`Target does not have a ${resolveEvt} rejection event`);
    }
    for (const evt of rejectEvts) {
      if (!targetValidateEvent(target, evt)) {
        throw new Exception(`Target does not have a ${evt} rejection event`);
      }
    }
  }
  const task = new Task();
  if (isNumber(timeout)) {
    const timeoutHandle = setTimeout(task.reject, timeout, `'${resolveEvt}' has timed out.`);
    task.finally(clearTimeout.bind(globalThis, timeoutHandle));
  }
  const register = (evt, callback) => {
    target.addEventListener(evt, callback);
    task.finally(() => target.removeEventListener(evt, callback));
  };
  register(resolveEvt, (evt) => task.resolve(evt));
  const onReject = (evt) => task.reject(evt);
  for (const rejectEvt of rejectEvts) {
    register(rejectEvt, onReject);
  }
  return task;
}
function success(task) {
  return task.then(alwaysTrue).catch(alwaysFalse);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/attrs.ts
var Attr = class {
  /**
   * Creates a new setter functor for HTML Attributes
   * @param key - the attribute name.
   * @param value - the value to set for the attribute.
   * @param tags - the HTML tags that support this attribute.
   */
  constructor(key, value2, bySetAttribute, ...tags) {
    this.key = key;
    this.value = value2;
    this.bySetAttribute = bySetAttribute;
    this.tags = tags.map((t2) => t2.toLocaleUpperCase());
    Object.freeze(this);
  }
  /**
   * Set the attribute value on an HTMLElement
   * @param elem - the element on which to set the attribute.
   */
  applyToElement(elem) {
    const isDataSet = this.key.startsWith("data-");
    const isValid = this.tags.length === 0 || this.tags.indexOf(elem.tagName) > -1 || isDataSet;
    if (!isValid) {
      console.warn(`Element ${elem.tagName} does not support Attribute ${this.key}`);
    } else if (isDataSet) {
      const subkey = this.key.substring(5);
      elem.dataset[subkey] = this.value;
    } else if (this.key === "style") {
      Object.assign(elem.style, this.value);
    } else if (this.key === "classList") {
      const arr = this.value.filter(identity);
      if (arr.length > 0) {
        arr.forEach((v) => elem.classList.add(v));
      }
    } else if (this.bySetAttribute) {
      elem.setAttribute(this.key, this.value);
    } else if (this.key in elem) {
      elem[this.key] = this.value;
    } else if (this.value === false) {
      elem.removeAttribute(this.key);
    } else if (this.value === true) {
      elem.setAttribute(this.key, "");
    } else {
      elem.setAttribute(this.key, this.value);
    }
  }
};
function isAttr(obj2) {
  return obj2 instanceof Attr;
}
function coallesceClassLists(attrs, ...rest) {
  const classes = [...rest];
  const classListAttr = arrayScan(attrs, (attr) => attr instanceof Attr && attr.key === "classList");
  if (isDefined(classListAttr)) {
    arrayRemove(attrs, classListAttr);
    classes.push(...classListAttr.value);
  }
  const classNameAttr = arrayScan(attrs, (attr) => attr instanceof Attr && attr.key === "className");
  if (isDefined(classNameAttr)) {
    arrayRemove(attrs, classNameAttr);
    classes.push(...classNameAttr.value.split(" "));
  }
  return classes;
}
function ariaValueMax(value2) {
  return new Attr("ariaValueMax", value2, false);
}
function ariaValueMin(value2) {
  return new Attr("ariaValueMin", value2, false);
}
function ariaValueNow(value2) {
  return new Attr("ariaValueNow", value2, false);
}
function autoComplete(value2) {
  return new Attr("autocomplete", value2 ? "on" : "off", false, "form", "input", "select", "textarea");
}
function autoPlay(value2) {
  return new Attr("autoplay", value2, false, "audio", "video");
}
function checked(value2) {
  return new Attr("checked", value2, false, "command", "input");
}
function className(value2) {
  return new Attr("className", value2, false);
}
function classList(...values) {
  return new Attr("classList", values, false);
}
function colSpan(value2) {
  return new Attr("colspan", value2, false, "td", "th");
}
function controls(value2) {
  return new Attr("controls", value2, false, "audio", "video");
}
function customData(name3, value2) {
  return new Attr("data-" + name3.toLowerCase(), value2, false);
}
function draggable(value2) {
  return new Attr("draggable", value2, false);
}
function htmlFor(value2) {
  return new Attr("htmlFor", value2, false, "label", "output");
}
function htmlHeight(value2) {
  return new Attr("height", value2, false, "canvas", "embed", "iframe", "img", "input", "object", "video");
}
function id(value2) {
  return new Attr("id", value2, false);
}
function list(value2) {
  return new Attr("list", value2, true, "input");
}
function loop(value2) {
  return new Attr("loop", value2, false, "audio", "bgsound", "marquee", "video");
}
function max(value2) {
  return new Attr("max", value2, false, "input", "meter", "progress");
}
function min(value2) {
  return new Attr("min", value2, false, "input", "meter");
}
function multiple(value2) {
  return new Attr("multiple", value2, false, "input", "select");
}
function muted(value2) {
  return new Attr("muted", value2, false, "audio", "video");
}
function name2(value2) {
  return new Attr("name", value2, false, "button", "form", "fieldset", "iframe", "input", "keygen", "object", "output", "select", "textarea", "map", "meta", "param");
}
function open(value2) {
  return new Attr("open", value2, false, "details");
}
function placeHolder(value2) {
  return new Attr("placeholder", value2, false, "input", "textarea");
}
function rel(value2) {
  return new Attr("rel", value2, false, "a", "area", "link");
}
function required(value2) {
  return new Attr("required", value2, false, "input", "select", "textarea");
}
function role(value2) {
  return new Attr("role", value2, false);
}
function selected(value2) {
  return new Attr("selected", value2, false, "option");
}
function unpackURL(value2) {
  if (value2 instanceof URL) {
    value2 = value2.href;
  }
  return value2;
}
function src(value2) {
  return new Attr("src", unpackURL(value2), false, "audio", "embed", "iframe", "img", "input", "script", "source", "track", "video");
}
function srcObject(value2) {
  return new Attr("srcObject", value2, false, "audio", "video");
}
function step(value2) {
  return new Attr("step", value2, false, "input");
}
function tabIndex(value2) {
  return new Attr("tabindex", value2, false);
}
function title(value2) {
  return new Attr("title", value2, false);
}
function type(value2) {
  if (!isString(value2)) {
    value2 = value2.value;
  }
  return new Attr("type", value2, false, "button", "input", "command", "embed", "link", "object", "script", "source", "style", "menu");
}
function value(value2) {
  return new Attr("value", value2, false, "button", "data", "input", "li", "meter", "option", "progress", "param");
}
function htmlWidth(value2) {
  return new Attr("width", value2, false, "canvas", "embed", "iframe", "img", "input", "object", "video");
}
function wrap(value2) {
  return new Attr("wrap", value2, false, "textarea");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/tags.ts
function isErsatzElement(obj2) {
  if (!isObject(obj2)) {
    return false;
  }
  const elem = obj2;
  return elem.element instanceof Element;
}
function resolveElement(elem) {
  if (isErsatzElement(elem)) {
    return elem.element;
  } else if (isString(elem)) {
    return getElement(elem);
  }
  return elem;
}
function isIElementAppliable(obj2) {
  return isObject(obj2) && "applyToElement" in obj2 && isFunction(obj2.applyToElement);
}
function isElementChild(obj2) {
  return obj2 instanceof Element || isErsatzElement(obj2) || isIElementAppliable(obj2) || isString(obj2) || isNumber(obj2) || isBoolean(obj2) || isDate(obj2);
}
function isElements(child) {
  return isErsatzElement(child) || child instanceof Element;
}
function elementSetDisplay(elem, visible, visibleDisplayType = "") {
  elem = resolveElement(elem);
  elem.style.display = visible ? visibleDisplayType : "none";
}
function elementIsDisplayed(elem) {
  elem = resolveElement(elem);
  return elem.style.display !== "none";
}
function elementToggleDisplay(elem, visibleDisplayType = "block") {
  elementSetDisplay(elem, !elementIsDisplayed(elem), visibleDisplayType);
}
function elementInsertBefore(parent, newElem, refElem) {
  parent = resolveElement(parent);
  newElem = resolveElement(newElem);
  refElem = resolveElement(refElem);
  if (parent && newElem) {
    parent.insertBefore(newElem, refElem);
  }
}
function elementGetIndexInParent(elem) {
  elem = resolveElement(elem);
  if (elem.parentElement) {
    for (let i = 0; i < elem.parentElement.childElementCount; ++i) {
      if (elem.parentElement.children[i] === elem) {
        return i;
      }
    }
  }
  return null;
}
function elementGetCustomData(elem, name3) {
  elem = resolveElement(elem);
  return elem.dataset[name3.toLowerCase()];
}
function elementApply(elem, ...children) {
  elem = resolveElement(elem);
  for (const child of children) {
    if (isDefined(child)) {
      if (child instanceof Node) {
        elem.append(child);
      } else if (isErsatzElement(child)) {
        elem.append(resolveElement(child));
      } else if (isIElementAppliable(child)) {
        child.applyToElement(elem);
      } else {
        elem.append(document.createTextNode(child.toLocaleString()));
      }
    }
  }
  return elem;
}
function elementRemoveFromParent(elem) {
  elem = resolveElement(elem);
  if (isDefined(elem)) {
    elem.remove();
  }
}
function elementReplace(elem, ...elems) {
  elem = resolveElement(elem);
  elem.replaceWith(...elems.map(resolveElement));
  return elem;
}
function elementSwap(elem, withPlaceholder) {
  const placeholder = Div();
  const e2 = withPlaceholder(placeholder);
  elementReplace(placeholder, elementReplace(elem, e2));
  return e2;
}
function getElement(selector) {
  return document.querySelector(selector);
}
function getElements(selector) {
  return Array.from(document.querySelectorAll(selector));
}
function getInput(selector) {
  return getElement(selector);
}
function tag(name3, ...rest) {
  let elem = null;
  for (const attr of rest) {
    if (attr instanceof Attr && attr.key === "id") {
      elem = document.getElementById(attr.value);
      break;
    }
  }
  if (elem == null) {
    elem = document.createElement(name3);
  }
  elementApply(elem, ...rest);
  return elem;
}
function isDisableable(obj2) {
  return isObject(obj2) && "disabled" in obj2 && isBoolean(obj2.disabled);
}
function elementClearChildren(elem) {
  elem = resolveElement(elem);
  while (elem.lastChild) {
    elem.lastChild.remove();
  }
}
function elementSetText(elem, text2) {
  elem = resolveElement(elem);
  elementClearChildren(elem);
  elem.append(TextNode(text2));
}
function elementGetText(elem) {
  elem = resolveElement(elem);
  return elem.innerText;
}
function elementSetTitle(elem, text2) {
  elem = resolveElement(elem);
  elem.title = text2;
}
function elementSetClass(elem, enabled, className2) {
  elem = resolveElement(elem);
  const canEnable = isDefined(className2);
  const hasEnabled = canEnable && elem.classList.contains(className2);
  if (canEnable && hasEnabled !== enabled) {
    elem.classList.toggle(className2);
  }
}
function buttonSetEnabled(button, enabled, label, title2) {
  button = resolveElement(button);
  button.disabled = !enabled;
  elementSetText(button, label);
  elementSetTitle(button, title2);
}
async function mediaElementCan(type2, elem, prog) {
  if (isDefined(prog)) {
    prog.start();
  }
  const expectedState = type2 === "canplay" ? elem.HAVE_CURRENT_DATA : elem.HAVE_ENOUGH_DATA;
  if (elem.readyState >= expectedState) {
    return true;
  }
  try {
    await once(elem, type2, "error");
    return true;
  } catch (err) {
    console.warn(elem.error, err);
    return false;
  } finally {
    if (isDefined(prog)) {
      prog.end();
    }
  }
}
function mediaElementCanPlay(elem, prog) {
  return mediaElementCan("canplay", elem, prog);
}
function mediaElementCanPlayThrough(elem, prog) {
  return mediaElementCan("canplaythrough", elem, prog);
}
function Audio2(...rest) {
  return tag("audio", ...rest);
}
function ButtonRaw(...rest) {
  return tag("button", ...rest);
}
function Button(...rest) {
  return ButtonRaw(...rest, type("button"));
}
function ButtonSmall(...rest) {
  return Button(...rest, classList("btn", "btn-sm"));
}
function ButtonPrimary(...rest) {
  return Button(...rest, classList("btn", "btn-primary"));
}
function ButtonPrimarySmall(...rest) {
  return Button(...rest, classList("btn", "btn-sm", "btn-primary"));
}
function ButtonSecondary(...rest) {
  return Button(...rest, classList("btn", "btn-secondary"));
}
function ButtonSecondarySmall(...rest) {
  return Button(...rest, classList("btn", "btn-sm", "btn-secondary"));
}
function ButtonSecondaryOutlineSmall(...rest) {
  return Button(...rest, classList("btn", "btn-sm", "btn-outline-secondary"));
}
function ButtonDanger(...rest) {
  return Button(...rest, classList("btn", "btn-danger"));
}
function ButtonDangerSmall(...rest) {
  return Button(...rest, classList("btn", "btn-sm", "btn-danger"));
}
function ButtonReset(...rest) {
  return ButtonRaw(...rest, type("reset"));
}
function Canvas(...rest) {
  return tag("canvas", ...rest);
}
function DataList(...rest) {
  return tag("datalist", ...rest);
}
function DD(...rest) {
  return tag("dd", ...rest);
}
function Details(...rest) {
  return tag("details", ...rest);
}
function Div(...rest) {
  return tag("div", ...rest);
}
function DL(...rest) {
  return tag("dl", ...rest);
}
function DT(...rest) {
  return tag("dt", ...rest);
}
function H1(...rest) {
  return tag("h1", ...rest);
}
function H2(...rest) {
  return tag("h2", ...rest);
}
function H3(...rest) {
  return tag("h3", ...rest);
}
function HR(...rest) {
  return tag("hr", ...rest);
}
function I(...rest) {
  return tag("i", ...rest);
}
function FAIcon(iconName, ...rest) {
  return I(className(`fa fa-${iconName}`), ...rest);
}
function IFrame(...rest) {
  return tag("iframe", ...rest);
}
function Img(...rest) {
  return tag("img", ...rest);
}
function Input(...rest) {
  return tag("input", ...rest);
}
function Label(...rest) {
  return tag("label", ...rest);
}
function PreLabeled(id2, label, input) {
  resolveElement(input).id = id2;
  return [
    Label(htmlFor(id2), label),
    input
  ];
}
function LI(...rest) {
  return tag("li", ...rest);
}
function Link(...rest) {
  return tag("link", ...rest);
}
function Meter(...rest) {
  return tag("meter", ...rest);
}
function Option(...rest) {
  return tag("option", ...rest);
}
function Script(...rest) {
  return tag("script", ...rest);
}
function Select(...rest) {
  return tag("select", ...rest);
}
function Span(...rest) {
  return tag("span", ...rest);
}
function Summary(...rest) {
  return tag("summary", ...rest);
}
function Table(...rest) {
  return tag("table", ...rest);
}
function TBody(...rest) {
  return tag("tbody", ...rest);
}
function TD(...rest) {
  return tag("td", ...rest);
}
function TextArea(...rest) {
  return tag("textarea", ...rest);
}
function TFoot(...rest) {
  return tag("tfoot", ...rest);
}
function TH(...rest) {
  return tag("th", ...rest);
}
function THead(...rest) {
  return tag("thead", ...rest);
}
function TR(...rest) {
  return tag("tr", ...rest);
}
function UL(...rest) {
  return tag("ul", ...rest);
}
function Video(...rest) {
  return tag("video", ...rest);
}
function InputCheckbox(...rest) {
  return Input(type("checkbox"), ...rest);
}
function InputDate(...rest) {
  return Input(type("date"), ...rest);
}
function InputFile(...rest) {
  return Input(type("file"), ...rest);
}
function InputNumber(...rest) {
  return Input(type("number"), ...rest);
}
function InputRange(...rest) {
  return Input(type("range"), ...rest);
}
function InputText(...rest) {
  return Input(type("text"), ...rest);
}
function InputURL(...rest) {
  return Input(type("url"), ...rest);
}
function TextNode(txt) {
  return document.createTextNode(txt);
}
function Run(...rest) {
  return Div(
    margin("auto"),
    ...rest
  );
}
function Style(...props) {
  const elem = document.createElement("style");
  document.head.append(elem);
  for (let prop of props) {
    prop.applyToSheet(elem.sheet);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/BaseProgress.ts
var BaseProgress = class extends TypedEventBase {
  constructor() {
    super(...arguments);
    this.attached = new Array();
    this.soFar = null;
    this.total = null;
    this.msg = null;
    this.est = null;
  }
  get p() {
    return this.total > 0 ? this.soFar / this.total : 0;
  }
  report(soFar, total, msg, est) {
    this.soFar = soFar;
    this.total = total;
    this.msg = msg;
    this.est = est;
    for (const attach of this.attached) {
      attach.report(soFar, total, msg, est);
    }
  }
  attach(prog) {
    this.attached.push(prog);
    prog.report(this.soFar, this.total, this.msg, this.est);
  }
  clear() {
    this.report(0, 0);
    this._clear();
  }
  start(msg) {
    this.report(0, 1, msg || "starting");
  }
  end(msg) {
    this.report(1, 1, msg || "done");
    this._clear();
  }
  _clear() {
    this.soFar = null;
    this.total = null;
    this.msg = null;
    this.est = null;
    arrayClear(this.attached);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/ChildProgressCallback.ts
var ChildProgressCallback = class extends BaseProgress {
  constructor(i, prog) {
    super();
    this.i = i;
    this.prog = prog;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    this.prog.update(this.i, soFar, total, msg);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/BaseParentProgressCallback.ts
var BaseParentProgressCallback = class {
  constructor(prog) {
    this.prog = prog;
    this.weightTotal = 0;
    this.subProgressCallbacks = new Array();
    this.subProgressWeights = new Array();
    this.subProgressValues = new Array();
    this.start = performance.now();
    for (let i = 0; i < this.subProgressWeights.length; ++i) {
      this.subProgressValues[i] = 0;
      this.subProgressCallbacks[i] = new ChildProgressCallback(i, this);
    }
  }
  addSubProgress(weight) {
    weight = weight || 1;
    this.weightTotal += weight;
    this.subProgressWeights.push(weight);
    this.subProgressValues.push(0);
    const child = new ChildProgressCallback(this.subProgressCallbacks.length, this);
    this.subProgressCallbacks.push(child);
    return child;
  }
  update(i, subSoFar, subTotal, msg) {
    if (this.prog) {
      this.subProgressValues[i] = subSoFar / subTotal;
      let soFar = 0;
      for (let j = 0; j < this.subProgressWeights.length; ++j) {
        soFar += this.subProgressValues[j] * this.subProgressWeights[j];
      }
      const end2 = performance.now();
      const delta3 = end2 - this.start;
      const est = this.start - end2 + delta3 * this.weightTotal / soFar;
      this.prog.report(soFar, this.weightTotal, msg, est);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressSplit.ts
function progressSplitWeighted(prog, subProgressWeights) {
  const subProg = new WeightedParentProgressCallback(subProgressWeights, prog);
  return subProg.subProgressCallbacks;
}
function progressSplit(prog, taskCount) {
  const subProgressWeights = new Array(taskCount);
  for (let i = 0; i < taskCount; ++i) {
    subProgressWeights[i] = 1;
  }
  return progressSplitWeighted(prog, subProgressWeights);
}
var WeightedParentProgressCallback = class extends BaseParentProgressCallback {
  constructor(subProgressWeights, prog) {
    super(prog);
    for (const weight of subProgressWeights) {
      this.addSubProgress(weight);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressTasks.ts
async function progressTasksWeighted(prog, taskDefs) {
  const weights = new Array(taskDefs.length);
  const callbacks = new Array(taskDefs.length);
  for (let i = 0; i < taskDefs.length; ++i) {
    const taskDef = taskDefs[i];
    weights[i] = taskDef[0];
    callbacks[i] = taskDef[1];
  }
  const progs = progressSplitWeighted(prog, weights);
  const tasks = new Array(taskDefs.length);
  for (let i = 0; i < taskDefs.length; ++i) {
    tasks[i] = callbacks[i](progs[i]);
  }
  return await Promise.all(tasks);
}
function progressTasks(prog, ...subTaskDef) {
  const taskDefs = subTaskDef.map((t2) => [1, t2]);
  return progressTasksWeighted(prog, taskDefs);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/application.ts
var application_exports = {};
__export(application_exports, {
  Application_A2L: () => Application_A2L,
  Application_AML: () => Application_AML,
  Application_ATF: () => Application_ATF,
  Application_ATFX: () => Application_ATFX,
  Application_ATXML: () => Application_ATXML,
  Application_Activemessage: () => Application_Activemessage,
  Application_Alto_CostmapJson: () => Application_Alto_CostmapJson,
  Application_Alto_CostmapfilterJson: () => Application_Alto_CostmapfilterJson,
  Application_Alto_DirectoryJson: () => Application_Alto_DirectoryJson,
  Application_Alto_EndpointcostJson: () => Application_Alto_EndpointcostJson,
  Application_Alto_EndpointcostparamsJson: () => Application_Alto_EndpointcostparamsJson,
  Application_Alto_EndpointpropJson: () => Application_Alto_EndpointpropJson,
  Application_Alto_EndpointpropparamsJson: () => Application_Alto_EndpointpropparamsJson,
  Application_Alto_ErrorJson: () => Application_Alto_ErrorJson,
  Application_Alto_NetworkmapJson: () => Application_Alto_NetworkmapJson,
  Application_Alto_NetworkmapfilterJson: () => Application_Alto_NetworkmapfilterJson,
  Application_Andrew_Inset: () => Application_Andrew_Inset,
  Application_Applefile: () => Application_Applefile,
  Application_Applixware: () => Application_Applixware,
  Application_AtomXml: () => Application_AtomXml,
  Application_AtomcatXml: () => Application_AtomcatXml,
  Application_AtomdeletedXml: () => Application_AtomdeletedXml,
  Application_Atomicmail: () => Application_Atomicmail,
  Application_AtomsvcXml: () => Application_AtomsvcXml,
  Application_Atsc_DwdXml: () => Application_Atsc_DwdXml,
  Application_Atsc_HeldXml: () => Application_Atsc_HeldXml,
  Application_Atsc_RdtJson: () => Application_Atsc_RdtJson,
  Application_Atsc_RsatXml: () => Application_Atsc_RsatXml,
  Application_Auth_PolicyXml: () => Application_Auth_PolicyXml,
  Application_Bacnet_XddZip: () => Application_Bacnet_XddZip,
  Application_Batch_SMTP: () => Application_Batch_SMTP,
  Application_Bdoc: () => Application_Bdoc,
  Application_BeepXml: () => Application_BeepXml,
  Application_CALS_1840: () => Application_CALS_1840,
  Application_CDFXXML: () => Application_CDFXXML,
  Application_CEA: () => Application_CEA,
  Application_CSTAdataXml: () => Application_CSTAdataXml,
  Application_CalendarJson: () => Application_CalendarJson,
  Application_CalendarXml: () => Application_CalendarXml,
  Application_Call_Completion: () => Application_Call_Completion,
  Application_Cbor: () => Application_Cbor,
  Application_Cbor_Seq: () => Application_Cbor_Seq,
  Application_Cccex: () => Application_Cccex,
  Application_CcmpXml: () => Application_CcmpXml,
  Application_CcxmlXml: () => Application_CcxmlXml,
  Application_Cdmi_Capability: () => Application_Cdmi_Capability,
  Application_Cdmi_Container: () => Application_Cdmi_Container,
  Application_Cdmi_Domain: () => Application_Cdmi_Domain,
  Application_Cdmi_Object: () => Application_Cdmi_Object,
  Application_Cdmi_Queue: () => Application_Cdmi_Queue,
  Application_Cdni: () => Application_Cdni,
  Application_Cea_2018Xml: () => Application_Cea_2018Xml,
  Application_CellmlXml: () => Application_CellmlXml,
  Application_Cfw: () => Application_Cfw,
  Application_ClueXml: () => Application_ClueXml,
  Application_Clue_infoXml: () => Application_Clue_infoXml,
  Application_Cms: () => Application_Cms,
  Application_CnrpXml: () => Application_CnrpXml,
  Application_Coap_GroupJson: () => Application_Coap_GroupJson,
  Application_Coap_Payload: () => Application_Coap_Payload,
  Application_Commonground: () => Application_Commonground,
  Application_Conference_InfoXml: () => Application_Conference_InfoXml,
  Application_Cose: () => Application_Cose,
  Application_Cose_Key: () => Application_Cose_Key,
  Application_Cose_Key_Set: () => Application_Cose_Key_Set,
  Application_CplXml: () => Application_CplXml,
  Application_Csrattrs: () => Application_Csrattrs,
  Application_CstaXml: () => Application_CstaXml,
  Application_CsvmJson: () => Application_CsvmJson,
  Application_Cu_Seeme: () => Application_Cu_Seeme,
  Application_Cwt: () => Application_Cwt,
  Application_Cybercash: () => Application_Cybercash,
  Application_DCD: () => Application_DCD,
  Application_DII: () => Application_DII,
  Application_DIT: () => Application_DIT,
  Application_Dart: () => Application_Dart,
  Application_DashXml: () => Application_DashXml,
  Application_Dashdelta: () => Application_Dashdelta,
  Application_DavmountXml: () => Application_DavmountXml,
  Application_Dca_Rft: () => Application_Dca_Rft,
  Application_Dec_Dx: () => Application_Dec_Dx,
  Application_Dialog_InfoXml: () => Application_Dialog_InfoXml,
  Application_Dicom: () => Application_Dicom,
  Application_DicomJson: () => Application_DicomJson,
  Application_DicomXml: () => Application_DicomXml,
  Application_Dns: () => Application_Dns,
  Application_DnsJson: () => Application_DnsJson,
  Application_Dns_Message: () => Application_Dns_Message,
  Application_DocbookXml: () => Application_DocbookXml,
  Application_DotsCbor: () => Application_DotsCbor,
  Application_DskppXml: () => Application_DskppXml,
  Application_DsscDer: () => Application_DsscDer,
  Application_DsscXml: () => Application_DsscXml,
  Application_Dvcs: () => Application_Dvcs,
  Application_EDIFACT: () => Application_EDIFACT,
  Application_EDI_Consent: () => Application_EDI_Consent,
  Application_EDI_X12: () => Application_EDI_X12,
  Application_Ecmascript: () => Application_Ecmascript,
  Application_Efi: () => Application_Efi,
  Application_EmergencyCallDataCommentXml: () => Application_EmergencyCallDataCommentXml,
  Application_EmergencyCallDataControlXml: () => Application_EmergencyCallDataControlXml,
  Application_EmergencyCallDataDeviceInfoXml: () => Application_EmergencyCallDataDeviceInfoXml,
  Application_EmergencyCallDataECallMSD: () => Application_EmergencyCallDataECallMSD,
  Application_EmergencyCallDataProviderInfoXml: () => Application_EmergencyCallDataProviderInfoXml,
  Application_EmergencyCallDataServiceInfoXml: () => Application_EmergencyCallDataServiceInfoXml,
  Application_EmergencyCallDataSubscriberInfoXml: () => Application_EmergencyCallDataSubscriberInfoXml,
  Application_EmergencyCallDataVEDSXml: () => Application_EmergencyCallDataVEDSXml,
  Application_EmmaXml: () => Application_EmmaXml,
  Application_EmotionmlXml: () => Application_EmotionmlXml,
  Application_Encaprtp: () => Application_Encaprtp,
  Application_EppXml: () => Application_EppXml,
  Application_EpubZip: () => Application_EpubZip,
  Application_Eshop: () => Application_Eshop,
  Application_Example: () => Application_Example,
  Application_Exi: () => Application_Exi,
  Application_Expect_Ct_ReportJson: () => Application_Expect_Ct_ReportJson,
  Application_Fastinfoset: () => Application_Fastinfoset,
  Application_Fastsoap: () => Application_Fastsoap,
  Application_FdtXml: () => Application_FdtXml,
  Application_FhirJson: () => Application_FhirJson,
  Application_FhirXml: () => Application_FhirXml,
  Application_Fido_TrustedAppsJson: () => Application_Fido_TrustedAppsJson,
  Application_Fits: () => Application_Fits,
  Application_Flexfec: () => Application_Flexfec,
  Application_Font_Sfnt: () => Application_Font_Sfnt,
  Application_Font_Tdpfr: () => Application_Font_Tdpfr,
  Application_Font_Woff: () => Application_Font_Woff,
  Application_Framework_AttributesXml: () => Application_Framework_AttributesXml,
  Application_GeoJson: () => Application_GeoJson,
  Application_GeoJson_Seq: () => Application_GeoJson_Seq,
  Application_GeopackageSqlite3: () => Application_GeopackageSqlite3,
  Application_GeoxacmlXml: () => Application_GeoxacmlXml,
  Application_Gltf_Buffer: () => Application_Gltf_Buffer,
  Application_GmlXml: () => Application_GmlXml,
  Application_GpxXml: () => Application_GpxXml,
  Application_Gxf: () => Application_Gxf,
  Application_Gzip: () => Application_Gzip,
  Application_H224: () => Application_H224,
  Application_HeldXml: () => Application_HeldXml,
  Application_Hjson: () => Application_Hjson,
  Application_Http: () => Application_Http,
  Application_Hyperstudio: () => Application_Hyperstudio,
  Application_IOTP: () => Application_IOTP,
  Application_ISUP: () => Application_ISUP,
  Application_Ibe_Key_RequestXml: () => Application_Ibe_Key_RequestXml,
  Application_Ibe_Pkg_ReplyXml: () => Application_Ibe_Pkg_ReplyXml,
  Application_Ibe_Pp_Data: () => Application_Ibe_Pp_Data,
  Application_Iges: () => Application_Iges,
  Application_Im_IscomposingXml: () => Application_Im_IscomposingXml,
  Application_Index: () => Application_Index,
  Application_IndexCmd: () => Application_IndexCmd,
  Application_IndexObj: () => Application_IndexObj,
  Application_IndexResponse: () => Application_IndexResponse,
  Application_IndexVnd: () => Application_IndexVnd,
  Application_InkmlXml: () => Application_InkmlXml,
  Application_Ipfix: () => Application_Ipfix,
  Application_Ipp: () => Application_Ipp,
  Application_ItsXml: () => Application_ItsXml,
  Application_Java_Archive: () => Application_Java_Archive,
  Application_Java_Serialized_Object: () => Application_Java_Serialized_Object,
  Application_Java_Vm: () => Application_Java_Vm,
  Application_Javascript: () => Application_Javascript,
  Application_Jf2feedJson: () => Application_Jf2feedJson,
  Application_Jose: () => Application_Jose,
  Application_JoseJson: () => Application_JoseJson,
  Application_JrdJson: () => Application_JrdJson,
  Application_Json: () => Application_Json,
  Application_Json5: () => Application_Json5,
  Application_JsonUTF8: () => Application_JsonUTF8,
  Application_Json_PatchJson: () => Application_Json_PatchJson,
  Application_Json_Seq: () => Application_Json_Seq,
  Application_JsonmlJson: () => Application_JsonmlJson,
  Application_JwkJson: () => Application_JwkJson,
  Application_Jwk_SetJson: () => Application_Jwk_SetJson,
  Application_Jwt: () => Application_Jwt,
  Application_Kpml_RequestXml: () => Application_Kpml_RequestXml,
  Application_Kpml_ResponseXml: () => Application_Kpml_ResponseXml,
  Application_LXF: () => Application_LXF,
  Application_LdJson: () => Application_LdJson,
  Application_LgrXml: () => Application_LgrXml,
  Application_Link_Format: () => Application_Link_Format,
  Application_Load_ControlXml: () => Application_Load_ControlXml,
  Application_LostXml: () => Application_LostXml,
  Application_LostsyncXml: () => Application_LostsyncXml,
  Application_MF4: () => Application_MF4,
  Application_Mac_Binhex40: () => Application_Mac_Binhex40,
  Application_Mac_Compactpro: () => Application_Mac_Compactpro,
  Application_Macwriteii: () => Application_Macwriteii,
  Application_MadsXml: () => Application_MadsXml,
  Application_ManifestJson: () => Application_ManifestJson,
  Application_Marc: () => Application_Marc,
  Application_MarcxmlXml: () => Application_MarcxmlXml,
  Application_Mathematica: () => Application_Mathematica,
  Application_MathmlXml: () => Application_MathmlXml,
  Application_Mathml_ContentXml: () => Application_Mathml_ContentXml,
  Application_Mathml_PresentationXml: () => Application_Mathml_PresentationXml,
  Application_Mbms_Associated_Procedure_DescriptionXml: () => Application_Mbms_Associated_Procedure_DescriptionXml,
  Application_Mbms_DeregisterXml: () => Application_Mbms_DeregisterXml,
  Application_Mbms_EnvelopeXml: () => Application_Mbms_EnvelopeXml,
  Application_Mbms_MskXml: () => Application_Mbms_MskXml,
  Application_Mbms_Msk_ResponseXml: () => Application_Mbms_Msk_ResponseXml,
  Application_Mbms_Protection_DescriptionXml: () => Application_Mbms_Protection_DescriptionXml,
  Application_Mbms_Reception_ReportXml: () => Application_Mbms_Reception_ReportXml,
  Application_Mbms_RegisterXml: () => Application_Mbms_RegisterXml,
  Application_Mbms_Register_ResponseXml: () => Application_Mbms_Register_ResponseXml,
  Application_Mbms_ScheduleXml: () => Application_Mbms_ScheduleXml,
  Application_Mbms_User_Service_DescriptionXml: () => Application_Mbms_User_Service_DescriptionXml,
  Application_Mbox: () => Application_Mbox,
  Application_Media_Policy_DatasetXml: () => Application_Media_Policy_DatasetXml,
  Application_Media_controlXml: () => Application_Media_controlXml,
  Application_MediaservercontrolXml: () => Application_MediaservercontrolXml,
  Application_Merge_PatchJson: () => Application_Merge_PatchJson,
  Application_Metalink4Xml: () => Application_Metalink4Xml,
  Application_MetalinkXml: () => Application_MetalinkXml,
  Application_MetsXml: () => Application_MetsXml,
  Application_Mikey: () => Application_Mikey,
  Application_Mipc: () => Application_Mipc,
  Application_Mmt_AeiXml: () => Application_Mmt_AeiXml,
  Application_Mmt_UsdXml: () => Application_Mmt_UsdXml,
  Application_ModsXml: () => Application_ModsXml,
  Application_Moss_Keys: () => Application_Moss_Keys,
  Application_Moss_Signature: () => Application_Moss_Signature,
  Application_Mosskey_Data: () => Application_Mosskey_Data,
  Application_Mosskey_Request: () => Application_Mosskey_Request,
  Application_Mp21: () => Application_Mp21,
  Application_Mp4: () => Application_Mp4,
  Application_Mpeg4_Generic: () => Application_Mpeg4_Generic,
  Application_Mpeg4_Iod: () => Application_Mpeg4_Iod,
  Application_Mpeg4_Iod_Xmt: () => Application_Mpeg4_Iod_Xmt,
  Application_Mrb_ConsumerXml: () => Application_Mrb_ConsumerXml,
  Application_Mrb_PublishXml: () => Application_Mrb_PublishXml,
  Application_Msc_IvrXml: () => Application_Msc_IvrXml,
  Application_Msc_MixerXml: () => Application_Msc_MixerXml,
  Application_Msword: () => Application_Msword,
  Application_MudJson: () => Application_MudJson,
  Application_Multipart_Core: () => Application_Multipart_Core,
  Application_Mxf: () => Application_Mxf,
  Application_N_Quads: () => Application_N_Quads,
  Application_N_Triples: () => Application_N_Triples,
  Application_Nasdata: () => Application_Nasdata,
  Application_News_Checkgroups: () => Application_News_Checkgroups,
  Application_News_Groupinfo: () => Application_News_Groupinfo,
  Application_News_Transmission: () => Application_News_Transmission,
  Application_NlsmlXml: () => Application_NlsmlXml,
  Application_Node: () => Application_Node,
  Application_Nss: () => Application_Nss,
  Application_ODA: () => Application_ODA,
  Application_ODX: () => Application_ODX,
  Application_Ocsp_Request: () => Application_Ocsp_Request,
  Application_Ocsp_Response: () => Application_Ocsp_Response,
  Application_Octet_Stream: () => Application_Octet_Stream,
  Application_OdmXml: () => Application_OdmXml,
  Application_Oebps_PackageXml: () => Application_Oebps_PackageXml,
  Application_Ogg: () => Application_Ogg,
  Application_OmdocXml: () => Application_OmdocXml,
  Application_Onenote: () => Application_Onenote,
  Application_Oscore: () => Application_Oscore,
  Application_Oxps: () => Application_Oxps,
  Application_P2p_OverlayXml: () => Application_P2p_OverlayXml,
  Application_PDX: () => Application_PDX,
  Application_Parityfec: () => Application_Parityfec,
  Application_Passport: () => Application_Passport,
  Application_Patch_Ops_ErrorXml: () => Application_Patch_Ops_ErrorXml,
  Application_Pdf: () => Application_Pdf,
  Application_Pem_Certificate_Chain: () => Application_Pem_Certificate_Chain,
  Application_Pgp_Encrypted: () => Application_Pgp_Encrypted,
  Application_Pgp_Keys: () => Application_Pgp_Keys,
  Application_Pgp_Signature: () => Application_Pgp_Signature,
  Application_Pics_Rules: () => Application_Pics_Rules,
  Application_PidfXml: () => Application_PidfXml,
  Application_Pidf_DiffXml: () => Application_Pidf_DiffXml,
  Application_Pkcs10: () => Application_Pkcs10,
  Application_Pkcs12: () => Application_Pkcs12,
  Application_Pkcs7_Mime: () => Application_Pkcs7_Mime,
  Application_Pkcs7_Signature: () => Application_Pkcs7_Signature,
  Application_Pkcs8: () => Application_Pkcs8,
  Application_Pkcs8_Encrypted: () => Application_Pkcs8_Encrypted,
  Application_Pkix_Attr_Cert: () => Application_Pkix_Attr_Cert,
  Application_Pkix_Cert: () => Application_Pkix_Cert,
  Application_Pkix_Crl: () => Application_Pkix_Crl,
  Application_Pkix_Pkipath: () => Application_Pkix_Pkipath,
  Application_Pkixcmp: () => Application_Pkixcmp,
  Application_PlsXml: () => Application_PlsXml,
  Application_Poc_SettingsXml: () => Application_Poc_SettingsXml,
  Application_Postscript: () => Application_Postscript,
  Application_Ppsp_TrackerJson: () => Application_Ppsp_TrackerJson,
  Application_ProblemJson: () => Application_ProblemJson,
  Application_ProblemXml: () => Application_ProblemXml,
  Application_ProvenanceXml: () => Application_ProvenanceXml,
  Application_PrsAlvestrandTitrax_Sheet: () => Application_PrsAlvestrandTitrax_Sheet,
  Application_PrsCww: () => Application_PrsCww,
  Application_PrsHpubZip: () => Application_PrsHpubZip,
  Application_PrsNprend: () => Application_PrsNprend,
  Application_PrsPlucker: () => Application_PrsPlucker,
  Application_PrsRdf_Xml_Crypt: () => Application_PrsRdf_Xml_Crypt,
  Application_PrsXsfXml: () => Application_PrsXsfXml,
  Application_PskcXml: () => Application_PskcXml,
  Application_QSIG: () => Application_QSIG,
  Application_RamlYaml: () => Application_RamlYaml,
  Application_Raptorfec: () => Application_Raptorfec,
  Application_RdapJson: () => Application_RdapJson,
  Application_RdfXml: () => Application_RdfXml,
  Application_ReginfoXml: () => Application_ReginfoXml,
  Application_Relax_Ng_Compact_Syntax: () => Application_Relax_Ng_Compact_Syntax,
  Application_Remote_Printing: () => Application_Remote_Printing,
  Application_ReputonJson: () => Application_ReputonJson,
  Application_Resource_ListsXml: () => Application_Resource_ListsXml,
  Application_Resource_Lists_DiffXml: () => Application_Resource_Lists_DiffXml,
  Application_RfcXml: () => Application_RfcXml,
  Application_Riscos: () => Application_Riscos,
  Application_RlmiXml: () => Application_RlmiXml,
  Application_Rls_ServicesXml: () => Application_Rls_ServicesXml,
  Application_Route_ApdXml: () => Application_Route_ApdXml,
  Application_Route_S_TsidXml: () => Application_Route_S_TsidXml,
  Application_Route_UsdXml: () => Application_Route_UsdXml,
  Application_Rpki_Ghostbusters: () => Application_Rpki_Ghostbusters,
  Application_Rpki_Manifest: () => Application_Rpki_Manifest,
  Application_Rpki_Publication: () => Application_Rpki_Publication,
  Application_Rpki_Roa: () => Application_Rpki_Roa,
  Application_Rpki_Updown: () => Application_Rpki_Updown,
  Application_RsdXml: () => Application_RsdXml,
  Application_RssXml: () => Application_RssXml,
  Application_Rtf: () => Application_Rtf,
  Application_Rtploopback: () => Application_Rtploopback,
  Application_Rtx: () => Application_Rtx,
  Application_SGML: () => Application_SGML,
  Application_SamlassertionXml: () => Application_SamlassertionXml,
  Application_SamlmetadataXml: () => Application_SamlmetadataXml,
  Application_SbmlXml: () => Application_SbmlXml,
  Application_ScaipXml: () => Application_ScaipXml,
  Application_ScenarioJson: () => Application_ScenarioJson,
  Application_ScimJson: () => Application_ScimJson,
  Application_Scvp_Cv_Request: () => Application_Scvp_Cv_Request,
  Application_Scvp_Cv_Response: () => Application_Scvp_Cv_Response,
  Application_Scvp_Vp_Request: () => Application_Scvp_Vp_Request,
  Application_Scvp_Vp_Response: () => Application_Scvp_Vp_Response,
  Application_Sdp: () => Application_Sdp,
  Application_SeceventJwt: () => Application_SeceventJwt,
  Application_SenmlCbor: () => Application_SenmlCbor,
  Application_SenmlJson: () => Application_SenmlJson,
  Application_SenmlXml: () => Application_SenmlXml,
  Application_Senml_Exi: () => Application_Senml_Exi,
  Application_SensmlCbor: () => Application_SensmlCbor,
  Application_SensmlJson: () => Application_SensmlJson,
  Application_SensmlXml: () => Application_SensmlXml,
  Application_Sensml_Exi: () => Application_Sensml_Exi,
  Application_SepXml: () => Application_SepXml,
  Application_Sep_Exi: () => Application_Sep_Exi,
  Application_Session_Info: () => Application_Session_Info,
  Application_Set_Payment: () => Application_Set_Payment,
  Application_Set_Payment_Initiation: () => Application_Set_Payment_Initiation,
  Application_Set_Registration: () => Application_Set_Registration,
  Application_Set_Registration_Initiation: () => Application_Set_Registration_Initiation,
  Application_Sgml_Open_Catalog: () => Application_Sgml_Open_Catalog,
  Application_ShfXml: () => Application_ShfXml,
  Application_Sieve: () => Application_Sieve,
  Application_SimpleSymbolContainer: () => Application_SimpleSymbolContainer,
  Application_Simple_FilterXml: () => Application_Simple_FilterXml,
  Application_Simple_Message_Summary: () => Application_Simple_Message_Summary,
  Application_Sipc: () => Application_Sipc,
  Application_Slate: () => Application_Slate,
  Application_Smil: () => Application_Smil,
  Application_SmilXml: () => Application_SmilXml,
  Application_Smpte336m: () => Application_Smpte336m,
  Application_SoapFastinfoset: () => Application_SoapFastinfoset,
  Application_SoapXml: () => Application_SoapXml,
  Application_Sparql_Query: () => Application_Sparql_Query,
  Application_Sparql_ResultsXml: () => Application_Sparql_ResultsXml,
  Application_Spirits_EventXml: () => Application_Spirits_EventXml,
  Application_Sql: () => Application_Sql,
  Application_Srgs: () => Application_Srgs,
  Application_SrgsXml: () => Application_SrgsXml,
  Application_SruXml: () => Application_SruXml,
  Application_SsdlXml: () => Application_SsdlXml,
  Application_SsmlXml: () => Application_SsmlXml,
  Application_StixJson: () => Application_StixJson,
  Application_SwidXml: () => Application_SwidXml,
  Application_TETRA_ISI: () => Application_TETRA_ISI,
  Application_Tamp_Apex_Update: () => Application_Tamp_Apex_Update,
  Application_Tamp_Apex_Update_Confirm: () => Application_Tamp_Apex_Update_Confirm,
  Application_Tamp_Community_Update: () => Application_Tamp_Community_Update,
  Application_Tamp_Community_Update_Confirm: () => Application_Tamp_Community_Update_Confirm,
  Application_Tamp_Error: () => Application_Tamp_Error,
  Application_Tamp_Sequence_Adjust: () => Application_Tamp_Sequence_Adjust,
  Application_Tamp_Sequence_Adjust_Confirm: () => Application_Tamp_Sequence_Adjust_Confirm,
  Application_Tamp_Status_Query: () => Application_Tamp_Status_Query,
  Application_Tamp_Status_Response: () => Application_Tamp_Status_Response,
  Application_Tamp_Update: () => Application_Tamp_Update,
  Application_Tamp_Update_Confirm: () => Application_Tamp_Update_Confirm,
  Application_Tar: () => Application_Tar,
  Application_TaxiiJson: () => Application_TaxiiJson,
  Application_TeiXml: () => Application_TeiXml,
  Application_ThraudXml: () => Application_ThraudXml,
  Application_Timestamp_Query: () => Application_Timestamp_Query,
  Application_Timestamp_Reply: () => Application_Timestamp_Reply,
  Application_Timestamped_Data: () => Application_Timestamped_Data,
  Application_TlsrptGzip: () => Application_TlsrptGzip,
  Application_TlsrptJson: () => Application_TlsrptJson,
  Application_Tnauthlist: () => Application_Tnauthlist,
  Application_Toml: () => Application_Toml,
  Application_Trickle_Ice_Sdpfrag: () => Application_Trickle_Ice_Sdpfrag,
  Application_Trig: () => Application_Trig,
  Application_TtmlXml: () => Application_TtmlXml,
  Application_Tve_Trigger: () => Application_Tve_Trigger,
  Application_Tzif: () => Application_Tzif,
  Application_Tzif_Leap: () => Application_Tzif_Leap,
  Application_Ubjson: () => Application_Ubjson,
  Application_Ulpfec: () => Application_Ulpfec,
  Application_Urc_GrpsheetXml: () => Application_Urc_GrpsheetXml,
  Application_Urc_RessheetXml: () => Application_Urc_RessheetXml,
  Application_Urc_TargetdescXml: () => Application_Urc_TargetdescXml,
  Application_Urc_UisocketdescXml: () => Application_Urc_UisocketdescXml,
  Application_VcardJson: () => Application_VcardJson,
  Application_VcardXml: () => Application_VcardXml,
  Application_Vemmi: () => Application_Vemmi,
  Application_Vendor_1000mindsDecision_ModelXml: () => Application_Vendor_1000mindsDecision_ModelXml,
  Application_Vendor_1d_Interleaved_Parityfec: () => Application_Vendor_1d_Interleaved_Parityfec,
  Application_Vendor_3MPost_It_Notes: () => Application_Vendor_3MPost_It_Notes,
  Application_Vendor_3gpdash_Qoe_ReportXml: () => Application_Vendor_3gpdash_Qoe_ReportXml,
  Application_Vendor_3gpp2BcmcsinfoXml: () => Application_Vendor_3gpp2BcmcsinfoXml,
  Application_Vendor_3gpp2Sms: () => Application_Vendor_3gpp2Sms,
  Application_Vendor_3gpp2Tcap: () => Application_Vendor_3gpp2Tcap,
  Application_Vendor_3gppAccess_Transfer_EventsXml: () => Application_Vendor_3gppAccess_Transfer_EventsXml,
  Application_Vendor_3gppBsfXml: () => Application_Vendor_3gppBsfXml,
  Application_Vendor_3gppGMOPXml: () => Application_Vendor_3gppGMOPXml,
  Application_Vendor_3gppMc_Signalling_Ear: () => Application_Vendor_3gppMc_Signalling_Ear,
  Application_Vendor_3gppMcdata_Affiliation_CommandXml: () => Application_Vendor_3gppMcdata_Affiliation_CommandXml,
  Application_Vendor_3gppMcdata_InfoXml: () => Application_Vendor_3gppMcdata_InfoXml,
  Application_Vendor_3gppMcdata_Payload: () => Application_Vendor_3gppMcdata_Payload,
  Application_Vendor_3gppMcdata_Service_ConfigXml: () => Application_Vendor_3gppMcdata_Service_ConfigXml,
  Application_Vendor_3gppMcdata_Signalling: () => Application_Vendor_3gppMcdata_Signalling,
  Application_Vendor_3gppMcdata_Ue_ConfigXml: () => Application_Vendor_3gppMcdata_Ue_ConfigXml,
  Application_Vendor_3gppMcdata_User_ProfileXml: () => Application_Vendor_3gppMcdata_User_ProfileXml,
  Application_Vendor_3gppMcptt_Affiliation_CommandXml: () => Application_Vendor_3gppMcptt_Affiliation_CommandXml,
  Application_Vendor_3gppMcptt_Floor_RequestXml: () => Application_Vendor_3gppMcptt_Floor_RequestXml,
  Application_Vendor_3gppMcptt_InfoXml: () => Application_Vendor_3gppMcptt_InfoXml,
  Application_Vendor_3gppMcptt_Location_InfoXml: () => Application_Vendor_3gppMcptt_Location_InfoXml,
  Application_Vendor_3gppMcptt_Mbms_Usage_InfoXml: () => Application_Vendor_3gppMcptt_Mbms_Usage_InfoXml,
  Application_Vendor_3gppMcptt_Service_ConfigXml: () => Application_Vendor_3gppMcptt_Service_ConfigXml,
  Application_Vendor_3gppMcptt_SignedXml: () => Application_Vendor_3gppMcptt_SignedXml,
  Application_Vendor_3gppMcptt_Ue_ConfigXml: () => Application_Vendor_3gppMcptt_Ue_ConfigXml,
  Application_Vendor_3gppMcptt_Ue_Init_ConfigXml: () => Application_Vendor_3gppMcptt_Ue_Init_ConfigXml,
  Application_Vendor_3gppMcptt_User_ProfileXml: () => Application_Vendor_3gppMcptt_User_ProfileXml,
  Application_Vendor_3gppMcvideo_Affiliation_CommandXml: () => Application_Vendor_3gppMcvideo_Affiliation_CommandXml,
  Application_Vendor_3gppMcvideo_Affiliation_InfoXml: () => Application_Vendor_3gppMcvideo_Affiliation_InfoXml,
  Application_Vendor_3gppMcvideo_InfoXml: () => Application_Vendor_3gppMcvideo_InfoXml,
  Application_Vendor_3gppMcvideo_Location_InfoXml: () => Application_Vendor_3gppMcvideo_Location_InfoXml,
  Application_Vendor_3gppMcvideo_Mbms_Usage_InfoXml: () => Application_Vendor_3gppMcvideo_Mbms_Usage_InfoXml,
  Application_Vendor_3gppMcvideo_Service_ConfigXml: () => Application_Vendor_3gppMcvideo_Service_ConfigXml,
  Application_Vendor_3gppMcvideo_Transmission_RequestXml: () => Application_Vendor_3gppMcvideo_Transmission_RequestXml,
  Application_Vendor_3gppMcvideo_Ue_ConfigXml: () => Application_Vendor_3gppMcvideo_Ue_ConfigXml,
  Application_Vendor_3gppMcvideo_User_ProfileXml: () => Application_Vendor_3gppMcvideo_User_ProfileXml,
  Application_Vendor_3gppMid_CallXml: () => Application_Vendor_3gppMid_CallXml,
  Application_Vendor_3gppPic_Bw_Large: () => Application_Vendor_3gppPic_Bw_Large,
  Application_Vendor_3gppPic_Bw_Small: () => Application_Vendor_3gppPic_Bw_Small,
  Application_Vendor_3gppPic_Bw_Var: () => Application_Vendor_3gppPic_Bw_Var,
  Application_Vendor_3gppSRVCC_InfoXml: () => Application_Vendor_3gppSRVCC_InfoXml,
  Application_Vendor_3gppSms: () => Application_Vendor_3gppSms,
  Application_Vendor_3gppSmsXml: () => Application_Vendor_3gppSmsXml,
  Application_Vendor_3gppSrvcc_ExtXml: () => Application_Vendor_3gppSrvcc_ExtXml,
  Application_Vendor_3gppState_And_Event_InfoXml: () => Application_Vendor_3gppState_And_Event_InfoXml,
  Application_Vendor_3gppUssdXml: () => Application_Vendor_3gppUssdXml,
  Application_Vendor_3gpp_ImsXml: () => Application_Vendor_3gpp_ImsXml,
  Application_Vendor_3gpp_ProseXml: () => Application_Vendor_3gpp_ProseXml,
  Application_Vendor_3gpp_Prose_Pc3chXml: () => Application_Vendor_3gpp_Prose_Pc3chXml,
  Application_Vendor_3gpp_V2x_Local_Service_Information: () => Application_Vendor_3gpp_V2x_Local_Service_Information,
  Application_Vendor_3lightssoftwareImagescal: () => Application_Vendor_3lightssoftwareImagescal,
  Application_Vendor_AccpacSimplyAso: () => Application_Vendor_AccpacSimplyAso,
  Application_Vendor_AccpacSimplyImp: () => Application_Vendor_AccpacSimplyImp,
  Application_Vendor_Acucobol: () => Application_Vendor_Acucobol,
  Application_Vendor_Acucorp: () => Application_Vendor_Acucorp,
  Application_Vendor_AdobeAir_Application_Installer_PackageZip: () => Application_Vendor_AdobeAir_Application_Installer_PackageZip,
  Application_Vendor_AdobeFlashMovie: () => Application_Vendor_AdobeFlashMovie,
  Application_Vendor_AdobeFormscentralFcdt: () => Application_Vendor_AdobeFormscentralFcdt,
  Application_Vendor_AdobeFxp: () => Application_Vendor_AdobeFxp,
  Application_Vendor_AdobePartial_Upload: () => Application_Vendor_AdobePartial_Upload,
  Application_Vendor_AdobeXdpXml: () => Application_Vendor_AdobeXdpXml,
  Application_Vendor_AdobeXfdf: () => Application_Vendor_AdobeXfdf,
  Application_Vendor_AetherImp: () => Application_Vendor_AetherImp,
  Application_Vendor_AfpcAfplinedata: () => Application_Vendor_AfpcAfplinedata,
  Application_Vendor_AfpcAfplinedata_Pagedef: () => Application_Vendor_AfpcAfplinedata_Pagedef,
  Application_Vendor_AfpcFoca_Charset: () => Application_Vendor_AfpcFoca_Charset,
  Application_Vendor_AfpcFoca_Codedfont: () => Application_Vendor_AfpcFoca_Codedfont,
  Application_Vendor_AfpcFoca_Codepage: () => Application_Vendor_AfpcFoca_Codepage,
  Application_Vendor_AfpcModca: () => Application_Vendor_AfpcModca,
  Application_Vendor_AfpcModca_Formdef: () => Application_Vendor_AfpcModca_Formdef,
  Application_Vendor_AfpcModca_Mediummap: () => Application_Vendor_AfpcModca_Mediummap,
  Application_Vendor_AfpcModca_Objectcontainer: () => Application_Vendor_AfpcModca_Objectcontainer,
  Application_Vendor_AfpcModca_Overlay: () => Application_Vendor_AfpcModca_Overlay,
  Application_Vendor_AfpcModca_Pagesegment: () => Application_Vendor_AfpcModca_Pagesegment,
  Application_Vendor_Ah_Barcode: () => Application_Vendor_Ah_Barcode,
  Application_Vendor_AheadSpace: () => Application_Vendor_AheadSpace,
  Application_Vendor_AirzipFilesecureAzf: () => Application_Vendor_AirzipFilesecureAzf,
  Application_Vendor_AirzipFilesecureAzs: () => Application_Vendor_AirzipFilesecureAzs,
  Application_Vendor_AmadeusJson: () => Application_Vendor_AmadeusJson,
  Application_Vendor_AmazonEbook: () => Application_Vendor_AmazonEbook,
  Application_Vendor_AmazonMobi8_Ebook: () => Application_Vendor_AmazonMobi8_Ebook,
  Application_Vendor_AmericandynamicsAcc: () => Application_Vendor_AmericandynamicsAcc,
  Application_Vendor_AmigaAmi: () => Application_Vendor_AmigaAmi,
  Application_Vendor_AmundsenMazeXml: () => Application_Vendor_AmundsenMazeXml,
  Application_Vendor_AndroidOta: () => Application_Vendor_AndroidOta,
  Application_Vendor_AndroidPackage_Archive: () => Application_Vendor_AndroidPackage_Archive,
  Application_Vendor_Anki: () => Application_Vendor_Anki,
  Application_Vendor_Anser_Web_Certificate_Issue_Initiation: () => Application_Vendor_Anser_Web_Certificate_Issue_Initiation,
  Application_Vendor_Anser_Web_Funds_Transfer_Initiation: () => Application_Vendor_Anser_Web_Funds_Transfer_Initiation,
  Application_Vendor_AntixGame_Component: () => Application_Vendor_AntixGame_Component,
  Application_Vendor_ApacheThriftBinary: () => Application_Vendor_ApacheThriftBinary,
  Application_Vendor_ApacheThriftCompact: () => Application_Vendor_ApacheThriftCompact,
  Application_Vendor_ApacheThriftJson: () => Application_Vendor_ApacheThriftJson,
  Application_Vendor_ApiJson: () => Application_Vendor_ApiJson,
  Application_Vendor_AplextorWarrpJson: () => Application_Vendor_AplextorWarrpJson,
  Application_Vendor_ApothekendeReservationJson: () => Application_Vendor_ApothekendeReservationJson,
  Application_Vendor_AppleInstallerXml: () => Application_Vendor_AppleInstallerXml,
  Application_Vendor_AppleKeynote: () => Application_Vendor_AppleKeynote,
  Application_Vendor_AppleMpegurl: () => Application_Vendor_AppleMpegurl,
  Application_Vendor_AppleNumbers: () => Application_Vendor_AppleNumbers,
  Application_Vendor_ApplePages: () => Application_Vendor_ApplePages,
  Application_Vendor_ApplePkpass: () => Application_Vendor_ApplePkpass,
  Application_Vendor_ArastraSwi: () => Application_Vendor_ArastraSwi,
  Application_Vendor_AristanetworksSwi: () => Application_Vendor_AristanetworksSwi,
  Application_Vendor_ArtisanJson: () => Application_Vendor_ArtisanJson,
  Application_Vendor_Artsquare: () => Application_Vendor_Artsquare,
  Application_Vendor_Astraea_SoftwareIota: () => Application_Vendor_Astraea_SoftwareIota,
  Application_Vendor_Audiograph: () => Application_Vendor_Audiograph,
  Application_Vendor_Autopackage: () => Application_Vendor_Autopackage,
  Application_Vendor_AvalonJson: () => Application_Vendor_AvalonJson,
  Application_Vendor_AvistarXml: () => Application_Vendor_AvistarXml,
  Application_Vendor_BalsamiqBmmlXml: () => Application_Vendor_BalsamiqBmmlXml,
  Application_Vendor_BalsamiqBmpr: () => Application_Vendor_BalsamiqBmpr,
  Application_Vendor_Banana_Accounting: () => Application_Vendor_Banana_Accounting,
  Application_Vendor_BbfUspError: () => Application_Vendor_BbfUspError,
  Application_Vendor_BbfUspMsg: () => Application_Vendor_BbfUspMsg,
  Application_Vendor_BbfUspMsgJson: () => Application_Vendor_BbfUspMsgJson,
  Application_Vendor_Bekitzur_StechJson: () => Application_Vendor_Bekitzur_StechJson,
  Application_Vendor_BintMed_Content: () => Application_Vendor_BintMed_Content,
  Application_Vendor_BiopaxRdfXml: () => Application_Vendor_BiopaxRdfXml,
  Application_Vendor_Blink_Idb_Value_Wrapper: () => Application_Vendor_Blink_Idb_Value_Wrapper,
  Application_Vendor_BlueiceMultipass: () => Application_Vendor_BlueiceMultipass,
  Application_Vendor_BluetoothEpOob: () => Application_Vendor_BluetoothEpOob,
  Application_Vendor_BluetoothLeOob: () => Application_Vendor_BluetoothLeOob,
  Application_Vendor_Bmi: () => Application_Vendor_Bmi,
  Application_Vendor_Bpf: () => Application_Vendor_Bpf,
  Application_Vendor_Bpf3: () => Application_Vendor_Bpf3,
  Application_Vendor_Businessobjects: () => Application_Vendor_Businessobjects,
  Application_Vendor_ByuUapiJson: () => Application_Vendor_ByuUapiJson,
  Application_Vendor_Cab_Jscript: () => Application_Vendor_Cab_Jscript,
  Application_Vendor_Canon_Cpdl: () => Application_Vendor_Canon_Cpdl,
  Application_Vendor_Canon_Lips: () => Application_Vendor_Canon_Lips,
  Application_Vendor_Capasystems_PgJson: () => Application_Vendor_Capasystems_PgJson,
  Application_Vendor_CendioThinlincClientconf: () => Application_Vendor_CendioThinlincClientconf,
  Application_Vendor_Century_SystemsTcp_stream: () => Application_Vendor_Century_SystemsTcp_stream,
  Application_Vendor_ChemdrawXml: () => Application_Vendor_ChemdrawXml,
  Application_Vendor_Chess_Pgn: () => Application_Vendor_Chess_Pgn,
  Application_Vendor_ChipnutsKaraoke_Mmd: () => Application_Vendor_ChipnutsKaraoke_Mmd,
  Application_Vendor_Ciedi: () => Application_Vendor_Ciedi,
  Application_Vendor_Cinderella: () => Application_Vendor_Cinderella,
  Application_Vendor_CirpackIsdn_Ext: () => Application_Vendor_CirpackIsdn_Ext,
  Application_Vendor_CitationstylesStyleXml: () => Application_Vendor_CitationstylesStyleXml,
  Application_Vendor_Claymore: () => Application_Vendor_Claymore,
  Application_Vendor_CloantoRp9: () => Application_Vendor_CloantoRp9,
  Application_Vendor_ClonkC4group: () => Application_Vendor_ClonkC4group,
  Application_Vendor_CluetrustCartomobile_Config: () => Application_Vendor_CluetrustCartomobile_Config,
  Application_Vendor_CluetrustCartomobile_Config_Pkg: () => Application_Vendor_CluetrustCartomobile_Config_Pkg,
  Application_Vendor_Coffeescript: () => Application_Vendor_Coffeescript,
  Application_Vendor_CollabioXodocumentsDocument: () => Application_Vendor_CollabioXodocumentsDocument,
  Application_Vendor_CollabioXodocumentsDocument_Template: () => Application_Vendor_CollabioXodocumentsDocument_Template,
  Application_Vendor_CollabioXodocumentsPresentation: () => Application_Vendor_CollabioXodocumentsPresentation,
  Application_Vendor_CollabioXodocumentsPresentation_Template: () => Application_Vendor_CollabioXodocumentsPresentation_Template,
  Application_Vendor_CollabioXodocumentsSpreadsheet: () => Application_Vendor_CollabioXodocumentsSpreadsheet,
  Application_Vendor_CollabioXodocumentsSpreadsheet_Template: () => Application_Vendor_CollabioXodocumentsSpreadsheet_Template,
  Application_Vendor_CollectionDocJson: () => Application_Vendor_CollectionDocJson,
  Application_Vendor_CollectionJson: () => Application_Vendor_CollectionJson,
  Application_Vendor_CollectionNextJson: () => Application_Vendor_CollectionNextJson,
  Application_Vendor_ComicbookZip: () => Application_Vendor_ComicbookZip,
  Application_Vendor_Comicbook_Rar: () => Application_Vendor_Comicbook_Rar,
  Application_Vendor_Commerce_Battelle: () => Application_Vendor_Commerce_Battelle,
  Application_Vendor_Commonspace: () => Application_Vendor_Commonspace,
  Application_Vendor_ContactCmsg: () => Application_Vendor_ContactCmsg,
  Application_Vendor_CoreosIgnitionJson: () => Application_Vendor_CoreosIgnitionJson,
  Application_Vendor_Cosmocaller: () => Application_Vendor_Cosmocaller,
  Application_Vendor_CrickClicker: () => Application_Vendor_CrickClicker,
  Application_Vendor_CrickClickerKeyboard: () => Application_Vendor_CrickClickerKeyboard,
  Application_Vendor_CrickClickerPalette: () => Application_Vendor_CrickClickerPalette,
  Application_Vendor_CrickClickerTemplate: () => Application_Vendor_CrickClickerTemplate,
  Application_Vendor_CrickClickerWordbank: () => Application_Vendor_CrickClickerWordbank,
  Application_Vendor_CriticaltoolsWbsXml: () => Application_Vendor_CriticaltoolsWbsXml,
  Application_Vendor_CryptiiPipeJson: () => Application_Vendor_CryptiiPipeJson,
  Application_Vendor_Crypto_Shade_File: () => Application_Vendor_Crypto_Shade_File,
  Application_Vendor_Ctc_Posml: () => Application_Vendor_Ctc_Posml,
  Application_Vendor_CtctWsXml: () => Application_Vendor_CtctWsXml,
  Application_Vendor_Cups_Pdf: () => Application_Vendor_Cups_Pdf,
  Application_Vendor_Cups_Postscript: () => Application_Vendor_Cups_Postscript,
  Application_Vendor_Cups_Ppd: () => Application_Vendor_Cups_Ppd,
  Application_Vendor_Cups_Raster: () => Application_Vendor_Cups_Raster,
  Application_Vendor_Cups_Raw: () => Application_Vendor_Cups_Raw,
  Application_Vendor_Curl: () => Application_Vendor_Curl,
  Application_Vendor_CurlCar: () => Application_Vendor_CurlCar,
  Application_Vendor_CurlPcurl: () => Application_Vendor_CurlPcurl,
  Application_Vendor_CyanDeanRootXml: () => Application_Vendor_CyanDeanRootXml,
  Application_Vendor_Cybank: () => Application_Vendor_Cybank,
  Application_Vendor_D2lCoursepackage1p0Zip: () => Application_Vendor_D2lCoursepackage1p0Zip,
  Application_Vendor_Dart: () => Application_Vendor_Dart,
  Application_Vendor_Data_VisionRdz: () => Application_Vendor_Data_VisionRdz,
  Application_Vendor_DatapackageJson: () => Application_Vendor_DatapackageJson,
  Application_Vendor_DataresourceJson: () => Application_Vendor_DataresourceJson,
  Application_Vendor_DebianBinary_Package: () => Application_Vendor_DebianBinary_Package,
  Application_Vendor_DeceData: () => Application_Vendor_DeceData,
  Application_Vendor_DeceTtmlXml: () => Application_Vendor_DeceTtmlXml,
  Application_Vendor_DeceUnspecified: () => Application_Vendor_DeceUnspecified,
  Application_Vendor_DeceZip: () => Application_Vendor_DeceZip,
  Application_Vendor_DenovoFcselayout_Link: () => Application_Vendor_DenovoFcselayout_Link,
  Application_Vendor_DesmumeMovie: () => Application_Vendor_DesmumeMovie,
  Application_Vendor_Dir_BiPlate_Dl_Nosuffix: () => Application_Vendor_Dir_BiPlate_Dl_Nosuffix,
  Application_Vendor_DmDelegationXml: () => Application_Vendor_DmDelegationXml,
  Application_Vendor_Dna: () => Application_Vendor_Dna,
  Application_Vendor_DocumentJson: () => Application_Vendor_DocumentJson,
  Application_Vendor_DolbyMlp: () => Application_Vendor_DolbyMlp,
  Application_Vendor_DolbyMobile1: () => Application_Vendor_DolbyMobile1,
  Application_Vendor_DolbyMobile2: () => Application_Vendor_DolbyMobile2,
  Application_Vendor_DoremirScorecloud_Binary_Document: () => Application_Vendor_DoremirScorecloud_Binary_Document,
  Application_Vendor_Dpgraph: () => Application_Vendor_Dpgraph,
  Application_Vendor_Dreamfactory: () => Application_Vendor_Dreamfactory,
  Application_Vendor_DriveJson: () => Application_Vendor_DriveJson,
  Application_Vendor_Ds_Keypoint: () => Application_Vendor_Ds_Keypoint,
  Application_Vendor_DtgLocal: () => Application_Vendor_DtgLocal,
  Application_Vendor_DtgLocalFlash: () => Application_Vendor_DtgLocalFlash,
  Application_Vendor_DtgLocalHtml: () => Application_Vendor_DtgLocalHtml,
  Application_Vendor_DvbAit: () => Application_Vendor_DvbAit,
  Application_Vendor_DvbDvbj: () => Application_Vendor_DvbDvbj,
  Application_Vendor_DvbEsgcontainer: () => Application_Vendor_DvbEsgcontainer,
  Application_Vendor_DvbIpdcdftnotifaccess: () => Application_Vendor_DvbIpdcdftnotifaccess,
  Application_Vendor_DvbIpdcesgaccess: () => Application_Vendor_DvbIpdcesgaccess,
  Application_Vendor_DvbIpdcesgaccess2: () => Application_Vendor_DvbIpdcesgaccess2,
  Application_Vendor_DvbIpdcesgpdd: () => Application_Vendor_DvbIpdcesgpdd,
  Application_Vendor_DvbIpdcroaming: () => Application_Vendor_DvbIpdcroaming,
  Application_Vendor_DvbIptvAlfec_Base: () => Application_Vendor_DvbIptvAlfec_Base,
  Application_Vendor_DvbIptvAlfec_Enhancement: () => Application_Vendor_DvbIptvAlfec_Enhancement,
  Application_Vendor_DvbNotif_Aggregate_RootXml: () => Application_Vendor_DvbNotif_Aggregate_RootXml,
  Application_Vendor_DvbNotif_ContainerXml: () => Application_Vendor_DvbNotif_ContainerXml,
  Application_Vendor_DvbNotif_GenericXml: () => Application_Vendor_DvbNotif_GenericXml,
  Application_Vendor_DvbNotif_Ia_MsglistXml: () => Application_Vendor_DvbNotif_Ia_MsglistXml,
  Application_Vendor_DvbNotif_Ia_Registration_RequestXml: () => Application_Vendor_DvbNotif_Ia_Registration_RequestXml,
  Application_Vendor_DvbNotif_Ia_Registration_ResponseXml: () => Application_Vendor_DvbNotif_Ia_Registration_ResponseXml,
  Application_Vendor_DvbNotif_InitXml: () => Application_Vendor_DvbNotif_InitXml,
  Application_Vendor_DvbPfr: () => Application_Vendor_DvbPfr,
  Application_Vendor_DvbService: () => Application_Vendor_DvbService,
  Application_Vendor_Dxr: () => Application_Vendor_Dxr,
  Application_Vendor_Dynageo: () => Application_Vendor_Dynageo,
  Application_Vendor_Dzr: () => Application_Vendor_Dzr,
  Application_Vendor_EasykaraokeCdgdownload: () => Application_Vendor_EasykaraokeCdgdownload,
  Application_Vendor_Ecdis_Update: () => Application_Vendor_Ecdis_Update,
  Application_Vendor_EcipRlp: () => Application_Vendor_EcipRlp,
  Application_Vendor_EcowinChart: () => Application_Vendor_EcowinChart,
  Application_Vendor_EcowinFilerequest: () => Application_Vendor_EcowinFilerequest,
  Application_Vendor_EcowinFileupdate: () => Application_Vendor_EcowinFileupdate,
  Application_Vendor_EcowinSeries: () => Application_Vendor_EcowinSeries,
  Application_Vendor_EcowinSeriesrequest: () => Application_Vendor_EcowinSeriesrequest,
  Application_Vendor_EcowinSeriesupdate: () => Application_Vendor_EcowinSeriesupdate,
  Application_Vendor_EfiImg: () => Application_Vendor_EfiImg,
  Application_Vendor_EfiIso: () => Application_Vendor_EfiIso,
  Application_Vendor_EmclientAccessrequestXml: () => Application_Vendor_EmclientAccessrequestXml,
  Application_Vendor_Enliven: () => Application_Vendor_Enliven,
  Application_Vendor_EnphaseEnvoy: () => Application_Vendor_EnphaseEnvoy,
  Application_Vendor_EprintsDataXml: () => Application_Vendor_EprintsDataXml,
  Application_Vendor_EpsonEsf: () => Application_Vendor_EpsonEsf,
  Application_Vendor_EpsonMsf: () => Application_Vendor_EpsonMsf,
  Application_Vendor_EpsonQuickanime: () => Application_Vendor_EpsonQuickanime,
  Application_Vendor_EpsonSalt: () => Application_Vendor_EpsonSalt,
  Application_Vendor_EpsonSsf: () => Application_Vendor_EpsonSsf,
  Application_Vendor_EricssonQuickcall: () => Application_Vendor_EricssonQuickcall,
  Application_Vendor_Espass_EspassZip: () => Application_Vendor_Espass_EspassZip,
  Application_Vendor_Eszigno3Xml: () => Application_Vendor_Eszigno3Xml,
  Application_Vendor_EtsiAocXml: () => Application_Vendor_EtsiAocXml,
  Application_Vendor_EtsiAsic_EZip: () => Application_Vendor_EtsiAsic_EZip,
  Application_Vendor_EtsiAsic_SZip: () => Application_Vendor_EtsiAsic_SZip,
  Application_Vendor_EtsiCugXml: () => Application_Vendor_EtsiCugXml,
  Application_Vendor_EtsiIptvcommandXml: () => Application_Vendor_EtsiIptvcommandXml,
  Application_Vendor_EtsiIptvdiscoveryXml: () => Application_Vendor_EtsiIptvdiscoveryXml,
  Application_Vendor_EtsiIptvprofileXml: () => Application_Vendor_EtsiIptvprofileXml,
  Application_Vendor_EtsiIptvsad_BcXml: () => Application_Vendor_EtsiIptvsad_BcXml,
  Application_Vendor_EtsiIptvsad_CodXml: () => Application_Vendor_EtsiIptvsad_CodXml,
  Application_Vendor_EtsiIptvsad_NpvrXml: () => Application_Vendor_EtsiIptvsad_NpvrXml,
  Application_Vendor_EtsiIptvserviceXml: () => Application_Vendor_EtsiIptvserviceXml,
  Application_Vendor_EtsiIptvsyncXml: () => Application_Vendor_EtsiIptvsyncXml,
  Application_Vendor_EtsiIptvueprofileXml: () => Application_Vendor_EtsiIptvueprofileXml,
  Application_Vendor_EtsiMcidXml: () => Application_Vendor_EtsiMcidXml,
  Application_Vendor_EtsiMheg5: () => Application_Vendor_EtsiMheg5,
  Application_Vendor_EtsiOverload_Control_Policy_DatasetXml: () => Application_Vendor_EtsiOverload_Control_Policy_DatasetXml,
  Application_Vendor_EtsiPstnXml: () => Application_Vendor_EtsiPstnXml,
  Application_Vendor_EtsiSciXml: () => Application_Vendor_EtsiSciXml,
  Application_Vendor_EtsiSimservsXml: () => Application_Vendor_EtsiSimservsXml,
  Application_Vendor_EtsiTimestamp_Token: () => Application_Vendor_EtsiTimestamp_Token,
  Application_Vendor_EtsiTslDer: () => Application_Vendor_EtsiTslDer,
  Application_Vendor_EtsiTslXml: () => Application_Vendor_EtsiTslXml,
  Application_Vendor_EudoraData: () => Application_Vendor_EudoraData,
  Application_Vendor_EvolvEcigProfile: () => Application_Vendor_EvolvEcigProfile,
  Application_Vendor_EvolvEcigSettings: () => Application_Vendor_EvolvEcigSettings,
  Application_Vendor_EvolvEcigTheme: () => Application_Vendor_EvolvEcigTheme,
  Application_Vendor_Exstream_EmpowerZip: () => Application_Vendor_Exstream_EmpowerZip,
  Application_Vendor_Exstream_Package: () => Application_Vendor_Exstream_Package,
  Application_Vendor_Ezpix_Album: () => Application_Vendor_Ezpix_Album,
  Application_Vendor_Ezpix_Package: () => Application_Vendor_Ezpix_Package,
  Application_Vendor_F_SecureMobile: () => Application_Vendor_F_SecureMobile,
  Application_Vendor_Fastcopy_Disk_Image: () => Application_Vendor_Fastcopy_Disk_Image,
  Application_Vendor_Fdf: () => Application_Vendor_Fdf,
  Application_Vendor_FdsnMseed: () => Application_Vendor_FdsnMseed,
  Application_Vendor_FdsnSeed: () => Application_Vendor_FdsnSeed,
  Application_Vendor_Ffsns: () => Application_Vendor_Ffsns,
  Application_Vendor_FiclabFlbZip: () => Application_Vendor_FiclabFlbZip,
  Application_Vendor_FilmitZfc: () => Application_Vendor_FilmitZfc,
  Application_Vendor_Fints: () => Application_Vendor_Fints,
  Application_Vendor_FiremonkeysCloudcell: () => Application_Vendor_FiremonkeysCloudcell,
  Application_Vendor_FloGraphIt: () => Application_Vendor_FloGraphIt,
  Application_Vendor_FluxtimeClip: () => Application_Vendor_FluxtimeClip,
  Application_Vendor_Font_Fontforge_Sfd: () => Application_Vendor_Font_Fontforge_Sfd,
  Application_Vendor_Framemaker: () => Application_Vendor_Framemaker,
  Application_Vendor_FrogansFnc: () => Application_Vendor_FrogansFnc,
  Application_Vendor_FrogansLtf: () => Application_Vendor_FrogansLtf,
  Application_Vendor_FscWeblaunch: () => Application_Vendor_FscWeblaunch,
  Application_Vendor_FujitsuOasys: () => Application_Vendor_FujitsuOasys,
  Application_Vendor_FujitsuOasys2: () => Application_Vendor_FujitsuOasys2,
  Application_Vendor_FujitsuOasys3: () => Application_Vendor_FujitsuOasys3,
  Application_Vendor_FujitsuOasysgp: () => Application_Vendor_FujitsuOasysgp,
  Application_Vendor_FujitsuOasysprs: () => Application_Vendor_FujitsuOasysprs,
  Application_Vendor_FujixeroxART4: () => Application_Vendor_FujixeroxART4,
  Application_Vendor_FujixeroxART_EX: () => Application_Vendor_FujixeroxART_EX,
  Application_Vendor_FujixeroxDdd: () => Application_Vendor_FujixeroxDdd,
  Application_Vendor_FujixeroxDocuworks: () => Application_Vendor_FujixeroxDocuworks,
  Application_Vendor_FujixeroxDocuworksBinder: () => Application_Vendor_FujixeroxDocuworksBinder,
  Application_Vendor_FujixeroxDocuworksContainer: () => Application_Vendor_FujixeroxDocuworksContainer,
  Application_Vendor_FujixeroxHBPL: () => Application_Vendor_FujixeroxHBPL,
  Application_Vendor_Fut_Misnet: () => Application_Vendor_Fut_Misnet,
  Application_Vendor_FutoinCbor: () => Application_Vendor_FutoinCbor,
  Application_Vendor_FutoinJson: () => Application_Vendor_FutoinJson,
  Application_Vendor_Fuzzysheet: () => Application_Vendor_Fuzzysheet,
  Application_Vendor_GenomatixTuxedo: () => Application_Vendor_GenomatixTuxedo,
  Application_Vendor_GenticsGrdJson: () => Application_Vendor_GenticsGrdJson,
  Application_Vendor_GeoJson: () => Application_Vendor_GeoJson,
  Application_Vendor_GeocubeXml: () => Application_Vendor_GeocubeXml,
  Application_Vendor_GeogebraFile: () => Application_Vendor_GeogebraFile,
  Application_Vendor_GeogebraTool: () => Application_Vendor_GeogebraTool,
  Application_Vendor_Geometry_Explorer: () => Application_Vendor_Geometry_Explorer,
  Application_Vendor_Geonext: () => Application_Vendor_Geonext,
  Application_Vendor_Geoplan: () => Application_Vendor_Geoplan,
  Application_Vendor_Geospace: () => Application_Vendor_Geospace,
  Application_Vendor_Gerber: () => Application_Vendor_Gerber,
  Application_Vendor_GlobalplatformCard_Content_Mgt: () => Application_Vendor_GlobalplatformCard_Content_Mgt,
  Application_Vendor_GlobalplatformCard_Content_Mgt_Response: () => Application_Vendor_GlobalplatformCard_Content_Mgt_Response,
  Application_Vendor_Gmx: () => Application_Vendor_Gmx,
  Application_Vendor_Google_Apps_Document: () => Application_Vendor_Google_Apps_Document,
  Application_Vendor_Google_Apps_Presentation: () => Application_Vendor_Google_Apps_Presentation,
  Application_Vendor_Google_Apps_Spreadsheet: () => Application_Vendor_Google_Apps_Spreadsheet,
  Application_Vendor_Google_EarthKmlXml: () => Application_Vendor_Google_EarthKmlXml,
  Application_Vendor_Google_EarthKmz: () => Application_Vendor_Google_EarthKmz,
  Application_Vendor_GovSkE_FormXml: () => Application_Vendor_GovSkE_FormXml,
  Application_Vendor_GovSkE_FormZip: () => Application_Vendor_GovSkE_FormZip,
  Application_Vendor_GovSkXmldatacontainerXml: () => Application_Vendor_GovSkXmldatacontainerXml,
  Application_Vendor_Grafeq: () => Application_Vendor_Grafeq,
  Application_Vendor_Gridmp: () => Application_Vendor_Gridmp,
  Application_Vendor_Groove_Account: () => Application_Vendor_Groove_Account,
  Application_Vendor_Groove_Help: () => Application_Vendor_Groove_Help,
  Application_Vendor_Groove_Identity_Message: () => Application_Vendor_Groove_Identity_Message,
  Application_Vendor_Groove_Injector: () => Application_Vendor_Groove_Injector,
  Application_Vendor_Groove_Tool_Message: () => Application_Vendor_Groove_Tool_Message,
  Application_Vendor_Groove_Tool_Template: () => Application_Vendor_Groove_Tool_Template,
  Application_Vendor_Groove_Vcard: () => Application_Vendor_Groove_Vcard,
  Application_Vendor_HalJson: () => Application_Vendor_HalJson,
  Application_Vendor_HalXml: () => Application_Vendor_HalXml,
  Application_Vendor_HandHeld_EntertainmentXml: () => Application_Vendor_HandHeld_EntertainmentXml,
  Application_Vendor_Hbci: () => Application_Vendor_Hbci,
  Application_Vendor_HcJson: () => Application_Vendor_HcJson,
  Application_Vendor_Hcl_Bireports: () => Application_Vendor_Hcl_Bireports,
  Application_Vendor_Hdt: () => Application_Vendor_Hdt,
  Application_Vendor_HerokuJson: () => Application_Vendor_HerokuJson,
  Application_Vendor_HheLesson_Player: () => Application_Vendor_HheLesson_Player,
  Application_Vendor_Hp_HPGL: () => Application_Vendor_Hp_HPGL,
  Application_Vendor_Hp_Hpid: () => Application_Vendor_Hp_Hpid,
  Application_Vendor_Hp_Hps: () => Application_Vendor_Hp_Hps,
  Application_Vendor_Hp_Jlyt: () => Application_Vendor_Hp_Jlyt,
  Application_Vendor_Hp_PCL: () => Application_Vendor_Hp_PCL,
  Application_Vendor_Hp_PCLXL: () => Application_Vendor_Hp_PCLXL,
  Application_Vendor_Httphone: () => Application_Vendor_Httphone,
  Application_Vendor_HydrostatixSof_Data: () => Application_Vendor_HydrostatixSof_Data,
  Application_Vendor_HyperJson: () => Application_Vendor_HyperJson,
  Application_Vendor_Hyper_ItemJson: () => Application_Vendor_Hyper_ItemJson,
  Application_Vendor_HyperdriveJson: () => Application_Vendor_HyperdriveJson,
  Application_Vendor_Hzn_3d_Crossword: () => Application_Vendor_Hzn_3d_Crossword,
  Application_Vendor_IbmAfplinedata: () => Application_Vendor_IbmAfplinedata,
  Application_Vendor_IbmElectronic_Media: () => Application_Vendor_IbmElectronic_Media,
  Application_Vendor_IbmMiniPay: () => Application_Vendor_IbmMiniPay,
  Application_Vendor_IbmModcap: () => Application_Vendor_IbmModcap,
  Application_Vendor_IbmRights_Management: () => Application_Vendor_IbmRights_Management,
  Application_Vendor_IbmSecure_Container: () => Application_Vendor_IbmSecure_Container,
  Application_Vendor_Iccprofile: () => Application_Vendor_Iccprofile,
  Application_Vendor_Ieee1905: () => Application_Vendor_Ieee1905,
  Application_Vendor_Igloader: () => Application_Vendor_Igloader,
  Application_Vendor_ImagemeterFolderZip: () => Application_Vendor_ImagemeterFolderZip,
  Application_Vendor_ImagemeterImageZip: () => Application_Vendor_ImagemeterImageZip,
  Application_Vendor_Immervision_Ivp: () => Application_Vendor_Immervision_Ivp,
  Application_Vendor_Immervision_Ivu: () => Application_Vendor_Immervision_Ivu,
  Application_Vendor_ImsImsccv1p1: () => Application_Vendor_ImsImsccv1p1,
  Application_Vendor_ImsImsccv1p2: () => Application_Vendor_ImsImsccv1p2,
  Application_Vendor_ImsImsccv1p3: () => Application_Vendor_ImsImsccv1p3,
  Application_Vendor_ImsLisV2ResultJson: () => Application_Vendor_ImsLisV2ResultJson,
  Application_Vendor_ImsLtiV2ToolconsumerprofileJson: () => Application_Vendor_ImsLtiV2ToolconsumerprofileJson,
  Application_Vendor_ImsLtiV2ToolproxyIdJson: () => Application_Vendor_ImsLtiV2ToolproxyIdJson,
  Application_Vendor_ImsLtiV2ToolproxyJson: () => Application_Vendor_ImsLtiV2ToolproxyJson,
  Application_Vendor_ImsLtiV2ToolsettingsJson: () => Application_Vendor_ImsLtiV2ToolsettingsJson,
  Application_Vendor_ImsLtiV2ToolsettingsSimpleJson: () => Application_Vendor_ImsLtiV2ToolsettingsSimpleJson,
  Application_Vendor_InformedcontrolRmsXml: () => Application_Vendor_InformedcontrolRmsXml,
  Application_Vendor_Informix_Visionary: () => Application_Vendor_Informix_Visionary,
  Application_Vendor_InfotechProject: () => Application_Vendor_InfotechProject,
  Application_Vendor_InfotechProjectXml: () => Application_Vendor_InfotechProjectXml,
  Application_Vendor_InnopathWampNotification: () => Application_Vendor_InnopathWampNotification,
  Application_Vendor_InsorsIgm: () => Application_Vendor_InsorsIgm,
  Application_Vendor_InterconFormnet: () => Application_Vendor_InterconFormnet,
  Application_Vendor_Intergeo: () => Application_Vendor_Intergeo,
  Application_Vendor_IntertrustDigibox: () => Application_Vendor_IntertrustDigibox,
  Application_Vendor_IntertrustNncp: () => Application_Vendor_IntertrustNncp,
  Application_Vendor_IntuQbo: () => Application_Vendor_IntuQbo,
  Application_Vendor_IntuQfx: () => Application_Vendor_IntuQfx,
  Application_Vendor_IptcG2CatalogitemXml: () => Application_Vendor_IptcG2CatalogitemXml,
  Application_Vendor_IptcG2ConceptitemXml: () => Application_Vendor_IptcG2ConceptitemXml,
  Application_Vendor_IptcG2KnowledgeitemXml: () => Application_Vendor_IptcG2KnowledgeitemXml,
  Application_Vendor_IptcG2NewsitemXml: () => Application_Vendor_IptcG2NewsitemXml,
  Application_Vendor_IptcG2NewsmessageXml: () => Application_Vendor_IptcG2NewsmessageXml,
  Application_Vendor_IptcG2PackageitemXml: () => Application_Vendor_IptcG2PackageitemXml,
  Application_Vendor_IptcG2PlanningitemXml: () => Application_Vendor_IptcG2PlanningitemXml,
  Application_Vendor_IpunpluggedRcprofile: () => Application_Vendor_IpunpluggedRcprofile,
  Application_Vendor_IrepositoryPackageXml: () => Application_Vendor_IrepositoryPackageXml,
  Application_Vendor_Is_Xpr: () => Application_Vendor_Is_Xpr,
  Application_Vendor_IsacFcs: () => Application_Vendor_IsacFcs,
  Application_Vendor_Iso11783_10Zip: () => Application_Vendor_Iso11783_10Zip,
  Application_Vendor_Jam: () => Application_Vendor_Jam,
  Application_Vendor_Japannet_Directory_Service: () => Application_Vendor_Japannet_Directory_Service,
  Application_Vendor_Japannet_Jpnstore_Wakeup: () => Application_Vendor_Japannet_Jpnstore_Wakeup,
  Application_Vendor_Japannet_Payment_Wakeup: () => Application_Vendor_Japannet_Payment_Wakeup,
  Application_Vendor_Japannet_Registration: () => Application_Vendor_Japannet_Registration,
  Application_Vendor_Japannet_Registration_Wakeup: () => Application_Vendor_Japannet_Registration_Wakeup,
  Application_Vendor_Japannet_Setstore_Wakeup: () => Application_Vendor_Japannet_Setstore_Wakeup,
  Application_Vendor_Japannet_Verification: () => Application_Vendor_Japannet_Verification,
  Application_Vendor_Japannet_Verification_Wakeup: () => Application_Vendor_Japannet_Verification_Wakeup,
  Application_Vendor_JcpJavameMidlet_Rms: () => Application_Vendor_JcpJavameMidlet_Rms,
  Application_Vendor_Jisp: () => Application_Vendor_Jisp,
  Application_Vendor_JoostJoda_Archive: () => Application_Vendor_JoostJoda_Archive,
  Application_Vendor_JskIsdn_Ngn: () => Application_Vendor_JskIsdn_Ngn,
  Application_Vendor_Kahootz: () => Application_Vendor_Kahootz,
  Application_Vendor_KdeKarbon: () => Application_Vendor_KdeKarbon,
  Application_Vendor_KdeKchart: () => Application_Vendor_KdeKchart,
  Application_Vendor_KdeKformula: () => Application_Vendor_KdeKformula,
  Application_Vendor_KdeKivio: () => Application_Vendor_KdeKivio,
  Application_Vendor_KdeKontour: () => Application_Vendor_KdeKontour,
  Application_Vendor_KdeKpresenter: () => Application_Vendor_KdeKpresenter,
  Application_Vendor_KdeKspread: () => Application_Vendor_KdeKspread,
  Application_Vendor_KdeKword: () => Application_Vendor_KdeKword,
  Application_Vendor_Kenameaapp: () => Application_Vendor_Kenameaapp,
  Application_Vendor_Kidspiration: () => Application_Vendor_Kidspiration,
  Application_Vendor_Kinar: () => Application_Vendor_Kinar,
  Application_Vendor_Koan: () => Application_Vendor_Koan,
  Application_Vendor_Kodak_Descriptor: () => Application_Vendor_Kodak_Descriptor,
  Application_Vendor_Las: () => Application_Vendor_Las,
  Application_Vendor_LasLasJson: () => Application_Vendor_LasLasJson,
  Application_Vendor_LasLasXml: () => Application_Vendor_LasLasXml,
  Application_Vendor_Laszip: () => Application_Vendor_Laszip,
  Application_Vendor_LeapJson: () => Application_Vendor_LeapJson,
  Application_Vendor_Liberty_RequestXml: () => Application_Vendor_Liberty_RequestXml,
  Application_Vendor_LlamagraphicsLife_BalanceDesktop: () => Application_Vendor_LlamagraphicsLife_BalanceDesktop,
  Application_Vendor_LlamagraphicsLife_BalanceExchangeXml: () => Application_Vendor_LlamagraphicsLife_BalanceExchangeXml,
  Application_Vendor_LogipipeCircuitZip: () => Application_Vendor_LogipipeCircuitZip,
  Application_Vendor_Loom: () => Application_Vendor_Loom,
  Application_Vendor_Lotus_1_2_3: () => Application_Vendor_Lotus_1_2_3,
  Application_Vendor_Lotus_Approach: () => Application_Vendor_Lotus_Approach,
  Application_Vendor_Lotus_Freelance: () => Application_Vendor_Lotus_Freelance,
  Application_Vendor_Lotus_Notes: () => Application_Vendor_Lotus_Notes,
  Application_Vendor_Lotus_Organizer: () => Application_Vendor_Lotus_Organizer,
  Application_Vendor_Lotus_Screencam: () => Application_Vendor_Lotus_Screencam,
  Application_Vendor_Lotus_Wordpro: () => Application_Vendor_Lotus_Wordpro,
  Application_Vendor_MFER: () => Application_Vendor_MFER,
  Application_Vendor_MacportsPortpkg: () => Application_Vendor_MacportsPortpkg,
  Application_Vendor_Mapbox_Vector_Tile: () => Application_Vendor_Mapbox_Vector_Tile,
  Application_Vendor_MarlinDrmActiontokenXml: () => Application_Vendor_MarlinDrmActiontokenXml,
  Application_Vendor_MarlinDrmConftokenXml: () => Application_Vendor_MarlinDrmConftokenXml,
  Application_Vendor_MarlinDrmLicenseXml: () => Application_Vendor_MarlinDrmLicenseXml,
  Application_Vendor_MarlinDrmMdcf: () => Application_Vendor_MarlinDrmMdcf,
  Application_Vendor_MasonJson: () => Application_Vendor_MasonJson,
  Application_Vendor_MaxmindMaxmind_Db: () => Application_Vendor_MaxmindMaxmind_Db,
  Application_Vendor_Mcd: () => Application_Vendor_Mcd,
  Application_Vendor_Medcalcdata: () => Application_Vendor_Medcalcdata,
  Application_Vendor_MediastationCdkey: () => Application_Vendor_MediastationCdkey,
  Application_Vendor_Meridian_Slingshot: () => Application_Vendor_Meridian_Slingshot,
  Application_Vendor_Mfmp: () => Application_Vendor_Mfmp,
  Application_Vendor_MicroJson: () => Application_Vendor_MicroJson,
  Application_Vendor_MicrografxFlo: () => Application_Vendor_MicrografxFlo,
  Application_Vendor_MicrografxIgx: () => Application_Vendor_MicrografxIgx,
  Application_Vendor_MicrosoftPortable_Executable: () => Application_Vendor_MicrosoftPortable_Executable,
  Application_Vendor_MicrosoftWindowsThumbnail_Cache: () => Application_Vendor_MicrosoftWindowsThumbnail_Cache,
  Application_Vendor_MieleJson: () => Application_Vendor_MieleJson,
  Application_Vendor_Mif: () => Application_Vendor_Mif,
  Application_Vendor_Minisoft_Hp3000_Save: () => Application_Vendor_Minisoft_Hp3000_Save,
  Application_Vendor_MitsubishiMisty_GuardTrustweb: () => Application_Vendor_MitsubishiMisty_GuardTrustweb,
  Application_Vendor_MobiusDAF: () => Application_Vendor_MobiusDAF,
  Application_Vendor_MobiusDIS: () => Application_Vendor_MobiusDIS,
  Application_Vendor_MobiusMBK: () => Application_Vendor_MobiusMBK,
  Application_Vendor_MobiusMQY: () => Application_Vendor_MobiusMQY,
  Application_Vendor_MobiusMSL: () => Application_Vendor_MobiusMSL,
  Application_Vendor_MobiusPLC: () => Application_Vendor_MobiusPLC,
  Application_Vendor_MobiusTXF: () => Application_Vendor_MobiusTXF,
  Application_Vendor_MophunApplication: () => Application_Vendor_MophunApplication,
  Application_Vendor_MophunCertificate: () => Application_Vendor_MophunCertificate,
  Application_Vendor_MotorolaFlexsuite: () => Application_Vendor_MotorolaFlexsuite,
  Application_Vendor_MotorolaFlexsuiteAdsi: () => Application_Vendor_MotorolaFlexsuiteAdsi,
  Application_Vendor_MotorolaFlexsuiteFis: () => Application_Vendor_MotorolaFlexsuiteFis,
  Application_Vendor_MotorolaFlexsuiteGotap: () => Application_Vendor_MotorolaFlexsuiteGotap,
  Application_Vendor_MotorolaFlexsuiteKmr: () => Application_Vendor_MotorolaFlexsuiteKmr,
  Application_Vendor_MotorolaFlexsuiteTtc: () => Application_Vendor_MotorolaFlexsuiteTtc,
  Application_Vendor_MotorolaFlexsuiteWem: () => Application_Vendor_MotorolaFlexsuiteWem,
  Application_Vendor_MotorolaIprm: () => Application_Vendor_MotorolaIprm,
  Application_Vendor_MozillaXulXml: () => Application_Vendor_MozillaXulXml,
  Application_Vendor_Ms_3mfdocument: () => Application_Vendor_Ms_3mfdocument,
  Application_Vendor_Ms_Artgalry: () => Application_Vendor_Ms_Artgalry,
  Application_Vendor_Ms_Asf: () => Application_Vendor_Ms_Asf,
  Application_Vendor_Ms_Cab_Compressed: () => Application_Vendor_Ms_Cab_Compressed,
  Application_Vendor_Ms_ColorIccprofile: () => Application_Vendor_Ms_ColorIccprofile,
  Application_Vendor_Ms_Excel: () => Application_Vendor_Ms_Excel,
  Application_Vendor_Ms_ExcelAddinMacroEnabled12: () => Application_Vendor_Ms_ExcelAddinMacroEnabled12,
  Application_Vendor_Ms_ExcelSheetBinaryMacroEnabled12: () => Application_Vendor_Ms_ExcelSheetBinaryMacroEnabled12,
  Application_Vendor_Ms_ExcelSheetMacroEnabled12: () => Application_Vendor_Ms_ExcelSheetMacroEnabled12,
  Application_Vendor_Ms_ExcelTemplateMacroEnabled12: () => Application_Vendor_Ms_ExcelTemplateMacroEnabled12,
  Application_Vendor_Ms_Fontobject: () => Application_Vendor_Ms_Fontobject,
  Application_Vendor_Ms_Htmlhelp: () => Application_Vendor_Ms_Htmlhelp,
  Application_Vendor_Ms_Ims: () => Application_Vendor_Ms_Ims,
  Application_Vendor_Ms_Lrm: () => Application_Vendor_Ms_Lrm,
  Application_Vendor_Ms_OfficeActiveXXml: () => Application_Vendor_Ms_OfficeActiveXXml,
  Application_Vendor_Ms_Officetheme: () => Application_Vendor_Ms_Officetheme,
  Application_Vendor_Ms_Opentype: () => Application_Vendor_Ms_Opentype,
  Application_Vendor_Ms_Outlook: () => Application_Vendor_Ms_Outlook,
  Application_Vendor_Ms_PackageObfuscated_Opentype: () => Application_Vendor_Ms_PackageObfuscated_Opentype,
  Application_Vendor_Ms_PkiSeccat: () => Application_Vendor_Ms_PkiSeccat,
  Application_Vendor_Ms_PkiStl: () => Application_Vendor_Ms_PkiStl,
  Application_Vendor_Ms_PlayreadyInitiatorXml: () => Application_Vendor_Ms_PlayreadyInitiatorXml,
  Application_Vendor_Ms_Powerpoint: () => Application_Vendor_Ms_Powerpoint,
  Application_Vendor_Ms_PowerpointAddinMacroEnabled12: () => Application_Vendor_Ms_PowerpointAddinMacroEnabled12,
  Application_Vendor_Ms_PowerpointPresentationMacroEnabled12: () => Application_Vendor_Ms_PowerpointPresentationMacroEnabled12,
  Application_Vendor_Ms_PowerpointSlideMacroEnabled12: () => Application_Vendor_Ms_PowerpointSlideMacroEnabled12,
  Application_Vendor_Ms_PowerpointSlideshowMacroEnabled12: () => Application_Vendor_Ms_PowerpointSlideshowMacroEnabled12,
  Application_Vendor_Ms_PowerpointTemplateMacroEnabled12: () => Application_Vendor_Ms_PowerpointTemplateMacroEnabled12,
  Application_Vendor_Ms_PrintDeviceCapabilitiesXml: () => Application_Vendor_Ms_PrintDeviceCapabilitiesXml,
  Application_Vendor_Ms_PrintSchemaTicketXml: () => Application_Vendor_Ms_PrintSchemaTicketXml,
  Application_Vendor_Ms_PrintingPrintticketXml: () => Application_Vendor_Ms_PrintingPrintticketXml,
  Application_Vendor_Ms_Project: () => Application_Vendor_Ms_Project,
  Application_Vendor_Ms_Tnef: () => Application_Vendor_Ms_Tnef,
  Application_Vendor_Ms_WindowsDevicepairing: () => Application_Vendor_Ms_WindowsDevicepairing,
  Application_Vendor_Ms_WindowsNwprintingOob: () => Application_Vendor_Ms_WindowsNwprintingOob,
  Application_Vendor_Ms_WindowsPrinterpairing: () => Application_Vendor_Ms_WindowsPrinterpairing,
  Application_Vendor_Ms_WindowsWsdOob: () => Application_Vendor_Ms_WindowsWsdOob,
  Application_Vendor_Ms_WmdrmLic_Chlg_Req: () => Application_Vendor_Ms_WmdrmLic_Chlg_Req,
  Application_Vendor_Ms_WmdrmLic_Resp: () => Application_Vendor_Ms_WmdrmLic_Resp,
  Application_Vendor_Ms_WmdrmMeter_Chlg_Req: () => Application_Vendor_Ms_WmdrmMeter_Chlg_Req,
  Application_Vendor_Ms_WmdrmMeter_Resp: () => Application_Vendor_Ms_WmdrmMeter_Resp,
  Application_Vendor_Ms_WordDocumentMacroEnabled12: () => Application_Vendor_Ms_WordDocumentMacroEnabled12,
  Application_Vendor_Ms_WordTemplateMacroEnabled12: () => Application_Vendor_Ms_WordTemplateMacroEnabled12,
  Application_Vendor_Ms_Works: () => Application_Vendor_Ms_Works,
  Application_Vendor_Ms_Wpl: () => Application_Vendor_Ms_Wpl,
  Application_Vendor_Ms_Xpsdocument: () => Application_Vendor_Ms_Xpsdocument,
  Application_Vendor_Msa_Disk_Image: () => Application_Vendor_Msa_Disk_Image,
  Application_Vendor_Mseq: () => Application_Vendor_Mseq,
  Application_Vendor_Msign: () => Application_Vendor_Msign,
  Application_Vendor_MultiadCreator: () => Application_Vendor_MultiadCreator,
  Application_Vendor_MultiadCreatorCif: () => Application_Vendor_MultiadCreatorCif,
  Application_Vendor_Music_Niff: () => Application_Vendor_Music_Niff,
  Application_Vendor_Musician: () => Application_Vendor_Musician,
  Application_Vendor_MuveeStyle: () => Application_Vendor_MuveeStyle,
  Application_Vendor_Mynfc: () => Application_Vendor_Mynfc,
  Application_Vendor_NcdControl: () => Application_Vendor_NcdControl,
  Application_Vendor_NcdReference: () => Application_Vendor_NcdReference,
  Application_Vendor_NearstInvJson: () => Application_Vendor_NearstInvJson,
  Application_Vendor_Nervana: () => Application_Vendor_Nervana,
  Application_Vendor_Netfpx: () => Application_Vendor_Netfpx,
  Application_Vendor_NeurolanguageNlu: () => Application_Vendor_NeurolanguageNlu,
  Application_Vendor_Nimn: () => Application_Vendor_Nimn,
  Application_Vendor_NintendoNitroRom: () => Application_Vendor_NintendoNitroRom,
  Application_Vendor_NintendoSnesRom: () => Application_Vendor_NintendoSnesRom,
  Application_Vendor_Nitf: () => Application_Vendor_Nitf,
  Application_Vendor_Noblenet_Directory: () => Application_Vendor_Noblenet_Directory,
  Application_Vendor_Noblenet_Sealer: () => Application_Vendor_Noblenet_Sealer,
  Application_Vendor_Noblenet_Web: () => Application_Vendor_Noblenet_Web,
  Application_Vendor_NokiaCatalogs: () => Application_Vendor_NokiaCatalogs,
  Application_Vendor_NokiaConmlWbxml: () => Application_Vendor_NokiaConmlWbxml,
  Application_Vendor_NokiaConmlXml: () => Application_Vendor_NokiaConmlXml,
  Application_Vendor_NokiaISDS_Radio_Presets: () => Application_Vendor_NokiaISDS_Radio_Presets,
  Application_Vendor_NokiaIptvConfigXml: () => Application_Vendor_NokiaIptvConfigXml,
  Application_Vendor_NokiaLandmarkWbxml: () => Application_Vendor_NokiaLandmarkWbxml,
  Application_Vendor_NokiaLandmarkXml: () => Application_Vendor_NokiaLandmarkXml,
  Application_Vendor_NokiaLandmarkcollectionXml: () => Application_Vendor_NokiaLandmarkcollectionXml,
  Application_Vendor_NokiaN_GageAcXml: () => Application_Vendor_NokiaN_GageAcXml,
  Application_Vendor_NokiaN_GageData: () => Application_Vendor_NokiaN_GageData,
  Application_Vendor_NokiaN_GageSymbianInstall: () => Application_Vendor_NokiaN_GageSymbianInstall,
  Application_Vendor_NokiaNcd: () => Application_Vendor_NokiaNcd,
  Application_Vendor_NokiaPcdWbxml: () => Application_Vendor_NokiaPcdWbxml,
  Application_Vendor_NokiaPcdXml: () => Application_Vendor_NokiaPcdXml,
  Application_Vendor_NokiaRadio_Preset: () => Application_Vendor_NokiaRadio_Preset,
  Application_Vendor_NokiaRadio_Presets: () => Application_Vendor_NokiaRadio_Presets,
  Application_Vendor_NovadigmEDM: () => Application_Vendor_NovadigmEDM,
  Application_Vendor_NovadigmEDX: () => Application_Vendor_NovadigmEDX,
  Application_Vendor_NovadigmEXT: () => Application_Vendor_NovadigmEXT,
  Application_Vendor_Ntt_LocalContent_Share: () => Application_Vendor_Ntt_LocalContent_Share,
  Application_Vendor_Ntt_LocalFile_Transfer: () => Application_Vendor_Ntt_LocalFile_Transfer,
  Application_Vendor_Ntt_LocalOgw_remote_Access: () => Application_Vendor_Ntt_LocalOgw_remote_Access,
  Application_Vendor_Ntt_LocalSip_Ta_remote: () => Application_Vendor_Ntt_LocalSip_Ta_remote,
  Application_Vendor_Ntt_LocalSip_Ta_tcp_stream: () => Application_Vendor_Ntt_LocalSip_Ta_tcp_stream,
  Application_Vendor_OasisOpendocumentChart: () => Application_Vendor_OasisOpendocumentChart,
  Application_Vendor_OasisOpendocumentChart_Template: () => Application_Vendor_OasisOpendocumentChart_Template,
  Application_Vendor_OasisOpendocumentDatabase: () => Application_Vendor_OasisOpendocumentDatabase,
  Application_Vendor_OasisOpendocumentFormula: () => Application_Vendor_OasisOpendocumentFormula,
  Application_Vendor_OasisOpendocumentFormula_Template: () => Application_Vendor_OasisOpendocumentFormula_Template,
  Application_Vendor_OasisOpendocumentGraphics: () => Application_Vendor_OasisOpendocumentGraphics,
  Application_Vendor_OasisOpendocumentGraphics_Template: () => Application_Vendor_OasisOpendocumentGraphics_Template,
  Application_Vendor_OasisOpendocumentImage: () => Application_Vendor_OasisOpendocumentImage,
  Application_Vendor_OasisOpendocumentImage_Template: () => Application_Vendor_OasisOpendocumentImage_Template,
  Application_Vendor_OasisOpendocumentPresentation: () => Application_Vendor_OasisOpendocumentPresentation,
  Application_Vendor_OasisOpendocumentPresentation_Template: () => Application_Vendor_OasisOpendocumentPresentation_Template,
  Application_Vendor_OasisOpendocumentSpreadsheet: () => Application_Vendor_OasisOpendocumentSpreadsheet,
  Application_Vendor_OasisOpendocumentSpreadsheet_Template: () => Application_Vendor_OasisOpendocumentSpreadsheet_Template,
  Application_Vendor_OasisOpendocumentText: () => Application_Vendor_OasisOpendocumentText,
  Application_Vendor_OasisOpendocumentText_Master: () => Application_Vendor_OasisOpendocumentText_Master,
  Application_Vendor_OasisOpendocumentText_Template: () => Application_Vendor_OasisOpendocumentText_Template,
  Application_Vendor_OasisOpendocumentText_Web: () => Application_Vendor_OasisOpendocumentText_Web,
  Application_Vendor_Obn: () => Application_Vendor_Obn,
  Application_Vendor_OcfCbor: () => Application_Vendor_OcfCbor,
  Application_Vendor_OftnL10nJson: () => Application_Vendor_OftnL10nJson,
  Application_Vendor_OipfContentaccessdownloadXml: () => Application_Vendor_OipfContentaccessdownloadXml,
  Application_Vendor_OipfContentaccessstreamingXml: () => Application_Vendor_OipfContentaccessstreamingXml,
  Application_Vendor_OipfCspg_Hexbinary: () => Application_Vendor_OipfCspg_Hexbinary,
  Application_Vendor_OipfDaeSvgXml: () => Application_Vendor_OipfDaeSvgXml,
  Application_Vendor_OipfDaeXhtmlXml: () => Application_Vendor_OipfDaeXhtmlXml,
  Application_Vendor_OipfMippvcontrolmessageXml: () => Application_Vendor_OipfMippvcontrolmessageXml,
  Application_Vendor_OipfPaeGem: () => Application_Vendor_OipfPaeGem,
  Application_Vendor_OipfSpdiscoveryXml: () => Application_Vendor_OipfSpdiscoveryXml,
  Application_Vendor_OipfSpdlistXml: () => Application_Vendor_OipfSpdlistXml,
  Application_Vendor_OipfUeprofileXml: () => Application_Vendor_OipfUeprofileXml,
  Application_Vendor_OipfUserprofileXml: () => Application_Vendor_OipfUserprofileXml,
  Application_Vendor_Olpc_Sugar: () => Application_Vendor_Olpc_Sugar,
  Application_Vendor_OmaBcastAssociated_Procedure_ParameterXml: () => Application_Vendor_OmaBcastAssociated_Procedure_ParameterXml,
  Application_Vendor_OmaBcastDrm_TriggerXml: () => Application_Vendor_OmaBcastDrm_TriggerXml,
  Application_Vendor_OmaBcastImdXml: () => Application_Vendor_OmaBcastImdXml,
  Application_Vendor_OmaBcastLtkm: () => Application_Vendor_OmaBcastLtkm,
  Application_Vendor_OmaBcastNotificationXml: () => Application_Vendor_OmaBcastNotificationXml,
  Application_Vendor_OmaBcastProvisioningtrigger: () => Application_Vendor_OmaBcastProvisioningtrigger,
  Application_Vendor_OmaBcastSgboot: () => Application_Vendor_OmaBcastSgboot,
  Application_Vendor_OmaBcastSgddXml: () => Application_Vendor_OmaBcastSgddXml,
  Application_Vendor_OmaBcastSgdu: () => Application_Vendor_OmaBcastSgdu,
  Application_Vendor_OmaBcastSimple_Symbol_Container: () => Application_Vendor_OmaBcastSimple_Symbol_Container,
  Application_Vendor_OmaBcastSmartcard_TriggerXml: () => Application_Vendor_OmaBcastSmartcard_TriggerXml,
  Application_Vendor_OmaBcastSprovXml: () => Application_Vendor_OmaBcastSprovXml,
  Application_Vendor_OmaBcastStkm: () => Application_Vendor_OmaBcastStkm,
  Application_Vendor_OmaCab_Address_BookXml: () => Application_Vendor_OmaCab_Address_BookXml,
  Application_Vendor_OmaCab_Feature_HandlerXml: () => Application_Vendor_OmaCab_Feature_HandlerXml,
  Application_Vendor_OmaCab_PccXml: () => Application_Vendor_OmaCab_PccXml,
  Application_Vendor_OmaCab_Subs_InviteXml: () => Application_Vendor_OmaCab_Subs_InviteXml,
  Application_Vendor_OmaCab_User_PrefsXml: () => Application_Vendor_OmaCab_User_PrefsXml,
  Application_Vendor_OmaDcd: () => Application_Vendor_OmaDcd,
  Application_Vendor_OmaDcdc: () => Application_Vendor_OmaDcdc,
  Application_Vendor_OmaDd2Xml: () => Application_Vendor_OmaDd2Xml,
  Application_Vendor_OmaDrmRisdXml: () => Application_Vendor_OmaDrmRisdXml,
  Application_Vendor_OmaGroup_Usage_ListXml: () => Application_Vendor_OmaGroup_Usage_ListXml,
  Application_Vendor_OmaLwm2mJson: () => Application_Vendor_OmaLwm2mJson,
  Application_Vendor_OmaLwm2mTlv: () => Application_Vendor_OmaLwm2mTlv,
  Application_Vendor_OmaPalXml: () => Application_Vendor_OmaPalXml,
  Application_Vendor_OmaPocDetailed_Progress_ReportXml: () => Application_Vendor_OmaPocDetailed_Progress_ReportXml,
  Application_Vendor_OmaPocFinal_ReportXml: () => Application_Vendor_OmaPocFinal_ReportXml,
  Application_Vendor_OmaPocGroupsXml: () => Application_Vendor_OmaPocGroupsXml,
  Application_Vendor_OmaPocInvocation_DescriptorXml: () => Application_Vendor_OmaPocInvocation_DescriptorXml,
  Application_Vendor_OmaPocOptimized_Progress_ReportXml: () => Application_Vendor_OmaPocOptimized_Progress_ReportXml,
  Application_Vendor_OmaPush: () => Application_Vendor_OmaPush,
  Application_Vendor_OmaScidmMessagesXml: () => Application_Vendor_OmaScidmMessagesXml,
  Application_Vendor_OmaXcap_DirectoryXml: () => Application_Vendor_OmaXcap_DirectoryXml,
  Application_Vendor_Oma_Scws_Config: () => Application_Vendor_Oma_Scws_Config,
  Application_Vendor_Oma_Scws_Http_Request: () => Application_Vendor_Oma_Scws_Http_Request,
  Application_Vendor_Oma_Scws_Http_Response: () => Application_Vendor_Oma_Scws_Http_Response,
  Application_Vendor_Omads_EmailXml: () => Application_Vendor_Omads_EmailXml,
  Application_Vendor_Omads_FileXml: () => Application_Vendor_Omads_FileXml,
  Application_Vendor_Omads_FolderXml: () => Application_Vendor_Omads_FolderXml,
  Application_Vendor_Omaloc_Supl_Init: () => Application_Vendor_Omaloc_Supl_Init,
  Application_Vendor_Onepager: () => Application_Vendor_Onepager,
  Application_Vendor_Onepagertamp: () => Application_Vendor_Onepagertamp,
  Application_Vendor_Onepagertamx: () => Application_Vendor_Onepagertamx,
  Application_Vendor_Onepagertat: () => Application_Vendor_Onepagertat,
  Application_Vendor_Onepagertatp: () => Application_Vendor_Onepagertatp,
  Application_Vendor_Onepagertatx: () => Application_Vendor_Onepagertatx,
  Application_Vendor_OpenbloxGameXml: () => Application_Vendor_OpenbloxGameXml,
  Application_Vendor_OpenbloxGame_Binary: () => Application_Vendor_OpenbloxGame_Binary,
  Application_Vendor_OpeneyeOeb: () => Application_Vendor_OpeneyeOeb,
  Application_Vendor_OpenofficeorgExtension: () => Application_Vendor_OpenofficeorgExtension,
  Application_Vendor_OpenstreetmapDataXml: () => Application_Vendor_OpenstreetmapDataXml,
  Application_Vendor_Openxmlformats_OfficedocumentCustomXmlPropertiesXml: () => Application_Vendor_Openxmlformats_OfficedocumentCustomXmlPropertiesXml,
  Application_Vendor_Openxmlformats_OfficedocumentCustom_PropertiesXml: () => Application_Vendor_Openxmlformats_OfficedocumentCustom_PropertiesXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartshapesXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartshapesXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramColorsXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramColorsXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramDataXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramDataXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramLayoutXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramLayoutXml,
  Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramStyleXml: () => Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramStyleXml,
  Application_Vendor_Openxmlformats_OfficedocumentExtended_PropertiesXml: () => Application_Vendor_Openxmlformats_OfficedocumentExtended_PropertiesXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentAuthorsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentAuthorsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlHandoutMasterXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlHandoutMasterXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesMasterXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesMasterXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesSlideXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesSlideXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresPropsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresPropsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentation: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentation,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentationMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentationMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlide: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlide,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideLayoutXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideLayoutXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideMasterXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideMasterXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideUpdateInfoXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideUpdateInfoXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshow: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshow,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshowMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshowMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTableStylesXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTableStylesXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTagsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTagsXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplate: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplate,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplateMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplateMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentPresentationmlViewPropsXml: () => Application_Vendor_Openxmlformats_OfficedocumentPresentationmlViewPropsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCalcChainXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCalcChainXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlChartsheetXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlChartsheetXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCommentsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCommentsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlConnectionsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlConnectionsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlDialogsheetXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlDialogsheetXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlExternalLinkXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlExternalLinkXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheDefinitionXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheDefinitionXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheRecordsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheRecordsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlQueryTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlQueryTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionHeadersXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionHeadersXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionLogXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionLogXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSharedStringsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSharedStringsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheet: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheet,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMetadataXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMetadataXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlStylesXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlStylesXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableSingleCellsXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableSingleCellsXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplate: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplate,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplateMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplateMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlUserNamesXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlUserNamesXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlVolatileDependenciesXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlVolatileDependenciesXml,
  Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlWorksheetXml: () => Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlWorksheetXml,
  Application_Vendor_Openxmlformats_OfficedocumentThemeOverrideXml: () => Application_Vendor_Openxmlformats_OfficedocumentThemeOverrideXml,
  Application_Vendor_Openxmlformats_OfficedocumentThemeXml: () => Application_Vendor_Openxmlformats_OfficedocumentThemeXml,
  Application_Vendor_Openxmlformats_OfficedocumentVmlDrawing: () => Application_Vendor_Openxmlformats_OfficedocumentVmlDrawing,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlCommentsXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlCommentsXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocument: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocument,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentGlossaryXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentGlossaryXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlEndnotesXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlEndnotesXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFontTableXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFontTableXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFooterXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFooterXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFootnotesXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFootnotesXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlNumberingXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlNumberingXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlSettingsXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlSettingsXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlStylesXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlStylesXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplate: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplate,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplateMainXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplateMainXml,
  Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlWebSettingsXml: () => Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlWebSettingsXml,
  Application_Vendor_Openxmlformats_PackageCore_PropertiesXml: () => Application_Vendor_Openxmlformats_PackageCore_PropertiesXml,
  Application_Vendor_Openxmlformats_PackageDigital_Signature_XmlsignatureXml: () => Application_Vendor_Openxmlformats_PackageDigital_Signature_XmlsignatureXml,
  Application_Vendor_Openxmlformats_PackageRelationshipsXml: () => Application_Vendor_Openxmlformats_PackageRelationshipsXml,
  Application_Vendor_OracleResourceJson: () => Application_Vendor_OracleResourceJson,
  Application_Vendor_OrangeIndata: () => Application_Vendor_OrangeIndata,
  Application_Vendor_OsaNetdeploy: () => Application_Vendor_OsaNetdeploy,
  Application_Vendor_OsgeoMapguidePackage: () => Application_Vendor_OsgeoMapguidePackage,
  Application_Vendor_OsgiBundle: () => Application_Vendor_OsgiBundle,
  Application_Vendor_OsgiDp: () => Application_Vendor_OsgiDp,
  Application_Vendor_OsgiSubsystem: () => Application_Vendor_OsgiSubsystem,
  Application_Vendor_OtpsCt_KipXml: () => Application_Vendor_OtpsCt_KipXml,
  Application_Vendor_OxliCountgraph: () => Application_Vendor_OxliCountgraph,
  Application_Vendor_PagerdutyJson: () => Application_Vendor_PagerdutyJson,
  Application_Vendor_Palm: () => Application_Vendor_Palm,
  Application_Vendor_Panoply: () => Application_Vendor_Panoply,
  Application_Vendor_PaosXml: () => Application_Vendor_PaosXml,
  Application_Vendor_Patentdive: () => Application_Vendor_Patentdive,
  Application_Vendor_Patientecommsdoc: () => Application_Vendor_Patientecommsdoc,
  Application_Vendor_Pawaafile: () => Application_Vendor_Pawaafile,
  Application_Vendor_Pcos: () => Application_Vendor_Pcos,
  Application_Vendor_PgFormat: () => Application_Vendor_PgFormat,
  Application_Vendor_PgOsasli: () => Application_Vendor_PgOsasli,
  Application_Vendor_PiaccessApplication_Licence: () => Application_Vendor_PiaccessApplication_Licence,
  Application_Vendor_Picsel: () => Application_Vendor_Picsel,
  Application_Vendor_PmiWidget: () => Application_Vendor_PmiWidget,
  Application_Vendor_PocGroup_AdvertisementXml: () => Application_Vendor_PocGroup_AdvertisementXml,
  Application_Vendor_Pocketlearn: () => Application_Vendor_Pocketlearn,
  Application_Vendor_Powerbuilder6: () => Application_Vendor_Powerbuilder6,
  Application_Vendor_Powerbuilder6_S: () => Application_Vendor_Powerbuilder6_S,
  Application_Vendor_Powerbuilder7: () => Application_Vendor_Powerbuilder7,
  Application_Vendor_Powerbuilder75: () => Application_Vendor_Powerbuilder75,
  Application_Vendor_Powerbuilder75_S: () => Application_Vendor_Powerbuilder75_S,
  Application_Vendor_Powerbuilder7_S: () => Application_Vendor_Powerbuilder7_S,
  Application_Vendor_Preminet: () => Application_Vendor_Preminet,
  Application_Vendor_PreviewsystemsBox: () => Application_Vendor_PreviewsystemsBox,
  Application_Vendor_ProteusMagazine: () => Application_Vendor_ProteusMagazine,
  Application_Vendor_Psfs: () => Application_Vendor_Psfs,
  Application_Vendor_Publishare_Delta_Tree: () => Application_Vendor_Publishare_Delta_Tree,
  Application_Vendor_PviPtid1: () => Application_Vendor_PviPtid1,
  Application_Vendor_Pwg_Multiplexed: () => Application_Vendor_Pwg_Multiplexed,
  Application_Vendor_Pwg_Xhtml_PrintXml: () => Application_Vendor_Pwg_Xhtml_PrintXml,
  Application_Vendor_QualcommBrew_App_Res: () => Application_Vendor_QualcommBrew_App_Res,
  Application_Vendor_Quarantainenet: () => Application_Vendor_Quarantainenet,
  Application_Vendor_QuarkQuarkXPress: () => Application_Vendor_QuarkQuarkXPress,
  Application_Vendor_Quobject_Quoxdocument: () => Application_Vendor_Quobject_Quoxdocument,
  Application_Vendor_RadisysMomlXml: () => Application_Vendor_RadisysMomlXml,
  Application_Vendor_RadisysMsmlXml: () => Application_Vendor_RadisysMsmlXml,
  Application_Vendor_RadisysMsml_AuditXml: () => Application_Vendor_RadisysMsml_AuditXml,
  Application_Vendor_RadisysMsml_Audit_ConfXml: () => Application_Vendor_RadisysMsml_Audit_ConfXml,
  Application_Vendor_RadisysMsml_Audit_ConnXml: () => Application_Vendor_RadisysMsml_Audit_ConnXml,
  Application_Vendor_RadisysMsml_Audit_DialogXml: () => Application_Vendor_RadisysMsml_Audit_DialogXml,
  Application_Vendor_RadisysMsml_Audit_StreamXml: () => Application_Vendor_RadisysMsml_Audit_StreamXml,
  Application_Vendor_RadisysMsml_ConfXml: () => Application_Vendor_RadisysMsml_ConfXml,
  Application_Vendor_RadisysMsml_DialogXml: () => Application_Vendor_RadisysMsml_DialogXml,
  Application_Vendor_RadisysMsml_Dialog_BaseXml: () => Application_Vendor_RadisysMsml_Dialog_BaseXml,
  Application_Vendor_RadisysMsml_Dialog_Fax_DetectXml: () => Application_Vendor_RadisysMsml_Dialog_Fax_DetectXml,
  Application_Vendor_RadisysMsml_Dialog_Fax_SendrecvXml: () => Application_Vendor_RadisysMsml_Dialog_Fax_SendrecvXml,
  Application_Vendor_RadisysMsml_Dialog_GroupXml: () => Application_Vendor_RadisysMsml_Dialog_GroupXml,
  Application_Vendor_RadisysMsml_Dialog_SpeechXml: () => Application_Vendor_RadisysMsml_Dialog_SpeechXml,
  Application_Vendor_RadisysMsml_Dialog_TransformXml: () => Application_Vendor_RadisysMsml_Dialog_TransformXml,
  Application_Vendor_RainstorData: () => Application_Vendor_RainstorData,
  Application_Vendor_Rapid: () => Application_Vendor_Rapid,
  Application_Vendor_Rar: () => Application_Vendor_Rar,
  Application_Vendor_RealvncBed: () => Application_Vendor_RealvncBed,
  Application_Vendor_RecordareMusicxml: () => Application_Vendor_RecordareMusicxml,
  Application_Vendor_RecordareMusicxmlXml: () => Application_Vendor_RecordareMusicxmlXml,
  Application_Vendor_RenLearnRlprint: () => Application_Vendor_RenLearnRlprint,
  Application_Vendor_RestfulJson: () => Application_Vendor_RestfulJson,
  Application_Vendor_RigCryptonote: () => Application_Vendor_RigCryptonote,
  Application_Vendor_RimCod: () => Application_Vendor_RimCod,
  Application_Vendor_Rn_Realmedia: () => Application_Vendor_Rn_Realmedia,
  Application_Vendor_Rn_Realmedia_Vbr: () => Application_Vendor_Rn_Realmedia_Vbr,
  Application_Vendor_Route66Link66Xml: () => Application_Vendor_Route66Link66Xml,
  Application_Vendor_Rs_274x: () => Application_Vendor_Rs_274x,
  Application_Vendor_RuckusDownload: () => Application_Vendor_RuckusDownload,
  Application_Vendor_S3sms: () => Application_Vendor_S3sms,
  Application_Vendor_SailingtrackerTrack: () => Application_Vendor_SailingtrackerTrack,
  Application_Vendor_Sar: () => Application_Vendor_Sar,
  Application_Vendor_SbmCid: () => Application_Vendor_SbmCid,
  Application_Vendor_SbmMid2: () => Application_Vendor_SbmMid2,
  Application_Vendor_Scribus: () => Application_Vendor_Scribus,
  Application_Vendor_Sealed3df: () => Application_Vendor_Sealed3df,
  Application_Vendor_SealedCsf: () => Application_Vendor_SealedCsf,
  Application_Vendor_SealedDoc: () => Application_Vendor_SealedDoc,
  Application_Vendor_SealedEml: () => Application_Vendor_SealedEml,
  Application_Vendor_SealedMht: () => Application_Vendor_SealedMht,
  Application_Vendor_SealedNet: () => Application_Vendor_SealedNet,
  Application_Vendor_SealedPpt: () => Application_Vendor_SealedPpt,
  Application_Vendor_SealedTiff: () => Application_Vendor_SealedTiff,
  Application_Vendor_SealedXls: () => Application_Vendor_SealedXls,
  Application_Vendor_SealedmediaSoftsealHtml: () => Application_Vendor_SealedmediaSoftsealHtml,
  Application_Vendor_SealedmediaSoftsealPdf: () => Application_Vendor_SealedmediaSoftsealPdf,
  Application_Vendor_Seemail: () => Application_Vendor_Seemail,
  Application_Vendor_Sema: () => Application_Vendor_Sema,
  Application_Vendor_Semd: () => Application_Vendor_Semd,
  Application_Vendor_Semf: () => Application_Vendor_Semf,
  Application_Vendor_Shade_Save_File: () => Application_Vendor_Shade_Save_File,
  Application_Vendor_ShanaInformedFormdata: () => Application_Vendor_ShanaInformedFormdata,
  Application_Vendor_ShanaInformedFormtemplate: () => Application_Vendor_ShanaInformedFormtemplate,
  Application_Vendor_ShanaInformedInterchange: () => Application_Vendor_ShanaInformedInterchange,
  Application_Vendor_ShanaInformedPackage: () => Application_Vendor_ShanaInformedPackage,
  Application_Vendor_ShootproofJson: () => Application_Vendor_ShootproofJson,
  Application_Vendor_ShopkickJson: () => Application_Vendor_ShopkickJson,
  Application_Vendor_SigrokSession: () => Application_Vendor_SigrokSession,
  Application_Vendor_SimTech_MindMapper: () => Application_Vendor_SimTech_MindMapper,
  Application_Vendor_SirenJson: () => Application_Vendor_SirenJson,
  Application_Vendor_Smaf: () => Application_Vendor_Smaf,
  Application_Vendor_SmartNotebook: () => Application_Vendor_SmartNotebook,
  Application_Vendor_SmartTeacher: () => Application_Vendor_SmartTeacher,
  Application_Vendor_Software602FillerFormXml: () => Application_Vendor_Software602FillerFormXml,
  Application_Vendor_Software602FillerForm_Xml_Zip: () => Application_Vendor_Software602FillerForm_Xml_Zip,
  Application_Vendor_SolentSdkmXml: () => Application_Vendor_SolentSdkmXml,
  Application_Vendor_SpotfireDxp: () => Application_Vendor_SpotfireDxp,
  Application_Vendor_SpotfireSfs: () => Application_Vendor_SpotfireSfs,
  Application_Vendor_Sqlite3: () => Application_Vendor_Sqlite3,
  Application_Vendor_Sss_Cod: () => Application_Vendor_Sss_Cod,
  Application_Vendor_Sss_Dtf: () => Application_Vendor_Sss_Dtf,
  Application_Vendor_Sss_Ntf: () => Application_Vendor_Sss_Ntf,
  Application_Vendor_StardivisionCalc: () => Application_Vendor_StardivisionCalc,
  Application_Vendor_StardivisionDraw: () => Application_Vendor_StardivisionDraw,
  Application_Vendor_StardivisionImpress: () => Application_Vendor_StardivisionImpress,
  Application_Vendor_StardivisionMath: () => Application_Vendor_StardivisionMath,
  Application_Vendor_StardivisionWriter: () => Application_Vendor_StardivisionWriter,
  Application_Vendor_StardivisionWriter_Global: () => Application_Vendor_StardivisionWriter_Global,
  Application_Vendor_StepmaniaPackage: () => Application_Vendor_StepmaniaPackage,
  Application_Vendor_StepmaniaStepchart: () => Application_Vendor_StepmaniaStepchart,
  Application_Vendor_Street_Stream: () => Application_Vendor_Street_Stream,
  Application_Vendor_SunWadlXml: () => Application_Vendor_SunWadlXml,
  Application_Vendor_SunXmlCalc: () => Application_Vendor_SunXmlCalc,
  Application_Vendor_SunXmlCalcTemplate: () => Application_Vendor_SunXmlCalcTemplate,
  Application_Vendor_SunXmlDraw: () => Application_Vendor_SunXmlDraw,
  Application_Vendor_SunXmlDrawTemplate: () => Application_Vendor_SunXmlDrawTemplate,
  Application_Vendor_SunXmlImpress: () => Application_Vendor_SunXmlImpress,
  Application_Vendor_SunXmlImpressTemplate: () => Application_Vendor_SunXmlImpressTemplate,
  Application_Vendor_SunXmlMath: () => Application_Vendor_SunXmlMath,
  Application_Vendor_SunXmlWriter: () => Application_Vendor_SunXmlWriter,
  Application_Vendor_SunXmlWriterGlobal: () => Application_Vendor_SunXmlWriterGlobal,
  Application_Vendor_SunXmlWriterTemplate: () => Application_Vendor_SunXmlWriterTemplate,
  Application_Vendor_Sus_Calendar: () => Application_Vendor_Sus_Calendar,
  Application_Vendor_Svd: () => Application_Vendor_Svd,
  Application_Vendor_Swiftview_Ics: () => Application_Vendor_Swiftview_Ics,
  Application_Vendor_SymbianInstall: () => Application_Vendor_SymbianInstall,
  Application_Vendor_SyncmlDmNotification: () => Application_Vendor_SyncmlDmNotification,
  Application_Vendor_SyncmlDmWbxml: () => Application_Vendor_SyncmlDmWbxml,
  Application_Vendor_SyncmlDmXml: () => Application_Vendor_SyncmlDmXml,
  Application_Vendor_SyncmlDmddfWbxml: () => Application_Vendor_SyncmlDmddfWbxml,
  Application_Vendor_SyncmlDmddfXml: () => Application_Vendor_SyncmlDmddfXml,
  Application_Vendor_SyncmlDmtndsWbxml: () => Application_Vendor_SyncmlDmtndsWbxml,
  Application_Vendor_SyncmlDmtndsXml: () => Application_Vendor_SyncmlDmtndsXml,
  Application_Vendor_SyncmlDsNotification: () => Application_Vendor_SyncmlDsNotification,
  Application_Vendor_SyncmlXml: () => Application_Vendor_SyncmlXml,
  Application_Vendor_TableschemaJson: () => Application_Vendor_TableschemaJson,
  Application_Vendor_TaoIntent_Module_Archive: () => Application_Vendor_TaoIntent_Module_Archive,
  Application_Vendor_TcpdumpPcap: () => Application_Vendor_TcpdumpPcap,
  Application_Vendor_Think_CellPpttcJson: () => Application_Vendor_Think_CellPpttcJson,
  Application_Vendor_TmdMediaflexApiXml: () => Application_Vendor_TmdMediaflexApiXml,
  Application_Vendor_Tml: () => Application_Vendor_Tml,
  Application_Vendor_Tmobile_Livetv: () => Application_Vendor_Tmobile_Livetv,
  Application_Vendor_TriOnesource: () => Application_Vendor_TriOnesource,
  Application_Vendor_TridTpt: () => Application_Vendor_TridTpt,
  Application_Vendor_TriscapeMxs: () => Application_Vendor_TriscapeMxs,
  Application_Vendor_Trueapp: () => Application_Vendor_Trueapp,
  Application_Vendor_Truedoc: () => Application_Vendor_Truedoc,
  Application_Vendor_UbisoftWebplayer: () => Application_Vendor_UbisoftWebplayer,
  Application_Vendor_Ufdl: () => Application_Vendor_Ufdl,
  Application_Vendor_UiqTheme: () => Application_Vendor_UiqTheme,
  Application_Vendor_Umajin: () => Application_Vendor_Umajin,
  Application_Vendor_Unity: () => Application_Vendor_Unity,
  Application_Vendor_UomlXml: () => Application_Vendor_UomlXml,
  Application_Vendor_UplanetAlert: () => Application_Vendor_UplanetAlert,
  Application_Vendor_UplanetAlert_Wbxml: () => Application_Vendor_UplanetAlert_Wbxml,
  Application_Vendor_UplanetBearer_Choice: () => Application_Vendor_UplanetBearer_Choice,
  Application_Vendor_UplanetBearer_Choice_Wbxml: () => Application_Vendor_UplanetBearer_Choice_Wbxml,
  Application_Vendor_UplanetCacheop: () => Application_Vendor_UplanetCacheop,
  Application_Vendor_UplanetCacheop_Wbxml: () => Application_Vendor_UplanetCacheop_Wbxml,
  Application_Vendor_UplanetChannel: () => Application_Vendor_UplanetChannel,
  Application_Vendor_UplanetChannel_Wbxml: () => Application_Vendor_UplanetChannel_Wbxml,
  Application_Vendor_UplanetList: () => Application_Vendor_UplanetList,
  Application_Vendor_UplanetList_Wbxml: () => Application_Vendor_UplanetList_Wbxml,
  Application_Vendor_UplanetListcmd: () => Application_Vendor_UplanetListcmd,
  Application_Vendor_UplanetListcmd_Wbxml: () => Application_Vendor_UplanetListcmd_Wbxml,
  Application_Vendor_UplanetSignal: () => Application_Vendor_UplanetSignal,
  Application_Vendor_Uri_Map: () => Application_Vendor_Uri_Map,
  Application_Vendor_ValveSourceMaterial: () => Application_Vendor_ValveSourceMaterial,
  Application_Vendor_Vcx: () => Application_Vendor_Vcx,
  Application_Vendor_Vd_Study: () => Application_Vendor_Vd_Study,
  Application_Vendor_Vectorworks: () => Application_Vendor_Vectorworks,
  Application_Vendor_VelJson: () => Application_Vendor_VelJson,
  Application_Vendor_VerimatrixVcas: () => Application_Vendor_VerimatrixVcas,
  Application_Vendor_VeryantThin: () => Application_Vendor_VeryantThin,
  Application_Vendor_VesEncrypted: () => Application_Vendor_VesEncrypted,
  Application_Vendor_VidsoftVidconference: () => Application_Vendor_VidsoftVidconference,
  Application_Vendor_Visio: () => Application_Vendor_Visio,
  Application_Vendor_Visionary: () => Application_Vendor_Visionary,
  Application_Vendor_VividenceScriptfile: () => Application_Vendor_VividenceScriptfile,
  Application_Vendor_Vsf: () => Application_Vendor_Vsf,
  Application_Vendor_WapSic: () => Application_Vendor_WapSic,
  Application_Vendor_WapSlc: () => Application_Vendor_WapSlc,
  Application_Vendor_WapWbxml: () => Application_Vendor_WapWbxml,
  Application_Vendor_WapWmlc: () => Application_Vendor_WapWmlc,
  Application_Vendor_WapWmlscriptc: () => Application_Vendor_WapWmlscriptc,
  Application_Vendor_Webturbo: () => Application_Vendor_Webturbo,
  Application_Vendor_WfaP2p: () => Application_Vendor_WfaP2p,
  Application_Vendor_WfaWsc: () => Application_Vendor_WfaWsc,
  Application_Vendor_WindowsDevicepairing: () => Application_Vendor_WindowsDevicepairing,
  Application_Vendor_Wmc: () => Application_Vendor_Wmc,
  Application_Vendor_WmfBootstrap: () => Application_Vendor_WmfBootstrap,
  Application_Vendor_WolframMathematica: () => Application_Vendor_WolframMathematica,
  Application_Vendor_WolframMathematicaPackage: () => Application_Vendor_WolframMathematicaPackage,
  Application_Vendor_WolframPlayer: () => Application_Vendor_WolframPlayer,
  Application_Vendor_Wordperfect: () => Application_Vendor_Wordperfect,
  Application_Vendor_Wqd: () => Application_Vendor_Wqd,
  Application_Vendor_Wrq_Hp3000_Labelled: () => Application_Vendor_Wrq_Hp3000_Labelled,
  Application_Vendor_WtStf: () => Application_Vendor_WtStf,
  Application_Vendor_WvCspWbxml: () => Application_Vendor_WvCspWbxml,
  Application_Vendor_WvCspXml: () => Application_Vendor_WvCspXml,
  Application_Vendor_WvSspXml: () => Application_Vendor_WvSspXml,
  Application_Vendor_XacmlJson: () => Application_Vendor_XacmlJson,
  Application_Vendor_Xara: () => Application_Vendor_Xara,
  Application_Vendor_Xfdl: () => Application_Vendor_Xfdl,
  Application_Vendor_XfdlWebform: () => Application_Vendor_XfdlWebform,
  Application_Vendor_XmiXml: () => Application_Vendor_XmiXml,
  Application_Vendor_XmpieCpkg: () => Application_Vendor_XmpieCpkg,
  Application_Vendor_XmpieDpkg: () => Application_Vendor_XmpieDpkg,
  Application_Vendor_XmpiePlan: () => Application_Vendor_XmpiePlan,
  Application_Vendor_XmpiePpkg: () => Application_Vendor_XmpiePpkg,
  Application_Vendor_XmpieXlim: () => Application_Vendor_XmpieXlim,
  Application_Vendor_YamahaHv_Dic: () => Application_Vendor_YamahaHv_Dic,
  Application_Vendor_YamahaHv_Script: () => Application_Vendor_YamahaHv_Script,
  Application_Vendor_YamahaHv_Voice: () => Application_Vendor_YamahaHv_Voice,
  Application_Vendor_YamahaOpenscoreformat: () => Application_Vendor_YamahaOpenscoreformat,
  Application_Vendor_YamahaOpenscoreformatOsfpvgXml: () => Application_Vendor_YamahaOpenscoreformatOsfpvgXml,
  Application_Vendor_YamahaRemote_Setup: () => Application_Vendor_YamahaRemote_Setup,
  Application_Vendor_YamahaSmaf_Audio: () => Application_Vendor_YamahaSmaf_Audio,
  Application_Vendor_YamahaSmaf_Phrase: () => Application_Vendor_YamahaSmaf_Phrase,
  Application_Vendor_YamahaThrough_Ngn: () => Application_Vendor_YamahaThrough_Ngn,
  Application_Vendor_YamahaTunnel_Udpencap: () => Application_Vendor_YamahaTunnel_Udpencap,
  Application_Vendor_Yaoweme: () => Application_Vendor_Yaoweme,
  Application_Vendor_Yellowriver_Custom_Menu: () => Application_Vendor_Yellowriver_Custom_Menu,
  Application_Vendor_YoutubeYt: () => Application_Vendor_YoutubeYt,
  Application_Vendor_Zul: () => Application_Vendor_Zul,
  Application_Vendor_ZzazzDeckXml: () => Application_Vendor_ZzazzDeckXml,
  Application_VividenceScriptfile: () => Application_VividenceScriptfile,
  Application_VoicexmlXml: () => Application_VoicexmlXml,
  Application_Voucher_CmsJson: () => Application_Voucher_CmsJson,
  Application_Vq_Rtcpxr: () => Application_Vq_Rtcpxr,
  Application_Wasm: () => Application_Wasm,
  Application_WatcherinfoXml: () => Application_WatcherinfoXml,
  Application_Webpush_OptionsJson: () => Application_Webpush_OptionsJson,
  Application_Whoispp_Query: () => Application_Whoispp_Query,
  Application_Whoispp_Response: () => Application_Whoispp_Response,
  Application_Widget: () => Application_Widget,
  Application_Winhlp: () => Application_Winhlp,
  Application_Wita: () => Application_Wita,
  Application_Wordperfect51: () => Application_Wordperfect51,
  Application_WsdlXml: () => Application_WsdlXml,
  Application_WspolicyXml: () => Application_WspolicyXml,
  Application_X400_Bp: () => Application_X400_Bp,
  Application_X_7z_Compressed: () => Application_X_7z_Compressed,
  Application_X_Abiword: () => Application_X_Abiword,
  Application_X_Ace_Compressed: () => Application_X_Ace_Compressed,
  Application_X_Amf: () => Application_X_Amf,
  Application_X_Apple_Diskimage: () => Application_X_Apple_Diskimage,
  Application_X_Arj: () => Application_X_Arj,
  Application_X_Authorware_Bin: () => Application_X_Authorware_Bin,
  Application_X_Authorware_Map: () => Application_X_Authorware_Map,
  Application_X_Authorware_Seg: () => Application_X_Authorware_Seg,
  Application_X_Bcpio: () => Application_X_Bcpio,
  Application_X_Bdoc: () => Application_X_Bdoc,
  Application_X_Bittorrent: () => Application_X_Bittorrent,
  Application_X_Blorb: () => Application_X_Blorb,
  Application_X_Bzip: () => Application_X_Bzip,
  Application_X_Bzip2: () => Application_X_Bzip2,
  Application_X_Cbr: () => Application_X_Cbr,
  Application_X_Cdlink: () => Application_X_Cdlink,
  Application_X_Cfs_Compressed: () => Application_X_Cfs_Compressed,
  Application_X_Chat: () => Application_X_Chat,
  Application_X_Chess_Pgn: () => Application_X_Chess_Pgn,
  Application_X_Chrome_Extension: () => Application_X_Chrome_Extension,
  Application_X_Compress: () => Application_X_Compress,
  Application_X_Conference: () => Application_X_Conference,
  Application_X_Cpio: () => Application_X_Cpio,
  Application_X_Csh: () => Application_X_Csh,
  Application_X_Deb: () => Application_X_Deb,
  Application_X_Debian_Package: () => Application_X_Debian_Package,
  Application_X_Dgc_Compressed: () => Application_X_Dgc_Compressed,
  Application_X_Director: () => Application_X_Director,
  Application_X_Doom: () => Application_X_Doom,
  Application_X_DtbncxXml: () => Application_X_DtbncxXml,
  Application_X_DtbookXml: () => Application_X_DtbookXml,
  Application_X_DtbresourceXml: () => Application_X_DtbresourceXml,
  Application_X_Dvi: () => Application_X_Dvi,
  Application_X_Envoy: () => Application_X_Envoy,
  Application_X_Eva: () => Application_X_Eva,
  Application_X_Font_Bdf: () => Application_X_Font_Bdf,
  Application_X_Font_Dos: () => Application_X_Font_Dos,
  Application_X_Font_Framemaker: () => Application_X_Font_Framemaker,
  Application_X_Font_Ghostscript: () => Application_X_Font_Ghostscript,
  Application_X_Font_Libgrx: () => Application_X_Font_Libgrx,
  Application_X_Font_Linux_Psf: () => Application_X_Font_Linux_Psf,
  Application_X_Font_Pcf: () => Application_X_Font_Pcf,
  Application_X_Font_Snf: () => Application_X_Font_Snf,
  Application_X_Font_Speedo: () => Application_X_Font_Speedo,
  Application_X_Font_Sunos_News: () => Application_X_Font_Sunos_News,
  Application_X_Font_Type1: () => Application_X_Font_Type1,
  Application_X_Font_Vfont: () => Application_X_Font_Vfont,
  Application_X_Freearc: () => Application_X_Freearc,
  Application_X_Futuresplash: () => Application_X_Futuresplash,
  Application_X_Gca_Compressed: () => Application_X_Gca_Compressed,
  Application_X_Glulx: () => Application_X_Glulx,
  Application_X_Gnumeric: () => Application_X_Gnumeric,
  Application_X_Gramps_Xml: () => Application_X_Gramps_Xml,
  Application_X_Gtar: () => Application_X_Gtar,
  Application_X_Gzip: () => Application_X_Gzip,
  Application_X_Hdf: () => Application_X_Hdf,
  Application_X_Httpd_Php: () => Application_X_Httpd_Php,
  Application_X_Install_Instructions: () => Application_X_Install_Instructions,
  Application_X_Iso9660_Image: () => Application_X_Iso9660_Image,
  Application_X_Iwork_Keynote_Sffkey: () => Application_X_Iwork_Keynote_Sffkey,
  Application_X_Iwork_Numbers_Sffnumbers: () => Application_X_Iwork_Numbers_Sffnumbers,
  Application_X_Iwork_Pages_Sffpages: () => Application_X_Iwork_Pages_Sffpages,
  Application_X_Java_Jnlp_File: () => Application_X_Java_Jnlp_File,
  Application_X_Javascript: () => Application_X_Javascript,
  Application_X_Keepass2: () => Application_X_Keepass2,
  Application_X_Latex: () => Application_X_Latex,
  Application_X_Lua_Bytecode: () => Application_X_Lua_Bytecode,
  Application_X_Lzh_Compressed: () => Application_X_Lzh_Compressed,
  Application_X_Mie: () => Application_X_Mie,
  Application_X_Mobipocket_Ebook: () => Application_X_Mobipocket_Ebook,
  Application_X_Mpegurl: () => Application_X_Mpegurl,
  Application_X_Ms_Application: () => Application_X_Ms_Application,
  Application_X_Ms_Shortcut: () => Application_X_Ms_Shortcut,
  Application_X_Ms_Wmd: () => Application_X_Ms_Wmd,
  Application_X_Ms_Wmz: () => Application_X_Ms_Wmz,
  Application_X_Ms_Xbap: () => Application_X_Ms_Xbap,
  Application_X_Msaccess: () => Application_X_Msaccess,
  Application_X_Msbinder: () => Application_X_Msbinder,
  Application_X_Mscardfile: () => Application_X_Mscardfile,
  Application_X_Msclip: () => Application_X_Msclip,
  Application_X_Msdos_Program: () => Application_X_Msdos_Program,
  Application_X_Msdownload: () => Application_X_Msdownload,
  Application_X_Msmediaview: () => Application_X_Msmediaview,
  Application_X_Msmetafile: () => Application_X_Msmetafile,
  Application_X_Msmoney: () => Application_X_Msmoney,
  Application_X_Mspublisher: () => Application_X_Mspublisher,
  Application_X_Msschedule: () => Application_X_Msschedule,
  Application_X_Msterminal: () => Application_X_Msterminal,
  Application_X_Mswrite: () => Application_X_Mswrite,
  Application_X_Netcdf: () => Application_X_Netcdf,
  Application_X_Ns_Proxy_Autoconfig: () => Application_X_Ns_Proxy_Autoconfig,
  Application_X_Nzb: () => Application_X_Nzb,
  Application_X_Pkcs12: () => Application_X_Pkcs12,
  Application_X_Pkcs7_Certificates: () => Application_X_Pkcs7_Certificates,
  Application_X_Pkcs7_Certreqresp: () => Application_X_Pkcs7_Certreqresp,
  Application_X_Rar_Compressed: () => Application_X_Rar_Compressed,
  Application_X_Research_Info_Systems: () => Application_X_Research_Info_Systems,
  Application_X_Sh: () => Application_X_Sh,
  Application_X_Shar: () => Application_X_Shar,
  Application_X_Shockwave_Flash: () => Application_X_Shockwave_Flash,
  Application_X_Silverlight_App: () => Application_X_Silverlight_App,
  Application_X_Sql: () => Application_X_Sql,
  Application_X_Stuffit: () => Application_X_Stuffit,
  Application_X_Stuffitx: () => Application_X_Stuffitx,
  Application_X_Subrip: () => Application_X_Subrip,
  Application_X_Sv4cpio: () => Application_X_Sv4cpio,
  Application_X_Sv4crc: () => Application_X_Sv4crc,
  Application_X_T3vm_Image: () => Application_X_T3vm_Image,
  Application_X_Tads: () => Application_X_Tads,
  Application_X_Tar: () => Application_X_Tar,
  Application_X_Tcl: () => Application_X_Tcl,
  Application_X_Tex: () => Application_X_Tex,
  Application_X_Tex_Tfm: () => Application_X_Tex_Tfm,
  Application_X_Texinfo: () => Application_X_Texinfo,
  Application_X_Tgif: () => Application_X_Tgif,
  Application_X_Url: () => Application_X_Url,
  Application_X_Ustar: () => Application_X_Ustar,
  Application_X_Virtualbox_Hdd: () => Application_X_Virtualbox_Hdd,
  Application_X_Virtualbox_Ova: () => Application_X_Virtualbox_Ova,
  Application_X_Virtualbox_Ovf: () => Application_X_Virtualbox_Ovf,
  Application_X_Virtualbox_Vbox: () => Application_X_Virtualbox_Vbox,
  Application_X_Virtualbox_Vbox_Extpack: () => Application_X_Virtualbox_Vbox_Extpack,
  Application_X_Virtualbox_Vdi: () => Application_X_Virtualbox_Vdi,
  Application_X_Virtualbox_Vhd: () => Application_X_Virtualbox_Vhd,
  Application_X_Virtualbox_Vmdk: () => Application_X_Virtualbox_Vmdk,
  Application_X_Wais_Source: () => Application_X_Wais_Source,
  Application_X_Web_App_ManifestJson: () => Application_X_Web_App_ManifestJson,
  Application_X_Www_Form_Urlencoded: () => Application_X_Www_Form_Urlencoded,
  Application_X_X509_Ca_Cert: () => Application_X_X509_Ca_Cert,
  Application_X_Xfig: () => Application_X_Xfig,
  Application_X_XliffXml: () => Application_X_XliffXml,
  Application_X_Xpinstall: () => Application_X_Xpinstall,
  Application_X_Xz: () => Application_X_Xz,
  Application_X_Zip_Compressed: () => Application_X_Zip_Compressed,
  Application_X_Zmachine: () => Application_X_Zmachine,
  Application_XacmlXml: () => Application_XacmlXml,
  Application_XamlXml: () => Application_XamlXml,
  Application_Xcap_AttXml: () => Application_Xcap_AttXml,
  Application_Xcap_CapsXml: () => Application_Xcap_CapsXml,
  Application_Xcap_DiffXml: () => Application_Xcap_DiffXml,
  Application_Xcap_ElXml: () => Application_Xcap_ElXml,
  Application_Xcap_ErrorXml: () => Application_Xcap_ErrorXml,
  Application_Xcap_NsXml: () => Application_Xcap_NsXml,
  Application_Xcon_Conference_InfoXml: () => Application_Xcon_Conference_InfoXml,
  Application_Xcon_Conference_Info_DiffXml: () => Application_Xcon_Conference_Info_DiffXml,
  Application_XencXml: () => Application_XencXml,
  Application_XhtmlXml: () => Application_XhtmlXml,
  Application_Xhtml_VoiceXml: () => Application_Xhtml_VoiceXml,
  Application_XliffXml: () => Application_XliffXml,
  Application_Xml: () => Application_Xml,
  Application_Xml_Dtd: () => Application_Xml_Dtd,
  Application_Xml_External_Parsed_Entity: () => Application_Xml_External_Parsed_Entity,
  Application_Xml_PatchXml: () => Application_Xml_PatchXml,
  Application_XmppXml: () => Application_XmppXml,
  Application_XopXml: () => Application_XopXml,
  Application_XprocXml: () => Application_XprocXml,
  Application_XsltXml: () => Application_XsltXml,
  Application_XspfXml: () => Application_XspfXml,
  Application_XvXml: () => Application_XvXml,
  Application_Yang: () => Application_Yang,
  Application_Yang_DataJson: () => Application_Yang_DataJson,
  Application_Yang_DataXml: () => Application_Yang_DataXml,
  Application_Yang_PatchJson: () => Application_Yang_PatchJson,
  Application_Yang_PatchXml: () => Application_Yang_PatchXml,
  Application_YinXml: () => Application_YinXml,
  Application_Zip: () => Application_Zip,
  Application_Zlib: () => Application_Zlib,
  Application_Zstd: () => Application_Zstd
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/util.ts
var typePattern = /([^\/]+)\/(.+)/;
var subTypePattern = /(?:([^\.]+)\.)?([^\+;]+)(?:\+([^;]+))?((?:; *([^=]+)=([^;]+))*)/;
function mediaTypesToAcceptValue(types) {
  return types.flatMap((type2) => type2.extensions.map((ext) => "." + ext)).sort().join(", ");
}
var MediaType = class {
  constructor(_type, _fullSubType, extensions) {
    this._type = _type;
    this._fullSubType = _fullSubType;
    this._primaryExtension = null;
    this.depMessage = null;
    const parameters = /* @__PURE__ */ new Map();
    this._parameters = parameters;
    const subTypeParts = this._fullSubType.match(subTypePattern);
    this._tree = subTypeParts[1];
    this._subType = subTypeParts[2];
    this._suffix = subTypeParts[3];
    const paramStr = subTypeParts[4];
    this._value = this._fullValue = this._type + "/";
    if (isDefined(this._tree)) {
      this._value = this._fullValue += this._tree + ".";
    }
    this._value = this._fullValue += this._subType;
    if (isDefined(this._suffix)) {
      this._value = this._fullValue += "+" + this._suffix;
    }
    if (isDefined(paramStr)) {
      const pairs = paramStr.split(";").map((p) => p.trim()).filter((p) => p.length > 0).map((p) => p.split("="));
      for (const [key, ...values] of pairs) {
        const value2 = values.join("=");
        parameters.set(key, value2);
        const slug = `; ${key}=${value2}`;
        this._fullValue += slug;
        if (key !== "q") {
          this._value += slug;
        }
      }
    }
    this._extensions = extensions || [];
    this._primaryExtension = this._extensions[0] || null;
  }
  static parse(value2) {
    if (!value2) {
      return null;
    }
    const match = value2.match(typePattern);
    if (!match) {
      return null;
    }
    const type2 = match[1];
    const subType = match[2];
    return new MediaType(type2, subType);
  }
  deprecate(message2) {
    this.depMessage = message2;
    return this;
  }
  check() {
    if (isDefined(this.depMessage)) {
      console.warn(`${this._value} is deprecated ${this.depMessage}`);
    }
  }
  matches(value2) {
    if (isNullOrUndefined(value2)) {
      return false;
    }
    if (this.typeName === "*" && this.subTypeName === "*") {
      return true;
    }
    let typeName = null;
    let subTypeName = null;
    if (isString(value2)) {
      const match = value2.match(typePattern);
      if (!match) {
        return false;
      }
      typeName = match[1];
      subTypeName = match[2];
    } else {
      typeName = value2.typeName;
      subTypeName = value2._fullSubType;
    }
    return this.typeName === typeName && (this._fullSubType === "*" || this._fullSubType === subTypeName);
  }
  withParameter(key, value2) {
    const newSubType = `${this._fullSubType}; ${key}=${value2}`;
    return new MediaType(this.typeName, newSubType, this.extensions);
  }
  get typeName() {
    this.check();
    return this._type;
  }
  get tree() {
    this.check();
    return this._tree;
  }
  get suffix() {
    return this._suffix;
  }
  get subTypeName() {
    this.check();
    return this._subType;
  }
  get value() {
    this.check();
    return this._value;
  }
  __getValueUnsafe() {
    return this._value;
  }
  get fullValue() {
    this.check();
    return this._fullValue;
  }
  get parameters() {
    this.check();
    return this._parameters;
  }
  get extensions() {
    this.check();
    return this._extensions;
  }
  __getExtensionsUnsafe() {
    return this._extensions;
  }
  get primaryExtension() {
    this.check();
    return this._primaryExtension;
  }
  toString() {
    if (this.parameters.get("q") === "1") {
      return this.value;
    } else {
      return this.fullValue;
    }
  }
  addExtension(fileName) {
    if (!fileName) {
      throw new Error("File name is not defined");
    }
    if (this.primaryExtension) {
      const idx = fileName.lastIndexOf(".");
      if (idx > -1) {
        const currentExtension = fileName.substring(idx + 1);
        ;
        if (this.extensions.indexOf(currentExtension) > -1) {
          fileName = fileName.substring(0, idx);
        }
      }
      fileName = `${fileName}.${this.primaryExtension}`;
    }
    return fileName;
  }
};
function create(group2, value2, ...extensions) {
  return new MediaType(group2, value2, extensions);
}
function specialize(group2) {
  return create.bind(null, group2);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/application.ts
var application = /* @__PURE__ */ specialize("application");
var Application_A2L = /* @__PURE__ */ application("a2l");
var Application_Activemessage = /* @__PURE__ */ application("activemessage");
var Application_ScenarioJson = /* @__PURE__ */ application("activity+json", "json");
var Application_Alto_CostmapfilterJson = /* @__PURE__ */ application("alto-costmapfilter+json", "json");
var Application_Alto_CostmapJson = /* @__PURE__ */ application("alto-costmap+json", "json");
var Application_Alto_DirectoryJson = /* @__PURE__ */ application("alto-directory+json", "json");
var Application_Alto_EndpointcostJson = /* @__PURE__ */ application("alto-endpointcost+json", "json");
var Application_Alto_EndpointcostparamsJson = /* @__PURE__ */ application("alto-endpointcostparams+json", "json");
var Application_Alto_EndpointpropJson = /* @__PURE__ */ application("alto-endpointprop+json", "json");
var Application_Alto_EndpointpropparamsJson = /* @__PURE__ */ application("alto-endpointpropparams+json", "json");
var Application_Alto_ErrorJson = /* @__PURE__ */ application("alto-error+json", "json");
var Application_Alto_NetworkmapfilterJson = /* @__PURE__ */ application("alto-networkmapfilter+json", "json");
var Application_Alto_NetworkmapJson = /* @__PURE__ */ application("alto-networkmap+json", "json");
var Application_AML = /* @__PURE__ */ application("aml");
var Application_Andrew_Inset = /* @__PURE__ */ application("andrew-inset", "ez");
var Application_Applefile = /* @__PURE__ */ application("applefile");
var Application_Applixware = /* @__PURE__ */ application("applixware", "aw");
var Application_ATF = /* @__PURE__ */ application("atf");
var Application_ATFX = /* @__PURE__ */ application("atfx");
var Application_AtomcatXml = /* @__PURE__ */ application("atomcat+xml", "atomcat");
var Application_AtomdeletedXml = /* @__PURE__ */ application("atomdeleted+xml", "xml");
var Application_Atomicmail = /* @__PURE__ */ application("atomicmail");
var Application_AtomsvcXml = /* @__PURE__ */ application("atomsvc+xml", "atomsvc");
var Application_AtomXml = /* @__PURE__ */ application("atom+xml", "atom");
var Application_Atsc_DwdXml = /* @__PURE__ */ application("atsc-dwd+xml", "xml");
var Application_Atsc_HeldXml = /* @__PURE__ */ application("atsc-held+xml", "xml");
var Application_Atsc_RdtJson = /* @__PURE__ */ application("atsc-rdt+json", "json");
var Application_Atsc_RsatXml = /* @__PURE__ */ application("atsc-rsat+xml", "xml");
var Application_ATXML = /* @__PURE__ */ application("atxml");
var Application_Auth_PolicyXml = /* @__PURE__ */ application("auth-policy+xml", "xml");
var Application_Bacnet_XddZip = /* @__PURE__ */ application("bacnet-xdd+zip", "zip");
var Application_Batch_SMTP = /* @__PURE__ */ application("batch-smtp");
var Application_Bdoc = /* @__PURE__ */ application("bdoc", "bdoc");
var Application_BeepXml = /* @__PURE__ */ application("beep+xml", "xml");
var Application_CalendarJson = /* @__PURE__ */ application("calendar+json", "json");
var Application_CalendarXml = /* @__PURE__ */ application("calendar+xml", "xml");
var Application_Call_Completion = /* @__PURE__ */ application("call-completion");
var Application_CALS_1840 = /* @__PURE__ */ application("cals-1840");
var Application_Cbor = /* @__PURE__ */ application("cbor");
var Application_Cbor_Seq = /* @__PURE__ */ application("cbor-seq");
var Application_Cccex = /* @__PURE__ */ application("cccex");
var Application_CcmpXml = /* @__PURE__ */ application("ccmp+xml", "xml");
var Application_CcxmlXml = /* @__PURE__ */ application("ccxml+xml", "ccxml");
var Application_CDFXXML = /* @__PURE__ */ application("cdfx+xml", "xml");
var Application_Cdmi_Capability = /* @__PURE__ */ application("cdmi-capability", "cdmia");
var Application_Cdmi_Container = /* @__PURE__ */ application("cdmi-container", "cdmic");
var Application_Cdmi_Domain = /* @__PURE__ */ application("cdmi-domain", "cdmid");
var Application_Cdmi_Object = /* @__PURE__ */ application("cdmi-object", "cdmio");
var Application_Cdmi_Queue = /* @__PURE__ */ application("cdmi-queue", "cdmiq");
var Application_Cdni = /* @__PURE__ */ application("cdni");
var Application_CEA = /* @__PURE__ */ application("cea");
var Application_Cea_2018Xml = /* @__PURE__ */ application("cea-2018+xml", "xml");
var Application_CellmlXml = /* @__PURE__ */ application("cellml+xml", "xml");
var Application_Cfw = /* @__PURE__ */ application("cfw");
var Application_Clue_infoXml = /* @__PURE__ */ application("clue_info+xml", "xml");
var Application_ClueXml = /* @__PURE__ */ application("clue+xml", "xml");
var Application_Cms = /* @__PURE__ */ application("cms");
var Application_CnrpXml = /* @__PURE__ */ application("cnrp+xml", "xml");
var Application_Coap_GroupJson = /* @__PURE__ */ application("coap-group+json", "json");
var Application_Coap_Payload = /* @__PURE__ */ application("coap-payload");
var Application_Commonground = /* @__PURE__ */ application("commonground");
var Application_Conference_InfoXml = /* @__PURE__ */ application("conference-info+xml", "xml");
var Application_Cose = /* @__PURE__ */ application("cose");
var Application_Cose_Key = /* @__PURE__ */ application("cose-key");
var Application_Cose_Key_Set = /* @__PURE__ */ application("cose-key-set");
var Application_CplXml = /* @__PURE__ */ application("cpl+xml", "xml");
var Application_Csrattrs = /* @__PURE__ */ application("csrattrs");
var Application_CSTAdataXml = /* @__PURE__ */ application("cstadata+xml", "xml");
var Application_CstaXml = /* @__PURE__ */ application("csta+xml", "xml");
var Application_CsvmJson = /* @__PURE__ */ application("csvm+json", "json");
var Application_Cu_Seeme = /* @__PURE__ */ application("cu-seeme", "cu");
var Application_Cwt = /* @__PURE__ */ application("cwt");
var Application_Cybercash = /* @__PURE__ */ application("cybercash");
var Application_Dart = /* @__PURE__ */ application("dart");
var Application_Dashdelta = /* @__PURE__ */ application("dashdelta");
var Application_DashXml = /* @__PURE__ */ application("dash+xml", "xml");
var Application_DavmountXml = /* @__PURE__ */ application("davmount+xml", "davmount");
var Application_Dca_Rft = /* @__PURE__ */ application("dca-rft");
var Application_DCD = /* @__PURE__ */ application("dcd");
var Application_Dec_Dx = /* @__PURE__ */ application("dec-dx");
var Application_Dialog_InfoXml = /* @__PURE__ */ application("dialog-info+xml", "xml");
var Application_Dicom = /* @__PURE__ */ application("dicom");
var Application_DicomJson = /* @__PURE__ */ application("dicom+json", "json");
var Application_DicomXml = /* @__PURE__ */ application("dicom+xml", "xml");
var Application_DII = /* @__PURE__ */ application("dii");
var Application_DIT = /* @__PURE__ */ application("dit");
var Application_Dns = /* @__PURE__ */ application("dns");
var Application_Dns_Message = /* @__PURE__ */ application("dns-message");
var Application_DnsJson = /* @__PURE__ */ application("dns+json", "json");
var Application_DocbookXml = /* @__PURE__ */ application("docbook+xml", "dbk");
var Application_DotsCbor = /* @__PURE__ */ application("dots+cbor", "cbor");
var Application_DskppXml = /* @__PURE__ */ application("dskpp+xml", "xml");
var Application_DsscDer = /* @__PURE__ */ application("dssc+der", "dssc");
var Application_DsscXml = /* @__PURE__ */ application("dssc+xml", "xdssc");
var Application_Dvcs = /* @__PURE__ */ application("dvcs");
var Application_Ecmascript = /* @__PURE__ */ application("ecmascript", "ecma");
var Application_EDI_Consent = /* @__PURE__ */ application("edi-consent");
var Application_EDI_X12 = /* @__PURE__ */ application("edi-x12");
var Application_EDIFACT = /* @__PURE__ */ application("edifact");
var Application_Efi = /* @__PURE__ */ application("efi");
var Application_EmergencyCallDataCommentXml = /* @__PURE__ */ application("emergencycalldata.comment+xml", "xml");
var Application_EmergencyCallDataControlXml = /* @__PURE__ */ application("emergencycalldata.control+xml", "xml");
var Application_EmergencyCallDataDeviceInfoXml = /* @__PURE__ */ application("emergencycalldata.deviceinfo+xml", "xml");
var Application_EmergencyCallDataECallMSD = /* @__PURE__ */ application("emergencycalldata.ecall.msd");
var Application_EmergencyCallDataProviderInfoXml = /* @__PURE__ */ application("emergencycalldata.providerinfo+xml", "xml");
var Application_EmergencyCallDataServiceInfoXml = /* @__PURE__ */ application("emergencycalldata.serviceinfo+xml", "xml");
var Application_EmergencyCallDataSubscriberInfoXml = /* @__PURE__ */ application("emergencycalldata.subscriberinfo+xml", "xml");
var Application_EmergencyCallDataVEDSXml = /* @__PURE__ */ application("emergencycalldata.veds+xml", "xml");
var Application_EmmaXml = /* @__PURE__ */ application("emma+xml", "emma");
var Application_EmotionmlXml = /* @__PURE__ */ application("emotionml+xml", "xml");
var Application_Encaprtp = /* @__PURE__ */ application("encaprtp");
var Application_EppXml = /* @__PURE__ */ application("epp+xml", "xml");
var Application_EpubZip = /* @__PURE__ */ application("epub+zip", "epub");
var Application_Eshop = /* @__PURE__ */ application("eshop");
var Application_Example = /* @__PURE__ */ application("example");
var Application_Exi = /* @__PURE__ */ application("exi", "exi");
var Application_Expect_Ct_ReportJson = /* @__PURE__ */ application("expect-ct-report+json", "json");
var Application_Fastinfoset = /* @__PURE__ */ application("fastinfoset");
var Application_Fastsoap = /* @__PURE__ */ application("fastsoap");
var Application_FdtXml = /* @__PURE__ */ application("fdt+xml", "xml");
var Application_FhirJson = /* @__PURE__ */ application("fhir+json", "json");
var Application_FhirXml = /* @__PURE__ */ application("fhir+xml", "xml");
var Application_Fido_TrustedAppsJson = /* @__PURE__ */ application("fido.trusted-apps+json");
var Application_Fits = /* @__PURE__ */ application("fits");
var Application_Flexfec = /* @__PURE__ */ application("flexfec");
var Application_Font_Sfnt = /* @__PURE__ */ application("font-sfnt").deprecate("in favor of font/sfnt");
var Application_Font_Tdpfr = /* @__PURE__ */ application("font-tdpfr", "pfr");
var Application_Font_Woff = /* @__PURE__ */ application("font-woff").deprecate("in favor of font/woff");
var Application_Framework_AttributesXml = /* @__PURE__ */ application("framework-attributes+xml", "xml");
var Application_GeoJson = /* @__PURE__ */ application("geo+json", "json");
var Application_GeoJson_Seq = /* @__PURE__ */ application("geo+json-seq", "json-seq");
var Application_GeopackageSqlite3 = /* @__PURE__ */ application("geopackage+sqlite3", "sqlite3");
var Application_GeoxacmlXml = /* @__PURE__ */ application("geoxacml+xml", "xml");
var Application_Gltf_Buffer = /* @__PURE__ */ application("gltf-buffer");
var Application_GmlXml = /* @__PURE__ */ application("gml+xml", "gml");
var Application_GpxXml = /* @__PURE__ */ application("gpx+xml", "gpx");
var Application_Gxf = /* @__PURE__ */ application("gxf", "gxf");
var Application_Gzip = /* @__PURE__ */ application("gzip");
var Application_H224 = /* @__PURE__ */ application("h224");
var Application_HeldXml = /* @__PURE__ */ application("held+xml", "xml");
var Application_Hjson = /* @__PURE__ */ application("hjson", "hjson");
var Application_Http = /* @__PURE__ */ application("http");
var Application_Hyperstudio = /* @__PURE__ */ application("hyperstudio", "stk");
var Application_Ibe_Key_RequestXml = /* @__PURE__ */ application("ibe-key-request+xml", "xml");
var Application_Ibe_Pkg_ReplyXml = /* @__PURE__ */ application("ibe-pkg-reply+xml", "xml");
var Application_Ibe_Pp_Data = /* @__PURE__ */ application("ibe-pp-data");
var Application_Iges = /* @__PURE__ */ application("iges");
var Application_Im_IscomposingXml = /* @__PURE__ */ application("im-iscomposing+xml", "xml");
var Application_Index = /* @__PURE__ */ application("index");
var Application_IndexCmd = /* @__PURE__ */ application("index.cmd");
var Application_IndexObj = /* @__PURE__ */ application("index.obj");
var Application_IndexResponse = /* @__PURE__ */ application("index.response");
var Application_IndexVnd = /* @__PURE__ */ application("index.vnd");
var Application_InkmlXml = /* @__PURE__ */ application("inkml+xml", "ink", "inkml");
var Application_IOTP = /* @__PURE__ */ application("iotp");
var Application_Ipfix = /* @__PURE__ */ application("ipfix", "ipfix");
var Application_Ipp = /* @__PURE__ */ application("ipp");
var Application_ISUP = /* @__PURE__ */ application("isup");
var Application_ItsXml = /* @__PURE__ */ application("its+xml", "xml");
var Application_Java_Archive = /* @__PURE__ */ application("java-archive", "jar");
var Application_Java_Serialized_Object = /* @__PURE__ */ application("java-serialized-object", "ser");
var Application_Java_Vm = /* @__PURE__ */ application("java-vm", "class");
var Application_Javascript = /* @__PURE__ */ application("javascript", "js");
var Application_Jf2feedJson = /* @__PURE__ */ application("jf2feed+json", "json");
var Application_Jose = /* @__PURE__ */ application("jose");
var Application_JoseJson = /* @__PURE__ */ application("jose+json", "json");
var Application_JrdJson = /* @__PURE__ */ application("jrd+json", "json");
var Application_Json = /* @__PURE__ */ application("json", "json");
var Application_Json5 = /* @__PURE__ */ application("json5", "json5");
var Application_JsonUTF8 = /* @__PURE__ */ application("json; charset=UTF-8", "json");
var Application_Json_PatchJson = /* @__PURE__ */ application("json-patch+json", "json");
var Application_Json_Seq = /* @__PURE__ */ application("json-seq");
var Application_JsonmlJson = /* @__PURE__ */ application("jsonml+json", "jsonml");
var Application_Jwk_SetJson = /* @__PURE__ */ application("jwk-set+json", "json");
var Application_JwkJson = /* @__PURE__ */ application("jwk+json", "json");
var Application_Jwt = /* @__PURE__ */ application("jwt");
var Application_Kpml_RequestXml = /* @__PURE__ */ application("kpml-request+xml", "xml");
var Application_Kpml_ResponseXml = /* @__PURE__ */ application("kpml-response+xml", "xml");
var Application_LdJson = /* @__PURE__ */ application("ld+json", "json");
var Application_LgrXml = /* @__PURE__ */ application("lgr+xml", "xml");
var Application_Link_Format = /* @__PURE__ */ application("link-format");
var Application_Load_ControlXml = /* @__PURE__ */ application("load-control+xml", "xml");
var Application_LostsyncXml = /* @__PURE__ */ application("lostsync+xml", "xml");
var Application_LostXml = /* @__PURE__ */ application("lost+xml", "lostxml");
var Application_LXF = /* @__PURE__ */ application("lxf");
var Application_Mac_Binhex40 = /* @__PURE__ */ application("mac-binhex40", "hqx");
var Application_Mac_Compactpro = /* @__PURE__ */ application("mac-compactpro", "cpt");
var Application_Macwriteii = /* @__PURE__ */ application("macwriteii");
var Application_MadsXml = /* @__PURE__ */ application("mads+xml", "mads");
var Application_ManifestJson = /* @__PURE__ */ application("manifest+json", "webmanifest");
var Application_Marc = /* @__PURE__ */ application("marc", "mrc");
var Application_MarcxmlXml = /* @__PURE__ */ application("marcxml+xml", "mrcx");
var Application_Mathematica = /* @__PURE__ */ application("mathematica", "ma", "nb", "mb");
var Application_Mathml_ContentXml = /* @__PURE__ */ application("mathml-content+xml", "xml");
var Application_Mathml_PresentationXml = /* @__PURE__ */ application("mathml-presentation+xml", "xml");
var Application_MathmlXml = /* @__PURE__ */ application("mathml+xml", "mathml");
var Application_Mbms_Associated_Procedure_DescriptionXml = /* @__PURE__ */ application("mbms-associated-procedure-description+xml", "xml");
var Application_Mbms_DeregisterXml = /* @__PURE__ */ application("mbms-deregister+xml", "xml");
var Application_Mbms_EnvelopeXml = /* @__PURE__ */ application("mbms-envelope+xml", "xml");
var Application_Mbms_Msk_ResponseXml = /* @__PURE__ */ application("mbms-msk-response+xml", "xml");
var Application_Mbms_MskXml = /* @__PURE__ */ application("mbms-msk+xml", "xml");
var Application_Mbms_Protection_DescriptionXml = /* @__PURE__ */ application("mbms-protection-description+xml", "xml");
var Application_Mbms_Reception_ReportXml = /* @__PURE__ */ application("mbms-reception-report+xml", "xml");
var Application_Mbms_Register_ResponseXml = /* @__PURE__ */ application("mbms-register-response+xml", "xml");
var Application_Mbms_RegisterXml = /* @__PURE__ */ application("mbms-register+xml", "xml");
var Application_Mbms_ScheduleXml = /* @__PURE__ */ application("mbms-schedule+xml", "xml");
var Application_Mbms_User_Service_DescriptionXml = /* @__PURE__ */ application("mbms-user-service-description+xml", "xml");
var Application_Mbox = /* @__PURE__ */ application("mbox", "mbox");
var Application_Media_controlXml = /* @__PURE__ */ application("media_control+xml", "xml");
var Application_Media_Policy_DatasetXml = /* @__PURE__ */ application("media-policy-dataset+xml", "xml");
var Application_MediaservercontrolXml = /* @__PURE__ */ application("mediaservercontrol+xml", "mscml");
var Application_Merge_PatchJson = /* @__PURE__ */ application("merge-patch+json", "json");
var Application_Metalink4Xml = /* @__PURE__ */ application("metalink4+xml", "meta4");
var Application_MetalinkXml = /* @__PURE__ */ application("metalink+xml", "metalink");
var Application_MetsXml = /* @__PURE__ */ application("mets+xml", "mets");
var Application_MF4 = /* @__PURE__ */ application("mf4");
var Application_Mikey = /* @__PURE__ */ application("mikey");
var Application_Mipc = /* @__PURE__ */ application("mipc");
var Application_Mmt_AeiXml = /* @__PURE__ */ application("mmt-aei+xml", "xml");
var Application_Mmt_UsdXml = /* @__PURE__ */ application("mmt-usd+xml", "xml");
var Application_ModsXml = /* @__PURE__ */ application("mods+xml", "mods");
var Application_Moss_Keys = /* @__PURE__ */ application("moss-keys");
var Application_Moss_Signature = /* @__PURE__ */ application("moss-signature");
var Application_Mosskey_Data = /* @__PURE__ */ application("mosskey-data");
var Application_Mosskey_Request = /* @__PURE__ */ application("mosskey-request");
var Application_Mp21 = /* @__PURE__ */ application("mp21", "m21", "mp21");
var Application_Mp4 = /* @__PURE__ */ application("mp4", "mp4s");
var Application_Mpeg4_Generic = /* @__PURE__ */ application("mpeg4-generic");
var Application_Mpeg4_Iod = /* @__PURE__ */ application("mpeg4-iod");
var Application_Mpeg4_Iod_Xmt = /* @__PURE__ */ application("mpeg4-iod-xmt");
var Application_Mrb_ConsumerXml = /* @__PURE__ */ application("mrb-consumer+xml", "xml");
var Application_Mrb_PublishXml = /* @__PURE__ */ application("mrb-publish+xml", "xml");
var Application_Msc_IvrXml = /* @__PURE__ */ application("msc-ivr+xml", "xml");
var Application_Msc_MixerXml = /* @__PURE__ */ application("msc-mixer+xml", "xml");
var Application_Msword = /* @__PURE__ */ application("msword", "doc", "dot");
var Application_MudJson = /* @__PURE__ */ application("mud+json", "json");
var Application_Multipart_Core = /* @__PURE__ */ application("multipart-core");
var Application_Mxf = /* @__PURE__ */ application("mxf", "mxf");
var Application_N_Quads = /* @__PURE__ */ application("n-quads");
var Application_N_Triples = /* @__PURE__ */ application("n-triples");
var Application_Nasdata = /* @__PURE__ */ application("nasdata");
var Application_News_Checkgroups = /* @__PURE__ */ application("news-checkgroups");
var Application_News_Groupinfo = /* @__PURE__ */ application("news-groupinfo");
var Application_News_Transmission = /* @__PURE__ */ application("news-transmission");
var Application_NlsmlXml = /* @__PURE__ */ application("nlsml+xml", "xml");
var Application_Node = /* @__PURE__ */ application("node");
var Application_Nss = /* @__PURE__ */ application("nss");
var Application_Ocsp_Request = /* @__PURE__ */ application("ocsp-request");
var Application_Ocsp_Response = /* @__PURE__ */ application("ocsp-response");
var Application_Octet_Stream = /* @__PURE__ */ application("octet-stream", "bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy");
var Application_ODA = /* @__PURE__ */ application("oda", "oda");
var Application_OdmXml = /* @__PURE__ */ application("odm+xml", "xml");
var Application_ODX = /* @__PURE__ */ application("odx");
var Application_Oebps_PackageXml = /* @__PURE__ */ application("oebps-package+xml", "opf");
var Application_Ogg = /* @__PURE__ */ application("ogg", "ogx");
var Application_OmdocXml = /* @__PURE__ */ application("omdoc+xml", "omdoc");
var Application_Onenote = /* @__PURE__ */ application("onenote", "onetoc", "onetoc2", "onetmp", "onepkg");
var Application_Oscore = /* @__PURE__ */ application("oscore");
var Application_Oxps = /* @__PURE__ */ application("oxps", "oxps");
var Application_P2p_OverlayXml = /* @__PURE__ */ application("p2p-overlay+xml", "xml");
var Application_Parityfec = /* @__PURE__ */ application("parityfec");
var Application_Passport = /* @__PURE__ */ application("passport");
var Application_Patch_Ops_ErrorXml = /* @__PURE__ */ application("patch-ops-error+xml", "xer");
var Application_Pdf = /* @__PURE__ */ application("pdf", "pdf");
var Application_PDX = /* @__PURE__ */ application("pdx");
var Application_Pem_Certificate_Chain = /* @__PURE__ */ application("pem-certificate-chain");
var Application_Pgp_Encrypted = /* @__PURE__ */ application("pgp-encrypted", "pgp");
var Application_Pgp_Keys = /* @__PURE__ */ application("pgp-keys");
var Application_Pgp_Signature = /* @__PURE__ */ application("pgp-signature", "asc", "sig");
var Application_Pics_Rules = /* @__PURE__ */ application("pics-rules", "prf");
var Application_Pidf_DiffXml = /* @__PURE__ */ application("pidf-diff+xml", "xml");
var Application_PidfXml = /* @__PURE__ */ application("pidf+xml", "xml");
var Application_Pkcs10 = /* @__PURE__ */ application("pkcs10", "p10");
var Application_Pkcs12 = /* @__PURE__ */ application("pkcs12");
var Application_Pkcs7_Mime = /* @__PURE__ */ application("pkcs7-mime", "p7m", "p7c");
var Application_Pkcs7_Signature = /* @__PURE__ */ application("pkcs7-signature", "p7s");
var Application_Pkcs8 = /* @__PURE__ */ application("pkcs8", "p8");
var Application_Pkcs8_Encrypted = /* @__PURE__ */ application("pkcs8-encrypted");
var Application_Pkix_Attr_Cert = /* @__PURE__ */ application("pkix-attr-cert", "ac");
var Application_Pkix_Cert = /* @__PURE__ */ application("pkix-cert", "cer");
var Application_Pkix_Crl = /* @__PURE__ */ application("pkix-crl", "crl");
var Application_Pkix_Pkipath = /* @__PURE__ */ application("pkix-pkipath", "pkipath");
var Application_Pkixcmp = /* @__PURE__ */ application("pkixcmp", "pki");
var Application_PlsXml = /* @__PURE__ */ application("pls+xml", "pls");
var Application_Poc_SettingsXml = /* @__PURE__ */ application("poc-settings+xml", "xml");
var Application_Postscript = /* @__PURE__ */ application("postscript", "ai", "eps", "ps");
var Application_Ppsp_TrackerJson = /* @__PURE__ */ application("ppsp-tracker+json", "json");
var Application_ProblemJson = /* @__PURE__ */ application("problem+json", "json");
var Application_ProblemXml = /* @__PURE__ */ application("problem+xml", "xml");
var Application_ProvenanceXml = /* @__PURE__ */ application("provenance+xml", "xml");
var Application_PrsAlvestrandTitrax_Sheet = /* @__PURE__ */ application("prs.alvestrand.titrax-sheet");
var Application_PrsCww = /* @__PURE__ */ application("prs.cww", "cww");
var Application_PrsHpubZip = /* @__PURE__ */ application("prs.hpub+zip", "zip");
var Application_PrsNprend = /* @__PURE__ */ application("prs.nprend");
var Application_PrsPlucker = /* @__PURE__ */ application("prs.plucker");
var Application_PrsRdf_Xml_Crypt = /* @__PURE__ */ application("prs.rdf-xml-crypt");
var Application_PrsXsfXml = /* @__PURE__ */ application("prs.xsf+xml", "xml");
var Application_PskcXml = /* @__PURE__ */ application("pskc+xml", "pskcxml");
var Application_QSIG = /* @__PURE__ */ application("qsig");
var Application_RamlYaml = /* @__PURE__ */ application("raml+yaml", "raml");
var Application_Raptorfec = /* @__PURE__ */ application("raptorfec");
var Application_RdapJson = /* @__PURE__ */ application("rdap+json", "json");
var Application_RdfXml = /* @__PURE__ */ application("rdf+xml", "rdf");
var Application_ReginfoXml = /* @__PURE__ */ application("reginfo+xml", "rif");
var Application_Relax_Ng_Compact_Syntax = /* @__PURE__ */ application("relax-ng-compact-syntax", "rnc");
var Application_Remote_Printing = /* @__PURE__ */ application("remote-printing");
var Application_ReputonJson = /* @__PURE__ */ application("reputon+json", "json");
var Application_Resource_Lists_DiffXml = /* @__PURE__ */ application("resource-lists-diff+xml", "rld");
var Application_Resource_ListsXml = /* @__PURE__ */ application("resource-lists+xml", "rl");
var Application_RfcXml = /* @__PURE__ */ application("rfc+xml", "xml");
var Application_Riscos = /* @__PURE__ */ application("riscos");
var Application_RlmiXml = /* @__PURE__ */ application("rlmi+xml", "xml");
var Application_Rls_ServicesXml = /* @__PURE__ */ application("rls-services+xml", "rs");
var Application_Route_ApdXml = /* @__PURE__ */ application("route-apd+xml", "xml");
var Application_Route_S_TsidXml = /* @__PURE__ */ application("route-s-tsid+xml", "xml");
var Application_Route_UsdXml = /* @__PURE__ */ application("route-usd+xml", "xml");
var Application_Rpki_Ghostbusters = /* @__PURE__ */ application("rpki-ghostbusters", "gbr");
var Application_Rpki_Manifest = /* @__PURE__ */ application("rpki-manifest", "mft");
var Application_Rpki_Publication = /* @__PURE__ */ application("rpki-publication");
var Application_Rpki_Roa = /* @__PURE__ */ application("rpki-roa", "roa");
var Application_Rpki_Updown = /* @__PURE__ */ application("rpki-updown");
var Application_RsdXml = /* @__PURE__ */ application("rsd+xml", "rsd");
var Application_RssXml = /* @__PURE__ */ application("rss+xml", "rss");
var Application_Rtf = /* @__PURE__ */ application("rtf", "rtf");
var Application_Rtploopback = /* @__PURE__ */ application("rtploopback");
var Application_Rtx = /* @__PURE__ */ application("rtx");
var Application_SamlassertionXml = /* @__PURE__ */ application("samlassertion+xml", "xml");
var Application_SamlmetadataXml = /* @__PURE__ */ application("samlmetadata+xml", "xml");
var Application_SbmlXml = /* @__PURE__ */ application("sbml+xml", "sbml");
var Application_ScaipXml = /* @__PURE__ */ application("scaip+xml", "xml");
var Application_ScimJson = /* @__PURE__ */ application("scim+json", "json");
var Application_Scvp_Cv_Request = /* @__PURE__ */ application("scvp-cv-request", "scq");
var Application_Scvp_Cv_Response = /* @__PURE__ */ application("scvp-cv-response", "scs");
var Application_Scvp_Vp_Request = /* @__PURE__ */ application("scvp-vp-request", "spq");
var Application_Scvp_Vp_Response = /* @__PURE__ */ application("scvp-vp-response", "spp");
var Application_Sdp = /* @__PURE__ */ application("sdp", "sdp");
var Application_SeceventJwt = /* @__PURE__ */ application("secevent+jwt", "jwt");
var Application_Senml_Exi = /* @__PURE__ */ application("senml-exi");
var Application_SenmlCbor = /* @__PURE__ */ application("senml+cbor", "cbor");
var Application_SenmlJson = /* @__PURE__ */ application("senml+json", "json");
var Application_SenmlXml = /* @__PURE__ */ application("senml+xml", "xml");
var Application_Sensml_Exi = /* @__PURE__ */ application("sensml-exi");
var Application_SensmlCbor = /* @__PURE__ */ application("sensml+cbor", "cbor");
var Application_SensmlJson = /* @__PURE__ */ application("sensml+json", "json");
var Application_SensmlXml = /* @__PURE__ */ application("sensml+xml", "xml");
var Application_Sep_Exi = /* @__PURE__ */ application("sep-exi");
var Application_SepXml = /* @__PURE__ */ application("sep+xml", "xml");
var Application_Session_Info = /* @__PURE__ */ application("session-info");
var Application_Set_Payment = /* @__PURE__ */ application("set-payment");
var Application_Set_Payment_Initiation = /* @__PURE__ */ application("set-payment-initiation", "setpay");
var Application_Set_Registration = /* @__PURE__ */ application("set-registration");
var Application_Set_Registration_Initiation = /* @__PURE__ */ application("set-registration-initiation", "setreg");
var Application_SGML = /* @__PURE__ */ application("sgml");
var Application_Sgml_Open_Catalog = /* @__PURE__ */ application("sgml-open-catalog");
var Application_ShfXml = /* @__PURE__ */ application("shf+xml", "shf");
var Application_Sieve = /* @__PURE__ */ application("sieve");
var Application_Simple_FilterXml = /* @__PURE__ */ application("simple-filter+xml", "xml");
var Application_Simple_Message_Summary = /* @__PURE__ */ application("simple-message-summary");
var Application_SimpleSymbolContainer = /* @__PURE__ */ application("simplesymbolcontainer");
var Application_Sipc = /* @__PURE__ */ application("sipc");
var Application_Slate = /* @__PURE__ */ application("slate");
var Application_Smil = /* @__PURE__ */ application("smil").deprecate("in favor of application/smil+xml");
var Application_SmilXml = /* @__PURE__ */ application("smil+xml", "smi", "smil");
var Application_Smpte336m = /* @__PURE__ */ application("smpte336m");
var Application_SoapFastinfoset = /* @__PURE__ */ application("soap+fastinfoset", "fastinfoset");
var Application_SoapXml = /* @__PURE__ */ application("soap+xml", "xml");
var Application_Sparql_Query = /* @__PURE__ */ application("sparql-query", "rq");
var Application_Sparql_ResultsXml = /* @__PURE__ */ application("sparql-results+xml", "srx");
var Application_Spirits_EventXml = /* @__PURE__ */ application("spirits-event+xml", "xml");
var Application_Sql = /* @__PURE__ */ application("sql");
var Application_Srgs = /* @__PURE__ */ application("srgs", "gram");
var Application_SrgsXml = /* @__PURE__ */ application("srgs+xml", "grxml");
var Application_SruXml = /* @__PURE__ */ application("sru+xml", "sru");
var Application_SsdlXml = /* @__PURE__ */ application("ssdl+xml", "ssdl");
var Application_SsmlXml = /* @__PURE__ */ application("ssml+xml", "ssml");
var Application_StixJson = /* @__PURE__ */ application("stix+json", "json");
var Application_SwidXml = /* @__PURE__ */ application("swid+xml", "xml");
var Application_Tamp_Apex_Update = /* @__PURE__ */ application("tamp-apex-update");
var Application_Tamp_Apex_Update_Confirm = /* @__PURE__ */ application("tamp-apex-update-confirm");
var Application_Tamp_Community_Update = /* @__PURE__ */ application("tamp-community-update");
var Application_Tamp_Community_Update_Confirm = /* @__PURE__ */ application("tamp-community-update-confirm");
var Application_Tamp_Error = /* @__PURE__ */ application("tamp-error");
var Application_Tamp_Sequence_Adjust = /* @__PURE__ */ application("tamp-sequence-adjust");
var Application_Tamp_Sequence_Adjust_Confirm = /* @__PURE__ */ application("tamp-sequence-adjust-confirm");
var Application_Tamp_Status_Query = /* @__PURE__ */ application("tamp-status-query");
var Application_Tamp_Status_Response = /* @__PURE__ */ application("tamp-status-response");
var Application_Tamp_Update = /* @__PURE__ */ application("tamp-update");
var Application_Tamp_Update_Confirm = /* @__PURE__ */ application("tamp-update-confirm");
var Application_Tar = /* @__PURE__ */ application("tar");
var Application_TaxiiJson = /* @__PURE__ */ application("taxii+json", "json");
var Application_TeiXml = /* @__PURE__ */ application("tei+xml", "tei", "teicorpus");
var Application_TETRA_ISI = /* @__PURE__ */ application("tetra_isi");
var Application_ThraudXml = /* @__PURE__ */ application("thraud+xml", "tfi");
var Application_Timestamp_Query = /* @__PURE__ */ application("timestamp-query");
var Application_Timestamp_Reply = /* @__PURE__ */ application("timestamp-reply");
var Application_Timestamped_Data = /* @__PURE__ */ application("timestamped-data", "tsd");
var Application_TlsrptGzip = /* @__PURE__ */ application("tlsrpt+gzip", "gzip");
var Application_TlsrptJson = /* @__PURE__ */ application("tlsrpt+json", "json");
var Application_Tnauthlist = /* @__PURE__ */ application("tnauthlist");
var Application_Toml = /* @__PURE__ */ application("toml", "toml");
var Application_Trickle_Ice_Sdpfrag = /* @__PURE__ */ application("trickle-ice-sdpfrag");
var Application_Trig = /* @__PURE__ */ application("trig");
var Application_TtmlXml = /* @__PURE__ */ application("ttml+xml", "xml");
var Application_Tve_Trigger = /* @__PURE__ */ application("tve-trigger");
var Application_Tzif = /* @__PURE__ */ application("tzif");
var Application_Tzif_Leap = /* @__PURE__ */ application("tzif-leap");
var Application_Ubjson = /* @__PURE__ */ application("ubjson", "ubj");
var Application_Ulpfec = /* @__PURE__ */ application("ulpfec");
var Application_Urc_GrpsheetXml = /* @__PURE__ */ application("urc-grpsheet+xml", "xml");
var Application_Urc_RessheetXml = /* @__PURE__ */ application("urc-ressheet+xml", "xml");
var Application_Urc_TargetdescXml = /* @__PURE__ */ application("urc-targetdesc+xml", "xml");
var Application_Urc_UisocketdescXml = /* @__PURE__ */ application("urc-uisocketdesc+xml", "xml");
var Application_VcardJson = /* @__PURE__ */ application("vcard+json", "json");
var Application_VcardXml = /* @__PURE__ */ application("vcard+xml", "xml");
var Application_Vemmi = /* @__PURE__ */ application("vemmi");
var Application_Vendor_1000mindsDecision_ModelXml = /* @__PURE__ */ application("vnd.1000minds.decision-model+xml", "xml");
var Application_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ application("1d-interleaved-parityfec");
var Application_Vendor_3gpdash_Qoe_ReportXml = /* @__PURE__ */ application("3gpdash-qoe-report+xml", "xml");
var Application_Vendor_3gpp_ImsXml = /* @__PURE__ */ application("3gpp-ims+xml", "xml");
var Application_Vendor_3gpp_Prose_Pc3chXml = /* @__PURE__ */ application("vnd.3gpp-prose-pc3ch+xml", "xml");
var Application_Vendor_3gpp_ProseXml = /* @__PURE__ */ application("vnd.3gpp-prose+xml", "xml");
var Application_Vendor_3gpp_V2x_Local_Service_Information = /* @__PURE__ */ application("vnd.3gpp-v2x-local-service-information");
var Application_Vendor_3gpp2BcmcsinfoXml = /* @__PURE__ */ application("vnd.3gpp2.bcmcsinfo+xml", "xml");
var Application_Vendor_3gpp2Sms = /* @__PURE__ */ application("vnd.3gpp2.sms");
var Application_Vendor_3gpp2Tcap = /* @__PURE__ */ application("vnd.3gpp2.tcap", "tcap");
var Application_Vendor_3gppAccess_Transfer_EventsXml = /* @__PURE__ */ application("vnd.3gpp.access-transfer-events+xml", "xml");
var Application_Vendor_3gppBsfXml = /* @__PURE__ */ application("vnd.3gpp.bsf+xml", "xml");
var Application_Vendor_3gppGMOPXml = /* @__PURE__ */ application("vnd.3gpp.gmop+xml", "xml");
var Application_Vendor_3gppMc_Signalling_Ear = /* @__PURE__ */ application("vnd.3gpp.mc-signalling-ear");
var Application_Vendor_3gppMcdata_Affiliation_CommandXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-affiliation-command+xml", "xml");
var Application_Vendor_3gppMcdata_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-info+xml", "xml");
var Application_Vendor_3gppMcdata_Payload = /* @__PURE__ */ application("vnd.3gpp.mcdata-payload");
var Application_Vendor_3gppMcdata_Service_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-service-config+xml", "xml");
var Application_Vendor_3gppMcdata_Signalling = /* @__PURE__ */ application("vnd.3gpp.mcdata-signalling");
var Application_Vendor_3gppMcdata_Ue_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-ue-config+xml", "xml");
var Application_Vendor_3gppMcdata_User_ProfileXml = /* @__PURE__ */ application("vnd.3gpp.mcdata-user-profile+xml", "xml");
var Application_Vendor_3gppMcptt_Affiliation_CommandXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-affiliation-command+xml", "xml");
var Application_Vendor_3gppMcptt_Floor_RequestXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-floor-request+xml", "xml");
var Application_Vendor_3gppMcptt_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-info+xml", "xml");
var Application_Vendor_3gppMcptt_Location_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-location-info+xml", "xml");
var Application_Vendor_3gppMcptt_Mbms_Usage_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-mbms-usage-info+xml", "xml");
var Application_Vendor_3gppMcptt_Service_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-service-config+xml", "xml");
var Application_Vendor_3gppMcptt_SignedXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-signed+xml", "xml");
var Application_Vendor_3gppMcptt_Ue_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-ue-config+xml", "xml");
var Application_Vendor_3gppMcptt_Ue_Init_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-ue-init-config+xml", "xml");
var Application_Vendor_3gppMcptt_User_ProfileXml = /* @__PURE__ */ application("vnd.3gpp.mcptt-user-profile+xml", "xml");
var Application_Vendor_3gppMcvideo_Affiliation_CommandXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-affiliation-command+xml", "xml");
var Application_Vendor_3gppMcvideo_Affiliation_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-affiliation-info+xml", "xml").deprecate("in favor of application/vnd.3gpp.mcvideo-info+xml");
var Application_Vendor_3gppMcvideo_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-info+xml", "xml");
var Application_Vendor_3gppMcvideo_Location_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-location-info+xml", "xml");
var Application_Vendor_3gppMcvideo_Mbms_Usage_InfoXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-mbms-usage-info+xml", "xml");
var Application_Vendor_3gppMcvideo_Service_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-service-config+xml", "xml");
var Application_Vendor_3gppMcvideo_Transmission_RequestXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-transmission-request+xml", "xml");
var Application_Vendor_3gppMcvideo_Ue_ConfigXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-ue-config+xml", "xml");
var Application_Vendor_3gppMcvideo_User_ProfileXml = /* @__PURE__ */ application("vnd.3gpp.mcvideo-user-profile+xml", "xml");
var Application_Vendor_3gppMid_CallXml = /* @__PURE__ */ application("vnd.3gpp.mid-call+xml", "xml");
var Application_Vendor_3gppPic_Bw_Large = /* @__PURE__ */ application("vnd.3gpp.pic-bw-large", "plb");
var Application_Vendor_3gppPic_Bw_Small = /* @__PURE__ */ application("vnd.3gpp.pic-bw-small", "psb");
var Application_Vendor_3gppPic_Bw_Var = /* @__PURE__ */ application("vnd.3gpp.pic-bw-var", "pvb");
var Application_Vendor_3gppSms = /* @__PURE__ */ application("vnd.3gpp.sms");
var Application_Vendor_3gppSmsXml = /* @__PURE__ */ application("vnd.3gpp.sms+xml", "xml");
var Application_Vendor_3gppSrvcc_ExtXml = /* @__PURE__ */ application("vnd.3gpp.srvcc-ext+xml", "xml");
var Application_Vendor_3gppSRVCC_InfoXml = /* @__PURE__ */ application("vnd.3gpp.srvcc-info+xml", "xml");
var Application_Vendor_3gppState_And_Event_InfoXml = /* @__PURE__ */ application("vnd.3gpp.state-and-event-info+xml", "xml");
var Application_Vendor_3gppUssdXml = /* @__PURE__ */ application("vnd.3gpp.ussd+xml", "xml");
var Application_Vendor_3lightssoftwareImagescal = /* @__PURE__ */ application("vnd.3lightssoftware.imagescal");
var Application_Vendor_3MPost_It_Notes = /* @__PURE__ */ application("vnd.3m.post-it-notes", "pwn");
var Application_Vendor_AccpacSimplyAso = /* @__PURE__ */ application("vnd.accpac.simply.aso", "aso");
var Application_Vendor_AccpacSimplyImp = /* @__PURE__ */ application("vnd.accpac.simply.imp", "imp");
var Application_Vendor_Acucobol = /* @__PURE__ */ application("vnd.acucobol", "acu");
var Application_Vendor_Acucorp = /* @__PURE__ */ application("vnd.acucorp", "atc", "acutc");
var Application_Vendor_AdobeAir_Application_Installer_PackageZip = /* @__PURE__ */ application("vnd.adobe.air-application-installer-package+zip", "air");
var Application_Vendor_AdobeFlashMovie = /* @__PURE__ */ application("vnd.adobe.flash.movie");
var Application_Vendor_AdobeFormscentralFcdt = /* @__PURE__ */ application("vnd.adobe.formscentral.fcdt", "fcdt");
var Application_Vendor_AdobeFxp = /* @__PURE__ */ application("vnd.adobe.fxp", "fxp", "fxpl");
var Application_Vendor_AdobePartial_Upload = /* @__PURE__ */ application("vnd.adobe.partial-upload");
var Application_Vendor_AdobeXdpXml = /* @__PURE__ */ application("vnd.adobe.xdp+xml", "xdp");
var Application_Vendor_AdobeXfdf = /* @__PURE__ */ application("vnd.adobe.xfdf", "xfdf");
var Application_Vendor_AetherImp = /* @__PURE__ */ application("vnd.aether.imp");
var Application_Vendor_AfpcAfplinedata = /* @__PURE__ */ application("vnd.afpc.afplinedata");
var Application_Vendor_AfpcAfplinedata_Pagedef = /* @__PURE__ */ application("vnd.afpc.afplinedata-pagedef");
var Application_Vendor_AfpcFoca_Charset = /* @__PURE__ */ application("vnd.afpc.foca-charset");
var Application_Vendor_AfpcFoca_Codedfont = /* @__PURE__ */ application("vnd.afpc.foca-codedfont");
var Application_Vendor_AfpcFoca_Codepage = /* @__PURE__ */ application("vnd.afpc.foca-codepage");
var Application_Vendor_AfpcModca = /* @__PURE__ */ application("vnd.afpc.modca");
var Application_Vendor_AfpcModca_Formdef = /* @__PURE__ */ application("vnd.afpc.modca-formdef");
var Application_Vendor_AfpcModca_Mediummap = /* @__PURE__ */ application("vnd.afpc.modca-mediummap");
var Application_Vendor_AfpcModca_Objectcontainer = /* @__PURE__ */ application("vnd.afpc.modca-objectcontainer");
var Application_Vendor_AfpcModca_Overlay = /* @__PURE__ */ application("vnd.afpc.modca-overlay");
var Application_Vendor_AfpcModca_Pagesegment = /* @__PURE__ */ application("vnd.afpc.modca-pagesegment");
var Application_Vendor_Ah_Barcode = /* @__PURE__ */ application("vnd.ah-barcode");
var Application_Vendor_AheadSpace = /* @__PURE__ */ application("vnd.ahead.space", "ahead");
var Application_Vendor_AirzipFilesecureAzf = /* @__PURE__ */ application("vnd.airzip.filesecure.azf", "azf");
var Application_Vendor_AirzipFilesecureAzs = /* @__PURE__ */ application("vnd.airzip.filesecure.azs", "azs");
var Application_Vendor_AmadeusJson = /* @__PURE__ */ application("vnd.amadeus+json", "json");
var Application_Vendor_AmazonEbook = /* @__PURE__ */ application("vnd.amazon.ebook", "azw");
var Application_Vendor_AmazonMobi8_Ebook = /* @__PURE__ */ application("vnd.amazon.mobi8-ebook");
var Application_Vendor_AmericandynamicsAcc = /* @__PURE__ */ application("vnd.americandynamics.acc", "acc");
var Application_Vendor_AmigaAmi = /* @__PURE__ */ application("vnd.amiga.ami", "ami");
var Application_Vendor_AmundsenMazeXml = /* @__PURE__ */ application("vnd.amundsen.maze+xml", "xml");
var Application_Vendor_AndroidOta = /* @__PURE__ */ application("vnd.android.ota");
var Application_Vendor_AndroidPackage_Archive = /* @__PURE__ */ application("vnd.android.package-archive", "apk");
var Application_Vendor_Anki = /* @__PURE__ */ application("vnd.anki");
var Application_Vendor_Anser_Web_Certificate_Issue_Initiation = /* @__PURE__ */ application("vnd.anser-web-certificate-issue-initiation", "cii");
var Application_Vendor_Anser_Web_Funds_Transfer_Initiation = /* @__PURE__ */ application("vnd.anser-web-funds-transfer-initiation", "fti");
var Application_Vendor_AntixGame_Component = /* @__PURE__ */ application("vnd.antix.game-component", "atx");
var Application_Vendor_ApacheThriftBinary = /* @__PURE__ */ application("vnd.apache.thrift.binary");
var Application_Vendor_ApacheThriftCompact = /* @__PURE__ */ application("vnd.apache.thrift.compact");
var Application_Vendor_ApacheThriftJson = /* @__PURE__ */ application("vnd.apache.thrift.json");
var Application_Vendor_ApiJson = /* @__PURE__ */ application("vnd.api+json", "json");
var Application_Vendor_AplextorWarrpJson = /* @__PURE__ */ application("vnd.aplextor.warrp+json", "json");
var Application_Vendor_ApothekendeReservationJson = /* @__PURE__ */ application("vnd.apothekende.reservation+json", "json");
var Application_Vendor_AppleInstallerXml = /* @__PURE__ */ application("vnd.apple.installer+xml", "mpkg");
var Application_Vendor_AppleKeynote = /* @__PURE__ */ application("vnd.apple.keynote");
var Application_Vendor_AppleMpegurl = /* @__PURE__ */ application("vnd.apple.mpegurl", "m3u8");
var Application_Vendor_AppleNumbers = /* @__PURE__ */ application("vnd.apple.numbers");
var Application_Vendor_ApplePages = /* @__PURE__ */ application("vnd.apple.pages");
var Application_Vendor_ApplePkpass = /* @__PURE__ */ application("vnd.apple.pkpass", "pkpass");
var Application_Vendor_ArastraSwi = /* @__PURE__ */ application("vnd.arastra.swi").deprecate("in favor of application/vnd.aristanetworks.swi");
var Application_Vendor_AristanetworksSwi = /* @__PURE__ */ application("vnd.aristanetworks.swi", "swi");
var Application_Vendor_ArtisanJson = /* @__PURE__ */ application("vnd.artisan+json", "json");
var Application_Vendor_Artsquare = /* @__PURE__ */ application("vnd.artsquare");
var Application_Vendor_Astraea_SoftwareIota = /* @__PURE__ */ application("vnd.astraea-software.iota", "iota");
var Application_Vendor_Audiograph = /* @__PURE__ */ application("vnd.audiograph", "aep");
var Application_Vendor_Autopackage = /* @__PURE__ */ application("vnd.autopackage");
var Application_Vendor_AvalonJson = /* @__PURE__ */ application("vnd.avalon+json", "json");
var Application_Vendor_AvistarXml = /* @__PURE__ */ application("vnd.avistar+xml", "xml");
var Application_Vendor_BalsamiqBmmlXml = /* @__PURE__ */ application("vnd.balsamiq.bmml+xml", "xml");
var Application_Vendor_BalsamiqBmpr = /* @__PURE__ */ application("vnd.balsamiq.bmpr");
var Application_Vendor_Banana_Accounting = /* @__PURE__ */ application("vnd.banana-accounting");
var Application_Vendor_BbfUspError = /* @__PURE__ */ application("vnd.bbf.usp.error");
var Application_Vendor_BbfUspMsg = /* @__PURE__ */ application("vnd.bbf.usp.msg");
var Application_Vendor_BbfUspMsgJson = /* @__PURE__ */ application("vnd.bbf.usp.msg+json", "json");
var Application_Vendor_Bekitzur_StechJson = /* @__PURE__ */ application("vnd.bekitzur-stech+json", "json");
var Application_Vendor_BintMed_Content = /* @__PURE__ */ application("vnd.bint.med-content");
var Application_Vendor_BiopaxRdfXml = /* @__PURE__ */ application("vnd.biopax.rdf+xml", "xml");
var Application_Vendor_Blink_Idb_Value_Wrapper = /* @__PURE__ */ application("vnd.blink-idb-value-wrapper");
var Application_Vendor_BlueiceMultipass = /* @__PURE__ */ application("vnd.blueice.multipass", "mpm");
var Application_Vendor_BluetoothEpOob = /* @__PURE__ */ application("vnd.bluetooth.ep.oob");
var Application_Vendor_BluetoothLeOob = /* @__PURE__ */ application("vnd.bluetooth.le.oob");
var Application_Vendor_Bmi = /* @__PURE__ */ application("vnd.bmi", "bmi");
var Application_Vendor_Bpf = /* @__PURE__ */ application("vnd.bpf");
var Application_Vendor_Bpf3 = /* @__PURE__ */ application("vnd.bpf3");
var Application_Vendor_Businessobjects = /* @__PURE__ */ application("vnd.businessobjects", "rep");
var Application_Vendor_ByuUapiJson = /* @__PURE__ */ application("vnd.byu.uapi+json", "json");
var Application_Vendor_Cab_Jscript = /* @__PURE__ */ application("vnd.cab-jscript");
var Application_Vendor_Canon_Cpdl = /* @__PURE__ */ application("vnd.canon-cpdl");
var Application_Vendor_Canon_Lips = /* @__PURE__ */ application("vnd.canon-lips");
var Application_Vendor_Capasystems_PgJson = /* @__PURE__ */ application("vnd.capasystems-pg+json", "json");
var Application_Vendor_CendioThinlincClientconf = /* @__PURE__ */ application("vnd.cendio.thinlinc.clientconf");
var Application_Vendor_Century_SystemsTcp_stream = /* @__PURE__ */ application("vnd.century-systems.tcp_stream");
var Application_Vendor_ChemdrawXml = /* @__PURE__ */ application("vnd.chemdraw+xml", "cdxml");
var Application_Vendor_Chess_Pgn = /* @__PURE__ */ application("vnd.chess-pgn");
var Application_Vendor_ChipnutsKaraoke_Mmd = /* @__PURE__ */ application("vnd.chipnuts.karaoke-mmd", "mmd");
var Application_Vendor_Ciedi = /* @__PURE__ */ application("vnd.ciedi");
var Application_Vendor_Cinderella = /* @__PURE__ */ application("vnd.cinderella", "cdy");
var Application_Vendor_CirpackIsdn_Ext = /* @__PURE__ */ application("vnd.cirpack.isdn-ext");
var Application_Vendor_CitationstylesStyleXml = /* @__PURE__ */ application("vnd.citationstyles.style+xml", "xml");
var Application_Vendor_Claymore = /* @__PURE__ */ application("vnd.claymore", "cla");
var Application_Vendor_CloantoRp9 = /* @__PURE__ */ application("vnd.cloanto.rp9", "rp9");
var Application_Vendor_ClonkC4group = /* @__PURE__ */ application("vnd.clonk.c4group", "c4g", "c4d", "c4f", "c4p", "c4u");
var Application_Vendor_CluetrustCartomobile_Config = /* @__PURE__ */ application("vnd.cluetrust.cartomobile-config", "c11amc");
var Application_Vendor_CluetrustCartomobile_Config_Pkg = /* @__PURE__ */ application("vnd.cluetrust.cartomobile-config-pkg", "c11amz");
var Application_Vendor_Coffeescript = /* @__PURE__ */ application("vnd.coffeescript");
var Application_Vendor_CollabioXodocumentsDocument = /* @__PURE__ */ application("vnd.collabio.xodocuments.document");
var Application_Vendor_CollabioXodocumentsDocument_Template = /* @__PURE__ */ application("vnd.collabio.xodocuments.document-template");
var Application_Vendor_CollabioXodocumentsPresentation = /* @__PURE__ */ application("vnd.collabio.xodocuments.presentation");
var Application_Vendor_CollabioXodocumentsPresentation_Template = /* @__PURE__ */ application("vnd.collabio.xodocuments.presentation-template");
var Application_Vendor_CollabioXodocumentsSpreadsheet = /* @__PURE__ */ application("vnd.collabio.xodocuments.spreadsheet");
var Application_Vendor_CollabioXodocumentsSpreadsheet_Template = /* @__PURE__ */ application("vnd.collabio.xodocuments.spreadsheet-template");
var Application_Vendor_CollectionDocJson = /* @__PURE__ */ application("vnd.collection.doc+json", "json");
var Application_Vendor_CollectionJson = /* @__PURE__ */ application("vnd.collection+json", "json");
var Application_Vendor_CollectionNextJson = /* @__PURE__ */ application("vnd.collection.next+json", "json");
var Application_Vendor_Comicbook_Rar = /* @__PURE__ */ application("vnd.comicbook-rar");
var Application_Vendor_ComicbookZip = /* @__PURE__ */ application("vnd.comicbook+zip", "zip");
var Application_Vendor_Commerce_Battelle = /* @__PURE__ */ application("vnd.commerce-battelle");
var Application_Vendor_Commonspace = /* @__PURE__ */ application("vnd.commonspace", "csp");
var Application_Vendor_ContactCmsg = /* @__PURE__ */ application("vnd.contact.cmsg", "cdbcmsg");
var Application_Vendor_CoreosIgnitionJson = /* @__PURE__ */ application("vnd.coreos.ignition+json", "json");
var Application_Vendor_Cosmocaller = /* @__PURE__ */ application("vnd.cosmocaller", "cmc");
var Application_Vendor_CrickClicker = /* @__PURE__ */ application("vnd.crick.clicker", "clkx");
var Application_Vendor_CrickClickerKeyboard = /* @__PURE__ */ application("vnd.crick.clicker.keyboard", "clkk");
var Application_Vendor_CrickClickerPalette = /* @__PURE__ */ application("vnd.crick.clicker.palette", "clkp");
var Application_Vendor_CrickClickerTemplate = /* @__PURE__ */ application("vnd.crick.clicker.template", "clkt");
var Application_Vendor_CrickClickerWordbank = /* @__PURE__ */ application("vnd.crick.clicker.wordbank", "clkw");
var Application_Vendor_CriticaltoolsWbsXml = /* @__PURE__ */ application("vnd.criticaltools.wbs+xml", "wbs");
var Application_Vendor_CryptiiPipeJson = /* @__PURE__ */ application("vnd.cryptii.pipe+json", "json");
var Application_Vendor_Crypto_Shade_File = /* @__PURE__ */ application("vnd.crypto-shade-file");
var Application_Vendor_Ctc_Posml = /* @__PURE__ */ application("vnd.ctc-posml", "pml");
var Application_Vendor_CtctWsXml = /* @__PURE__ */ application("vnd.ctct.ws+xml", "xml");
var Application_Vendor_Cups_Pdf = /* @__PURE__ */ application("vnd.cups-pdf");
var Application_Vendor_Cups_Postscript = /* @__PURE__ */ application("vnd.cups-postscript");
var Application_Vendor_Cups_Ppd = /* @__PURE__ */ application("vnd.cups-ppd", "ppd");
var Application_Vendor_Cups_Raster = /* @__PURE__ */ application("vnd.cups-raster");
var Application_Vendor_Cups_Raw = /* @__PURE__ */ application("vnd.cups-raw");
var Application_Vendor_Curl = /* @__PURE__ */ application("vnd.curl");
var Application_Vendor_CurlCar = /* @__PURE__ */ application("vnd.curl.car", "car");
var Application_Vendor_CurlPcurl = /* @__PURE__ */ application("vnd.curl.pcurl", "pcurl");
var Application_Vendor_CyanDeanRootXml = /* @__PURE__ */ application("vnd.cyan.dean.root+xml", "xml");
var Application_Vendor_Cybank = /* @__PURE__ */ application("vnd.cybank");
var Application_Vendor_D2lCoursepackage1p0Zip = /* @__PURE__ */ application("vnd.d2l.coursepackage1p0+zip", "zip");
var Application_Vendor_Dart = /* @__PURE__ */ application("vnd.dart", "dart");
var Application_Vendor_Data_VisionRdz = /* @__PURE__ */ application("vnd.data-vision.rdz", "rdz");
var Application_Vendor_DatapackageJson = /* @__PURE__ */ application("vnd.datapackage+json", "json");
var Application_Vendor_DataresourceJson = /* @__PURE__ */ application("vnd.dataresource+json", "json");
var Application_Vendor_DebianBinary_Package = /* @__PURE__ */ application("vnd.debian.binary-package");
var Application_Vendor_DeceData = /* @__PURE__ */ application("vnd.dece.data", "uvf", "uvvf", "uvd", "uvvd");
var Application_Vendor_DeceTtmlXml = /* @__PURE__ */ application("vnd.dece.ttml+xml", "uvt", "uvvt");
var Application_Vendor_DeceUnspecified = /* @__PURE__ */ application("vnd.dece.unspecified", "uvx", "uvvx");
var Application_Vendor_DeceZip = /* @__PURE__ */ application("vnd.dece.zip", "uvz", "uvvz");
var Application_Vendor_DenovoFcselayout_Link = /* @__PURE__ */ application("vnd.denovo.fcselayout-link", "fe_launch");
var Application_Vendor_DesmumeMovie = /* @__PURE__ */ application("vnd.desmume.movie");
var Application_Vendor_Dir_BiPlate_Dl_Nosuffix = /* @__PURE__ */ application("vnd.dir-bi.plate-dl-nosuffix");
var Application_Vendor_DmDelegationXml = /* @__PURE__ */ application("vnd.dm.delegation+xml", "xml");
var Application_Vendor_Dna = /* @__PURE__ */ application("vnd.dna", "dna");
var Application_Vendor_DocumentJson = /* @__PURE__ */ application("vnd.document+json", "json");
var Application_Vendor_DolbyMlp = /* @__PURE__ */ application("vnd.dolby.mlp", "mlp");
var Application_Vendor_DolbyMobile1 = /* @__PURE__ */ application("vnd.dolby.mobile.1");
var Application_Vendor_DolbyMobile2 = /* @__PURE__ */ application("vnd.dolby.mobile.2");
var Application_Vendor_DoremirScorecloud_Binary_Document = /* @__PURE__ */ application("vnd.doremir.scorecloud-binary-document");
var Application_Vendor_Dpgraph = /* @__PURE__ */ application("vnd.dpgraph", "dpg");
var Application_Vendor_Dreamfactory = /* @__PURE__ */ application("vnd.dreamfactory", "dfac");
var Application_Vendor_DriveJson = /* @__PURE__ */ application("vnd.drive+json", "json");
var Application_Vendor_Ds_Keypoint = /* @__PURE__ */ application("vnd.ds-keypoint", "kpxx");
var Application_Vendor_DtgLocal = /* @__PURE__ */ application("vnd.dtg.local");
var Application_Vendor_DtgLocalFlash = /* @__PURE__ */ application("vnd.dtg.local.flash");
var Application_Vendor_DtgLocalHtml = /* @__PURE__ */ application("vnd.dtg.local.html");
var Application_Vendor_DvbAit = /* @__PURE__ */ application("vnd.dvb.ait", "ait");
var Application_Vendor_DvbDvbj = /* @__PURE__ */ application("vnd.dvb.dvbj");
var Application_Vendor_DvbEsgcontainer = /* @__PURE__ */ application("vnd.dvb.esgcontainer");
var Application_Vendor_DvbIpdcdftnotifaccess = /* @__PURE__ */ application("vnd.dvb.ipdcdftnotifaccess");
var Application_Vendor_DvbIpdcesgaccess = /* @__PURE__ */ application("vnd.dvb.ipdcesgaccess");
var Application_Vendor_DvbIpdcesgaccess2 = /* @__PURE__ */ application("vnd.dvb.ipdcesgaccess2");
var Application_Vendor_DvbIpdcesgpdd = /* @__PURE__ */ application("vnd.dvb.ipdcesgpdd");
var Application_Vendor_DvbIpdcroaming = /* @__PURE__ */ application("vnd.dvb.ipdcroaming");
var Application_Vendor_DvbIptvAlfec_Base = /* @__PURE__ */ application("vnd.dvb.iptv.alfec-base");
var Application_Vendor_DvbIptvAlfec_Enhancement = /* @__PURE__ */ application("vnd.dvb.iptv.alfec-enhancement");
var Application_Vendor_DvbNotif_Aggregate_RootXml = /* @__PURE__ */ application("vnd.dvb.notif-aggregate-root+xml", "xml");
var Application_Vendor_DvbNotif_ContainerXml = /* @__PURE__ */ application("vnd.dvb.notif-container+xml", "xml");
var Application_Vendor_DvbNotif_GenericXml = /* @__PURE__ */ application("vnd.dvb.notif-generic+xml", "xml");
var Application_Vendor_DvbNotif_Ia_MsglistXml = /* @__PURE__ */ application("vnd.dvb.notif-ia-msglist+xml", "xml");
var Application_Vendor_DvbNotif_Ia_Registration_RequestXml = /* @__PURE__ */ application("vnd.dvb.notif-ia-registration-request+xml", "xml");
var Application_Vendor_DvbNotif_Ia_Registration_ResponseXml = /* @__PURE__ */ application("vnd.dvb.notif-ia-registration-response+xml", "xml");
var Application_Vendor_DvbNotif_InitXml = /* @__PURE__ */ application("vnd.dvb.notif-init+xml", "xml");
var Application_Vendor_DvbPfr = /* @__PURE__ */ application("vnd.dvb.pfr");
var Application_Vendor_DvbService = /* @__PURE__ */ application("vnd.dvb.service", "svc");
var Application_Vendor_Dxr = /* @__PURE__ */ application("vnd.dxr");
var Application_Vendor_Dynageo = /* @__PURE__ */ application("vnd.dynageo", "geo");
var Application_Vendor_Dzr = /* @__PURE__ */ application("vnd.dzr");
var Application_Vendor_EasykaraokeCdgdownload = /* @__PURE__ */ application("vnd.easykaraoke.cdgdownload");
var Application_Vendor_Ecdis_Update = /* @__PURE__ */ application("vnd.ecdis-update");
var Application_Vendor_EcipRlp = /* @__PURE__ */ application("vnd.ecip.rlp");
var Application_Vendor_EcowinChart = /* @__PURE__ */ application("vnd.ecowin.chart", "mag");
var Application_Vendor_EcowinFilerequest = /* @__PURE__ */ application("vnd.ecowin.filerequest");
var Application_Vendor_EcowinFileupdate = /* @__PURE__ */ application("vnd.ecowin.fileupdate");
var Application_Vendor_EcowinSeries = /* @__PURE__ */ application("vnd.ecowin.series");
var Application_Vendor_EcowinSeriesrequest = /* @__PURE__ */ application("vnd.ecowin.seriesrequest");
var Application_Vendor_EcowinSeriesupdate = /* @__PURE__ */ application("vnd.ecowin.seriesupdate");
var Application_Vendor_EfiImg = /* @__PURE__ */ application("vnd.efi.img");
var Application_Vendor_EfiIso = /* @__PURE__ */ application("vnd.efi.iso");
var Application_Vendor_EmclientAccessrequestXml = /* @__PURE__ */ application("vnd.emclient.accessrequest+xml", "xml");
var Application_Vendor_Enliven = /* @__PURE__ */ application("vnd.enliven", "nml");
var Application_Vendor_EnphaseEnvoy = /* @__PURE__ */ application("vnd.enphase.envoy");
var Application_Vendor_EprintsDataXml = /* @__PURE__ */ application("vnd.eprints.data+xml", "xml");
var Application_Vendor_EpsonEsf = /* @__PURE__ */ application("vnd.epson.esf", "esf");
var Application_Vendor_EpsonMsf = /* @__PURE__ */ application("vnd.epson.msf", "msf");
var Application_Vendor_EpsonQuickanime = /* @__PURE__ */ application("vnd.epson.quickanime", "qam");
var Application_Vendor_EpsonSalt = /* @__PURE__ */ application("vnd.epson.salt", "slt");
var Application_Vendor_EpsonSsf = /* @__PURE__ */ application("vnd.epson.ssf", "ssf");
var Application_Vendor_EricssonQuickcall = /* @__PURE__ */ application("vnd.ericsson.quickcall");
var Application_Vendor_Espass_EspassZip = /* @__PURE__ */ application("vnd.espass-espass+zip", "zip");
var Application_Vendor_Eszigno3Xml = /* @__PURE__ */ application("vnd.eszigno3+xml", "es3", "et3");
var Application_Vendor_EtsiAocXml = /* @__PURE__ */ application("vnd.etsi.aoc+xml", "xml");
var Application_Vendor_EtsiAsic_EZip = /* @__PURE__ */ application("vnd.etsi.asic-e+zip", "zip");
var Application_Vendor_EtsiAsic_SZip = /* @__PURE__ */ application("vnd.etsi.asic-s+zip", "zip");
var Application_Vendor_EtsiCugXml = /* @__PURE__ */ application("vnd.etsi.cug+xml", "xml");
var Application_Vendor_EtsiIptvcommandXml = /* @__PURE__ */ application("vnd.etsi.iptvcommand+xml", "xml");
var Application_Vendor_EtsiIptvdiscoveryXml = /* @__PURE__ */ application("vnd.etsi.iptvdiscovery+xml", "xml");
var Application_Vendor_EtsiIptvprofileXml = /* @__PURE__ */ application("vnd.etsi.iptvprofile+xml", "xml");
var Application_Vendor_EtsiIptvsad_BcXml = /* @__PURE__ */ application("vnd.etsi.iptvsad-bc+xml", "xml");
var Application_Vendor_EtsiIptvsad_CodXml = /* @__PURE__ */ application("vnd.etsi.iptvsad-cod+xml", "xml");
var Application_Vendor_EtsiIptvsad_NpvrXml = /* @__PURE__ */ application("vnd.etsi.iptvsad-npvr+xml", "xml");
var Application_Vendor_EtsiIptvserviceXml = /* @__PURE__ */ application("vnd.etsi.iptvservice+xml", "xml");
var Application_Vendor_EtsiIptvsyncXml = /* @__PURE__ */ application("vnd.etsi.iptvsync+xml", "xml");
var Application_Vendor_EtsiIptvueprofileXml = /* @__PURE__ */ application("vnd.etsi.iptvueprofile+xml", "xml");
var Application_Vendor_EtsiMcidXml = /* @__PURE__ */ application("vnd.etsi.mcid+xml", "xml");
var Application_Vendor_EtsiMheg5 = /* @__PURE__ */ application("vnd.etsi.mheg5");
var Application_Vendor_EtsiOverload_Control_Policy_DatasetXml = /* @__PURE__ */ application("vnd.etsi.overload-control-policy-dataset+xml", "xml");
var Application_Vendor_EtsiPstnXml = /* @__PURE__ */ application("vnd.etsi.pstn+xml", "xml");
var Application_Vendor_EtsiSciXml = /* @__PURE__ */ application("vnd.etsi.sci+xml", "xml");
var Application_Vendor_EtsiSimservsXml = /* @__PURE__ */ application("vnd.etsi.simservs+xml", "xml");
var Application_Vendor_EtsiTimestamp_Token = /* @__PURE__ */ application("vnd.etsi.timestamp-token");
var Application_Vendor_EtsiTslDer = /* @__PURE__ */ application("vnd.etsi.tsl.der");
var Application_Vendor_EtsiTslXml = /* @__PURE__ */ application("vnd.etsi.tsl+xml", "xml");
var Application_Vendor_EudoraData = /* @__PURE__ */ application("vnd.eudora.data");
var Application_Vendor_EvolvEcigProfile = /* @__PURE__ */ application("vnd.evolv.ecig.profile");
var Application_Vendor_EvolvEcigSettings = /* @__PURE__ */ application("vnd.evolv.ecig.settings");
var Application_Vendor_EvolvEcigTheme = /* @__PURE__ */ application("vnd.evolv.ecig.theme");
var Application_Vendor_Exstream_EmpowerZip = /* @__PURE__ */ application("vnd.exstream-empower+zip", "zip");
var Application_Vendor_Exstream_Package = /* @__PURE__ */ application("vnd.exstream-package");
var Application_Vendor_Ezpix_Album = /* @__PURE__ */ application("vnd.ezpix-album", "ez2");
var Application_Vendor_Ezpix_Package = /* @__PURE__ */ application("vnd.ezpix-package", "ez3");
var Application_Vendor_F_SecureMobile = /* @__PURE__ */ application("vnd.f-secure.mobile");
var Application_Vendor_Fastcopy_Disk_Image = /* @__PURE__ */ application("vnd.fastcopy-disk-image");
var Application_Vendor_Fdf = /* @__PURE__ */ application("vnd.fdf", "fdf");
var Application_Vendor_FdsnMseed = /* @__PURE__ */ application("vnd.fdsn.mseed", "mseed");
var Application_Vendor_FdsnSeed = /* @__PURE__ */ application("vnd.fdsn.seed", "seed", "dataless");
var Application_Vendor_Ffsns = /* @__PURE__ */ application("vnd.ffsns");
var Application_Vendor_FiclabFlbZip = /* @__PURE__ */ application("vnd.ficlab.flb+zip", "zip");
var Application_Vendor_FilmitZfc = /* @__PURE__ */ application("vnd.filmit.zfc");
var Application_Vendor_Fints = /* @__PURE__ */ application("vnd.fints");
var Application_Vendor_FiremonkeysCloudcell = /* @__PURE__ */ application("vnd.firemonkeys.cloudcell");
var Application_Vendor_FloGraphIt = /* @__PURE__ */ application("vnd.flographit", "gph");
var Application_Vendor_FluxtimeClip = /* @__PURE__ */ application("vnd.fluxtime.clip", "ftc");
var Application_Vendor_Font_Fontforge_Sfd = /* @__PURE__ */ application("vnd.font-fontforge-sfd");
var Application_Vendor_Framemaker = /* @__PURE__ */ application("vnd.framemaker", "fm", "frame", "maker", "book");
var Application_Vendor_FrogansFnc = /* @__PURE__ */ application("vnd.frogans.fnc", "fnc");
var Application_Vendor_FrogansLtf = /* @__PURE__ */ application("vnd.frogans.ltf", "ltf");
var Application_Vendor_FscWeblaunch = /* @__PURE__ */ application("vnd.fsc.weblaunch", "fsc");
var Application_Vendor_FujitsuOasys = /* @__PURE__ */ application("vnd.fujitsu.oasys", "oas");
var Application_Vendor_FujitsuOasys2 = /* @__PURE__ */ application("vnd.fujitsu.oasys2", "oa2");
var Application_Vendor_FujitsuOasys3 = /* @__PURE__ */ application("vnd.fujitsu.oasys3", "oa3");
var Application_Vendor_FujitsuOasysgp = /* @__PURE__ */ application("vnd.fujitsu.oasysgp", "fg5");
var Application_Vendor_FujitsuOasysprs = /* @__PURE__ */ application("vnd.fujitsu.oasysprs", "bh2");
var Application_Vendor_FujixeroxART_EX = /* @__PURE__ */ application("vnd.fujixerox.art-ex");
var Application_Vendor_FujixeroxART4 = /* @__PURE__ */ application("vnd.fujixerox.art4");
var Application_Vendor_FujixeroxDdd = /* @__PURE__ */ application("vnd.fujixerox.ddd", "ddd");
var Application_Vendor_FujixeroxDocuworks = /* @__PURE__ */ application("vnd.fujixerox.docuworks", "xdw");
var Application_Vendor_FujixeroxDocuworksBinder = /* @__PURE__ */ application("vnd.fujixerox.docuworks.binder", "xbd");
var Application_Vendor_FujixeroxDocuworksContainer = /* @__PURE__ */ application("vnd.fujixerox.docuworks.container");
var Application_Vendor_FujixeroxHBPL = /* @__PURE__ */ application("vnd.fujixerox.hbpl");
var Application_Vendor_Fut_Misnet = /* @__PURE__ */ application("vnd.fut-misnet");
var Application_Vendor_FutoinCbor = /* @__PURE__ */ application("vnd.futoin+cbor", "cbor");
var Application_Vendor_FutoinJson = /* @__PURE__ */ application("vnd.futoin+json", "json");
var Application_Vendor_Fuzzysheet = /* @__PURE__ */ application("vnd.fuzzysheet", "fzs");
var Application_Vendor_GenomatixTuxedo = /* @__PURE__ */ application("vnd.genomatix.tuxedo", "txd");
var Application_Vendor_GenticsGrdJson = /* @__PURE__ */ application("vnd.gentics.grd+json", "json");
var Application_Vendor_GeocubeXml = /* @__PURE__ */ application("vnd.geocube+xml", "xml").deprecate("by request");
var Application_Vendor_GeogebraFile = /* @__PURE__ */ application("vnd.geogebra.file", "ggb");
var Application_Vendor_GeogebraTool = /* @__PURE__ */ application("vnd.geogebra.tool", "ggt");
var Application_Vendor_GeoJson = /* @__PURE__ */ application("vnd.geo+json", "json").deprecate("in favor of application/geo+json");
var Application_Vendor_Geometry_Explorer = /* @__PURE__ */ application("vnd.geometry-explorer", "gex", "gre");
var Application_Vendor_Geonext = /* @__PURE__ */ application("vnd.geonext", "gxt");
var Application_Vendor_Geoplan = /* @__PURE__ */ application("vnd.geoplan", "g2w");
var Application_Vendor_Geospace = /* @__PURE__ */ application("vnd.geospace", "g3w");
var Application_Vendor_Gerber = /* @__PURE__ */ application("vnd.gerber");
var Application_Vendor_GlobalplatformCard_Content_Mgt = /* @__PURE__ */ application("vnd.globalplatform.card-content-mgt");
var Application_Vendor_GlobalplatformCard_Content_Mgt_Response = /* @__PURE__ */ application("vnd.globalplatform.card-content-mgt-response");
var Application_Vendor_Gmx = /* @__PURE__ */ application("vnd.gmx", "gmx").deprecate("with no reason given");
var Application_Vendor_Google_Apps_Document = /* @__PURE__ */ application("vnd.google-apps.document", "gdoc");
var Application_Vendor_Google_Apps_Presentation = /* @__PURE__ */ application("vnd.google-apps.presentation", "gslides");
var Application_Vendor_Google_Apps_Spreadsheet = /* @__PURE__ */ application("vnd.google-apps.spreadsheet", "gsheet");
var Application_Vendor_Google_EarthKmlXml = /* @__PURE__ */ application("vnd.google-earth.kml+xml", "kml");
var Application_Vendor_Google_EarthKmz = /* @__PURE__ */ application("vnd.google-earth.kmz", "kmz");
var Application_Vendor_GovSkE_FormXml = /* @__PURE__ */ application("vnd.gov.sk.e-form+xml", "xml");
var Application_Vendor_GovSkE_FormZip = /* @__PURE__ */ application("vnd.gov.sk.e-form+zip", "zip");
var Application_Vendor_GovSkXmldatacontainerXml = /* @__PURE__ */ application("vnd.gov.sk.xmldatacontainer+xml", "xml");
var Application_Vendor_Grafeq = /* @__PURE__ */ application("vnd.grafeq", "gqf", "gqs");
var Application_Vendor_Gridmp = /* @__PURE__ */ application("vnd.gridmp");
var Application_Vendor_Groove_Account = /* @__PURE__ */ application("vnd.groove-account", "gac");
var Application_Vendor_Groove_Help = /* @__PURE__ */ application("vnd.groove-help", "ghf");
var Application_Vendor_Groove_Identity_Message = /* @__PURE__ */ application("vnd.groove-identity-message", "gim");
var Application_Vendor_Groove_Injector = /* @__PURE__ */ application("vnd.groove-injector", "grv");
var Application_Vendor_Groove_Tool_Message = /* @__PURE__ */ application("vnd.groove-tool-message", "gtm");
var Application_Vendor_Groove_Tool_Template = /* @__PURE__ */ application("vnd.groove-tool-template", "tpl");
var Application_Vendor_Groove_Vcard = /* @__PURE__ */ application("vnd.groove-vcard", "vcg");
var Application_Vendor_HalJson = /* @__PURE__ */ application("vnd.hal+json", "json");
var Application_Vendor_HalXml = /* @__PURE__ */ application("vnd.hal+xml", "hal");
var Application_Vendor_HandHeld_EntertainmentXml = /* @__PURE__ */ application("vnd.handheld-entertainment+xml", "zmm");
var Application_Vendor_Hbci = /* @__PURE__ */ application("vnd.hbci", "hbci");
var Application_Vendor_HcJson = /* @__PURE__ */ application("vnd.hc+json", "json");
var Application_Vendor_Hcl_Bireports = /* @__PURE__ */ application("vnd.hcl-bireports");
var Application_Vendor_Hdt = /* @__PURE__ */ application("vnd.hdt");
var Application_Vendor_HerokuJson = /* @__PURE__ */ application("vnd.heroku+json", "json");
var Application_Vendor_HheLesson_Player = /* @__PURE__ */ application("vnd.hhe.lesson-player", "les");
var Application_Vendor_Hp_HPGL = /* @__PURE__ */ application("vnd.hp-hpgl", "hpgl");
var Application_Vendor_Hp_Hpid = /* @__PURE__ */ application("vnd.hp-hpid", "hpid");
var Application_Vendor_Hp_Hps = /* @__PURE__ */ application("vnd.hp-hps", "hps");
var Application_Vendor_Hp_Jlyt = /* @__PURE__ */ application("vnd.hp-jlyt", "jlt");
var Application_Vendor_Hp_PCL = /* @__PURE__ */ application("vnd.hp-pcl", "pcl");
var Application_Vendor_Hp_PCLXL = /* @__PURE__ */ application("vnd.hp-pclxl", "pclxl");
var Application_Vendor_Httphone = /* @__PURE__ */ application("vnd.httphone");
var Application_Vendor_HydrostatixSof_Data = /* @__PURE__ */ application("vnd.hydrostatix.sof-data", "sfd-hdstx");
var Application_Vendor_Hyper_ItemJson = /* @__PURE__ */ application("vnd.hyper-item+json", "json");
var Application_Vendor_HyperdriveJson = /* @__PURE__ */ application("vnd.hyperdrive+json", "json");
var Application_Vendor_HyperJson = /* @__PURE__ */ application("vnd.hyper+json", "json");
var Application_Vendor_Hzn_3d_Crossword = /* @__PURE__ */ application("vnd.hzn-3d-crossword");
var Application_Vendor_IbmAfplinedata = /* @__PURE__ */ application("vnd.ibm.afplinedata").deprecate("in favor of vnd.afpc.afplinedata");
var Application_Vendor_IbmElectronic_Media = /* @__PURE__ */ application("vnd.ibm.electronic-media");
var Application_Vendor_IbmMiniPay = /* @__PURE__ */ application("vnd.ibm.minipay", "mpy");
var Application_Vendor_IbmModcap = /* @__PURE__ */ application("vnd.ibm.modcap", "afp", "listafp", "list3820").deprecate("in favor of application/vnd.afpc.modca");
var Application_Vendor_IbmRights_Management = /* @__PURE__ */ application("vnd.ibm.rights-management", "irm");
var Application_Vendor_IbmSecure_Container = /* @__PURE__ */ application("vnd.ibm.secure-container", "sc");
var Application_Vendor_Iccprofile = /* @__PURE__ */ application("vnd.iccprofile", "icc", "icm");
var Application_Vendor_Ieee1905 = /* @__PURE__ */ application("vnd.ieee.1905");
var Application_Vendor_Igloader = /* @__PURE__ */ application("vnd.igloader", "igl");
var Application_Vendor_ImagemeterFolderZip = /* @__PURE__ */ application("vnd.imagemeter.folder+zip", "zip");
var Application_Vendor_ImagemeterImageZip = /* @__PURE__ */ application("vnd.imagemeter.image+zip", "zip");
var Application_Vendor_Immervision_Ivp = /* @__PURE__ */ application("vnd.immervision-ivp", "ivp");
var Application_Vendor_Immervision_Ivu = /* @__PURE__ */ application("vnd.immervision-ivu", "ivu");
var Application_Vendor_ImsImsccv1p1 = /* @__PURE__ */ application("vnd.ims.imsccv1p1");
var Application_Vendor_ImsImsccv1p2 = /* @__PURE__ */ application("vnd.ims.imsccv1p2");
var Application_Vendor_ImsImsccv1p3 = /* @__PURE__ */ application("vnd.ims.imsccv1p3");
var Application_Vendor_ImsLisV2ResultJson = /* @__PURE__ */ application("vnd.ims.lis.v2.result+json", "json");
var Application_Vendor_ImsLtiV2ToolconsumerprofileJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolconsumerprofile+json", "json");
var Application_Vendor_ImsLtiV2ToolproxyIdJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolproxy.id+json", "json");
var Application_Vendor_ImsLtiV2ToolproxyJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolproxy+json", "json");
var Application_Vendor_ImsLtiV2ToolsettingsJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolsettings+json", "json");
var Application_Vendor_ImsLtiV2ToolsettingsSimpleJson = /* @__PURE__ */ application("vnd.ims.lti.v2.toolsettings.simple+json", "json");
var Application_Vendor_InformedcontrolRmsXml = /* @__PURE__ */ application("vnd.informedcontrol.rms+xml", "xml");
var Application_Vendor_Informix_Visionary = /* @__PURE__ */ application("vnd.informix-visionary").deprecate("in favor of application/vnd.visionary");
var Application_Vendor_InfotechProject = /* @__PURE__ */ application("vnd.infotech.project");
var Application_Vendor_InfotechProjectXml = /* @__PURE__ */ application("vnd.infotech.project+xml", "xml");
var Application_Vendor_InnopathWampNotification = /* @__PURE__ */ application("vnd.innopath.wamp.notification");
var Application_Vendor_InsorsIgm = /* @__PURE__ */ application("vnd.insors.igm", "igm");
var Application_Vendor_InterconFormnet = /* @__PURE__ */ application("vnd.intercon.formnet", "xpw", "xpx");
var Application_Vendor_Intergeo = /* @__PURE__ */ application("vnd.intergeo", "i2g");
var Application_Vendor_IntertrustDigibox = /* @__PURE__ */ application("vnd.intertrust.digibox");
var Application_Vendor_IntertrustNncp = /* @__PURE__ */ application("vnd.intertrust.nncp");
var Application_Vendor_IntuQbo = /* @__PURE__ */ application("vnd.intu.qbo", "qbo");
var Application_Vendor_IntuQfx = /* @__PURE__ */ application("vnd.intu.qfx", "qfx");
var Application_Vendor_IptcG2CatalogitemXml = /* @__PURE__ */ application("vnd.iptc.g2.catalogitem+xml", "xml");
var Application_Vendor_IptcG2ConceptitemXml = /* @__PURE__ */ application("vnd.iptc.g2.conceptitem+xml", "xml");
var Application_Vendor_IptcG2KnowledgeitemXml = /* @__PURE__ */ application("vnd.iptc.g2.knowledgeitem+xml", "xml");
var Application_Vendor_IptcG2NewsitemXml = /* @__PURE__ */ application("vnd.iptc.g2.newsitem+xml", "xml");
var Application_Vendor_IptcG2NewsmessageXml = /* @__PURE__ */ application("vnd.iptc.g2.newsmessage+xml", "xml");
var Application_Vendor_IptcG2PackageitemXml = /* @__PURE__ */ application("vnd.iptc.g2.packageitem+xml", "xml");
var Application_Vendor_IptcG2PlanningitemXml = /* @__PURE__ */ application("vnd.iptc.g2.planningitem+xml", "xml");
var Application_Vendor_IpunpluggedRcprofile = /* @__PURE__ */ application("vnd.ipunplugged.rcprofile", "rcprofile");
var Application_Vendor_IrepositoryPackageXml = /* @__PURE__ */ application("vnd.irepository.package+xml", "irp");
var Application_Vendor_Is_Xpr = /* @__PURE__ */ application("vnd.is-xpr", "xpr");
var Application_Vendor_IsacFcs = /* @__PURE__ */ application("vnd.isac.fcs", "fcs");
var Application_Vendor_Iso11783_10Zip = /* @__PURE__ */ application("vnd.iso11783-10+zip", "zip");
var Application_Vendor_Jam = /* @__PURE__ */ application("vnd.jam", "jam");
var Application_Vendor_Japannet_Directory_Service = /* @__PURE__ */ application("vnd.japannet-directory-service");
var Application_Vendor_Japannet_Jpnstore_Wakeup = /* @__PURE__ */ application("vnd.japannet-jpnstore-wakeup");
var Application_Vendor_Japannet_Payment_Wakeup = /* @__PURE__ */ application("vnd.japannet-payment-wakeup");
var Application_Vendor_Japannet_Registration = /* @__PURE__ */ application("vnd.japannet-registration");
var Application_Vendor_Japannet_Registration_Wakeup = /* @__PURE__ */ application("vnd.japannet-registration-wakeup");
var Application_Vendor_Japannet_Setstore_Wakeup = /* @__PURE__ */ application("vnd.japannet-setstore-wakeup");
var Application_Vendor_Japannet_Verification = /* @__PURE__ */ application("vnd.japannet-verification");
var Application_Vendor_Japannet_Verification_Wakeup = /* @__PURE__ */ application("vnd.japannet-verification-wakeup");
var Application_Vendor_JcpJavameMidlet_Rms = /* @__PURE__ */ application("vnd.jcp.javame.midlet-rms", "rms");
var Application_Vendor_Jisp = /* @__PURE__ */ application("vnd.jisp", "jisp");
var Application_Vendor_JoostJoda_Archive = /* @__PURE__ */ application("vnd.joost.joda-archive", "joda");
var Application_Vendor_JskIsdn_Ngn = /* @__PURE__ */ application("vnd.jsk.isdn-ngn");
var Application_Vendor_Kahootz = /* @__PURE__ */ application("vnd.kahootz", "ktz", "ktr");
var Application_Vendor_KdeKarbon = /* @__PURE__ */ application("vnd.kde.karbon", "karbon");
var Application_Vendor_KdeKchart = /* @__PURE__ */ application("vnd.kde.kchart", "chrt");
var Application_Vendor_KdeKformula = /* @__PURE__ */ application("vnd.kde.kformula", "kfo");
var Application_Vendor_KdeKivio = /* @__PURE__ */ application("vnd.kde.kivio", "flw");
var Application_Vendor_KdeKontour = /* @__PURE__ */ application("vnd.kde.kontour", "kon");
var Application_Vendor_KdeKpresenter = /* @__PURE__ */ application("vnd.kde.kpresenter", "kpr", "kpt");
var Application_Vendor_KdeKspread = /* @__PURE__ */ application("vnd.kde.kspread", "ksp");
var Application_Vendor_KdeKword = /* @__PURE__ */ application("vnd.kde.kword", "kwd", "kwt");
var Application_Vendor_Kenameaapp = /* @__PURE__ */ application("vnd.kenameaapp", "htke");
var Application_Vendor_Kidspiration = /* @__PURE__ */ application("vnd.kidspiration", "kia");
var Application_Vendor_Kinar = /* @__PURE__ */ application("vnd.kinar", "kne", "knp");
var Application_Vendor_Koan = /* @__PURE__ */ application("vnd.koan", "skp", "skd", "skt", "skm");
var Application_Vendor_Kodak_Descriptor = /* @__PURE__ */ application("vnd.kodak-descriptor", "sse");
var Application_Vendor_Las = /* @__PURE__ */ application("vnd.las");
var Application_Vendor_LasLasJson = /* @__PURE__ */ application("vnd.las.las+json", "json");
var Application_Vendor_LasLasXml = /* @__PURE__ */ application("vnd.las.las+xml", "lasxml");
var Application_Vendor_Laszip = /* @__PURE__ */ application("vnd.laszip");
var Application_Vendor_LeapJson = /* @__PURE__ */ application("vnd.leap+json", "json");
var Application_Vendor_Liberty_RequestXml = /* @__PURE__ */ application("vnd.liberty-request+xml", "xml");
var Application_Vendor_LlamagraphicsLife_BalanceDesktop = /* @__PURE__ */ application("vnd.llamagraphics.life-balance.desktop", "lbd");
var Application_Vendor_LlamagraphicsLife_BalanceExchangeXml = /* @__PURE__ */ application("vnd.llamagraphics.life-balance.exchange+xml", "lbe");
var Application_Vendor_LogipipeCircuitZip = /* @__PURE__ */ application("vnd.logipipe.circuit+zip", "zip");
var Application_Vendor_Loom = /* @__PURE__ */ application("vnd.loom");
var Application_Vendor_Lotus_1_2_3 = /* @__PURE__ */ application("vnd.lotus-1-2-3", "123");
var Application_Vendor_Lotus_Approach = /* @__PURE__ */ application("vnd.lotus-approach", "apr");
var Application_Vendor_Lotus_Freelance = /* @__PURE__ */ application("vnd.lotus-freelance", "pre");
var Application_Vendor_Lotus_Notes = /* @__PURE__ */ application("vnd.lotus-notes", "nsf");
var Application_Vendor_Lotus_Organizer = /* @__PURE__ */ application("vnd.lotus-organizer", "org");
var Application_Vendor_Lotus_Screencam = /* @__PURE__ */ application("vnd.lotus-screencam", "scm");
var Application_Vendor_Lotus_Wordpro = /* @__PURE__ */ application("vnd.lotus-wordpro", "lwp");
var Application_Vendor_MacportsPortpkg = /* @__PURE__ */ application("vnd.macports.portpkg", "portpkg");
var Application_Vendor_Mapbox_Vector_Tile = /* @__PURE__ */ application("vnd.mapbox-vector-tile");
var Application_Vendor_MarlinDrmActiontokenXml = /* @__PURE__ */ application("vnd.marlin.drm.actiontoken+xml", "xml");
var Application_Vendor_MarlinDrmConftokenXml = /* @__PURE__ */ application("vnd.marlin.drm.conftoken+xml", "xml");
var Application_Vendor_MarlinDrmLicenseXml = /* @__PURE__ */ application("vnd.marlin.drm.license+xml", "xml");
var Application_Vendor_MarlinDrmMdcf = /* @__PURE__ */ application("vnd.marlin.drm.mdcf");
var Application_Vendor_MasonJson = /* @__PURE__ */ application("vnd.mason+json", "json");
var Application_Vendor_MaxmindMaxmind_Db = /* @__PURE__ */ application("vnd.maxmind.maxmind-db");
var Application_Vendor_Mcd = /* @__PURE__ */ application("vnd.mcd", "mcd");
var Application_Vendor_Medcalcdata = /* @__PURE__ */ application("vnd.medcalcdata", "mc1");
var Application_Vendor_MediastationCdkey = /* @__PURE__ */ application("vnd.mediastation.cdkey", "cdkey");
var Application_Vendor_Meridian_Slingshot = /* @__PURE__ */ application("vnd.meridian-slingshot");
var Application_Vendor_MFER = /* @__PURE__ */ application("vnd.mfer", "mwf");
var Application_Vendor_Mfmp = /* @__PURE__ */ application("vnd.mfmp", "mfm");
var Application_Vendor_MicrografxFlo = /* @__PURE__ */ application("vnd.micrografx.flo", "flo");
var Application_Vendor_MicrografxIgx = /* @__PURE__ */ application("vnd.micrografx.igx", "igx");
var Application_Vendor_MicroJson = /* @__PURE__ */ application("vnd.micro+json", "json");
var Application_Vendor_MicrosoftPortable_Executable = /* @__PURE__ */ application("vnd.microsoft.portable-executable");
var Application_Vendor_MicrosoftWindowsThumbnail_Cache = /* @__PURE__ */ application("vnd.microsoft.windows.thumbnail-cache");
var Application_Vendor_MieleJson = /* @__PURE__ */ application("vnd.miele+json", "json");
var Application_Vendor_Mif = /* @__PURE__ */ application("vnd.mif", "mif");
var Application_Vendor_Minisoft_Hp3000_Save = /* @__PURE__ */ application("vnd.minisoft-hp3000-save");
var Application_Vendor_MitsubishiMisty_GuardTrustweb = /* @__PURE__ */ application("vnd.mitsubishi.misty-guard.trustweb");
var Application_Vendor_MobiusDAF = /* @__PURE__ */ application("vnd.mobius.daf", "daf");
var Application_Vendor_MobiusDIS = /* @__PURE__ */ application("vnd.mobius.dis", "dis");
var Application_Vendor_MobiusMBK = /* @__PURE__ */ application("vnd.mobius.mbk", "mbk");
var Application_Vendor_MobiusMQY = /* @__PURE__ */ application("vnd.mobius.mqy", "mqy");
var Application_Vendor_MobiusMSL = /* @__PURE__ */ application("vnd.mobius.msl", "msl");
var Application_Vendor_MobiusPLC = /* @__PURE__ */ application("vnd.mobius.plc", "plc");
var Application_Vendor_MobiusTXF = /* @__PURE__ */ application("vnd.mobius.txf", "txf");
var Application_Vendor_MophunApplication = /* @__PURE__ */ application("vnd.mophun.application", "mpn");
var Application_Vendor_MophunCertificate = /* @__PURE__ */ application("vnd.mophun.certificate", "mpc");
var Application_Vendor_MotorolaFlexsuite = /* @__PURE__ */ application("vnd.motorola.flexsuite");
var Application_Vendor_MotorolaFlexsuiteAdsi = /* @__PURE__ */ application("vnd.motorola.flexsuite.adsi");
var Application_Vendor_MotorolaFlexsuiteFis = /* @__PURE__ */ application("vnd.motorola.flexsuite.fis");
var Application_Vendor_MotorolaFlexsuiteGotap = /* @__PURE__ */ application("vnd.motorola.flexsuite.gotap");
var Application_Vendor_MotorolaFlexsuiteKmr = /* @__PURE__ */ application("vnd.motorola.flexsuite.kmr");
var Application_Vendor_MotorolaFlexsuiteTtc = /* @__PURE__ */ application("vnd.motorola.flexsuite.ttc");
var Application_Vendor_MotorolaFlexsuiteWem = /* @__PURE__ */ application("vnd.motorola.flexsuite.wem");
var Application_Vendor_MotorolaIprm = /* @__PURE__ */ application("vnd.motorola.iprm");
var Application_Vendor_MozillaXulXml = /* @__PURE__ */ application("vnd.mozilla.xul+xml", "xul");
var Application_Vendor_Ms_3mfdocument = /* @__PURE__ */ application("vnd.ms-3mfdocument");
var Application_Vendor_Ms_Artgalry = /* @__PURE__ */ application("vnd.ms-artgalry", "cil");
var Application_Vendor_Ms_Asf = /* @__PURE__ */ application("vnd.ms-asf");
var Application_Vendor_Ms_Cab_Compressed = /* @__PURE__ */ application("vnd.ms-cab-compressed", "cab");
var Application_Vendor_Ms_ColorIccprofile = /* @__PURE__ */ application("vnd.ms-color.iccprofile");
var Application_Vendor_Ms_Excel = /* @__PURE__ */ application("vnd.ms-excel", "xls", "xlm", "xla", "xlc", "xlt", "xlw");
var Application_Vendor_Ms_ExcelAddinMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.addin.macroenabled.12", "xlam");
var Application_Vendor_Ms_ExcelSheetBinaryMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb");
var Application_Vendor_Ms_ExcelSheetMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.sheet.macroenabled.12", "xlsm");
var Application_Vendor_Ms_ExcelTemplateMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-excel.template.macroenabled.12", "xltm");
var Application_Vendor_Ms_Fontobject = /* @__PURE__ */ application("vnd.ms-fontobject", "eot");
var Application_Vendor_Ms_Htmlhelp = /* @__PURE__ */ application("vnd.ms-htmlhelp", "chm");
var Application_Vendor_Ms_Ims = /* @__PURE__ */ application("vnd.ms-ims", "ims");
var Application_Vendor_Ms_Lrm = /* @__PURE__ */ application("vnd.ms-lrm", "lrm");
var Application_Vendor_Ms_OfficeActiveXXml = /* @__PURE__ */ application("vnd.ms-office.activex+xml", "xml");
var Application_Vendor_Ms_Officetheme = /* @__PURE__ */ application("vnd.ms-officetheme", "thmx");
var Application_Vendor_Ms_Opentype = /* @__PURE__ */ application("vnd.ms-opentype");
var Application_Vendor_Ms_Outlook = /* @__PURE__ */ application("vnd.ms-outlook", "msg");
var Application_Vendor_Ms_PackageObfuscated_Opentype = /* @__PURE__ */ application("vnd.ms-package.obfuscated-opentype");
var Application_Vendor_Ms_PkiSeccat = /* @__PURE__ */ application("vnd.ms-pki.seccat", "cat");
var Application_Vendor_Ms_PkiStl = /* @__PURE__ */ application("vnd.ms-pki.stl", "stl");
var Application_Vendor_Ms_PlayreadyInitiatorXml = /* @__PURE__ */ application("vnd.ms-playready.initiator+xml", "xml");
var Application_Vendor_Ms_Powerpoint = /* @__PURE__ */ application("vnd.ms-powerpoint", "ppt", "pps", "pot");
var Application_Vendor_Ms_PowerpointAddinMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.addin.macroenabled.12", "ppam");
var Application_Vendor_Ms_PowerpointPresentationMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.presentation.macroenabled.12", "pptm");
var Application_Vendor_Ms_PowerpointSlideMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.slide.macroenabled.12", "sldm");
var Application_Vendor_Ms_PowerpointSlideshowMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm");
var Application_Vendor_Ms_PowerpointTemplateMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-powerpoint.template.macroenabled.12", "potm");
var Application_Vendor_Ms_PrintDeviceCapabilitiesXml = /* @__PURE__ */ application("vnd.ms-printdevicecapabilities+xml", "xml");
var Application_Vendor_Ms_PrintingPrintticketXml = /* @__PURE__ */ application("vnd.ms-printing.printticket+xml", "xml");
var Application_Vendor_Ms_PrintSchemaTicketXml = /* @__PURE__ */ application("vnd.ms-printschematicket+xml", "xml");
var Application_Vendor_Ms_Project = /* @__PURE__ */ application("vnd.ms-project", "mpp", "mpt");
var Application_Vendor_Ms_Tnef = /* @__PURE__ */ application("vnd.ms-tnef");
var Application_Vendor_Ms_WindowsDevicepairing = /* @__PURE__ */ application("vnd.ms-windows.devicepairing");
var Application_Vendor_Ms_WindowsNwprintingOob = /* @__PURE__ */ application("vnd.ms-windows.nwprinting.oob");
var Application_Vendor_Ms_WindowsPrinterpairing = /* @__PURE__ */ application("vnd.ms-windows.printerpairing");
var Application_Vendor_Ms_WindowsWsdOob = /* @__PURE__ */ application("vnd.ms-windows.wsd.oob");
var Application_Vendor_Ms_WmdrmLic_Chlg_Req = /* @__PURE__ */ application("vnd.ms-wmdrm.lic-chlg-req");
var Application_Vendor_Ms_WmdrmLic_Resp = /* @__PURE__ */ application("vnd.ms-wmdrm.lic-resp");
var Application_Vendor_Ms_WmdrmMeter_Chlg_Req = /* @__PURE__ */ application("vnd.ms-wmdrm.meter-chlg-req");
var Application_Vendor_Ms_WmdrmMeter_Resp = /* @__PURE__ */ application("vnd.ms-wmdrm.meter-resp");
var Application_Vendor_Ms_WordDocumentMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-word.document.macroenabled.12", "docm");
var Application_Vendor_Ms_WordTemplateMacroEnabled12 = /* @__PURE__ */ application("vnd.ms-word.template.macroenabled.12", "dotm");
var Application_Vendor_Ms_Works = /* @__PURE__ */ application("vnd.ms-works", "wps", "wks", "wcm", "wdb");
var Application_Vendor_Ms_Wpl = /* @__PURE__ */ application("vnd.ms-wpl", "wpl");
var Application_Vendor_Ms_Xpsdocument = /* @__PURE__ */ application("vnd.ms-xpsdocument", "xps");
var Application_Vendor_Msa_Disk_Image = /* @__PURE__ */ application("vnd.msa-disk-image");
var Application_Vendor_Mseq = /* @__PURE__ */ application("vnd.mseq", "mseq");
var Application_Vendor_Msign = /* @__PURE__ */ application("vnd.msign");
var Application_Vendor_MultiadCreator = /* @__PURE__ */ application("vnd.multiad.creator");
var Application_Vendor_MultiadCreatorCif = /* @__PURE__ */ application("vnd.multiad.creator.cif");
var Application_Vendor_Music_Niff = /* @__PURE__ */ application("vnd.music-niff");
var Application_Vendor_Musician = /* @__PURE__ */ application("vnd.musician", "mus");
var Application_Vendor_MuveeStyle = /* @__PURE__ */ application("vnd.muvee.style", "msty");
var Application_Vendor_Mynfc = /* @__PURE__ */ application("vnd.mynfc", "taglet");
var Application_Vendor_NcdControl = /* @__PURE__ */ application("vnd.ncd.control");
var Application_Vendor_NcdReference = /* @__PURE__ */ application("vnd.ncd.reference");
var Application_Vendor_NearstInvJson = /* @__PURE__ */ application("vnd.nearst.inv+json", "json");
var Application_Vendor_Nervana = /* @__PURE__ */ application("vnd.nervana");
var Application_Vendor_Netfpx = /* @__PURE__ */ application("vnd.netfpx");
var Application_Vendor_NeurolanguageNlu = /* @__PURE__ */ application("vnd.neurolanguage.nlu", "nlu");
var Application_Vendor_Nimn = /* @__PURE__ */ application("vnd.nimn");
var Application_Vendor_NintendoNitroRom = /* @__PURE__ */ application("vnd.nintendo.nitro.rom");
var Application_Vendor_NintendoSnesRom = /* @__PURE__ */ application("vnd.nintendo.snes.rom");
var Application_Vendor_Nitf = /* @__PURE__ */ application("vnd.nitf", "ntf", "nitf");
var Application_Vendor_Noblenet_Directory = /* @__PURE__ */ application("vnd.noblenet-directory", "nnd");
var Application_Vendor_Noblenet_Sealer = /* @__PURE__ */ application("vnd.noblenet-sealer", "nns");
var Application_Vendor_Noblenet_Web = /* @__PURE__ */ application("vnd.noblenet-web", "nnw");
var Application_Vendor_NokiaCatalogs = /* @__PURE__ */ application("vnd.nokia.catalogs");
var Application_Vendor_NokiaConmlWbxml = /* @__PURE__ */ application("vnd.nokia.conml+wbxml", "wbxml");
var Application_Vendor_NokiaConmlXml = /* @__PURE__ */ application("vnd.nokia.conml+xml", "xml");
var Application_Vendor_NokiaIptvConfigXml = /* @__PURE__ */ application("vnd.nokia.iptv.config+xml", "xml");
var Application_Vendor_NokiaISDS_Radio_Presets = /* @__PURE__ */ application("vnd.nokia.isds-radio-presets");
var Application_Vendor_NokiaLandmarkcollectionXml = /* @__PURE__ */ application("vnd.nokia.landmarkcollection+xml", "xml");
var Application_Vendor_NokiaLandmarkWbxml = /* @__PURE__ */ application("vnd.nokia.landmark+wbxml", "wbxml");
var Application_Vendor_NokiaLandmarkXml = /* @__PURE__ */ application("vnd.nokia.landmark+xml", "xml");
var Application_Vendor_NokiaN_GageAcXml = /* @__PURE__ */ application("vnd.nokia.n-gage.ac+xml", "xml");
var Application_Vendor_NokiaN_GageData = /* @__PURE__ */ application("vnd.nokia.n-gage.data", "ngdat");
var Application_Vendor_NokiaN_GageSymbianInstall = /* @__PURE__ */ application("vnd.nokia.n-gage.symbian.install", "n-gage").deprecate("as obsolete with no replacement given");
var Application_Vendor_NokiaNcd = /* @__PURE__ */ application("vnd.nokia.ncd");
var Application_Vendor_NokiaPcdWbxml = /* @__PURE__ */ application("vnd.nokia.pcd+wbxml", "wbxml");
var Application_Vendor_NokiaPcdXml = /* @__PURE__ */ application("vnd.nokia.pcd+xml", "xml");
var Application_Vendor_NokiaRadio_Preset = /* @__PURE__ */ application("vnd.nokia.radio-preset", "rpst");
var Application_Vendor_NokiaRadio_Presets = /* @__PURE__ */ application("vnd.nokia.radio-presets", "rpss");
var Application_Vendor_NovadigmEDM = /* @__PURE__ */ application("vnd.novadigm.edm", "edm");
var Application_Vendor_NovadigmEDX = /* @__PURE__ */ application("vnd.novadigm.edx", "edx");
var Application_Vendor_NovadigmEXT = /* @__PURE__ */ application("vnd.novadigm.ext", "ext");
var Application_Vendor_Ntt_LocalContent_Share = /* @__PURE__ */ application("vnd.ntt-local.content-share");
var Application_Vendor_Ntt_LocalFile_Transfer = /* @__PURE__ */ application("vnd.ntt-local.file-transfer");
var Application_Vendor_Ntt_LocalOgw_remote_Access = /* @__PURE__ */ application("vnd.ntt-local.ogw_remote-access");
var Application_Vendor_Ntt_LocalSip_Ta_remote = /* @__PURE__ */ application("vnd.ntt-local.sip-ta_remote");
var Application_Vendor_Ntt_LocalSip_Ta_tcp_stream = /* @__PURE__ */ application("vnd.ntt-local.sip-ta_tcp_stream");
var Application_Vendor_OasisOpendocumentChart = /* @__PURE__ */ application("vnd.oasis.opendocument.chart", "odc");
var Application_Vendor_OasisOpendocumentChart_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.chart-template", "otc");
var Application_Vendor_OasisOpendocumentDatabase = /* @__PURE__ */ application("vnd.oasis.opendocument.database", "odb");
var Application_Vendor_OasisOpendocumentFormula = /* @__PURE__ */ application("vnd.oasis.opendocument.formula", "odf");
var Application_Vendor_OasisOpendocumentFormula_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.formula-template", "odft");
var Application_Vendor_OasisOpendocumentGraphics = /* @__PURE__ */ application("vnd.oasis.opendocument.graphics", "odg");
var Application_Vendor_OasisOpendocumentGraphics_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.graphics-template", "otg");
var Application_Vendor_OasisOpendocumentImage = /* @__PURE__ */ application("vnd.oasis.opendocument.image", "odi");
var Application_Vendor_OasisOpendocumentImage_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.image-template", "oti");
var Application_Vendor_OasisOpendocumentPresentation = /* @__PURE__ */ application("vnd.oasis.opendocument.presentation", "odp");
var Application_Vendor_OasisOpendocumentPresentation_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.presentation-template", "otp");
var Application_Vendor_OasisOpendocumentSpreadsheet = /* @__PURE__ */ application("vnd.oasis.opendocument.spreadsheet", "ods");
var Application_Vendor_OasisOpendocumentSpreadsheet_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.spreadsheet-template", "ots");
var Application_Vendor_OasisOpendocumentText = /* @__PURE__ */ application("vnd.oasis.opendocument.text", "odt");
var Application_Vendor_OasisOpendocumentText_Master = /* @__PURE__ */ application("vnd.oasis.opendocument.text-master", "odm");
var Application_Vendor_OasisOpendocumentText_Template = /* @__PURE__ */ application("vnd.oasis.opendocument.text-template", "ott");
var Application_Vendor_OasisOpendocumentText_Web = /* @__PURE__ */ application("vnd.oasis.opendocument.text-web", "oth");
var Application_Vendor_Obn = /* @__PURE__ */ application("vnd.obn");
var Application_Vendor_OcfCbor = /* @__PURE__ */ application("vnd.ocf+cbor", "cbor");
var Application_Vendor_OftnL10nJson = /* @__PURE__ */ application("vnd.oftn.l10n+json", "json");
var Application_Vendor_OipfContentaccessdownloadXml = /* @__PURE__ */ application("vnd.oipf.contentaccessdownload+xml", "xml");
var Application_Vendor_OipfContentaccessstreamingXml = /* @__PURE__ */ application("vnd.oipf.contentaccessstreaming+xml", "xml");
var Application_Vendor_OipfCspg_Hexbinary = /* @__PURE__ */ application("vnd.oipf.cspg-hexbinary");
var Application_Vendor_OipfDaeSvgXml = /* @__PURE__ */ application("vnd.oipf.dae.svg+xml", "xml");
var Application_Vendor_OipfDaeXhtmlXml = /* @__PURE__ */ application("vnd.oipf.dae.xhtml+xml", "xml");
var Application_Vendor_OipfMippvcontrolmessageXml = /* @__PURE__ */ application("vnd.oipf.mippvcontrolmessage+xml", "xml");
var Application_Vendor_OipfPaeGem = /* @__PURE__ */ application("vnd.oipf.pae.gem");
var Application_Vendor_OipfSpdiscoveryXml = /* @__PURE__ */ application("vnd.oipf.spdiscovery+xml", "xml");
var Application_Vendor_OipfSpdlistXml = /* @__PURE__ */ application("vnd.oipf.spdlist+xml", "xml");
var Application_Vendor_OipfUeprofileXml = /* @__PURE__ */ application("vnd.oipf.ueprofile+xml", "xml");
var Application_Vendor_OipfUserprofileXml = /* @__PURE__ */ application("vnd.oipf.userprofile+xml", "xml");
var Application_Vendor_Olpc_Sugar = /* @__PURE__ */ application("vnd.olpc-sugar", "xo");
var Application_Vendor_Oma_Scws_Config = /* @__PURE__ */ application("vnd.oma-scws-config");
var Application_Vendor_Oma_Scws_Http_Request = /* @__PURE__ */ application("vnd.oma-scws-http-request");
var Application_Vendor_Oma_Scws_Http_Response = /* @__PURE__ */ application("vnd.oma-scws-http-response");
var Application_Vendor_OmaBcastAssociated_Procedure_ParameterXml = /* @__PURE__ */ application("vnd.oma.bcast.associated-procedure-parameter+xml", "xml");
var Application_Vendor_OmaBcastDrm_TriggerXml = /* @__PURE__ */ application("vnd.oma.bcast.drm-trigger+xml", "xml");
var Application_Vendor_OmaBcastImdXml = /* @__PURE__ */ application("vnd.oma.bcast.imd+xml", "xml");
var Application_Vendor_OmaBcastLtkm = /* @__PURE__ */ application("vnd.oma.bcast.ltkm");
var Application_Vendor_OmaBcastNotificationXml = /* @__PURE__ */ application("vnd.oma.bcast.notification+xml", "xml");
var Application_Vendor_OmaBcastProvisioningtrigger = /* @__PURE__ */ application("vnd.oma.bcast.provisioningtrigger");
var Application_Vendor_OmaBcastSgboot = /* @__PURE__ */ application("vnd.oma.bcast.sgboot");
var Application_Vendor_OmaBcastSgddXml = /* @__PURE__ */ application("vnd.oma.bcast.sgdd+xml", "xml");
var Application_Vendor_OmaBcastSgdu = /* @__PURE__ */ application("vnd.oma.bcast.sgdu");
var Application_Vendor_OmaBcastSimple_Symbol_Container = /* @__PURE__ */ application("vnd.oma.bcast.simple-symbol-container");
var Application_Vendor_OmaBcastSmartcard_TriggerXml = /* @__PURE__ */ application("vnd.oma.bcast.smartcard-trigger+xml", "xml");
var Application_Vendor_OmaBcastSprovXml = /* @__PURE__ */ application("vnd.oma.bcast.sprov+xml", "xml");
var Application_Vendor_OmaBcastStkm = /* @__PURE__ */ application("vnd.oma.bcast.stkm");
var Application_Vendor_OmaCab_Address_BookXml = /* @__PURE__ */ application("vnd.oma.cab-address-book+xml", "xml");
var Application_Vendor_OmaCab_Feature_HandlerXml = /* @__PURE__ */ application("vnd.oma.cab-feature-handler+xml", "xml");
var Application_Vendor_OmaCab_PccXml = /* @__PURE__ */ application("vnd.oma.cab-pcc+xml", "xml");
var Application_Vendor_OmaCab_Subs_InviteXml = /* @__PURE__ */ application("vnd.oma.cab-subs-invite+xml", "xml");
var Application_Vendor_OmaCab_User_PrefsXml = /* @__PURE__ */ application("vnd.oma.cab-user-prefs+xml", "xml");
var Application_Vendor_OmaDcd = /* @__PURE__ */ application("vnd.oma.dcd");
var Application_Vendor_OmaDcdc = /* @__PURE__ */ application("vnd.oma.dcdc");
var Application_Vendor_OmaDd2Xml = /* @__PURE__ */ application("vnd.oma.dd2+xml", "dd2");
var Application_Vendor_OmaDrmRisdXml = /* @__PURE__ */ application("vnd.oma.drm.risd+xml", "xml");
var Application_Vendor_Omads_EmailXml = /* @__PURE__ */ application("vnd.omads-email+xml", "xml");
var Application_Vendor_Omads_FileXml = /* @__PURE__ */ application("vnd.omads-file+xml", "xml");
var Application_Vendor_Omads_FolderXml = /* @__PURE__ */ application("vnd.omads-folder+xml", "xml");
var Application_Vendor_OmaGroup_Usage_ListXml = /* @__PURE__ */ application("vnd.oma.group-usage-list+xml", "xml");
var Application_Vendor_Omaloc_Supl_Init = /* @__PURE__ */ application("vnd.omaloc-supl-init");
var Application_Vendor_OmaLwm2mJson = /* @__PURE__ */ application("vnd.oma.lwm2m+json", "json");
var Application_Vendor_OmaLwm2mTlv = /* @__PURE__ */ application("vnd.oma.lwm2m+tlv", "tlv");
var Application_Vendor_OmaPalXml = /* @__PURE__ */ application("vnd.oma.pal+xml", "xml");
var Application_Vendor_OmaPocDetailed_Progress_ReportXml = /* @__PURE__ */ application("vnd.oma.poc.detailed-progress-report+xml", "xml");
var Application_Vendor_OmaPocFinal_ReportXml = /* @__PURE__ */ application("vnd.oma.poc.final-report+xml", "xml");
var Application_Vendor_OmaPocGroupsXml = /* @__PURE__ */ application("vnd.oma.poc.groups+xml", "xml");
var Application_Vendor_OmaPocInvocation_DescriptorXml = /* @__PURE__ */ application("vnd.oma.poc.invocation-descriptor+xml", "xml");
var Application_Vendor_OmaPocOptimized_Progress_ReportXml = /* @__PURE__ */ application("vnd.oma.poc.optimized-progress-report+xml", "xml");
var Application_Vendor_OmaPush = /* @__PURE__ */ application("vnd.oma.push");
var Application_Vendor_OmaScidmMessagesXml = /* @__PURE__ */ application("vnd.oma.scidm.messages+xml", "xml");
var Application_Vendor_OmaXcap_DirectoryXml = /* @__PURE__ */ application("vnd.oma.xcap-directory+xml", "xml");
var Application_Vendor_Onepager = /* @__PURE__ */ application("vnd.onepager");
var Application_Vendor_Onepagertamp = /* @__PURE__ */ application("vnd.onepagertamp");
var Application_Vendor_Onepagertamx = /* @__PURE__ */ application("vnd.onepagertamx");
var Application_Vendor_Onepagertat = /* @__PURE__ */ application("vnd.onepagertat");
var Application_Vendor_Onepagertatp = /* @__PURE__ */ application("vnd.onepagertatp");
var Application_Vendor_Onepagertatx = /* @__PURE__ */ application("vnd.onepagertatx");
var Application_Vendor_OpenbloxGame_Binary = /* @__PURE__ */ application("vnd.openblox.game-binary");
var Application_Vendor_OpenbloxGameXml = /* @__PURE__ */ application("vnd.openblox.game+xml", "xml");
var Application_Vendor_OpeneyeOeb = /* @__PURE__ */ application("vnd.openeye.oeb");
var Application_Vendor_OpenofficeorgExtension = /* @__PURE__ */ application("vnd.openofficeorg.extension", "oxt");
var Application_Vendor_OpenstreetmapDataXml = /* @__PURE__ */ application("vnd.openstreetmap.data+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentCustom_PropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.custom-properties+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentCustomXmlPropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.customxmlproperties+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartshapesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.chartshapes+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlChartXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.chart+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramColorsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramDataXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramdata+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramLayoutXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingmlDiagramStyleXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentDrawingXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.drawing+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentExtended_PropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.extended-properties+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentAuthorsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.commentauthors+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlCommentsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.comments+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlHandoutMasterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesMasterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.notesmaster+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlNotesSlideXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.notesslide+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentation = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.presentation", "pptx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresentationMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.presentation.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlPresPropsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.presprops+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlide = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slide", "sldx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideLayoutXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slidelayout+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideMasterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slidemaster+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshow = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideshowMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideUpdateInfoXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlSlideXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.slide+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTableStylesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.tablestyles+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTagsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.tags+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplate = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.template", "potx");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlTemplateMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.template.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentPresentationmlViewPropsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.presentationml.viewprops+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCalcChainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlChartsheetXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlCommentsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.comments+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlConnectionsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.connections+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlDialogsheetXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlExternalLinkXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheDefinitionXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotCacheRecordsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlPivotTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlQueryTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionHeadersXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlRevisionLogXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSharedStringsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheet = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlSheetMetadataXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlStylesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.styles+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableSingleCellsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.table+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplate = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlTemplateMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlUserNamesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlVolatileDependenciesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentSpreadsheetmlWorksheetXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentThemeOverrideXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.themeoverride+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentThemeXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.theme+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentVmlDrawing = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.vmldrawing");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlCommentsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.comments+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocument = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.document", "docx");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentGlossaryXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlDocumentMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlEndnotesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFontTableXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFooterXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.footer+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlFootnotesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlNumberingXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlSettingsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.settings+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlStylesXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.styles+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplate = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlTemplateMainXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml", "xml");
var Application_Vendor_Openxmlformats_OfficedocumentWordprocessingmlWebSettingsXml = /* @__PURE__ */ application("vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml", "xml");
var Application_Vendor_Openxmlformats_PackageCore_PropertiesXml = /* @__PURE__ */ application("vnd.openxmlformats-package.core-properties+xml", "xml");
var Application_Vendor_Openxmlformats_PackageDigital_Signature_XmlsignatureXml = /* @__PURE__ */ application("vnd.openxmlformats-package.digital-signature-xmlsignature+xml", "xml");
var Application_Vendor_Openxmlformats_PackageRelationshipsXml = /* @__PURE__ */ application("vnd.openxmlformats-package.relationships+xml", "xml");
var Application_Vendor_OracleResourceJson = /* @__PURE__ */ application("vnd.oracle.resource+json", "json");
var Application_Vendor_OrangeIndata = /* @__PURE__ */ application("vnd.orange.indata");
var Application_Vendor_OsaNetdeploy = /* @__PURE__ */ application("vnd.osa.netdeploy");
var Application_Vendor_OsgeoMapguidePackage = /* @__PURE__ */ application("vnd.osgeo.mapguide.package", "mgp");
var Application_Vendor_OsgiBundle = /* @__PURE__ */ application("vnd.osgi.bundle");
var Application_Vendor_OsgiDp = /* @__PURE__ */ application("vnd.osgi.dp", "dp");
var Application_Vendor_OsgiSubsystem = /* @__PURE__ */ application("vnd.osgi.subsystem", "esa");
var Application_Vendor_OtpsCt_KipXml = /* @__PURE__ */ application("vnd.otps.ct-kip+xml", "xml");
var Application_Vendor_OxliCountgraph = /* @__PURE__ */ application("vnd.oxli.countgraph");
var Application_Vendor_PagerdutyJson = /* @__PURE__ */ application("vnd.pagerduty+json", "json");
var Application_Vendor_Palm = /* @__PURE__ */ application("vnd.palm", "pdb", "pqa", "oprc");
var Application_Vendor_Panoply = /* @__PURE__ */ application("vnd.panoply");
var Application_Vendor_PaosXml = /* @__PURE__ */ application("vnd.paos.xml");
var Application_Vendor_Patentdive = /* @__PURE__ */ application("vnd.patentdive");
var Application_Vendor_Patientecommsdoc = /* @__PURE__ */ application("vnd.patientecommsdoc");
var Application_Vendor_Pawaafile = /* @__PURE__ */ application("vnd.pawaafile", "paw");
var Application_Vendor_Pcos = /* @__PURE__ */ application("vnd.pcos");
var Application_Vendor_PgFormat = /* @__PURE__ */ application("vnd.pg.format", "str");
var Application_Vendor_PgOsasli = /* @__PURE__ */ application("vnd.pg.osasli", "ei6");
var Application_Vendor_PiaccessApplication_Licence = /* @__PURE__ */ application("vnd.piaccess.application-licence");
var Application_Vendor_Picsel = /* @__PURE__ */ application("vnd.picsel", "efif");
var Application_Vendor_PmiWidget = /* @__PURE__ */ application("vnd.pmi.widget", "wg");
var Application_Vendor_PocGroup_AdvertisementXml = /* @__PURE__ */ application("vnd.poc.group-advertisement+xml", "xml");
var Application_Vendor_Pocketlearn = /* @__PURE__ */ application("vnd.pocketlearn", "plf");
var Application_Vendor_Powerbuilder6 = /* @__PURE__ */ application("vnd.powerbuilder6", "pbd");
var Application_Vendor_Powerbuilder6_S = /* @__PURE__ */ application("vnd.powerbuilder6-s");
var Application_Vendor_Powerbuilder7 = /* @__PURE__ */ application("vnd.powerbuilder7");
var Application_Vendor_Powerbuilder7_S = /* @__PURE__ */ application("vnd.powerbuilder7-s");
var Application_Vendor_Powerbuilder75 = /* @__PURE__ */ application("vnd.powerbuilder75");
var Application_Vendor_Powerbuilder75_S = /* @__PURE__ */ application("vnd.powerbuilder75-s");
var Application_Vendor_Preminet = /* @__PURE__ */ application("vnd.preminet");
var Application_Vendor_PreviewsystemsBox = /* @__PURE__ */ application("vnd.previewsystems.box", "box");
var Application_Vendor_ProteusMagazine = /* @__PURE__ */ application("vnd.proteus.magazine", "mgz");
var Application_Vendor_Psfs = /* @__PURE__ */ application("vnd.psfs");
var Application_Vendor_Publishare_Delta_Tree = /* @__PURE__ */ application("vnd.publishare-delta-tree", "qps");
var Application_Vendor_PviPtid1 = /* @__PURE__ */ application("vnd.pvi.ptid1", "ptid");
var Application_Vendor_Pwg_Multiplexed = /* @__PURE__ */ application("vnd.pwg-multiplexed");
var Application_Vendor_Pwg_Xhtml_PrintXml = /* @__PURE__ */ application("vnd.pwg-xhtml-print+xml", "xml");
var Application_Vendor_QualcommBrew_App_Res = /* @__PURE__ */ application("vnd.qualcomm.brew-app-res");
var Application_Vendor_Quarantainenet = /* @__PURE__ */ application("vnd.quarantainenet");
var Application_Vendor_QuarkQuarkXPress = /* @__PURE__ */ application("vnd.quark.quarkxpress", "qxd", "qxt", "qwd", "qwt", "qxl", "qxb");
var Application_Vendor_Quobject_Quoxdocument = /* @__PURE__ */ application("vnd.quobject-quoxdocument");
var Application_Vendor_RadisysMomlXml = /* @__PURE__ */ application("vnd.radisys.moml+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_ConfXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-conf+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_ConnXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-conn+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_DialogXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-dialog+xml", "xml");
var Application_Vendor_RadisysMsml_Audit_StreamXml = /* @__PURE__ */ application("vnd.radisys.msml-audit-stream+xml", "xml");
var Application_Vendor_RadisysMsml_AuditXml = /* @__PURE__ */ application("vnd.radisys.msml-audit+xml", "xml");
var Application_Vendor_RadisysMsml_ConfXml = /* @__PURE__ */ application("vnd.radisys.msml-conf+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_BaseXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-base+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_Fax_DetectXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-fax-detect+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_Fax_SendrecvXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-fax-sendrecv+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_GroupXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-group+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_SpeechXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-speech+xml", "xml");
var Application_Vendor_RadisysMsml_Dialog_TransformXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog-transform+xml", "xml");
var Application_Vendor_RadisysMsml_DialogXml = /* @__PURE__ */ application("vnd.radisys.msml-dialog+xml", "xml");
var Application_Vendor_RadisysMsmlXml = /* @__PURE__ */ application("vnd.radisys.msml+xml", "xml");
var Application_Vendor_RainstorData = /* @__PURE__ */ application("vnd.rainstor.data");
var Application_Vendor_Rapid = /* @__PURE__ */ application("vnd.rapid");
var Application_Vendor_Rar = /* @__PURE__ */ application("vnd.rar");
var Application_Vendor_RealvncBed = /* @__PURE__ */ application("vnd.realvnc.bed", "bed");
var Application_Vendor_RecordareMusicxml = /* @__PURE__ */ application("vnd.recordare.musicxml", "mxl");
var Application_Vendor_RecordareMusicxmlXml = /* @__PURE__ */ application("vnd.recordare.musicxml+xml", "musicxml");
var Application_Vendor_RenLearnRlprint = /* @__PURE__ */ application("vnd.renlearn.rlprint");
var Application_Vendor_RestfulJson = /* @__PURE__ */ application("vnd.restful+json", "json");
var Application_Vendor_RigCryptonote = /* @__PURE__ */ application("vnd.rig.cryptonote", "cryptonote");
var Application_Vendor_RimCod = /* @__PURE__ */ application("vnd.rim.cod", "cod");
var Application_Vendor_Rn_Realmedia = /* @__PURE__ */ application("vnd.rn-realmedia", "rm");
var Application_Vendor_Rn_Realmedia_Vbr = /* @__PURE__ */ application("vnd.rn-realmedia-vbr", "rmvb");
var Application_Vendor_Route66Link66Xml = /* @__PURE__ */ application("vnd.route66.link66+xml", "link66");
var Application_Vendor_Rs_274x = /* @__PURE__ */ application("vnd.rs-274x");
var Application_Vendor_RuckusDownload = /* @__PURE__ */ application("vnd.ruckus.download");
var Application_Vendor_S3sms = /* @__PURE__ */ application("vnd.s3sms");
var Application_Vendor_SailingtrackerTrack = /* @__PURE__ */ application("vnd.sailingtracker.track", "st");
var Application_Vendor_Sar = /* @__PURE__ */ application("vnd.sar");
var Application_Vendor_SbmCid = /* @__PURE__ */ application("vnd.sbm.cid");
var Application_Vendor_SbmMid2 = /* @__PURE__ */ application("vnd.sbm.mid2");
var Application_Vendor_Scribus = /* @__PURE__ */ application("vnd.scribus");
var Application_Vendor_Sealed3df = /* @__PURE__ */ application("vnd.sealed.3df");
var Application_Vendor_SealedCsf = /* @__PURE__ */ application("vnd.sealed.csf");
var Application_Vendor_SealedDoc = /* @__PURE__ */ application("vnd.sealed.doc");
var Application_Vendor_SealedEml = /* @__PURE__ */ application("vnd.sealed.eml");
var Application_Vendor_SealedmediaSoftsealHtml = /* @__PURE__ */ application("vnd.sealedmedia.softseal.html");
var Application_Vendor_SealedmediaSoftsealPdf = /* @__PURE__ */ application("vnd.sealedmedia.softseal.pdf");
var Application_Vendor_SealedMht = /* @__PURE__ */ application("vnd.sealed.mht");
var Application_Vendor_SealedNet = /* @__PURE__ */ application("vnd.sealed.net");
var Application_Vendor_SealedPpt = /* @__PURE__ */ application("vnd.sealed.ppt");
var Application_Vendor_SealedTiff = /* @__PURE__ */ application("vnd.sealed.tiff");
var Application_Vendor_SealedXls = /* @__PURE__ */ application("vnd.sealed.xls");
var Application_Vendor_Seemail = /* @__PURE__ */ application("vnd.seemail", "see");
var Application_Vendor_Sema = /* @__PURE__ */ application("vnd.sema", "sema");
var Application_Vendor_Semd = /* @__PURE__ */ application("vnd.semd", "semd");
var Application_Vendor_Semf = /* @__PURE__ */ application("vnd.semf", "semf");
var Application_Vendor_Shade_Save_File = /* @__PURE__ */ application("vnd.shade-save-file");
var Application_Vendor_ShanaInformedFormdata = /* @__PURE__ */ application("vnd.shana.informed.formdata", "ifm");
var Application_Vendor_ShanaInformedFormtemplate = /* @__PURE__ */ application("vnd.shana.informed.formtemplate", "itp");
var Application_Vendor_ShanaInformedInterchange = /* @__PURE__ */ application("vnd.shana.informed.interchange", "iif");
var Application_Vendor_ShanaInformedPackage = /* @__PURE__ */ application("vnd.shana.informed.package", "ipk");
var Application_Vendor_ShootproofJson = /* @__PURE__ */ application("vnd.shootproof+json", "json");
var Application_Vendor_ShopkickJson = /* @__PURE__ */ application("vnd.shopkick+json", "json");
var Application_Vendor_SigrokSession = /* @__PURE__ */ application("vnd.sigrok.session");
var Application_Vendor_SimTech_MindMapper = /* @__PURE__ */ application("vnd.simtech-mindmapper", "twd", "twds");
var Application_Vendor_SirenJson = /* @__PURE__ */ application("vnd.siren+json", "json");
var Application_Vendor_Smaf = /* @__PURE__ */ application("vnd.smaf", "mmf");
var Application_Vendor_SmartNotebook = /* @__PURE__ */ application("vnd.smart.notebook");
var Application_Vendor_SmartTeacher = /* @__PURE__ */ application("vnd.smart.teacher", "teacher");
var Application_Vendor_Software602FillerForm_Xml_Zip = /* @__PURE__ */ application("vnd.software602.filler.form-xml-zip");
var Application_Vendor_Software602FillerFormXml = /* @__PURE__ */ application("vnd.software602.filler.form+xml", "xml");
var Application_Vendor_SolentSdkmXml = /* @__PURE__ */ application("vnd.solent.sdkm+xml", "sdkm", "sdkd");
var Application_Vendor_SpotfireDxp = /* @__PURE__ */ application("vnd.spotfire.dxp", "dxp");
var Application_Vendor_SpotfireSfs = /* @__PURE__ */ application("vnd.spotfire.sfs", "sfs");
var Application_Vendor_Sqlite3 = /* @__PURE__ */ application("vnd.sqlite3");
var Application_Vendor_Sss_Cod = /* @__PURE__ */ application("vnd.sss-cod");
var Application_Vendor_Sss_Dtf = /* @__PURE__ */ application("vnd.sss-dtf");
var Application_Vendor_Sss_Ntf = /* @__PURE__ */ application("vnd.sss-ntf");
var Application_Vendor_StardivisionCalc = /* @__PURE__ */ application("vnd.stardivision.calc", "sdc");
var Application_Vendor_StardivisionDraw = /* @__PURE__ */ application("vnd.stardivision.draw", "sda");
var Application_Vendor_StardivisionImpress = /* @__PURE__ */ application("vnd.stardivision.impress", "sdd");
var Application_Vendor_StardivisionMath = /* @__PURE__ */ application("vnd.stardivision.math", "smf");
var Application_Vendor_StardivisionWriter = /* @__PURE__ */ application("vnd.stardivision.writer", "sdw", "vor");
var Application_Vendor_StardivisionWriter_Global = /* @__PURE__ */ application("vnd.stardivision.writer-global", "sgl");
var Application_Vendor_StepmaniaPackage = /* @__PURE__ */ application("vnd.stepmania.package", "smzip");
var Application_Vendor_StepmaniaStepchart = /* @__PURE__ */ application("vnd.stepmania.stepchart", "sm");
var Application_Vendor_Street_Stream = /* @__PURE__ */ application("vnd.street-stream");
var Application_Vendor_SunWadlXml = /* @__PURE__ */ application("vnd.sun.wadl+xml", "xml");
var Application_Vendor_SunXmlCalc = /* @__PURE__ */ application("vnd.sun.xml.calc", "sxc");
var Application_Vendor_SunXmlCalcTemplate = /* @__PURE__ */ application("vnd.sun.xml.calc.template", "stc");
var Application_Vendor_SunXmlDraw = /* @__PURE__ */ application("vnd.sun.xml.draw", "sxd");
var Application_Vendor_SunXmlDrawTemplate = /* @__PURE__ */ application("vnd.sun.xml.draw.template", "std");
var Application_Vendor_SunXmlImpress = /* @__PURE__ */ application("vnd.sun.xml.impress", "sxi");
var Application_Vendor_SunXmlImpressTemplate = /* @__PURE__ */ application("vnd.sun.xml.impress.template", "sti");
var Application_Vendor_SunXmlMath = /* @__PURE__ */ application("vnd.sun.xml.math", "sxm");
var Application_Vendor_SunXmlWriter = /* @__PURE__ */ application("vnd.sun.xml.writer", "sxw");
var Application_Vendor_SunXmlWriterGlobal = /* @__PURE__ */ application("vnd.sun.xml.writer.global", "sxg");
var Application_Vendor_SunXmlWriterTemplate = /* @__PURE__ */ application("vnd.sun.xml.writer.template", "stw");
var Application_Vendor_Sus_Calendar = /* @__PURE__ */ application("vnd.sus-calendar", "sus", "susp");
var Application_Vendor_Svd = /* @__PURE__ */ application("vnd.svd", "svd");
var Application_Vendor_Swiftview_Ics = /* @__PURE__ */ application("vnd.swiftview-ics");
var Application_Vendor_SymbianInstall = /* @__PURE__ */ application("vnd.symbian.install", "sis", "sisx");
var Application_Vendor_SyncmlDmddfWbxml = /* @__PURE__ */ application("vnd.syncml.dmddf+wbxml", "wbxml");
var Application_Vendor_SyncmlDmddfXml = /* @__PURE__ */ application("vnd.syncml.dmddf+xml", "xml");
var Application_Vendor_SyncmlDmNotification = /* @__PURE__ */ application("vnd.syncml.dm.notification");
var Application_Vendor_SyncmlDmtndsWbxml = /* @__PURE__ */ application("vnd.syncml.dmtnds+wbxml", "wbxml");
var Application_Vendor_SyncmlDmtndsXml = /* @__PURE__ */ application("vnd.syncml.dmtnds+xml", "xml");
var Application_Vendor_SyncmlDmWbxml = /* @__PURE__ */ application("vnd.syncml.dm+wbxml", "bdm");
var Application_Vendor_SyncmlDmXml = /* @__PURE__ */ application("vnd.syncml.dm+xml", "xdm");
var Application_Vendor_SyncmlDsNotification = /* @__PURE__ */ application("vnd.syncml.ds.notification");
var Application_Vendor_SyncmlXml = /* @__PURE__ */ application("vnd.syncml+xml", "xsm");
var Application_Vendor_TableschemaJson = /* @__PURE__ */ application("vnd.tableschema+json", "json");
var Application_Vendor_TaoIntent_Module_Archive = /* @__PURE__ */ application("vnd.tao.intent-module-archive", "tao");
var Application_Vendor_TcpdumpPcap = /* @__PURE__ */ application("vnd.tcpdump.pcap", "pcap", "cap", "dmp");
var Application_Vendor_Think_CellPpttcJson = /* @__PURE__ */ application("vnd.think-cell.ppttc+json", "json");
var Application_Vendor_TmdMediaflexApiXml = /* @__PURE__ */ application("vnd.tmd.mediaflex.api+xml", "xml");
var Application_Vendor_Tml = /* @__PURE__ */ application("vnd.tml");
var Application_Vendor_Tmobile_Livetv = /* @__PURE__ */ application("vnd.tmobile-livetv", "tmo");
var Application_Vendor_TridTpt = /* @__PURE__ */ application("vnd.trid.tpt", "tpt");
var Application_Vendor_TriOnesource = /* @__PURE__ */ application("vnd.tri.onesource");
var Application_Vendor_TriscapeMxs = /* @__PURE__ */ application("vnd.triscape.mxs", "mxs");
var Application_Vendor_Trueapp = /* @__PURE__ */ application("vnd.trueapp", "tra");
var Application_Vendor_Truedoc = /* @__PURE__ */ application("vnd.truedoc");
var Application_Vendor_UbisoftWebplayer = /* @__PURE__ */ application("vnd.ubisoft.webplayer");
var Application_Vendor_Ufdl = /* @__PURE__ */ application("vnd.ufdl", "ufd", "ufdl");
var Application_Vendor_UiqTheme = /* @__PURE__ */ application("vnd.uiq.theme", "utz");
var Application_Vendor_Umajin = /* @__PURE__ */ application("vnd.umajin", "umj");
var Application_Vendor_Unity = /* @__PURE__ */ application("vnd.unity", "unityweb");
var Application_Vendor_UomlXml = /* @__PURE__ */ application("vnd.uoml+xml", "uoml");
var Application_Vendor_UplanetAlert = /* @__PURE__ */ application("vnd.uplanet.alert");
var Application_Vendor_UplanetAlert_Wbxml = /* @__PURE__ */ application("vnd.uplanet.alert-wbxml");
var Application_Vendor_UplanetBearer_Choice = /* @__PURE__ */ application("vnd.uplanet.bearer-choice");
var Application_Vendor_UplanetBearer_Choice_Wbxml = /* @__PURE__ */ application("vnd.uplanet.bearer-choice-wbxml");
var Application_Vendor_UplanetCacheop = /* @__PURE__ */ application("vnd.uplanet.cacheop");
var Application_Vendor_UplanetCacheop_Wbxml = /* @__PURE__ */ application("vnd.uplanet.cacheop-wbxml");
var Application_Vendor_UplanetChannel = /* @__PURE__ */ application("vnd.uplanet.channel");
var Application_Vendor_UplanetChannel_Wbxml = /* @__PURE__ */ application("vnd.uplanet.channel-wbxml");
var Application_Vendor_UplanetList = /* @__PURE__ */ application("vnd.uplanet.list");
var Application_Vendor_UplanetList_Wbxml = /* @__PURE__ */ application("vnd.uplanet.list-wbxml");
var Application_Vendor_UplanetListcmd = /* @__PURE__ */ application("vnd.uplanet.listcmd");
var Application_Vendor_UplanetListcmd_Wbxml = /* @__PURE__ */ application("vnd.uplanet.listcmd-wbxml");
var Application_Vendor_UplanetSignal = /* @__PURE__ */ application("vnd.uplanet.signal");
var Application_Vendor_Uri_Map = /* @__PURE__ */ application("vnd.uri-map");
var Application_Vendor_ValveSourceMaterial = /* @__PURE__ */ application("vnd.valve.source.material");
var Application_Vendor_Vcx = /* @__PURE__ */ application("vnd.vcx", "vcx");
var Application_Vendor_Vd_Study = /* @__PURE__ */ application("vnd.vd-study");
var Application_Vendor_Vectorworks = /* @__PURE__ */ application("vnd.vectorworks");
var Application_Vendor_VelJson = /* @__PURE__ */ application("vnd.vel+json", "json");
var Application_Vendor_VerimatrixVcas = /* @__PURE__ */ application("vnd.verimatrix.vcas");
var Application_Vendor_VeryantThin = /* @__PURE__ */ application("vnd.veryant.thin");
var Application_Vendor_VesEncrypted = /* @__PURE__ */ application("vnd.ves.encrypted");
var Application_Vendor_VidsoftVidconference = /* @__PURE__ */ application("vnd.vidsoft.vidconference");
var Application_Vendor_Visio = /* @__PURE__ */ application("vnd.visio", "vsd", "vst", "vss", "vsw");
var Application_Vendor_Visionary = /* @__PURE__ */ application("vnd.visionary", "vis");
var Application_Vendor_VividenceScriptfile = /* @__PURE__ */ application("vnd.vividence.scriptfile");
var Application_Vendor_Vsf = /* @__PURE__ */ application("vnd.vsf", "vsf");
var Application_Vendor_WapSic = /* @__PURE__ */ application("vnd.wap.sic");
var Application_Vendor_WapSlc = /* @__PURE__ */ application("vnd.wap.slc");
var Application_Vendor_WapWbxml = /* @__PURE__ */ application("vnd.wap.wbxml", "wbxml");
var Application_Vendor_WapWmlc = /* @__PURE__ */ application("vnd.wap.wmlc", "wmlc");
var Application_Vendor_WapWmlscriptc = /* @__PURE__ */ application("vnd.wap.wmlscriptc", "wmlsc");
var Application_Vendor_Webturbo = /* @__PURE__ */ application("vnd.webturbo", "wtb");
var Application_Vendor_WfaP2p = /* @__PURE__ */ application("vnd.wfa.p2p");
var Application_Vendor_WfaWsc = /* @__PURE__ */ application("vnd.wfa.wsc");
var Application_Vendor_WindowsDevicepairing = /* @__PURE__ */ application("vnd.windows.devicepairing");
var Application_Vendor_Wmc = /* @__PURE__ */ application("vnd.wmc");
var Application_Vendor_WmfBootstrap = /* @__PURE__ */ application("vnd.wmf.bootstrap");
var Application_Vendor_WolframMathematica = /* @__PURE__ */ application("vnd.wolfram.mathematica");
var Application_Vendor_WolframMathematicaPackage = /* @__PURE__ */ application("vnd.wolfram.mathematica.package");
var Application_Vendor_WolframPlayer = /* @__PURE__ */ application("vnd.wolfram.player", "nbp");
var Application_Vendor_Wordperfect = /* @__PURE__ */ application("vnd.wordperfect", "wpd");
var Application_Vendor_Wqd = /* @__PURE__ */ application("vnd.wqd", "wqd");
var Application_Vendor_Wrq_Hp3000_Labelled = /* @__PURE__ */ application("vnd.wrq-hp3000-labelled");
var Application_Vendor_WtStf = /* @__PURE__ */ application("vnd.wt.stf", "stf");
var Application_Vendor_WvCspWbxml = /* @__PURE__ */ application("vnd.wv.csp+wbxml", "wbxml");
var Application_Vendor_WvCspXml = /* @__PURE__ */ application("vnd.wv.csp+xml", "xml");
var Application_Vendor_WvSspXml = /* @__PURE__ */ application("vnd.wv.ssp+xml", "xml");
var Application_Vendor_XacmlJson = /* @__PURE__ */ application("vnd.xacml+json", "json");
var Application_Vendor_Xara = /* @__PURE__ */ application("vnd.xara", "xar");
var Application_Vendor_Xfdl = /* @__PURE__ */ application("vnd.xfdl", "xfdl");
var Application_Vendor_XfdlWebform = /* @__PURE__ */ application("vnd.xfdl.webform");
var Application_Vendor_XmiXml = /* @__PURE__ */ application("vnd.xmi+xml", "xml");
var Application_Vendor_XmpieCpkg = /* @__PURE__ */ application("vnd.xmpie.cpkg");
var Application_Vendor_XmpieDpkg = /* @__PURE__ */ application("vnd.xmpie.dpkg");
var Application_Vendor_XmpiePlan = /* @__PURE__ */ application("vnd.xmpie.plan");
var Application_Vendor_XmpiePpkg = /* @__PURE__ */ application("vnd.xmpie.ppkg");
var Application_Vendor_XmpieXlim = /* @__PURE__ */ application("vnd.xmpie.xlim");
var Application_Vendor_YamahaHv_Dic = /* @__PURE__ */ application("vnd.yamaha.hv-dic", "hvd");
var Application_Vendor_YamahaHv_Script = /* @__PURE__ */ application("vnd.yamaha.hv-script", "hvs");
var Application_Vendor_YamahaHv_Voice = /* @__PURE__ */ application("vnd.yamaha.hv-voice", "hvp");
var Application_Vendor_YamahaOpenscoreformat = /* @__PURE__ */ application("vnd.yamaha.openscoreformat", "osf");
var Application_Vendor_YamahaOpenscoreformatOsfpvgXml = /* @__PURE__ */ application("vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg");
var Application_Vendor_YamahaRemote_Setup = /* @__PURE__ */ application("vnd.yamaha.remote-setup");
var Application_Vendor_YamahaSmaf_Audio = /* @__PURE__ */ application("vnd.yamaha.smaf-audio", "saf");
var Application_Vendor_YamahaSmaf_Phrase = /* @__PURE__ */ application("vnd.yamaha.smaf-phrase", "spf");
var Application_Vendor_YamahaThrough_Ngn = /* @__PURE__ */ application("vnd.yamaha.through-ngn");
var Application_Vendor_YamahaTunnel_Udpencap = /* @__PURE__ */ application("vnd.yamaha.tunnel-udpencap");
var Application_Vendor_Yaoweme = /* @__PURE__ */ application("vnd.yaoweme");
var Application_Vendor_Yellowriver_Custom_Menu = /* @__PURE__ */ application("vnd.yellowriver-custom-menu", "cmp");
var Application_Vendor_YoutubeYt = /* @__PURE__ */ application("vnd.youtube.yt").deprecate("in favor of video/vnd.youtube.yt");
var Application_Vendor_Zul = /* @__PURE__ */ application("vnd.zul", "zir", "zirz");
var Application_Vendor_ZzazzDeckXml = /* @__PURE__ */ application("vnd.zzazz.deck+xml", "zaz");
var Application_VividenceScriptfile = /* @__PURE__ */ application("vividence.scriptfile");
var Application_VoicexmlXml = /* @__PURE__ */ application("voicexml+xml", "vxml");
var Application_Voucher_CmsJson = /* @__PURE__ */ application("voucher-cms+json", "json");
var Application_Vq_Rtcpxr = /* @__PURE__ */ application("vq-rtcpxr");
var Application_Wasm = /* @__PURE__ */ application("wasm", "wasm");
var Application_WatcherinfoXml = /* @__PURE__ */ application("watcherinfo+xml", "xml");
var Application_Webpush_OptionsJson = /* @__PURE__ */ application("webpush-options+json", "json");
var Application_Whoispp_Query = /* @__PURE__ */ application("whoispp-query");
var Application_Whoispp_Response = /* @__PURE__ */ application("whoispp-response");
var Application_Widget = /* @__PURE__ */ application("widget", "wgt");
var Application_Winhlp = /* @__PURE__ */ application("winhlp", "hlp");
var Application_Wita = /* @__PURE__ */ application("wita");
var Application_Wordperfect51 = /* @__PURE__ */ application("wordperfect5.1");
var Application_WsdlXml = /* @__PURE__ */ application("wsdl+xml", "wsdl");
var Application_WspolicyXml = /* @__PURE__ */ application("wspolicy+xml", "wspolicy");
var Application_X_7z_Compressed = /* @__PURE__ */ application("x-7z-compressed", "7z");
var Application_X_Abiword = /* @__PURE__ */ application("x-abiword", "abw");
var Application_X_Ace_Compressed = /* @__PURE__ */ application("x-ace-compressed", "ace");
var Application_X_Amf = /* @__PURE__ */ application("x-amf");
var Application_X_Apple_Diskimage = /* @__PURE__ */ application("x-apple-diskimage", "dmg");
var Application_X_Arj = /* @__PURE__ */ application("x-arj", "arj");
var Application_X_Authorware_Bin = /* @__PURE__ */ application("x-authorware-bin", "aab", "x32", "u32", "vox");
var Application_X_Authorware_Map = /* @__PURE__ */ application("x-authorware-map", "aam");
var Application_X_Authorware_Seg = /* @__PURE__ */ application("x-authorware-seg", "aas");
var Application_X_Bcpio = /* @__PURE__ */ application("x-bcpio", "bcpio");
var Application_X_Bdoc = /* @__PURE__ */ application("x-bdoc", "bdoc");
var Application_X_Bittorrent = /* @__PURE__ */ application("x-bittorrent", "torrent");
var Application_X_Blorb = /* @__PURE__ */ application("x-blorb", "blb", "blorb");
var Application_X_Bzip = /* @__PURE__ */ application("x-bzip", "bz");
var Application_X_Bzip2 = /* @__PURE__ */ application("x-bzip2", "bz2", "boz");
var Application_X_Cbr = /* @__PURE__ */ application("x-cbr", "cbr", "cba", "cbt", "cbz", "cb7");
var Application_X_Cdlink = /* @__PURE__ */ application("x-cdlink", "vcd");
var Application_X_Cfs_Compressed = /* @__PURE__ */ application("x-cfs-compressed", "cfs");
var Application_X_Chat = /* @__PURE__ */ application("x-chat", "chat");
var Application_X_Chess_Pgn = /* @__PURE__ */ application("x-chess-pgn", "pgn");
var Application_X_Chrome_Extension = /* @__PURE__ */ application("x-chrome-extension", "crx");
var Application_X_Deb = /* @__PURE__ */ application("x-deb");
var Application_X_Compress = /* @__PURE__ */ application("x-compress");
var Application_X_Conference = /* @__PURE__ */ application("x-conference", "nsc");
var Application_X_Cpio = /* @__PURE__ */ application("x-cpio", "cpio");
var Application_X_Csh = /* @__PURE__ */ application("x-csh", "csh");
var Application_X_Debian_Package = /* @__PURE__ */ application("x-debian-package", "deb", "udeb");
var Application_X_Dgc_Compressed = /* @__PURE__ */ application("x-dgc-compressed", "dgc");
var Application_X_Director = /* @__PURE__ */ application("x-director", "dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa");
var Application_X_Doom = /* @__PURE__ */ application("x-doom", "wad");
var Application_X_DtbncxXml = /* @__PURE__ */ application("x-dtbncx+xml", "ncx");
var Application_X_DtbookXml = /* @__PURE__ */ application("x-dtbook+xml", "dtb");
var Application_X_DtbresourceXml = /* @__PURE__ */ application("x-dtbresource+xml", "res");
var Application_X_Dvi = /* @__PURE__ */ application("x-dvi", "dvi");
var Application_X_Envoy = /* @__PURE__ */ application("x-envoy", "evy");
var Application_X_Eva = /* @__PURE__ */ application("x-eva", "eva");
var Application_X_Font_Bdf = /* @__PURE__ */ application("x-font-bdf", "bdf");
var Application_X_Font_Dos = /* @__PURE__ */ application("x-font-dos");
var Application_X_Font_Framemaker = /* @__PURE__ */ application("x-font-framemaker");
var Application_X_Font_Ghostscript = /* @__PURE__ */ application("x-font-ghostscript", "gsf");
var Application_X_Font_Libgrx = /* @__PURE__ */ application("x-font-libgrx");
var Application_X_Font_Linux_Psf = /* @__PURE__ */ application("x-font-linux-psf", "psf");
var Application_X_Font_Pcf = /* @__PURE__ */ application("x-font-pcf", "pcf");
var Application_X_Font_Snf = /* @__PURE__ */ application("x-font-snf", "snf");
var Application_X_Font_Speedo = /* @__PURE__ */ application("x-font-speedo");
var Application_X_Font_Sunos_News = /* @__PURE__ */ application("x-font-sunos-news");
var Application_X_Font_Type1 = /* @__PURE__ */ application("x-font-type1", "pfa", "pfb", "pfm", "afm");
var Application_X_Font_Vfont = /* @__PURE__ */ application("x-font-vfont");
var Application_X_Freearc = /* @__PURE__ */ application("x-freearc", "arc");
var Application_X_Futuresplash = /* @__PURE__ */ application("x-futuresplash", "spl");
var Application_X_Gca_Compressed = /* @__PURE__ */ application("x-gca-compressed", "gca");
var Application_X_Glulx = /* @__PURE__ */ application("x-glulx", "ulx");
var Application_X_Gnumeric = /* @__PURE__ */ application("x-gnumeric", "gnumeric");
var Application_X_Gramps_Xml = /* @__PURE__ */ application("x-gramps-xml", "gramps");
var Application_X_Gtar = /* @__PURE__ */ application("x-gtar", "gtar");
var Application_X_Gzip = /* @__PURE__ */ application("x-gzip");
var Application_X_Hdf = /* @__PURE__ */ application("x-hdf", "hdf");
var Application_X_Httpd_Php = /* @__PURE__ */ application("x-httpd-php", "php");
var Application_X_Install_Instructions = /* @__PURE__ */ application("x-install-instructions", "install");
var Application_X_Iso9660_Image = /* @__PURE__ */ application("x-iso9660-image", "iso");
var Application_X_Iwork_Keynote_Sffkey = /* @__PURE__ */ application("x-iwork-keynote-sffkey", "key").deprecate("alias for iWorks Keynote file");
var Application_X_Iwork_Numbers_Sffnumbers = /* @__PURE__ */ application("x-iwork-numbers-sffnumbers", "numbers").deprecate("alias for iWorks Numbers file");
var Application_X_Iwork_Pages_Sffpages = /* @__PURE__ */ application("x-iwork-pages-sffpages", "pages").deprecate("alias for iWorks Pages file");
var Application_X_Java_Jnlp_File = /* @__PURE__ */ application("x-java-jnlp-file", "jnlp");
var Application_X_Javascript = /* @__PURE__ */ application("x-javascript");
var Application_X_Keepass2 = /* @__PURE__ */ application("x-keepass2", "kdbx");
var Application_X_Latex = /* @__PURE__ */ application("x-latex", "latex");
var Application_X_Lua_Bytecode = /* @__PURE__ */ application("x-lua-bytecode", "luac");
var Application_X_Lzh_Compressed = /* @__PURE__ */ application("x-lzh-compressed", "lzh", "lha");
var Application_X_Mie = /* @__PURE__ */ application("x-mie", "mie");
var Application_X_Mobipocket_Ebook = /* @__PURE__ */ application("x-mobipocket-ebook", "prc", "mobi");
var Application_X_Mpegurl = /* @__PURE__ */ application("x-mpegurl");
var Application_X_Ms_Application = /* @__PURE__ */ application("x-ms-application", "application");
var Application_X_Ms_Shortcut = /* @__PURE__ */ application("x-ms-shortcut", "lnk");
var Application_X_Ms_Wmd = /* @__PURE__ */ application("x-ms-wmd", "wmd");
var Application_X_Ms_Wmz = /* @__PURE__ */ application("x-ms-wmz", "wmz");
var Application_X_Ms_Xbap = /* @__PURE__ */ application("x-ms-xbap", "xbap");
var Application_X_Msdos_Program = /* @__PURE__ */ application("x-msdos-program", "exe");
var Application_X_Msaccess = /* @__PURE__ */ application("x-msaccess", "mdb");
var Application_X_Msbinder = /* @__PURE__ */ application("x-msbinder", "obd");
var Application_X_Mscardfile = /* @__PURE__ */ application("x-mscardfile", "crd");
var Application_X_Msclip = /* @__PURE__ */ application("x-msclip", "clp");
var Application_X_Msdownload = /* @__PURE__ */ application("x-msdownload", "exe", "dll", "com", "bat", "msi");
var Application_X_Msmediaview = /* @__PURE__ */ application("x-msmediaview", "mvb", "m13", "m14");
var Application_X_Msmetafile = /* @__PURE__ */ application("x-msmetafile", "wmf", "wmz", "emf", "emz");
var Application_X_Msmoney = /* @__PURE__ */ application("x-msmoney", "mny");
var Application_X_Mspublisher = /* @__PURE__ */ application("x-mspublisher", "pub");
var Application_X_Msschedule = /* @__PURE__ */ application("x-msschedule", "scd");
var Application_X_Msterminal = /* @__PURE__ */ application("x-msterminal", "trm");
var Application_X_Mswrite = /* @__PURE__ */ application("x-mswrite", "wri");
var Application_X_Netcdf = /* @__PURE__ */ application("x-netcdf", "nc", "cdf");
var Application_X_Ns_Proxy_Autoconfig = /* @__PURE__ */ application("x-ns-proxy-autoconfig", "pac");
var Application_X_Nzb = /* @__PURE__ */ application("x-nzb", "nzb");
var Application_X_Pkcs12 = /* @__PURE__ */ application("x-pkcs12", "p12", "pfx");
var Application_X_Pkcs7_Certificates = /* @__PURE__ */ application("x-pkcs7-certificates", "p7b", "spc");
var Application_X_Pkcs7_Certreqresp = /* @__PURE__ */ application("x-pkcs7-certreqresp", "p7r");
var Application_X_Rar_Compressed = /* @__PURE__ */ application("x-rar-compressed", "rar");
var Application_X_Research_Info_Systems = /* @__PURE__ */ application("x-research-info-systems", "ris");
var Application_X_Sh = /* @__PURE__ */ application("x-sh", "sh");
var Application_X_Shar = /* @__PURE__ */ application("x-shar", "shar");
var Application_X_Shockwave_Flash = /* @__PURE__ */ application("x-shockwave-flash", "swf");
var Application_X_Silverlight_App = /* @__PURE__ */ application("x-silverlight-app", "xap");
var Application_X_Sql = /* @__PURE__ */ application("x-sql", "sql");
var Application_X_Stuffit = /* @__PURE__ */ application("x-stuffit", "sit");
var Application_X_Stuffitx = /* @__PURE__ */ application("x-stuffitx", "sitx");
var Application_X_Subrip = /* @__PURE__ */ application("x-subrip", "srt");
var Application_X_Sv4cpio = /* @__PURE__ */ application("x-sv4cpio", "sv4cpio");
var Application_X_Sv4crc = /* @__PURE__ */ application("x-sv4crc", "sv4crc");
var Application_X_T3vm_Image = /* @__PURE__ */ application("x-t3vm-image", "t3");
var Application_X_Tads = /* @__PURE__ */ application("x-tads", "gam");
var Application_X_Tar = /* @__PURE__ */ application("x-tar", "tar");
var Application_X_Tcl = /* @__PURE__ */ application("x-tcl", "tcl");
var Application_X_Tex = /* @__PURE__ */ application("x-tex", "tex");
var Application_X_Tex_Tfm = /* @__PURE__ */ application("x-tex-tfm", "tfm");
var Application_X_Texinfo = /* @__PURE__ */ application("x-texinfo", "texinfo", "texi");
var Application_X_Tgif = /* @__PURE__ */ application("x-tgif", "obj");
var Application_X_Url = /* @__PURE__ */ application("x-url", "url");
var Application_X_Ustar = /* @__PURE__ */ application("x-ustar", "ustar");
var Application_X_Virtualbox_Hdd = /* @__PURE__ */ application("x-virtualbox-hdd", "hdd");
var Application_X_Virtualbox_Ova = /* @__PURE__ */ application("x-virtualbox-ova", "ova");
var Application_X_Virtualbox_Ovf = /* @__PURE__ */ application("x-virtualbox-ovf", "ovf");
var Application_X_Virtualbox_Vbox = /* @__PURE__ */ application("x-virtualbox-vbox", "vbox");
var Application_X_Virtualbox_Vbox_Extpack = /* @__PURE__ */ application("x-virtualbox-vbox-extpack", "vbox-extpack");
var Application_X_Virtualbox_Vdi = /* @__PURE__ */ application("x-virtualbox-vdi", "vdi");
var Application_X_Virtualbox_Vhd = /* @__PURE__ */ application("x-virtualbox-vhd", "vhd");
var Application_X_Virtualbox_Vmdk = /* @__PURE__ */ application("x-virtualbox-vmdk", "vmdk");
var Application_X_Wais_Source = /* @__PURE__ */ application("x-wais-source", "src");
var Application_X_Web_App_ManifestJson = /* @__PURE__ */ application("x-web-app-manifest+json", "webapp");
var Application_X_Www_Form_Urlencoded = /* @__PURE__ */ application("x-www-form-urlencoded");
var Application_X_X509_Ca_Cert = /* @__PURE__ */ application("x-x509-ca-cert", "der", "crt");
var Application_X_Xfig = /* @__PURE__ */ application("x-xfig", "fig");
var Application_X_XliffXml = /* @__PURE__ */ application("x-xliff+xml", "xlf");
var Application_X_Xpinstall = /* @__PURE__ */ application("x-xpinstall", "xpi");
var Application_X_Xz = /* @__PURE__ */ application("x-xz", "xz");
var Application_X_Zip_Compressed = /* @__PURE__ */ application("x-zip-compressed", "zip");
var Application_X_Zmachine = /* @__PURE__ */ application("x-zmachine", "z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8");
var Application_X400_Bp = /* @__PURE__ */ application("x400-bp");
var Application_XacmlXml = /* @__PURE__ */ application("xacml+xml", "xml");
var Application_XamlXml = /* @__PURE__ */ application("xaml+xml", "xaml");
var Application_Xcap_AttXml = /* @__PURE__ */ application("xcap-att+xml", "xml");
var Application_Xcap_CapsXml = /* @__PURE__ */ application("xcap-caps+xml", "xml");
var Application_Xcap_DiffXml = /* @__PURE__ */ application("xcap-diff+xml", "xdf");
var Application_Xcap_ElXml = /* @__PURE__ */ application("xcap-el+xml", "xml");
var Application_Xcap_ErrorXml = /* @__PURE__ */ application("xcap-error+xml", "xml");
var Application_Xcap_NsXml = /* @__PURE__ */ application("xcap-ns+xml", "xml");
var Application_Xcon_Conference_Info_DiffXml = /* @__PURE__ */ application("xcon-conference-info-diff+xml", "xml");
var Application_Xcon_Conference_InfoXml = /* @__PURE__ */ application("xcon-conference-info+xml", "xml");
var Application_XencXml = /* @__PURE__ */ application("xenc+xml", "xenc");
var Application_Xhtml_VoiceXml = /* @__PURE__ */ application("xhtml-voice+xml", "xml");
var Application_XhtmlXml = /* @__PURE__ */ application("xhtml+xml", "xhtml", "xht");
var Application_XliffXml = /* @__PURE__ */ application("xliff+xml", "xml");
var Application_Xml = /* @__PURE__ */ application("xml", "xml", "xsl");
var Application_Xml_Dtd = /* @__PURE__ */ application("xml-dtd", "dtd");
var Application_Xml_External_Parsed_Entity = /* @__PURE__ */ application("xml-external-parsed-entity");
var Application_Xml_PatchXml = /* @__PURE__ */ application("xml-patch+xml", "xml");
var Application_XmppXml = /* @__PURE__ */ application("xmpp+xml", "xml");
var Application_XopXml = /* @__PURE__ */ application("xop+xml", "xop");
var Application_XprocXml = /* @__PURE__ */ application("xproc+xml", "xpl");
var Application_XsltXml = /* @__PURE__ */ application("xslt+xml", "xslt");
var Application_XspfXml = /* @__PURE__ */ application("xspf+xml", "xspf");
var Application_XvXml = /* @__PURE__ */ application("xv+xml", "mxml", "xhvml", "xvml", "xvm");
var Application_Yang = /* @__PURE__ */ application("yang", "yang");
var Application_Yang_DataJson = /* @__PURE__ */ application("yang-data+json", "json");
var Application_Yang_DataXml = /* @__PURE__ */ application("yang-data+xml", "xml");
var Application_Yang_PatchJson = /* @__PURE__ */ application("yang-patch+json", "json");
var Application_Yang_PatchXml = /* @__PURE__ */ application("yang-patch+xml", "xml");
var Application_YinXml = /* @__PURE__ */ application("yin+xml", "yin");
var Application_Zip = /* @__PURE__ */ application("zip", "zip");
var Application_Zlib = /* @__PURE__ */ application("zlib");
var Application_Zstd = /* @__PURE__ */ application("zstd");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/audio.ts
var audio_exports = {};
__export(audio_exports, {
  Audio_AMR: () => Audio_AMR,
  Audio_AMR_WB: () => Audio_AMR_WB,
  Audio_ATRAC3: () => Audio_ATRAC3,
  Audio_ATRAC_ADVANCED_LOSSLESS: () => Audio_ATRAC_ADVANCED_LOSSLESS,
  Audio_ATRAC_X: () => Audio_ATRAC_X,
  Audio_Aac: () => Audio_Aac,
  Audio_Ac3: () => Audio_Ac3,
  Audio_Adpcm: () => Audio_Adpcm,
  Audio_Amr_WbPlus: () => Audio_Amr_WbPlus,
  Audio_Aptx: () => Audio_Aptx,
  Audio_Asc: () => Audio_Asc,
  Audio_BV16: () => Audio_BV16,
  Audio_BV32: () => Audio_BV32,
  Audio_Basic: () => Audio_Basic,
  Audio_CN: () => Audio_CN,
  Audio_Clearmode: () => Audio_Clearmode,
  Audio_DAT12: () => Audio_DAT12,
  Audio_DV: () => Audio_DV,
  Audio_DVI4: () => Audio_DVI4,
  Audio_Dls: () => Audio_Dls,
  Audio_Dsr_Es201108: () => Audio_Dsr_Es201108,
  Audio_Dsr_Es202050: () => Audio_Dsr_Es202050,
  Audio_Dsr_Es202211: () => Audio_Dsr_Es202211,
  Audio_Dsr_Es202212: () => Audio_Dsr_Es202212,
  Audio_EVRC: () => Audio_EVRC,
  Audio_EVRC0: () => Audio_EVRC0,
  Audio_EVRC1: () => Audio_EVRC1,
  Audio_EVRCB: () => Audio_EVRCB,
  Audio_EVRCB0: () => Audio_EVRCB0,
  Audio_EVRCB1: () => Audio_EVRCB1,
  Audio_EVRCNW: () => Audio_EVRCNW,
  Audio_EVRCNW0: () => Audio_EVRCNW0,
  Audio_EVRCNW1: () => Audio_EVRCNW1,
  Audio_EVRCWB: () => Audio_EVRCWB,
  Audio_EVRCWB0: () => Audio_EVRCWB0,
  Audio_EVRCWB1: () => Audio_EVRCWB1,
  Audio_EVRC_QCP: () => Audio_EVRC_QCP,
  Audio_EVS: () => Audio_EVS,
  Audio_Eac3: () => Audio_Eac3,
  Audio_Encaprtp: () => Audio_Encaprtp,
  Audio_Example: () => Audio_Example,
  Audio_Flexfec: () => Audio_Flexfec,
  Audio_Fwdred: () => Audio_Fwdred,
  Audio_G711_0: () => Audio_G711_0,
  Audio_G719: () => Audio_G719,
  Audio_G722: () => Audio_G722,
  Audio_G7221: () => Audio_G7221,
  Audio_G723: () => Audio_G723,
  Audio_G726_16: () => Audio_G726_16,
  Audio_G726_24: () => Audio_G726_24,
  Audio_G726_32: () => Audio_G726_32,
  Audio_G726_40: () => Audio_G726_40,
  Audio_G728: () => Audio_G728,
  Audio_G729: () => Audio_G729,
  Audio_G7291: () => Audio_G7291,
  Audio_G729D: () => Audio_G729D,
  Audio_G729E: () => Audio_G729E,
  Audio_GSM: () => Audio_GSM,
  Audio_GSM_EFR: () => Audio_GSM_EFR,
  Audio_GSM_HR_08: () => Audio_GSM_HR_08,
  Audio_ILBC: () => Audio_ILBC,
  Audio_Ip_Mr_v25: () => Audio_Ip_Mr_v25,
  Audio_Isac: () => Audio_Isac,
  Audio_L16: () => Audio_L16,
  Audio_L20: () => Audio_L20,
  Audio_L24: () => Audio_L24,
  Audio_L8: () => Audio_L8,
  Audio_LPC: () => Audio_LPC,
  Audio_MELP: () => Audio_MELP,
  Audio_MELP1200: () => Audio_MELP1200,
  Audio_MELP2400: () => Audio_MELP2400,
  Audio_MELP600: () => Audio_MELP600,
  Audio_MP4A_LATM: () => Audio_MP4A_LATM,
  Audio_MPA: () => Audio_MPA,
  Audio_Midi: () => Audio_Midi,
  Audio_Mobile_Xmf: () => Audio_Mobile_Xmf,
  Audio_Mp4: () => Audio_Mp4,
  Audio_Mpa_Robust: () => Audio_Mpa_Robust,
  Audio_Mpeg: () => Audio_Mpeg,
  Audio_Mpeg4_Generic: () => Audio_Mpeg4_Generic,
  Audio_Musepack: () => Audio_Musepack,
  Audio_Ogg: () => Audio_Ogg,
  Audio_Opus: () => Audio_Opus,
  Audio_PCMA: () => Audio_PCMA,
  Audio_PCMA_WB: () => Audio_PCMA_WB,
  Audio_PCMU: () => Audio_PCMU,
  Audio_PCMU_WB: () => Audio_PCMU_WB,
  Audio_Parityfec: () => Audio_Parityfec,
  Audio_PrsSid: () => Audio_PrsSid,
  Audio_Qcelp: () => Audio_Qcelp,
  Audio_RED: () => Audio_RED,
  Audio_Raptorfec: () => Audio_Raptorfec,
  Audio_Rtp_Enc_Aescm128: () => Audio_Rtp_Enc_Aescm128,
  Audio_Rtp_Midi: () => Audio_Rtp_Midi,
  Audio_Rtploopback: () => Audio_Rtploopback,
  Audio_Rtx: () => Audio_Rtx,
  Audio_S3m: () => Audio_S3m,
  Audio_SMV: () => Audio_SMV,
  Audio_SMV0: () => Audio_SMV0,
  Audio_SMV_QCP: () => Audio_SMV_QCP,
  Audio_Silk: () => Audio_Silk,
  Audio_Sp_Midi: () => Audio_Sp_Midi,
  Audio_Speex: () => Audio_Speex,
  Audio_T140c: () => Audio_T140c,
  Audio_T38: () => Audio_T38,
  Audio_TETRA_ACELP: () => Audio_TETRA_ACELP,
  Audio_TETRA_ACELP_BB: () => Audio_TETRA_ACELP_BB,
  Audio_Telephone_Event: () => Audio_Telephone_Event,
  Audio_Tone: () => Audio_Tone,
  Audio_UEMCLIP: () => Audio_UEMCLIP,
  Audio_Ulpfec: () => Audio_Ulpfec,
  Audio_Usac: () => Audio_Usac,
  Audio_VDVI: () => Audio_VDVI,
  Audio_VMR_WB: () => Audio_VMR_WB,
  Audio_Vendor_1d_Interleaved_Parityfec: () => Audio_Vendor_1d_Interleaved_Parityfec,
  Audio_Vendor_32kadpcm: () => Audio_Vendor_32kadpcm,
  Audio_Vendor_3gpp: () => Audio_Vendor_3gpp,
  Audio_Vendor_3gpp2: () => Audio_Vendor_3gpp2,
  Audio_Vendor_3gppIufp: () => Audio_Vendor_3gppIufp,
  Audio_Vendor_4SB: () => Audio_Vendor_4SB,
  Audio_Vendor_Audiokoz: () => Audio_Vendor_Audiokoz,
  Audio_Vendor_CELP: () => Audio_Vendor_CELP,
  Audio_Vendor_CiscoNse: () => Audio_Vendor_CiscoNse,
  Audio_Vendor_CmlesRadio_Events: () => Audio_Vendor_CmlesRadio_Events,
  Audio_Vendor_CnsAnp1: () => Audio_Vendor_CnsAnp1,
  Audio_Vendor_CnsInf1: () => Audio_Vendor_CnsInf1,
  Audio_Vendor_DeceAudio: () => Audio_Vendor_DeceAudio,
  Audio_Vendor_Digital_Winds: () => Audio_Vendor_Digital_Winds,
  Audio_Vendor_DlnaAdts: () => Audio_Vendor_DlnaAdts,
  Audio_Vendor_DolbyHeaac1: () => Audio_Vendor_DolbyHeaac1,
  Audio_Vendor_DolbyHeaac2: () => Audio_Vendor_DolbyHeaac2,
  Audio_Vendor_DolbyMlp: () => Audio_Vendor_DolbyMlp,
  Audio_Vendor_DolbyMps: () => Audio_Vendor_DolbyMps,
  Audio_Vendor_DolbyPl2: () => Audio_Vendor_DolbyPl2,
  Audio_Vendor_DolbyPl2x: () => Audio_Vendor_DolbyPl2x,
  Audio_Vendor_DolbyPl2z: () => Audio_Vendor_DolbyPl2z,
  Audio_Vendor_DolbyPulse1: () => Audio_Vendor_DolbyPulse1,
  Audio_Vendor_Dra: () => Audio_Vendor_Dra,
  Audio_Vendor_Dts: () => Audio_Vendor_Dts,
  Audio_Vendor_DtsHd: () => Audio_Vendor_DtsHd,
  Audio_Vendor_DtsUhd: () => Audio_Vendor_DtsUhd,
  Audio_Vendor_DvbFile: () => Audio_Vendor_DvbFile,
  Audio_Vendor_EveradPlj: () => Audio_Vendor_EveradPlj,
  Audio_Vendor_HnsAudio: () => Audio_Vendor_HnsAudio,
  Audio_Vendor_LucentVoice: () => Audio_Vendor_LucentVoice,
  Audio_Vendor_Ms_PlayreadyMediaPya: () => Audio_Vendor_Ms_PlayreadyMediaPya,
  Audio_Vendor_NokiaMobile_Xmf: () => Audio_Vendor_NokiaMobile_Xmf,
  Audio_Vendor_NortelVbk: () => Audio_Vendor_NortelVbk,
  Audio_Vendor_NueraEcelp4800: () => Audio_Vendor_NueraEcelp4800,
  Audio_Vendor_NueraEcelp7470: () => Audio_Vendor_NueraEcelp7470,
  Audio_Vendor_NueraEcelp9600: () => Audio_Vendor_NueraEcelp9600,
  Audio_Vendor_OctelSbc: () => Audio_Vendor_OctelSbc,
  Audio_Vendor_PresonusMultitrack: () => Audio_Vendor_PresonusMultitrack,
  Audio_Vendor_Qcelp: () => Audio_Vendor_Qcelp,
  Audio_Vendor_Rhetorex32kadpcm: () => Audio_Vendor_Rhetorex32kadpcm,
  Audio_Vendor_Rip: () => Audio_Vendor_Rip,
  Audio_Vendor_Rn_Realaudio: () => Audio_Vendor_Rn_Realaudio,
  Audio_Vendor_SealedmediaSoftsealMpeg: () => Audio_Vendor_SealedmediaSoftsealMpeg,
  Audio_Vendor_VmxCvsd: () => Audio_Vendor_VmxCvsd,
  Audio_Vendor_Wave: () => Audio_Vendor_Wave,
  Audio_Vorbis: () => Audio_Vorbis,
  Audio_Vorbis_Config: () => Audio_Vorbis_Config,
  Audio_Wav: () => Audio_Wav,
  Audio_Wave: () => Audio_Wave,
  Audio_WebMOpus: () => Audio_WebMOpus,
  Audio_Webm: () => Audio_Webm,
  Audio_X_Aac: () => Audio_X_Aac,
  Audio_X_Aiff: () => Audio_X_Aiff,
  Audio_X_Caf: () => Audio_X_Caf,
  Audio_X_Flac: () => Audio_X_Flac,
  Audio_X_Matroska: () => Audio_X_Matroska,
  Audio_X_Mpegurl: () => Audio_X_Mpegurl,
  Audio_X_Ms_Wax: () => Audio_X_Ms_Wax,
  Audio_X_Ms_Wma: () => Audio_X_Ms_Wma,
  Audio_X_Pn_Realaudio: () => Audio_X_Pn_Realaudio,
  Audio_X_Pn_Realaudio_Plugin: () => Audio_X_Pn_Realaudio_Plugin,
  Audio_X_Tta: () => Audio_X_Tta,
  Audio_X_Wav: () => Audio_X_Wav,
  Audio_Xm: () => Audio_Xm
});
var audio = /* @__PURE__ */ specialize("audio");
var Audio_Aac = /* @__PURE__ */ audio("aac", "aac");
var Audio_Ac3 = /* @__PURE__ */ audio("ac3", "ac3");
var Audio_Adpcm = /* @__PURE__ */ audio("adpcm", "adp");
var Audio_AMR = /* @__PURE__ */ audio("amr", "amr");
var Audio_AMR_WB = /* @__PURE__ */ audio("amr-wb");
var Audio_Amr_WbPlus = /* @__PURE__ */ audio("amr-wb+");
var Audio_Aptx = /* @__PURE__ */ audio("aptx");
var Audio_Asc = /* @__PURE__ */ audio("asc");
var Audio_ATRAC_ADVANCED_LOSSLESS = /* @__PURE__ */ audio("atrac-advanced-lossless");
var Audio_ATRAC_X = /* @__PURE__ */ audio("atrac-x");
var Audio_ATRAC3 = /* @__PURE__ */ audio("atrac3");
var Audio_Basic = /* @__PURE__ */ audio("basic", "au", "snd");
var Audio_BV16 = /* @__PURE__ */ audio("bv16");
var Audio_BV32 = /* @__PURE__ */ audio("bv32");
var Audio_Clearmode = /* @__PURE__ */ audio("clearmode");
var Audio_CN = /* @__PURE__ */ audio("cn");
var Audio_DAT12 = /* @__PURE__ */ audio("dat12");
var Audio_Dls = /* @__PURE__ */ audio("dls");
var Audio_Dsr_Es201108 = /* @__PURE__ */ audio("dsr-es201108");
var Audio_Dsr_Es202050 = /* @__PURE__ */ audio("dsr-es202050");
var Audio_Dsr_Es202211 = /* @__PURE__ */ audio("dsr-es202211");
var Audio_Dsr_Es202212 = /* @__PURE__ */ audio("dsr-es202212");
var Audio_DV = /* @__PURE__ */ audio("dv");
var Audio_DVI4 = /* @__PURE__ */ audio("dvi4");
var Audio_Eac3 = /* @__PURE__ */ audio("eac3");
var Audio_Encaprtp = /* @__PURE__ */ audio("encaprtp");
var Audio_EVRC = /* @__PURE__ */ audio("evrc");
var Audio_EVRC_QCP = /* @__PURE__ */ audio("evrc-qcp");
var Audio_EVRC0 = /* @__PURE__ */ audio("evrc0");
var Audio_EVRC1 = /* @__PURE__ */ audio("evrc1");
var Audio_EVRCB = /* @__PURE__ */ audio("evrcb");
var Audio_EVRCB0 = /* @__PURE__ */ audio("evrcb0");
var Audio_EVRCB1 = /* @__PURE__ */ audio("evrcb1");
var Audio_EVRCNW = /* @__PURE__ */ audio("evrcnw");
var Audio_EVRCNW0 = /* @__PURE__ */ audio("evrcnw0");
var Audio_EVRCNW1 = /* @__PURE__ */ audio("evrcnw1");
var Audio_EVRCWB = /* @__PURE__ */ audio("evrcwb");
var Audio_EVRCWB0 = /* @__PURE__ */ audio("evrcwb0");
var Audio_EVRCWB1 = /* @__PURE__ */ audio("evrcwb1");
var Audio_EVS = /* @__PURE__ */ audio("evs");
var Audio_Example = /* @__PURE__ */ audio("example");
var Audio_Flexfec = /* @__PURE__ */ audio("flexfec");
var Audio_Fwdred = /* @__PURE__ */ audio("fwdred");
var Audio_G711_0 = /* @__PURE__ */ audio("g711-0");
var Audio_G719 = /* @__PURE__ */ audio("g719");
var Audio_G722 = /* @__PURE__ */ audio("g722");
var Audio_G7221 = /* @__PURE__ */ audio("g7221");
var Audio_G723 = /* @__PURE__ */ audio("g723");
var Audio_G726_16 = /* @__PURE__ */ audio("g726-16");
var Audio_G726_24 = /* @__PURE__ */ audio("g726-24");
var Audio_G726_32 = /* @__PURE__ */ audio("g726-32");
var Audio_G726_40 = /* @__PURE__ */ audio("g726-40");
var Audio_G728 = /* @__PURE__ */ audio("g728");
var Audio_G729 = /* @__PURE__ */ audio("g729");
var Audio_G7291 = /* @__PURE__ */ audio("g7291");
var Audio_G729D = /* @__PURE__ */ audio("g729d");
var Audio_G729E = /* @__PURE__ */ audio("g729e");
var Audio_GSM = /* @__PURE__ */ audio("gsm", "gsm");
var Audio_GSM_EFR = /* @__PURE__ */ audio("gsm-efr");
var Audio_GSM_HR_08 = /* @__PURE__ */ audio("gsm-hr-08");
var Audio_ILBC = /* @__PURE__ */ audio("ilbc");
var Audio_Ip_Mr_v25 = /* @__PURE__ */ audio("ip-mr_v2.5");
var Audio_Isac = /* @__PURE__ */ audio("isac");
var Audio_L16 = /* @__PURE__ */ audio("l16");
var Audio_L20 = /* @__PURE__ */ audio("l20");
var Audio_L24 = /* @__PURE__ */ audio("l24");
var Audio_L8 = /* @__PURE__ */ audio("l8");
var Audio_LPC = /* @__PURE__ */ audio("lpc");
var Audio_MELP = /* @__PURE__ */ audio("melp");
var Audio_MELP1200 = /* @__PURE__ */ audio("melp1200");
var Audio_MELP2400 = /* @__PURE__ */ audio("melp2400");
var Audio_MELP600 = /* @__PURE__ */ audio("melp600");
var Audio_Midi = /* @__PURE__ */ audio("midi", "mid", "midi", "kar", "rmi");
var Audio_Mobile_Xmf = /* @__PURE__ */ audio("mobile-xmf");
var Audio_Mp4 = /* @__PURE__ */ audio("mp4", "m4a", "mp4a");
var Audio_MP4A_LATM = /* @__PURE__ */ audio("mp4a-latm");
var Audio_MPA = /* @__PURE__ */ audio("mpa");
var Audio_Mpa_Robust = /* @__PURE__ */ audio("mpa-robust");
var Audio_Mpeg = /* @__PURE__ */ audio("mpeg", "mp3", "mp2", "mp2a", "mpga", "m2a", "m3a");
var Audio_Mpeg4_Generic = /* @__PURE__ */ audio("mpeg4-generic");
var Audio_Musepack = /* @__PURE__ */ audio("musepack");
var Audio_Ogg = /* @__PURE__ */ audio("ogg", "ogg", "oga", "spx");
var Audio_Opus = /* @__PURE__ */ audio("opus");
var Audio_Parityfec = /* @__PURE__ */ audio("parityfec");
var Audio_PCMA = /* @__PURE__ */ audio("pcma");
var Audio_PCMA_WB = /* @__PURE__ */ audio("pcma-wb");
var Audio_PCMU = /* @__PURE__ */ audio("pcmu");
var Audio_PCMU_WB = /* @__PURE__ */ audio("pcmu-wb");
var Audio_PrsSid = /* @__PURE__ */ audio("prs.sid");
var Audio_Qcelp = /* @__PURE__ */ audio("qcelp");
var Audio_Raptorfec = /* @__PURE__ */ audio("raptorfec");
var Audio_RED = /* @__PURE__ */ audio("red");
var Audio_Rtp_Enc_Aescm128 = /* @__PURE__ */ audio("rtp-enc-aescm128");
var Audio_Rtp_Midi = /* @__PURE__ */ audio("rtp-midi");
var Audio_Rtploopback = /* @__PURE__ */ audio("rtploopback");
var Audio_Rtx = /* @__PURE__ */ audio("rtx");
var Audio_S3m = /* @__PURE__ */ audio("s3m", "s3m");
var Audio_Silk = /* @__PURE__ */ audio("silk", "sil");
var Audio_SMV = /* @__PURE__ */ audio("smv");
var Audio_SMV_QCP = /* @__PURE__ */ audio("smv-qcp");
var Audio_SMV0 = /* @__PURE__ */ audio("smv0");
var Audio_Sp_Midi = /* @__PURE__ */ audio("sp-midi");
var Audio_Speex = /* @__PURE__ */ audio("speex");
var Audio_T140c = /* @__PURE__ */ audio("t140c");
var Audio_T38 = /* @__PURE__ */ audio("t38");
var Audio_Telephone_Event = /* @__PURE__ */ audio("telephone-event");
var Audio_TETRA_ACELP = /* @__PURE__ */ audio("tetra_acelp");
var Audio_TETRA_ACELP_BB = /* @__PURE__ */ audio("tetra_acelp_bb");
var Audio_Tone = /* @__PURE__ */ audio("tone");
var Audio_UEMCLIP = /* @__PURE__ */ audio("uemclip");
var Audio_Ulpfec = /* @__PURE__ */ audio("ulpfec");
var Audio_Usac = /* @__PURE__ */ audio("usac");
var Audio_VDVI = /* @__PURE__ */ audio("vdvi");
var Audio_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ audio("1d-interleaved-parityfec");
var Audio_Vendor_32kadpcm = /* @__PURE__ */ audio("32kadpcm");
var Audio_Vendor_3gpp = /* @__PURE__ */ audio("3gpp");
var Audio_Vendor_3gpp2 = /* @__PURE__ */ audio("3gpp2");
var Audio_Vendor_3gppIufp = /* @__PURE__ */ audio("vnd.3gpp.iufp");
var Audio_Vendor_4SB = /* @__PURE__ */ audio("vnd.4sb");
var Audio_Vendor_Audiokoz = /* @__PURE__ */ audio("vnd.audiokoz");
var Audio_Vendor_CELP = /* @__PURE__ */ audio("vnd.celp");
var Audio_Vendor_CiscoNse = /* @__PURE__ */ audio("vnd.cisco.nse");
var Audio_Vendor_CmlesRadio_Events = /* @__PURE__ */ audio("vnd.cmles.radio-events");
var Audio_Vendor_CnsAnp1 = /* @__PURE__ */ audio("vnd.cns.anp1");
var Audio_Vendor_CnsInf1 = /* @__PURE__ */ audio("vnd.cns.inf1");
var Audio_Vendor_DeceAudio = /* @__PURE__ */ audio("vnd.dece.audio", "uva", "uvva");
var Audio_Vendor_Digital_Winds = /* @__PURE__ */ audio("vnd.digital-winds", "eol");
var Audio_Vendor_DlnaAdts = /* @__PURE__ */ audio("vnd.dlna.adts");
var Audio_Vendor_DolbyHeaac1 = /* @__PURE__ */ audio("vnd.dolby.heaac.1");
var Audio_Vendor_DolbyHeaac2 = /* @__PURE__ */ audio("vnd.dolby.heaac.2");
var Audio_Vendor_DolbyMlp = /* @__PURE__ */ audio("vnd.dolby.mlp");
var Audio_Vendor_DolbyMps = /* @__PURE__ */ audio("vnd.dolby.mps");
var Audio_Vendor_DolbyPl2 = /* @__PURE__ */ audio("vnd.dolby.pl2");
var Audio_Vendor_DolbyPl2x = /* @__PURE__ */ audio("vnd.dolby.pl2x");
var Audio_Vendor_DolbyPl2z = /* @__PURE__ */ audio("vnd.dolby.pl2z");
var Audio_Vendor_DolbyPulse1 = /* @__PURE__ */ audio("vnd.dolby.pulse.1");
var Audio_Vendor_Dra = /* @__PURE__ */ audio("vnd.dra", "dra");
var Audio_Vendor_Dts = /* @__PURE__ */ audio("vnd.dts", "dts");
var Audio_Vendor_DtsHd = /* @__PURE__ */ audio("vnd.dts.hd", "dtshd");
var Audio_Vendor_DtsUhd = /* @__PURE__ */ audio("vnd.dts.uhd");
var Audio_Vendor_DvbFile = /* @__PURE__ */ audio("vnd.dvb.file");
var Audio_Vendor_EveradPlj = /* @__PURE__ */ audio("vnd.everad.plj");
var Audio_Vendor_HnsAudio = /* @__PURE__ */ audio("vnd.hns.audio");
var Audio_Vendor_LucentVoice = /* @__PURE__ */ audio("vnd.lucent.voice", "lvp");
var Audio_Vendor_Ms_PlayreadyMediaPya = /* @__PURE__ */ audio("vnd.ms-playready.media.pya", "pya");
var Audio_Vendor_NokiaMobile_Xmf = /* @__PURE__ */ audio("vnd.nokia.mobile-xmf");
var Audio_Vendor_NortelVbk = /* @__PURE__ */ audio("vnd.nortel.vbk");
var Audio_Vendor_NueraEcelp4800 = /* @__PURE__ */ audio("vnd.nuera.ecelp4800", "ecelp4800");
var Audio_Vendor_NueraEcelp7470 = /* @__PURE__ */ audio("vnd.nuera.ecelp7470", "ecelp7470");
var Audio_Vendor_NueraEcelp9600 = /* @__PURE__ */ audio("vnd.nuera.ecelp9600", "ecelp9600");
var Audio_Vendor_OctelSbc = /* @__PURE__ */ audio("vnd.octel.sbc");
var Audio_Vendor_PresonusMultitrack = /* @__PURE__ */ audio("vnd.presonus.multitrack");
var Audio_Vendor_Qcelp = /* @__PURE__ */ audio("vnd.qcelp").deprecate("in favor of audio/qcelp");
var Audio_Vendor_Rhetorex32kadpcm = /* @__PURE__ */ audio("vnd.rhetorex.32kadpcm");
var Audio_Vendor_Rip = /* @__PURE__ */ audio("vnd.rip", "rip");
var Audio_Vendor_Rn_Realaudio = /* @__PURE__ */ audio("vnd.rn-realaudio");
var Audio_Vendor_SealedmediaSoftsealMpeg = /* @__PURE__ */ audio("vnd.sealedmedia.softseal.mpeg");
var Audio_Vendor_VmxCvsd = /* @__PURE__ */ audio("vnd.vmx.cvsd");
var Audio_Vendor_Wave = /* @__PURE__ */ audio("vnd.wave", "wav");
var Audio_VMR_WB = /* @__PURE__ */ audio("vmr-wb");
var Audio_Vorbis = /* @__PURE__ */ audio("vorbis");
var Audio_Vorbis_Config = /* @__PURE__ */ audio("vorbis-config");
var Audio_Wav = /* @__PURE__ */ audio("wav", "wav");
var Audio_Wave = /* @__PURE__ */ audio("wave", "wav");
var Audio_Webm = /* @__PURE__ */ audio("webm", "weba", "webm");
var Audio_WebMOpus = /* @__PURE__ */ audio("webm; codec=opus", "weba");
var Audio_X_Aac = /* @__PURE__ */ audio("x-aac", "aac");
var Audio_X_Aiff = /* @__PURE__ */ audio("x-aiff", "aif", "aiff", "aifc");
var Audio_X_Caf = /* @__PURE__ */ audio("x-caf", "caf");
var Audio_X_Flac = /* @__PURE__ */ audio("x-flac", "flac");
var Audio_X_Matroska = /* @__PURE__ */ audio("x-matroska", "mka");
var Audio_X_Mpegurl = /* @__PURE__ */ audio("x-mpegurl", "m3u");
var Audio_X_Ms_Wax = /* @__PURE__ */ audio("x-ms-wax", "wax");
var Audio_X_Ms_Wma = /* @__PURE__ */ audio("x-ms-wma", "wma");
var Audio_X_Pn_Realaudio = /* @__PURE__ */ audio("x-pn-realaudio", "ram", "ra");
var Audio_X_Pn_Realaudio_Plugin = /* @__PURE__ */ audio("x-pn-realaudio-plugin", "rmp");
var Audio_X_Tta = /* @__PURE__ */ audio("x-tta");
var Audio_X_Wav = /* @__PURE__ */ audio("x-wav", "wav");
var Audio_Xm = /* @__PURE__ */ audio("xm", "xm");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/chemical.ts
var chemical_exports = {};
__export(chemical_exports, {
  Chemical_X_Cdx: () => Chemical_X_Cdx,
  Chemical_X_Cif: () => Chemical_X_Cif,
  Chemical_X_Cmdf: () => Chemical_X_Cmdf,
  Chemical_X_Cml: () => Chemical_X_Cml,
  Chemical_X_Csml: () => Chemical_X_Csml,
  Chemical_X_Pdb: () => Chemical_X_Pdb,
  Chemical_X_Xyz: () => Chemical_X_Xyz
});
var chemical = /* @__PURE__ */ specialize("chemical");
var Chemical_X_Cdx = /* @__PURE__ */ chemical("x-cdx", "cdx");
var Chemical_X_Cif = /* @__PURE__ */ chemical("x-cif", "cif");
var Chemical_X_Cmdf = /* @__PURE__ */ chemical("x-cmdf", "cmdf");
var Chemical_X_Cml = /* @__PURE__ */ chemical("x-cml", "cml");
var Chemical_X_Csml = /* @__PURE__ */ chemical("x-csml", "csml");
var Chemical_X_Pdb = /* @__PURE__ */ chemical("x-pdb");
var Chemical_X_Xyz = /* @__PURE__ */ chemical("x-xyz", "xyz");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/font.ts
var font_exports = {};
__export(font_exports, {
  Font_Collection: () => Font_Collection,
  Font_Otf: () => Font_Otf,
  Font_Sfnt: () => Font_Sfnt,
  Font_Ttf: () => Font_Ttf,
  Font_Woff: () => Font_Woff,
  Font_Woff2: () => Font_Woff2
});
var font = /* @__PURE__ */ specialize("font");
var Font_Collection = /* @__PURE__ */ font("collection", "ttc");
var Font_Otf = /* @__PURE__ */ font("otf", "otf");
var Font_Sfnt = /* @__PURE__ */ font("sfnt");
var Font_Ttf = /* @__PURE__ */ font("ttf", "ttf");
var Font_Woff = /* @__PURE__ */ font("woff", "woff");
var Font_Woff2 = /* @__PURE__ */ font("woff2", "woff2");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/image.ts
var image_exports = {};
__export(image_exports, {
  Image_Aces: () => Image_Aces,
  Image_Apng: () => Image_Apng,
  Image_Avci: () => Image_Avci,
  Image_Avcs: () => Image_Avcs,
  Image_Avif: () => Image_Avif,
  Image_Bmp: () => Image_Bmp,
  Image_Cgm: () => Image_Cgm,
  Image_Dicom_Rle: () => Image_Dicom_Rle,
  Image_EXR: () => Image_EXR,
  Image_Emf: () => Image_Emf,
  Image_Example: () => Image_Example,
  Image_Fits: () => Image_Fits,
  Image_G3fax: () => Image_G3fax,
  Image_Gif: () => Image_Gif,
  Image_Heic: () => Image_Heic,
  Image_Heic_Sequence: () => Image_Heic_Sequence,
  Image_Heif: () => Image_Heif,
  Image_Heif_Sequence: () => Image_Heif_Sequence,
  Image_Hej2k: () => Image_Hej2k,
  Image_Hsj2: () => Image_Hsj2,
  Image_Ief: () => Image_Ief,
  Image_Jls: () => Image_Jls,
  Image_Jp2: () => Image_Jp2,
  Image_Jpeg: () => Image_Jpeg,
  Image_Jph: () => Image_Jph,
  Image_Jphc: () => Image_Jphc,
  Image_Jpm: () => Image_Jpm,
  Image_Jpx: () => Image_Jpx,
  Image_Jxr: () => Image_Jxr,
  Image_JxrA: () => Image_JxrA,
  Image_JxrS: () => Image_JxrS,
  Image_Jxs: () => Image_Jxs,
  Image_Jxsc: () => Image_Jxsc,
  Image_Jxsi: () => Image_Jxsi,
  Image_Jxss: () => Image_Jxss,
  Image_Ktx: () => Image_Ktx,
  Image_Naplps: () => Image_Naplps,
  Image_Pjpeg: () => Image_Pjpeg,
  Image_Png: () => Image_Png,
  Image_PrsBtif: () => Image_PrsBtif,
  Image_PrsPti: () => Image_PrsPti,
  Image_Pwg_Raster: () => Image_Pwg_Raster,
  Image_Raw: () => Image_Raw,
  Image_Sgi: () => Image_Sgi,
  Image_SvgXml: () => Image_SvgXml,
  Image_T38: () => Image_T38,
  Image_Tiff: () => Image_Tiff,
  Image_Tiff_Fx: () => Image_Tiff_Fx,
  Image_Vendor_AdobePhotoshop: () => Image_Vendor_AdobePhotoshop,
  Image_Vendor_AirzipAcceleratorAzv: () => Image_Vendor_AirzipAcceleratorAzv,
  Image_Vendor_CnsInf2: () => Image_Vendor_CnsInf2,
  Image_Vendor_DeceGraphic: () => Image_Vendor_DeceGraphic,
  Image_Vendor_Djvu: () => Image_Vendor_Djvu,
  Image_Vendor_DvbSubtitle: () => Image_Vendor_DvbSubtitle,
  Image_Vendor_Dwg: () => Image_Vendor_Dwg,
  Image_Vendor_Dxf: () => Image_Vendor_Dxf,
  Image_Vendor_Fastbidsheet: () => Image_Vendor_Fastbidsheet,
  Image_Vendor_Fpx: () => Image_Vendor_Fpx,
  Image_Vendor_Fst: () => Image_Vendor_Fst,
  Image_Vendor_FujixeroxEdmics_Mmr: () => Image_Vendor_FujixeroxEdmics_Mmr,
  Image_Vendor_FujixeroxEdmics_Rlc: () => Image_Vendor_FujixeroxEdmics_Rlc,
  Image_Vendor_GlobalgraphicsPgb: () => Image_Vendor_GlobalgraphicsPgb,
  Image_Vendor_MicrosoftIcon: () => Image_Vendor_MicrosoftIcon,
  Image_Vendor_Mix: () => Image_Vendor_Mix,
  Image_Vendor_MozillaApng: () => Image_Vendor_MozillaApng,
  Image_Vendor_Ms_Dds: () => Image_Vendor_Ms_Dds,
  Image_Vendor_Ms_Modi: () => Image_Vendor_Ms_Modi,
  Image_Vendor_Ms_Photo: () => Image_Vendor_Ms_Photo,
  Image_Vendor_Net_Fpx: () => Image_Vendor_Net_Fpx,
  Image_Vendor_Radiance: () => Image_Vendor_Radiance,
  Image_Vendor_SealedPng: () => Image_Vendor_SealedPng,
  Image_Vendor_SealedmediaSoftsealGif: () => Image_Vendor_SealedmediaSoftsealGif,
  Image_Vendor_SealedmediaSoftsealJpg: () => Image_Vendor_SealedmediaSoftsealJpg,
  Image_Vendor_Svf: () => Image_Vendor_Svf,
  Image_Vendor_TencentTap: () => Image_Vendor_TencentTap,
  Image_Vendor_ValveSourceTexture: () => Image_Vendor_ValveSourceTexture,
  Image_Vendor_WapWbmp: () => Image_Vendor_WapWbmp,
  Image_Vendor_Xiff: () => Image_Vendor_Xiff,
  Image_Vendor_ZbrushPcx: () => Image_Vendor_ZbrushPcx,
  Image_Webp: () => Image_Webp,
  Image_Wmf: () => Image_Wmf,
  Image_X_3ds: () => Image_X_3ds,
  Image_X_Cmu_Raster: () => Image_X_Cmu_Raster,
  Image_X_Cmx: () => Image_X_Cmx,
  Image_X_Emf: () => Image_X_Emf,
  Image_X_Freehand: () => Image_X_Freehand,
  Image_X_Icon: () => Image_X_Icon,
  Image_X_Mrsid_Image: () => Image_X_Mrsid_Image,
  Image_X_Ms_Bmp: () => Image_X_Ms_Bmp,
  Image_X_Pcx: () => Image_X_Pcx,
  Image_X_Pict: () => Image_X_Pict,
  Image_X_Portable_Anymap: () => Image_X_Portable_Anymap,
  Image_X_Portable_Bitmap: () => Image_X_Portable_Bitmap,
  Image_X_Portable_Graymap: () => Image_X_Portable_Graymap,
  Image_X_Portable_Pixmap: () => Image_X_Portable_Pixmap,
  Image_X_Rgb: () => Image_X_Rgb,
  Image_X_Tga: () => Image_X_Tga,
  Image_X_Wmf: () => Image_X_Wmf,
  Image_X_Xbitmap: () => Image_X_Xbitmap,
  Image_X_Xcf: () => Image_X_Xcf,
  Image_X_Xpixmap: () => Image_X_Xpixmap,
  Image_X_Xwindowdump: () => Image_X_Xwindowdump
});
var image = /* @__PURE__ */ specialize("image");
var Image_Aces = /* @__PURE__ */ image("aces");
var Image_Apng = /* @__PURE__ */ image("apng", "apng");
var Image_Avci = /* @__PURE__ */ image("avci");
var Image_Avcs = /* @__PURE__ */ image("avcs");
var Image_Avif = /* @__PURE__ */ image("avif", "avif");
var Image_Bmp = /* @__PURE__ */ image("bmp", "bmp");
var Image_Cgm = /* @__PURE__ */ image("cgm", "cgm");
var Image_Dicom_Rle = /* @__PURE__ */ image("dicom-rle");
var Image_Emf = /* @__PURE__ */ image("emf");
var Image_Example = /* @__PURE__ */ image("example");
var Image_EXR = /* @__PURE__ */ image("x-exr", "exr");
var Image_Fits = /* @__PURE__ */ image("fits");
var Image_G3fax = /* @__PURE__ */ image("g3fax", "g3");
var Image_Gif = /* @__PURE__ */ image("gif", "gif");
var Image_Heic = /* @__PURE__ */ image("heic");
var Image_Heic_Sequence = /* @__PURE__ */ image("heic-sequence");
var Image_Heif = /* @__PURE__ */ image("heif");
var Image_Heif_Sequence = /* @__PURE__ */ image("heif-sequence");
var Image_Hej2k = /* @__PURE__ */ image("hej2k");
var Image_Hsj2 = /* @__PURE__ */ image("hsj2");
var Image_Ief = /* @__PURE__ */ image("ief", "ief");
var Image_Jls = /* @__PURE__ */ image("jls");
var Image_Jp2 = /* @__PURE__ */ image("jp2");
var Image_Jpeg = /* @__PURE__ */ image("jpeg", "jpeg", "jpg", "jpe");
var Image_Jph = /* @__PURE__ */ image("jph");
var Image_Jphc = /* @__PURE__ */ image("jphc");
var Image_Jpm = /* @__PURE__ */ image("jpm");
var Image_Jpx = /* @__PURE__ */ image("jpx");
var Image_Jxr = /* @__PURE__ */ image("jxr");
var Image_JxrA = /* @__PURE__ */ image("jxra");
var Image_JxrS = /* @__PURE__ */ image("jxrs");
var Image_Jxs = /* @__PURE__ */ image("jxs");
var Image_Jxsc = /* @__PURE__ */ image("jxsc");
var Image_Jxsi = /* @__PURE__ */ image("jxsi");
var Image_Jxss = /* @__PURE__ */ image("jxss");
var Image_Ktx = /* @__PURE__ */ image("ktx", "ktx");
var Image_Naplps = /* @__PURE__ */ image("naplps");
var Image_Pjpeg = /* @__PURE__ */ image("pjpeg");
var Image_Png = /* @__PURE__ */ image("png", "png");
var Image_PrsBtif = /* @__PURE__ */ image("prs.btif", "btif");
var Image_PrsPti = /* @__PURE__ */ image("prs.pti");
var Image_Pwg_Raster = /* @__PURE__ */ image("pwg-raster");
var Image_Raw = /* @__PURE__ */ image("x-raw", "raw");
var Image_Sgi = /* @__PURE__ */ image("sgi", "sgi");
var Image_SvgXml = /* @__PURE__ */ image("svg+xml", "svg", "svgz");
var Image_T38 = /* @__PURE__ */ image("t38");
var Image_Tiff = /* @__PURE__ */ image("tiff", "tiff", "tif");
var Image_Tiff_Fx = /* @__PURE__ */ image("tiff-fx");
var Image_Vendor_AdobePhotoshop = /* @__PURE__ */ image("vnd.adobe.photoshop", "psd");
var Image_Vendor_AirzipAcceleratorAzv = /* @__PURE__ */ image("vnd.airzip.accelerator.azv");
var Image_Vendor_CnsInf2 = /* @__PURE__ */ image("vnd.cns.inf2");
var Image_Vendor_DeceGraphic = /* @__PURE__ */ image("vnd.dece.graphic", "uvi", "uvvi", "uvg", "uvvg");
var Image_Vendor_Djvu = /* @__PURE__ */ image("vnd.djvu", "djvu", "djv");
var Image_Vendor_DvbSubtitle = /* @__PURE__ */ image("vnd.dvb.subtitle", "sub");
var Image_Vendor_Dwg = /* @__PURE__ */ image("vnd.dwg", "dwg");
var Image_Vendor_Dxf = /* @__PURE__ */ image("vnd.dxf", "dxf");
var Image_Vendor_Fastbidsheet = /* @__PURE__ */ image("vnd.fastbidsheet", "fbs");
var Image_Vendor_Fpx = /* @__PURE__ */ image("vnd.fpx", "fpx");
var Image_Vendor_Fst = /* @__PURE__ */ image("vnd.fst", "fst");
var Image_Vendor_FujixeroxEdmics_Mmr = /* @__PURE__ */ image("vnd.fujixerox.edmics-mmr", "mmr");
var Image_Vendor_FujixeroxEdmics_Rlc = /* @__PURE__ */ image("vnd.fujixerox.edmics-rlc", "rlc");
var Image_Vendor_GlobalgraphicsPgb = /* @__PURE__ */ image("vnd.globalgraphics.pgb");
var Image_Vendor_MicrosoftIcon = /* @__PURE__ */ image("vnd.microsoft.icon");
var Image_Vendor_Mix = /* @__PURE__ */ image("vnd.mix");
var Image_Vendor_MozillaApng = /* @__PURE__ */ image("vnd.mozilla.apng");
var Image_Vendor_Ms_Dds = /* @__PURE__ */ image("vnd.ms-dds", "dds");
var Image_Vendor_Ms_Modi = /* @__PURE__ */ image("vnd.ms-modi", "mdi");
var Image_Vendor_Ms_Photo = /* @__PURE__ */ image("vnd.ms-photo", "wdp");
var Image_Vendor_Net_Fpx = /* @__PURE__ */ image("vnd.net-fpx", "npx");
var Image_Vendor_Radiance = /* @__PURE__ */ image("vnd.radiance");
var Image_Vendor_SealedmediaSoftsealGif = /* @__PURE__ */ image("vnd.sealedmedia.softseal.gif");
var Image_Vendor_SealedmediaSoftsealJpg = /* @__PURE__ */ image("vnd.sealedmedia.softseal.jpg");
var Image_Vendor_SealedPng = /* @__PURE__ */ image("vnd.sealed.png");
var Image_Vendor_Svf = /* @__PURE__ */ image("vnd.svf");
var Image_Vendor_TencentTap = /* @__PURE__ */ image("vnd.tencent.tap");
var Image_Vendor_ValveSourceTexture = /* @__PURE__ */ image("vnd.valve.source.texture");
var Image_Vendor_WapWbmp = /* @__PURE__ */ image("vnd.wap.wbmp", "wbmp");
var Image_Vendor_Xiff = /* @__PURE__ */ image("vnd.xiff", "xif");
var Image_Vendor_ZbrushPcx = /* @__PURE__ */ image("vnd.zbrush.pcx");
var Image_Webp = /* @__PURE__ */ image("webp", "webp");
var Image_Wmf = /* @__PURE__ */ image("wmf");
var Image_X_3ds = /* @__PURE__ */ image("x-3ds", "3ds");
var Image_X_Cmu_Raster = /* @__PURE__ */ image("x-cmu-raster", "ras");
var Image_X_Cmx = /* @__PURE__ */ image("x-cmx", "cmx");
var Image_X_Emf = /* @__PURE__ */ image("x-emf").deprecate("in favor of image/emf");
var Image_X_Freehand = /* @__PURE__ */ image("x-freehand", "fh", "fhc", "fh4", "fh5", "fh7");
var Image_X_Icon = /* @__PURE__ */ image("x-icon", "ico");
var Image_X_Mrsid_Image = /* @__PURE__ */ image("x-mrsid-image", "sid");
var Image_X_Ms_Bmp = /* @__PURE__ */ image("x-ms-bmp");
var Image_X_Pcx = /* @__PURE__ */ image("x-pcx", "pcx");
var Image_X_Pict = /* @__PURE__ */ image("x-pict", "pic", "pct");
var Image_X_Portable_Anymap = /* @__PURE__ */ image("x-portable-anymap", "pnm");
var Image_X_Portable_Bitmap = /* @__PURE__ */ image("x-portable-bitmap", "pbm");
var Image_X_Portable_Graymap = /* @__PURE__ */ image("x-portable-graymap", "pgm");
var Image_X_Portable_Pixmap = /* @__PURE__ */ image("x-portable-pixmap", "ppm");
var Image_X_Rgb = /* @__PURE__ */ image("x-rgb", "rgb");
var Image_X_Tga = /* @__PURE__ */ image("x-tga", "tga");
var Image_X_Wmf = /* @__PURE__ */ image("x-wmf").deprecate("in favor of image/wmf");
var Image_X_Xbitmap = /* @__PURE__ */ image("x-xbitmap", "xbm");
var Image_X_Xcf = /* @__PURE__ */ image("x-xcf");
var Image_X_Xpixmap = /* @__PURE__ */ image("x-xpixmap", "xpm");
var Image_X_Xwindowdump = /* @__PURE__ */ image("x-xwindowdump", "xwd");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/message.ts
var message_exports = {};
__export(message_exports, {
  Message_CPIM: () => Message_CPIM,
  Message_Delivery_Status: () => Message_Delivery_Status,
  Message_Disposition_Notification: () => Message_Disposition_Notification,
  Message_Example: () => Message_Example,
  Message_External_Body: () => Message_External_Body,
  Message_Feedback_Report: () => Message_Feedback_Report,
  Message_Global: () => Message_Global,
  Message_Global_Delivery_Status: () => Message_Global_Delivery_Status,
  Message_Global_Disposition_Notification: () => Message_Global_Disposition_Notification,
  Message_Global_Headers: () => Message_Global_Headers,
  Message_Http: () => Message_Http,
  Message_ImdnXml: () => Message_ImdnXml,
  Message_News: () => Message_News,
  Message_Partial: () => Message_Partial,
  Message_Rfc822: () => Message_Rfc822,
  Message_S_Http: () => Message_S_Http,
  Message_Sip: () => Message_Sip,
  Message_Sipfrag: () => Message_Sipfrag,
  Message_Tracking_Status: () => Message_Tracking_Status,
  Message_Vendor_SiSimp: () => Message_Vendor_SiSimp,
  Message_Vendor_WfaWsc: () => Message_Vendor_WfaWsc
});
var message = /* @__PURE__ */ specialize("message");
var Message_CPIM = /* @__PURE__ */ message("cpim");
var Message_Delivery_Status = /* @__PURE__ */ message("delivery-status");
var Message_Disposition_Notification = /* @__PURE__ */ message("disposition-notification");
var Message_Example = /* @__PURE__ */ message("example");
var Message_External_Body = /* @__PURE__ */ message("external-body");
var Message_Feedback_Report = /* @__PURE__ */ message("feedback-report");
var Message_Global = /* @__PURE__ */ message("global");
var Message_Global_Delivery_Status = /* @__PURE__ */ message("global-delivery-status");
var Message_Global_Disposition_Notification = /* @__PURE__ */ message("global-disposition-notification");
var Message_Global_Headers = /* @__PURE__ */ message("global-headers");
var Message_Http = /* @__PURE__ */ message("http");
var Message_ImdnXml = /* @__PURE__ */ message("imdn+xml", "xml");
var Message_News = /* @__PURE__ */ message("news").deprecate("by RFC5537");
var Message_Partial = /* @__PURE__ */ message("partial");
var Message_Rfc822 = /* @__PURE__ */ message("rfc822", "eml", "mime");
var Message_S_Http = /* @__PURE__ */ message("s-http");
var Message_Sip = /* @__PURE__ */ message("sip");
var Message_Sipfrag = /* @__PURE__ */ message("sipfrag");
var Message_Tracking_Status = /* @__PURE__ */ message("tracking-status");
var Message_Vendor_SiSimp = /* @__PURE__ */ message("vnd.si.simp").deprecate("by request");
var Message_Vendor_WfaWsc = /* @__PURE__ */ message("vnd.wfa.wsc");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/model.ts
var model_exports = {};
__export(model_exports, {
  Model_Example: () => Model_Example,
  Model_Gltf_Binary: () => Model_Gltf_Binary,
  Model_Gltf_Json: () => Model_Gltf_Json,
  Model_Iges: () => Model_Iges,
  Model_Mesh: () => Model_Mesh,
  Model_Stl: () => Model_Stl,
  Model_Vendor_3mf: () => Model_Vendor_3mf,
  Model_Vendor_ColladaXml: () => Model_Vendor_ColladaXml,
  Model_Vendor_Dwf: () => Model_Vendor_Dwf,
  Model_Vendor_Flatland3dml: () => Model_Vendor_Flatland3dml,
  Model_Vendor_Gdl: () => Model_Vendor_Gdl,
  Model_Vendor_GsGdl: () => Model_Vendor_GsGdl,
  Model_Vendor_Gs_Gdl: () => Model_Vendor_Gs_Gdl,
  Model_Vendor_Gtw: () => Model_Vendor_Gtw,
  Model_Vendor_MomlXml: () => Model_Vendor_MomlXml,
  Model_Vendor_Mts: () => Model_Vendor_Mts,
  Model_Vendor_Opengex: () => Model_Vendor_Opengex,
  Model_Vendor_ParasolidTransmitBinary: () => Model_Vendor_ParasolidTransmitBinary,
  Model_Vendor_ParasolidTransmitText: () => Model_Vendor_ParasolidTransmitText,
  Model_Vendor_RosetteAnnotated_Data_Model: () => Model_Vendor_RosetteAnnotated_Data_Model,
  Model_Vendor_UsdzZip: () => Model_Vendor_UsdzZip,
  Model_Vendor_ValveSourceCompiled_Map: () => Model_Vendor_ValveSourceCompiled_Map,
  Model_Vendor_Vtu: () => Model_Vendor_Vtu,
  Model_Vrml: () => Model_Vrml,
  Model_X3dBinary: () => Model_X3dBinary,
  Model_X3dFastinfoset: () => Model_X3dFastinfoset,
  Model_X3dVrml: () => Model_X3dVrml,
  Model_X3dXml: () => Model_X3dXml,
  Model_X3d_Vrml: () => Model_X3d_Vrml
});
var model = /* @__PURE__ */ specialize("model");
var Model_Example = /* @__PURE__ */ model("example");
var Model_Gltf_Binary = /* @__PURE__ */ model("gltf-binary", "glb");
var Model_Gltf_Json = /* @__PURE__ */ model("gltf+json", "gltf");
var Model_Iges = /* @__PURE__ */ model("iges", "igs", "iges");
var Model_Mesh = /* @__PURE__ */ model("mesh", "msh", "mesh", "silo");
var Model_Stl = /* @__PURE__ */ model("stl");
var Model_Vendor_3mf = /* @__PURE__ */ model("3mf");
var Model_Vendor_ColladaXml = /* @__PURE__ */ model("vnd.collada+xml", "dae");
var Model_Vendor_Dwf = /* @__PURE__ */ model("vnd.dwf", "dwf");
var Model_Vendor_Flatland3dml = /* @__PURE__ */ model("vnd.flatland.3dml");
var Model_Vendor_Gdl = /* @__PURE__ */ model("vnd.gdl", "gdl");
var Model_Vendor_Gs_Gdl = /* @__PURE__ */ model("vnd.gs-gdl");
var Model_Vendor_GsGdl = /* @__PURE__ */ model("vnd.gs.gdl");
var Model_Vendor_Gtw = /* @__PURE__ */ model("vnd.gtw", "gtw");
var Model_Vendor_MomlXml = /* @__PURE__ */ model("vnd.moml+xml", "xml");
var Model_Vendor_Mts = /* @__PURE__ */ model("vnd.mts", "mts");
var Model_Vendor_Opengex = /* @__PURE__ */ model("vnd.opengex");
var Model_Vendor_ParasolidTransmitBinary = /* @__PURE__ */ model("vnd.parasolid.transmit.binary");
var Model_Vendor_ParasolidTransmitText = /* @__PURE__ */ model("vnd.parasolid.transmit.text");
var Model_Vendor_RosetteAnnotated_Data_Model = /* @__PURE__ */ model("vnd.rosette.annotated-data-model");
var Model_Vendor_UsdzZip = /* @__PURE__ */ model("vnd.usdz+zip", "zip");
var Model_Vendor_ValveSourceCompiled_Map = /* @__PURE__ */ model("vnd.valve.source.compiled-map");
var Model_Vendor_Vtu = /* @__PURE__ */ model("vnd.vtu", "vtu");
var Model_Vrml = /* @__PURE__ */ model("vrml", "wrl", "vrml");
var Model_X3d_Vrml = /* @__PURE__ */ model("x3d-vrml");
var Model_X3dBinary = /* @__PURE__ */ model("x3d+binary", "x3db", "x3dbz");
var Model_X3dFastinfoset = /* @__PURE__ */ model("x3d+fastinfoset", "fastinfoset");
var Model_X3dVrml = /* @__PURE__ */ model("x3d+vrml", "x3dv", "x3dvz");
var Model_X3dXml = /* @__PURE__ */ model("x3d+xml", "x3d", "x3dz");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/multipart.ts
var multipart_exports = {};
__export(multipart_exports, {
  MultipartAlternative: () => MultipartAlternative,
  MultipartAppledouble: () => MultipartAppledouble,
  MultipartByteranges: () => MultipartByteranges,
  MultipartDigest: () => MultipartDigest,
  MultipartEncrypted: () => MultipartEncrypted,
  MultipartExample: () => MultipartExample,
  MultipartForm_Data: () => MultipartForm_Data,
  MultipartHeader_Set: () => MultipartHeader_Set,
  MultipartMixed: () => MultipartMixed,
  MultipartMultilingual: () => MultipartMultilingual,
  MultipartParallel: () => MultipartParallel,
  MultipartRelated: () => MultipartRelated,
  MultipartReport: () => MultipartReport,
  MultipartSigned: () => MultipartSigned,
  MultipartVendorBintMed_Plus: () => MultipartVendorBintMed_Plus,
  MultipartVoice_Message: () => MultipartVoice_Message,
  MultipartX_Mixed_Replace: () => MultipartX_Mixed_Replace
});
var multipart = /* @__PURE__ */ specialize("multipart");
var MultipartAlternative = /* @__PURE__ */ multipart("alternative");
var MultipartAppledouble = /* @__PURE__ */ multipart("appledouble");
var MultipartByteranges = /* @__PURE__ */ multipart("byteranges");
var MultipartDigest = /* @__PURE__ */ multipart("digest");
var MultipartEncrypted = /* @__PURE__ */ multipart("encrypted");
var MultipartExample = /* @__PURE__ */ multipart("example");
var MultipartForm_Data = /* @__PURE__ */ multipart("form-data");
var MultipartHeader_Set = /* @__PURE__ */ multipart("header-set");
var MultipartMixed = /* @__PURE__ */ multipart("mixed");
var MultipartMultilingual = /* @__PURE__ */ multipart("multilingual");
var MultipartParallel = /* @__PURE__ */ multipart("parallel");
var MultipartRelated = /* @__PURE__ */ multipart("related");
var MultipartReport = /* @__PURE__ */ multipart("report");
var MultipartSigned = /* @__PURE__ */ multipart("signed");
var MultipartVendorBintMed_Plus = /* @__PURE__ */ multipart("vnd.bint.med-plus");
var MultipartVoice_Message = /* @__PURE__ */ multipart("voice-message");
var MultipartX_Mixed_Replace = /* @__PURE__ */ multipart("x-mixed-replace");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/text.ts
var text_exports = {};
__export(text_exports, {
  Text_Cache_Manifest: () => Text_Cache_Manifest,
  Text_Calendar: () => Text_Calendar,
  Text_Calender: () => Text_Calender,
  Text_Cmd: () => Text_Cmd,
  Text_Coffeescript: () => Text_Coffeescript,
  Text_Css: () => Text_Css,
  Text_Csv: () => Text_Csv,
  Text_Csv_Schema: () => Text_Csv_Schema,
  Text_Directory: () => Text_Directory,
  Text_Dns: () => Text_Dns,
  Text_Ecmascript: () => Text_Ecmascript,
  Text_Encaprtp: () => Text_Encaprtp,
  Text_Enriched: () => Text_Enriched,
  Text_Event_Stream: () => Text_Event_Stream,
  Text_Example: () => Text_Example,
  Text_Flexfec: () => Text_Flexfec,
  Text_Fwdred: () => Text_Fwdred,
  Text_Grammar_Ref_List: () => Text_Grammar_Ref_List,
  Text_Html: () => Text_Html,
  Text_Jade: () => Text_Jade,
  Text_Javascript: () => Text_Javascript,
  Text_Jcr_Cnd: () => Text_Jcr_Cnd,
  Text_Jsx: () => Text_Jsx,
  Text_Less: () => Text_Less,
  Text_Markdown: () => Text_Markdown,
  Text_Mdx: () => Text_Mdx,
  Text_Mizar: () => Text_Mizar,
  Text_N3: () => Text_N3,
  Text_Parameters: () => Text_Parameters,
  Text_Parityfec: () => Text_Parityfec,
  Text_Plain: () => Text_Plain,
  Text_PlainUTF8: () => Text_PlainUTF8,
  Text_Provenance_Notation: () => Text_Provenance_Notation,
  Text_PrsFallensteinRst: () => Text_PrsFallensteinRst,
  Text_PrsLinesTag: () => Text_PrsLinesTag,
  Text_PrsPropLogic: () => Text_PrsPropLogic,
  Text_RED: () => Text_RED,
  Text_Raptorfec: () => Text_Raptorfec,
  Text_Rfc822_Headers: () => Text_Rfc822_Headers,
  Text_Richtext: () => Text_Richtext,
  Text_Rtf: () => Text_Rtf,
  Text_Rtp_Enc_Aescm128: () => Text_Rtp_Enc_Aescm128,
  Text_Rtploopback: () => Text_Rtploopback,
  Text_Rtx: () => Text_Rtx,
  Text_Sgml: () => Text_Sgml,
  Text_Shex: () => Text_Shex,
  Text_Slim: () => Text_Slim,
  Text_Strings: () => Text_Strings,
  Text_Stylus: () => Text_Stylus,
  Text_T140: () => Text_T140,
  Text_Tab_Separated_Values: () => Text_Tab_Separated_Values,
  Text_Troff: () => Text_Troff,
  Text_Turtle: () => Text_Turtle,
  Text_Ulpfec: () => Text_Ulpfec,
  Text_Uri_List: () => Text_Uri_List,
  Text_Vcard: () => Text_Vcard,
  Text_Vendor_1d_Interleaved_Parityfec: () => Text_Vendor_1d_Interleaved_Parityfec,
  Text_Vendor_A: () => Text_Vendor_A,
  Text_Vendor_Abc: () => Text_Vendor_Abc,
  Text_Vendor_Ascii_Art: () => Text_Vendor_Ascii_Art,
  Text_Vendor_Curl: () => Text_Vendor_Curl,
  Text_Vendor_CurlDcurl: () => Text_Vendor_CurlDcurl,
  Text_Vendor_CurlMcurl: () => Text_Vendor_CurlMcurl,
  Text_Vendor_CurlScurl: () => Text_Vendor_CurlScurl,
  Text_Vendor_DMClientScript: () => Text_Vendor_DMClientScript,
  Text_Vendor_DebianCopyright: () => Text_Vendor_DebianCopyright,
  Text_Vendor_DvbSubtitle: () => Text_Vendor_DvbSubtitle,
  Text_Vendor_EsmertecTheme_Descriptor: () => Text_Vendor_EsmertecTheme_Descriptor,
  Text_Vendor_FiclabFlt: () => Text_Vendor_FiclabFlt,
  Text_Vendor_Fly: () => Text_Vendor_Fly,
  Text_Vendor_FmiFlexstor: () => Text_Vendor_FmiFlexstor,
  Text_Vendor_Gml: () => Text_Vendor_Gml,
  Text_Vendor_Graphviz: () => Text_Vendor_Graphviz,
  Text_Vendor_Hgl: () => Text_Vendor_Hgl,
  Text_Vendor_IPTCNITF: () => Text_Vendor_IPTCNITF,
  Text_Vendor_IPTCNewsML: () => Text_Vendor_IPTCNewsML,
  Text_Vendor_In3d3dml: () => Text_Vendor_In3d3dml,
  Text_Vendor_In3dSpot: () => Text_Vendor_In3dSpot,
  Text_Vendor_Latex_Z: () => Text_Vendor_Latex_Z,
  Text_Vendor_MotorolaReflex: () => Text_Vendor_MotorolaReflex,
  Text_Vendor_Ms_Mediapackage: () => Text_Vendor_Ms_Mediapackage,
  Text_Vendor_Net2phoneCommcenterCommand: () => Text_Vendor_Net2phoneCommcenterCommand,
  Text_Vendor_RadisysMsml_Basic_Layout: () => Text_Vendor_RadisysMsml_Basic_Layout,
  Text_Vendor_SenxWarpscript: () => Text_Vendor_SenxWarpscript,
  Text_Vendor_SiUricatalogue: () => Text_Vendor_SiUricatalogue,
  Text_Vendor_Sosi: () => Text_Vendor_Sosi,
  Text_Vendor_SunJ2meApp_Descriptor: () => Text_Vendor_SunJ2meApp_Descriptor,
  Text_Vendor_TrolltechLinguist: () => Text_Vendor_TrolltechLinguist,
  Text_Vendor_WapSi: () => Text_Vendor_WapSi,
  Text_Vendor_WapSl: () => Text_Vendor_WapSl,
  Text_Vendor_WapWml: () => Text_Vendor_WapWml,
  Text_Vendor_WapWmlscript: () => Text_Vendor_WapWmlscript,
  Text_Vtt: () => Text_Vtt,
  Text_X_Asm: () => Text_X_Asm,
  Text_X_C: () => Text_X_C,
  Text_X_Fortran: () => Text_X_Fortran,
  Text_X_Gwt_Rpc: () => Text_X_Gwt_Rpc,
  Text_X_Handlebars_Template: () => Text_X_Handlebars_Template,
  Text_X_Java_Source: () => Text_X_Java_Source,
  Text_X_Jquery_Tmpl: () => Text_X_Jquery_Tmpl,
  Text_X_Lua: () => Text_X_Lua,
  Text_X_Markdown: () => Text_X_Markdown,
  Text_X_Nfo: () => Text_X_Nfo,
  Text_X_Opml: () => Text_X_Opml,
  Text_X_Org: () => Text_X_Org,
  Text_X_Pascal: () => Text_X_Pascal,
  Text_X_Processing: () => Text_X_Processing,
  Text_X_Sass: () => Text_X_Sass,
  Text_X_Scss: () => Text_X_Scss,
  Text_X_Setext: () => Text_X_Setext,
  Text_X_Sfv: () => Text_X_Sfv,
  Text_X_Suse_Ymp: () => Text_X_Suse_Ymp,
  Text_X_Uuencode: () => Text_X_Uuencode,
  Text_X_Vcalendar: () => Text_X_Vcalendar,
  Text_X_Vcard: () => Text_X_Vcard,
  Text_Xml: () => Text_Xml,
  Text_Xml_External_Parsed_Entity: () => Text_Xml_External_Parsed_Entity,
  Text_Yaml: () => Text_Yaml
});
var text = /* @__PURE__ */ specialize("text");
var Text_Cache_Manifest = /* @__PURE__ */ text("cache-manifest", "appcache");
var Text_Calendar = /* @__PURE__ */ text("calendar", "ics", "ifb");
var Text_Calender = /* @__PURE__ */ text("calender");
var Text_Cmd = /* @__PURE__ */ text("cmd");
var Text_Coffeescript = /* @__PURE__ */ text("coffeescript", "coffee", "litcoffee");
var Text_Css = /* @__PURE__ */ text("css", "css");
var Text_Csv = /* @__PURE__ */ text("csv", "csv");
var Text_Csv_Schema = /* @__PURE__ */ text("csv-schema");
var Text_Directory = /* @__PURE__ */ text("directory").deprecate("by RFC6350");
var Text_Dns = /* @__PURE__ */ text("dns");
var Text_Ecmascript = /* @__PURE__ */ text("ecmascript").deprecate("in favor of application/ecmascript");
var Text_Encaprtp = /* @__PURE__ */ text("encaprtp");
var Text_Enriched = /* @__PURE__ */ text("enriched");
var Text_Event_Stream = /* @__PURE__ */ text("event-stream");
var Text_Example = /* @__PURE__ */ text("example");
var Text_Flexfec = /* @__PURE__ */ text("flexfec");
var Text_Fwdred = /* @__PURE__ */ text("fwdred");
var Text_Grammar_Ref_List = /* @__PURE__ */ text("grammar-ref-list");
var Text_Html = /* @__PURE__ */ text("html", "html", "htm");
var Text_Jade = /* @__PURE__ */ text("jade", "jade");
var Text_Javascript = /* @__PURE__ */ text("javascript").deprecate("in favor of application/javascript");
var Text_Jcr_Cnd = /* @__PURE__ */ text("jcr-cnd");
var Text_Jsx = /* @__PURE__ */ text("jsx", "jsx");
var Text_Less = /* @__PURE__ */ text("less", "less");
var Text_Markdown = /* @__PURE__ */ text("markdown");
var Text_Mdx = /* @__PURE__ */ text("mdx", "mdx");
var Text_Mizar = /* @__PURE__ */ text("mizar");
var Text_N3 = /* @__PURE__ */ text("n3", "n3");
var Text_Parameters = /* @__PURE__ */ text("parameters");
var Text_Parityfec = /* @__PURE__ */ text("parityfec");
var Text_Plain = /* @__PURE__ */ text("plain", "txt", "text", "conf", "def", "list", "log", "in");
var Text_PlainUTF8 = /* @__PURE__ */ text("plain; charset=UTF-8", "txt", "text", "conf", "def", "list", "log", "in");
var Text_Provenance_Notation = /* @__PURE__ */ text("provenance-notation");
var Text_PrsFallensteinRst = /* @__PURE__ */ text("prs.fallenstein.rst");
var Text_PrsLinesTag = /* @__PURE__ */ text("prs.lines.tag", "dsc");
var Text_PrsPropLogic = /* @__PURE__ */ text("prs.prop.logic");
var Text_Raptorfec = /* @__PURE__ */ text("raptorfec");
var Text_RED = /* @__PURE__ */ text("red");
var Text_Rfc822_Headers = /* @__PURE__ */ text("rfc822-headers");
var Text_Richtext = /* @__PURE__ */ text("richtext", "rtx");
var Text_Rtf = /* @__PURE__ */ text("rtf");
var Text_Rtp_Enc_Aescm128 = /* @__PURE__ */ text("rtp-enc-aescm128");
var Text_Rtploopback = /* @__PURE__ */ text("rtploopback");
var Text_Rtx = /* @__PURE__ */ text("rtx");
var Text_Sgml = /* @__PURE__ */ text("sgml", "sgml", "sgm");
var Text_Shex = /* @__PURE__ */ text("shex", "shex");
var Text_Slim = /* @__PURE__ */ text("slim", "slim", "slm");
var Text_Strings = /* @__PURE__ */ text("strings");
var Text_Stylus = /* @__PURE__ */ text("stylus", "stylus", "styl");
var Text_T140 = /* @__PURE__ */ text("t140");
var Text_Tab_Separated_Values = /* @__PURE__ */ text("tab-separated-values", "tsv");
var Text_Troff = /* @__PURE__ */ text("troff", "t", "tr", "roff", "man", "me", "ms");
var Text_Turtle = /* @__PURE__ */ text("turtle", "ttl");
var Text_Ulpfec = /* @__PURE__ */ text("ulpfec");
var Text_Uri_List = /* @__PURE__ */ text("uri-list", "uri", "uris", "urls");
var Text_Vcard = /* @__PURE__ */ text("vcard", "vcard");
var Text_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ text("1d-interleaved-parityfec");
var Text_Vendor_A = /* @__PURE__ */ text("vnd.a");
var Text_Vendor_Abc = /* @__PURE__ */ text("vnd.abc");
var Text_Vendor_Ascii_Art = /* @__PURE__ */ text("vnd.ascii-art");
var Text_Vendor_Curl = /* @__PURE__ */ text("vnd.curl", "curl");
var Text_Vendor_CurlDcurl = /* @__PURE__ */ text("vnd.curl.dcurl", "dcurl");
var Text_Vendor_CurlMcurl = /* @__PURE__ */ text("vnd.curl.mcurl", "mcurl");
var Text_Vendor_CurlScurl = /* @__PURE__ */ text("vnd.curl.scurl", "scurl");
var Text_Vendor_DebianCopyright = /* @__PURE__ */ text("vnd.debian.copyright");
var Text_Vendor_DMClientScript = /* @__PURE__ */ text("vnd.dmclientscript");
var Text_Vendor_DvbSubtitle = /* @__PURE__ */ text("vnd.dvb.subtitle", "sub");
var Text_Vendor_EsmertecTheme_Descriptor = /* @__PURE__ */ text("vnd.esmertec.theme-descriptor");
var Text_Vendor_FiclabFlt = /* @__PURE__ */ text("vnd.ficlab.flt");
var Text_Vendor_Fly = /* @__PURE__ */ text("vnd.fly", "fly");
var Text_Vendor_FmiFlexstor = /* @__PURE__ */ text("vnd.fmi.flexstor", "flx");
var Text_Vendor_Gml = /* @__PURE__ */ text("vnd.gml");
var Text_Vendor_Graphviz = /* @__PURE__ */ text("vnd.graphviz", "gv");
var Text_Vendor_Hgl = /* @__PURE__ */ text("vnd.hgl");
var Text_Vendor_In3d3dml = /* @__PURE__ */ text("vnd.in3d.3dml", "3dml");
var Text_Vendor_In3dSpot = /* @__PURE__ */ text("vnd.in3d.spot", "spot");
var Text_Vendor_IPTCNewsML = /* @__PURE__ */ text("vnd.iptc.newsml");
var Text_Vendor_IPTCNITF = /* @__PURE__ */ text("vnd.iptc.nitf");
var Text_Vendor_Latex_Z = /* @__PURE__ */ text("vnd.latex-z");
var Text_Vendor_MotorolaReflex = /* @__PURE__ */ text("vnd.motorola.reflex");
var Text_Vendor_Ms_Mediapackage = /* @__PURE__ */ text("vnd.ms-mediapackage");
var Text_Vendor_Net2phoneCommcenterCommand = /* @__PURE__ */ text("vnd.net2phone.commcenter.command");
var Text_Vendor_RadisysMsml_Basic_Layout = /* @__PURE__ */ text("vnd.radisys.msml-basic-layout");
var Text_Vendor_SenxWarpscript = /* @__PURE__ */ text("vnd.senx.warpscript");
var Text_Vendor_SiUricatalogue = /* @__PURE__ */ text("vnd.si.uricatalogue").deprecate("by request");
var Text_Vendor_Sosi = /* @__PURE__ */ text("vnd.sosi");
var Text_Vendor_SunJ2meApp_Descriptor = /* @__PURE__ */ text("vnd.sun.j2me.app-descriptor", "jad");
var Text_Vendor_TrolltechLinguist = /* @__PURE__ */ text("vnd.trolltech.linguist");
var Text_Vendor_WapSi = /* @__PURE__ */ text("vnd.wap.si");
var Text_Vendor_WapSl = /* @__PURE__ */ text("vnd.wap.sl");
var Text_Vendor_WapWml = /* @__PURE__ */ text("vnd.wap.wml", "wml");
var Text_Vendor_WapWmlscript = /* @__PURE__ */ text("vnd.wap.wmlscript", "wmls");
var Text_Vtt = /* @__PURE__ */ text("vtt");
var Text_X_Asm = /* @__PURE__ */ text("x-asm", "s", "asm");
var Text_X_C = /* @__PURE__ */ text("x-c", "c", "cc", "cxx", "cpp", "h", "hh", "dic");
var Text_X_Fortran = /* @__PURE__ */ text("x-fortran", "f", "for", "f77", "f90");
var Text_X_Gwt_Rpc = /* @__PURE__ */ text("x-gwt-rpc");
var Text_X_Handlebars_Template = /* @__PURE__ */ text("x-handlebars-template", "hbs");
var Text_X_Java_Source = /* @__PURE__ */ text("x-java-source", "java");
var Text_X_Jquery_Tmpl = /* @__PURE__ */ text("x-jquery-tmpl");
var Text_X_Lua = /* @__PURE__ */ text("x-lua", "lua");
var Text_X_Markdown = /* @__PURE__ */ text("x-markdown", "mkd");
var Text_X_Nfo = /* @__PURE__ */ text("x-nfo", "nfo");
var Text_X_Opml = /* @__PURE__ */ text("x-opml", "opml");
var Text_X_Org = /* @__PURE__ */ text("x-org", "org");
var Text_X_Pascal = /* @__PURE__ */ text("x-pascal", "p", "pas");
var Text_X_Processing = /* @__PURE__ */ text("x-processing", "pde");
var Text_X_Sass = /* @__PURE__ */ text("x-sass", "sass");
var Text_X_Scss = /* @__PURE__ */ text("x-scss", "scss");
var Text_X_Setext = /* @__PURE__ */ text("x-setext", "etx");
var Text_X_Sfv = /* @__PURE__ */ text("x-sfv", "sfv");
var Text_X_Suse_Ymp = /* @__PURE__ */ text("x-suse-ymp", "ymp");
var Text_X_Uuencode = /* @__PURE__ */ text("x-uuencode", "uu");
var Text_X_Vcalendar = /* @__PURE__ */ text("x-vcalendar", "vcs");
var Text_X_Vcard = /* @__PURE__ */ text("x-vcard", "vcf");
var Text_Xml = /* @__PURE__ */ text("xml");
var Text_Xml_External_Parsed_Entity = /* @__PURE__ */ text("xml-external-parsed-entity");
var Text_Yaml = /* @__PURE__ */ text("yaml", "yaml", "yml");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/video.ts
var video_exports = {};
__export(video_exports, {
  Video_BMPEG: () => Video_BMPEG,
  Video_BT656: () => Video_BT656,
  Video_CelB: () => Video_CelB,
  Video_DV: () => Video_DV,
  Video_Encaprtp: () => Video_Encaprtp,
  Video_Example: () => Video_Example,
  Video_Flexfec: () => Video_Flexfec,
  Video_H261: () => Video_H261,
  Video_H263: () => Video_H263,
  Video_H263_1998: () => Video_H263_1998,
  Video_H263_2000: () => Video_H263_2000,
  Video_H264: () => Video_H264,
  Video_H264_RCDO: () => Video_H264_RCDO,
  Video_H264_SVC: () => Video_H264_SVC,
  Video_H265: () => Video_H265,
  Video_IsoSegment: () => Video_IsoSegment,
  Video_JPEG: () => Video_JPEG,
  Video_Jpeg2000: () => Video_Jpeg2000,
  Video_Jpm: () => Video_Jpm,
  Video_MP1S: () => Video_MP1S,
  Video_MP2P: () => Video_MP2P,
  Video_MP2T: () => Video_MP2T,
  Video_MP4V_ES: () => Video_MP4V_ES,
  Video_MPV: () => Video_MPV,
  Video_Mj2: () => Video_Mj2,
  Video_Mp4: () => Video_Mp4,
  Video_Mpeg: () => Video_Mpeg,
  Video_Mpeg4_Generic: () => Video_Mpeg4_Generic,
  Video_Nv: () => Video_Nv,
  Video_Ogg: () => Video_Ogg,
  Video_Parityfec: () => Video_Parityfec,
  Video_Pointer: () => Video_Pointer,
  Video_Quicktime: () => Video_Quicktime,
  Video_Raptorfec: () => Video_Raptorfec,
  Video_Raw: () => Video_Raw,
  Video_Rtp_Enc_Aescm128: () => Video_Rtp_Enc_Aescm128,
  Video_Rtploopback: () => Video_Rtploopback,
  Video_Rtx: () => Video_Rtx,
  Video_SMPTE292M: () => Video_SMPTE292M,
  Video_Smpte291: () => Video_Smpte291,
  Video_Ulpfec: () => Video_Ulpfec,
  Video_VP8: () => Video_VP8,
  Video_Vc1: () => Video_Vc1,
  Video_Vc2: () => Video_Vc2,
  Video_Vendor_1d_Interleaved_Parityfec: () => Video_Vendor_1d_Interleaved_Parityfec,
  Video_Vendor_3gpp: () => Video_Vendor_3gpp,
  Video_Vendor_3gpp2: () => Video_Vendor_3gpp2,
  Video_Vendor_3gpp_Tt: () => Video_Vendor_3gpp_Tt,
  Video_Vendor_CCTV: () => Video_Vendor_CCTV,
  Video_Vendor_DeceHd: () => Video_Vendor_DeceHd,
  Video_Vendor_DeceMobile: () => Video_Vendor_DeceMobile,
  Video_Vendor_DeceMp4: () => Video_Vendor_DeceMp4,
  Video_Vendor_DecePd: () => Video_Vendor_DecePd,
  Video_Vendor_DeceSd: () => Video_Vendor_DeceSd,
  Video_Vendor_DeceVideo: () => Video_Vendor_DeceVideo,
  Video_Vendor_DirectvMpeg: () => Video_Vendor_DirectvMpeg,
  Video_Vendor_DirectvMpeg_Tts: () => Video_Vendor_DirectvMpeg_Tts,
  Video_Vendor_DlnaMpeg_Tts: () => Video_Vendor_DlnaMpeg_Tts,
  Video_Vendor_DvbFile: () => Video_Vendor_DvbFile,
  Video_Vendor_Fvt: () => Video_Vendor_Fvt,
  Video_Vendor_HnsVideo: () => Video_Vendor_HnsVideo,
  Video_Vendor_Iptvforum1dparityfec_1010: () => Video_Vendor_Iptvforum1dparityfec_1010,
  Video_Vendor_Iptvforum1dparityfec_2005: () => Video_Vendor_Iptvforum1dparityfec_2005,
  Video_Vendor_Iptvforum2dparityfec_1010: () => Video_Vendor_Iptvforum2dparityfec_1010,
  Video_Vendor_Iptvforum2dparityfec_2005: () => Video_Vendor_Iptvforum2dparityfec_2005,
  Video_Vendor_IptvforumTtsavc: () => Video_Vendor_IptvforumTtsavc,
  Video_Vendor_IptvforumTtsmpeg2: () => Video_Vendor_IptvforumTtsmpeg2,
  Video_Vendor_MotorolaVideo: () => Video_Vendor_MotorolaVideo,
  Video_Vendor_MotorolaVideop: () => Video_Vendor_MotorolaVideop,
  Video_Vendor_Mpeg_Dash_Mpd: () => Video_Vendor_Mpeg_Dash_Mpd,
  Video_Vendor_Mpegurl: () => Video_Vendor_Mpegurl,
  Video_Vendor_Ms_PlayreadyMediaPyv: () => Video_Vendor_Ms_PlayreadyMediaPyv,
  Video_Vendor_NokiaInterleaved_Multimedia: () => Video_Vendor_NokiaInterleaved_Multimedia,
  Video_Vendor_NokiaMp4vr: () => Video_Vendor_NokiaMp4vr,
  Video_Vendor_NokiaVideovoip: () => Video_Vendor_NokiaVideovoip,
  Video_Vendor_Objectvideo: () => Video_Vendor_Objectvideo,
  Video_Vendor_RadgamettoolsBink: () => Video_Vendor_RadgamettoolsBink,
  Video_Vendor_RadgamettoolsSmacker: () => Video_Vendor_RadgamettoolsSmacker,
  Video_Vendor_SealedMpeg1: () => Video_Vendor_SealedMpeg1,
  Video_Vendor_SealedMpeg4: () => Video_Vendor_SealedMpeg4,
  Video_Vendor_SealedSwf: () => Video_Vendor_SealedSwf,
  Video_Vendor_SealedmediaSoftsealMov: () => Video_Vendor_SealedmediaSoftsealMov,
  Video_Vendor_UvvuMp4: () => Video_Vendor_UvvuMp4,
  Video_Vendor_Vivo: () => Video_Vendor_Vivo,
  Video_Vendor_YoutubeYt: () => Video_Vendor_YoutubeYt,
  Video_Webm: () => Video_Webm,
  Video_X_F4v: () => Video_X_F4v,
  Video_X_Fli: () => Video_X_Fli,
  Video_X_Flv: () => Video_X_Flv,
  Video_X_M4v: () => Video_X_M4v,
  Video_X_Matroska: () => Video_X_Matroska,
  Video_X_Mng: () => Video_X_Mng,
  Video_X_Ms_Asf: () => Video_X_Ms_Asf,
  Video_X_Ms_Vob: () => Video_X_Ms_Vob,
  Video_X_Ms_Wm: () => Video_X_Ms_Wm,
  Video_X_Ms_Wmv: () => Video_X_Ms_Wmv,
  Video_X_Ms_Wmx: () => Video_X_Ms_Wmx,
  Video_X_Ms_Wvx: () => Video_X_Ms_Wvx,
  Video_X_Msvideo: () => Video_X_Msvideo,
  Video_X_Sgi_Movie: () => Video_X_Sgi_Movie,
  Video_X_Smv: () => Video_X_Smv
});
var video = /* @__PURE__ */ specialize("video");
var Video_BMPEG = /* @__PURE__ */ video("bmpeg");
var Video_BT656 = /* @__PURE__ */ video("bt656");
var Video_CelB = /* @__PURE__ */ video("celb");
var Video_DV = /* @__PURE__ */ video("dv");
var Video_Encaprtp = /* @__PURE__ */ video("encaprtp");
var Video_Example = /* @__PURE__ */ video("example");
var Video_Flexfec = /* @__PURE__ */ video("flexfec");
var Video_H261 = /* @__PURE__ */ video("h261", "h261");
var Video_H263 = /* @__PURE__ */ video("h263", "h263");
var Video_H263_1998 = /* @__PURE__ */ video("h263-1998");
var Video_H263_2000 = /* @__PURE__ */ video("h263-2000");
var Video_H264 = /* @__PURE__ */ video("h264", "h264");
var Video_H264_RCDO = /* @__PURE__ */ video("h264-rcdo");
var Video_H264_SVC = /* @__PURE__ */ video("h264-svc");
var Video_H265 = /* @__PURE__ */ video("h265");
var Video_IsoSegment = /* @__PURE__ */ video("iso.segment");
var Video_JPEG = /* @__PURE__ */ video("jpeg", "jpgv");
var Video_Jpeg2000 = /* @__PURE__ */ video("jpeg2000");
var Video_Jpm = /* @__PURE__ */ video("jpm", "jpm", "jpgm");
var Video_Mj2 = /* @__PURE__ */ video("mj2", "mj2", "mjp2");
var Video_MP1S = /* @__PURE__ */ video("mp1s");
var Video_MP2P = /* @__PURE__ */ video("mp2p");
var Video_MP2T = /* @__PURE__ */ video("mp2t");
var Video_Mp4 = /* @__PURE__ */ video("mp4", "mp4", "mp4v", "mpg4");
var Video_MP4V_ES = /* @__PURE__ */ video("mp4v-es");
var Video_Mpeg = /* @__PURE__ */ video("mpeg", "mpeg", "mpg", "mpe", "m1v", "m2v");
var Video_Mpeg4_Generic = /* @__PURE__ */ video("mpeg4-generic");
var Video_MPV = /* @__PURE__ */ video("mpv");
var Video_Nv = /* @__PURE__ */ video("nv");
var Video_Ogg = /* @__PURE__ */ video("ogg", "ogv");
var Video_Parityfec = /* @__PURE__ */ video("parityfec");
var Video_Pointer = /* @__PURE__ */ video("pointer");
var Video_Quicktime = /* @__PURE__ */ video("quicktime", "qt", "mov");
var Video_Raptorfec = /* @__PURE__ */ video("raptorfec");
var Video_Raw = /* @__PURE__ */ video("raw");
var Video_Rtp_Enc_Aescm128 = /* @__PURE__ */ video("rtp-enc-aescm128");
var Video_Rtploopback = /* @__PURE__ */ video("rtploopback");
var Video_Rtx = /* @__PURE__ */ video("rtx");
var Video_Smpte291 = /* @__PURE__ */ video("smpte291");
var Video_SMPTE292M = /* @__PURE__ */ video("smpte292m");
var Video_Ulpfec = /* @__PURE__ */ video("ulpfec");
var Video_Vc1 = /* @__PURE__ */ video("vc1");
var Video_Vc2 = /* @__PURE__ */ video("vc2");
var Video_Vendor_1d_Interleaved_Parityfec = /* @__PURE__ */ video("1d-interleaved-parityfec");
var Video_Vendor_3gpp = /* @__PURE__ */ video("3gpp", "3gp");
var Video_Vendor_3gpp_Tt = /* @__PURE__ */ video("3gpp-tt");
var Video_Vendor_3gpp2 = /* @__PURE__ */ video("3gpp2", "3g2");
var Video_Vendor_CCTV = /* @__PURE__ */ video("vnd.cctv");
var Video_Vendor_DeceHd = /* @__PURE__ */ video("vnd.dece.hd", "uvh", "uvvh");
var Video_Vendor_DeceMobile = /* @__PURE__ */ video("vnd.dece.mobile", "uvm", "uvvm");
var Video_Vendor_DeceMp4 = /* @__PURE__ */ video("vnd.dece.mp4");
var Video_Vendor_DecePd = /* @__PURE__ */ video("vnd.dece.pd", "uvp", "uvvp");
var Video_Vendor_DeceSd = /* @__PURE__ */ video("vnd.dece.sd", "uvs", "uvvs");
var Video_Vendor_DeceVideo = /* @__PURE__ */ video("vnd.dece.video", "uvv", "uvvv");
var Video_Vendor_DirectvMpeg = /* @__PURE__ */ video("vnd.directv.mpeg");
var Video_Vendor_DirectvMpeg_Tts = /* @__PURE__ */ video("vnd.directv.mpeg-tts");
var Video_Vendor_DlnaMpeg_Tts = /* @__PURE__ */ video("vnd.dlna.mpeg-tts");
var Video_Vendor_DvbFile = /* @__PURE__ */ video("vnd.dvb.file", "dvb");
var Video_Vendor_Fvt = /* @__PURE__ */ video("vnd.fvt", "fvt");
var Video_Vendor_HnsVideo = /* @__PURE__ */ video("vnd.hns.video");
var Video_Vendor_Iptvforum1dparityfec_1010 = /* @__PURE__ */ video("vnd.iptvforum.1dparityfec-1010");
var Video_Vendor_Iptvforum1dparityfec_2005 = /* @__PURE__ */ video("vnd.iptvforum.1dparityfec-2005");
var Video_Vendor_Iptvforum2dparityfec_1010 = /* @__PURE__ */ video("vnd.iptvforum.2dparityfec-1010");
var Video_Vendor_Iptvforum2dparityfec_2005 = /* @__PURE__ */ video("vnd.iptvforum.2dparityfec-2005");
var Video_Vendor_IptvforumTtsavc = /* @__PURE__ */ video("vnd.iptvforum.ttsavc");
var Video_Vendor_IptvforumTtsmpeg2 = /* @__PURE__ */ video("vnd.iptvforum.ttsmpeg2");
var Video_Vendor_MotorolaVideo = /* @__PURE__ */ video("vnd.motorola.video");
var Video_Vendor_MotorolaVideop = /* @__PURE__ */ video("vnd.motorola.videop");
var Video_Vendor_Mpegurl = /* @__PURE__ */ video("vnd.mpegurl", "mxu", "m4u");
var Video_Vendor_Ms_PlayreadyMediaPyv = /* @__PURE__ */ video("vnd.ms-playready.media.pyv", "pyv");
var Video_Vendor_NokiaInterleaved_Multimedia = /* @__PURE__ */ video("vnd.nokia.interleaved-multimedia");
var Video_Vendor_NokiaMp4vr = /* @__PURE__ */ video("vnd.nokia.mp4vr");
var Video_Vendor_NokiaVideovoip = /* @__PURE__ */ video("vnd.nokia.videovoip");
var Video_Vendor_Objectvideo = /* @__PURE__ */ video("vnd.objectvideo");
var Video_Vendor_RadgamettoolsBink = /* @__PURE__ */ video("vnd.radgamettools.bink");
var Video_Vendor_RadgamettoolsSmacker = /* @__PURE__ */ video("vnd.radgamettools.smacker");
var Video_Vendor_SealedmediaSoftsealMov = /* @__PURE__ */ video("vnd.sealedmedia.softseal.mov");
var Video_Vendor_SealedMpeg1 = /* @__PURE__ */ video("vnd.sealed.mpeg1");
var Video_Vendor_SealedMpeg4 = /* @__PURE__ */ video("vnd.sealed.mpeg4");
var Video_Vendor_SealedSwf = /* @__PURE__ */ video("vnd.sealed.swf");
var Video_Vendor_UvvuMp4 = /* @__PURE__ */ video("vnd.uvvu.mp4", "uvu", "uvvu");
var Video_Vendor_Vivo = /* @__PURE__ */ video("vnd.vivo", "viv");
var Video_Vendor_YoutubeYt = /* @__PURE__ */ video("vnd.youtube.yt");
var Video_Vendor_Mpeg_Dash_Mpd = /* @__PURE__ */ video("vnd.mpeg.dash.mpd", "mpd");
var Video_VP8 = /* @__PURE__ */ video("vp8");
var Video_Webm = /* @__PURE__ */ video("webm", "webm");
var Video_X_F4v = /* @__PURE__ */ video("x-f4v", "f4v");
var Video_X_Fli = /* @__PURE__ */ video("x-fli", "fli");
var Video_X_Flv = /* @__PURE__ */ video("x-flv", "flv");
var Video_X_M4v = /* @__PURE__ */ video("x-m4v", "m4v");
var Video_X_Matroska = /* @__PURE__ */ video("x-matroska", "mkv", "mk3d", "mks");
var Video_X_Mng = /* @__PURE__ */ video("x-mng", "mng");
var Video_X_Ms_Asf = /* @__PURE__ */ video("x-ms-asf", "asf", "asx");
var Video_X_Ms_Vob = /* @__PURE__ */ video("x-ms-vob", "vob");
var Video_X_Ms_Wm = /* @__PURE__ */ video("x-ms-wm", "wm");
var Video_X_Ms_Wmv = /* @__PURE__ */ video("x-ms-wmv", "wmv");
var Video_X_Ms_Wmx = /* @__PURE__ */ video("x-ms-wmx", "wmx");
var Video_X_Ms_Wvx = /* @__PURE__ */ video("x-ms-wvx", "wvx");
var Video_X_Msvideo = /* @__PURE__ */ video("x-msvideo", "avi");
var Video_X_Sgi_Movie = /* @__PURE__ */ video("x-sgi-movie", "movie");
var Video_X_Smv = /* @__PURE__ */ video("x-smv", "smv");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/xConference.ts
var xConference_exports = {};
__export(xConference_exports, {
  XConference_XCooltalk: () => XConference_XCooltalk
});
var xConference = /* @__PURE__ */ specialize("xconference");
var XConference_XCooltalk = /* @__PURE__ */ xConference("x-cooltalk", "ice");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/xShader.ts
var xShader_exports = {};
__export(xShader_exports, {
  XShader_XFragment: () => XShader_XFragment,
  XShader_XVertex: () => XShader_XVertex
});
var xShader = /* @__PURE__ */ specialize("x-shader");
var XShader_XVertex = /* @__PURE__ */ xShader("x-vertex", "vert", "vs", "glsl");
var XShader_XFragment = /* @__PURE__ */ xShader("x-fragment", "frag", "fs", "glsl");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/assertSuccess.ts
function assertSuccess(response) {
  if (response.status >= 400) {
    throw new Error("Resource could not be retrieved: " + response.requestPath);
  }
  return response;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/unwrapResponse.ts
function unwrapResponse(response) {
  const { content } = assertSuccess(response);
  return content;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/Asset.ts
function isAsset(obj2) {
  return isDefined(obj2) && isFunction(obj2.then) && isFunction(obj2.catch) && isFunction(obj2.finally) && isFunction(obj2.fetch) && isFunction(obj2.getSize);
}
var BaseAsset = class {
  constructor(path, type2) {
    this.path = path;
    this.type = type2;
    this._result = null;
    this._error = null;
    this._started = false;
    this._finished = false;
    this.resolve = null;
    this.reject = null;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value2) => {
        this._result = value2;
        this._finished = true;
        resolve(value2);
      };
      this.reject = (reason) => {
        this._error = reason;
        this._finished = true;
        reject(reason);
      };
    });
  }
  get result() {
    if (isDefined(this.error)) {
      throw this.error;
    }
    return this._result;
  }
  get error() {
    return this._error;
  }
  get started() {
    return this._started;
  }
  get finished() {
    return this._finished;
  }
  async getSize(fetcher2) {
    try {
      const { contentLength } = await fetcher2.head(this.path).accept(this.type).exec();
      return [this, contentLength || 1];
    } catch (exp2) {
      console.warn(exp2);
      return [this, 1];
    }
    ;
  }
  async fetch(fetcher2, prog) {
    try {
      const result = await this.getResult(fetcher2, prog);
      this.resolve(result);
    } catch (err) {
      this.reject(err);
    }
  }
  get [Symbol.toStringTag]() {
    return this.promise.toString();
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.promise.catch(onrejected);
  }
  finally(onfinally) {
    return this.promise.finally(onfinally);
  }
};
var BaseFetchedAsset = class extends BaseAsset {
  constructor(path, typeOrUseCache, useCache) {
    let type2;
    if (isBoolean(typeOrUseCache)) {
      useCache = typeOrUseCache;
    } else {
      type2 = typeOrUseCache;
    }
    super(path, type2);
    this.useCache = !!useCache;
  }
  getResult(fetcher2, prog) {
    return this.getRequest(fetcher2, prog).then(unwrapResponse);
  }
  getRequest(fetcher2, prog) {
    const request = fetcher2.get(this.path).useCache(this.useCache).progress(prog);
    return this.getResponse(request);
  }
};
var AssetFile = class extends BaseFetchedAsset {
  getResponse(request) {
    return request.file(this.type);
  }
};
var AssetImage = class extends BaseFetchedAsset {
  getResponse(request) {
    return request.image(this.type);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/using.ts
function interfaceSigCheck(obj2, ...funcNames) {
  if (!isObject(obj2)) {
    return false;
  }
  obj2 = obj2;
  for (const funcName of funcNames) {
    if (!(funcName in obj2)) {
      return false;
    }
    const func = obj2[funcName];
    if (!isFunction(func)) {
      return false;
    }
  }
  return true;
}
function isDisposable(obj2) {
  return interfaceSigCheck(obj2, "dispose");
}
function isDestroyable(obj2) {
  return interfaceSigCheck(obj2, "destroy");
}
function isClosable(obj2) {
  return interfaceSigCheck(obj2, "close");
}
function dispose(val) {
  if (isDisposable(val)) {
    val.dispose();
  }
  if (isClosable(val)) {
    val.close();
  }
  if (isDestroyable(val)) {
    val.destroy();
  }
}
function using(val, thunk) {
  try {
    return thunk(val);
  } finally {
    dispose(val);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/canvas.ts
var hasHTMLCanvas = "HTMLCanvasElement" in globalThis;
var hasHTMLImage = "HTMLImageElement" in globalThis;
var disableAdvancedSettings = false;
var hasOffscreenCanvas = !disableAdvancedSettings && "OffscreenCanvas" in globalThis;
var hasImageBitmap = !disableAdvancedSettings && "createImageBitmap" in globalThis;
function isHTMLCanvas(obj2) {
  return hasHTMLCanvas && obj2 instanceof HTMLCanvasElement;
}
function isOffscreenCanvas(obj2) {
  return hasOffscreenCanvas && obj2 instanceof OffscreenCanvas;
}
function isImageBitmap(img) {
  return hasImageBitmap && img instanceof ImageBitmap;
}
function isImageData(img) {
  return img instanceof ImageData;
}
function isCanvas(obj2) {
  return isHTMLCanvas(obj2) || isOffscreenCanvas(obj2);
}
function drawImageBitmapToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.drawImage(img, 0, 0);
}
function drawImageDataToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.putImageData(img, 0, 0);
}
function testOffscreen2D() {
  try {
    const canv = new OffscreenCanvas(1, 1);
    const g = canv.getContext("2d");
    return g != null;
  } catch (exp2) {
    return false;
  }
}
var hasOffscreenCanvasRenderingContext2D = hasOffscreenCanvas && testOffscreen2D();
var createUtilityCanvas = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvas || hasHTMLCanvas && createCanvas || null;
var createUICanvas = hasHTMLCanvas ? createCanvas : createUtilityCanvas;
function testOffscreen3D() {
  try {
    const canv = new OffscreenCanvas(1, 1);
    const g = canv.getContext("webgl2");
    return g != null;
  } catch (exp2) {
    return false;
  }
}
var hasOffscreenCanvasRenderingContext3D = hasOffscreenCanvas && testOffscreen3D();
function createOffscreenCanvas(width2, height2) {
  return new OffscreenCanvas(width2, height2);
}
function createCanvas(w, h) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  return Canvas(htmlWidth(w), htmlHeight(h));
}
function createOffscreenCanvasFromImageBitmap(img) {
  const canv = createOffscreenCanvas(img.width, img.height);
  drawImageBitmapToCanvas(canv, img);
  return canv;
}
function createCanvasFromImageBitmap(img) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  const canv = createCanvas(img.width, img.height);
  drawImageBitmapToCanvas(canv, img);
  return canv;
}
var createUtilityCanvasFromImageBitmap = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvasFromImageBitmap || hasHTMLCanvas && createCanvasFromImageBitmap || null;
function createOffscreenCanvasFromImageData(img) {
  const canv = createOffscreenCanvas(img.width, img.height);
  drawImageDataToCanvas(canv, img);
  return canv;
}
function createCanvasFromImageData(img) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  const canv = createCanvas(img.width, img.height);
  drawImageDataToCanvas(canv, img);
  return canv;
}
var createUtilityCanvasFromImageData = hasOffscreenCanvasRenderingContext2D && createOffscreenCanvasFromImageData || hasHTMLCanvas && createCanvasFromImageData || null;
function drawImageToCanvas(canv, img) {
  const g = canv.getContext("2d");
  if (isNullOrUndefined(g)) {
    throw new Error("Could not create 2d context for canvas");
  }
  g.drawImage(img, 0, 0);
}
function createCanvasFromImage(img) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  const canv = createCanvas(img.width, img.height);
  drawImageToCanvas(canv, img);
  return canv;
}
async function createImageFromFile(file) {
  if (false) {
    throw new Error("HTML Image is not supported in workers");
  }
  const img = Img(src(file));
  await once(img, "load", "error");
  return img;
}
function setCanvasSize(canv, w, h, superscale = 1) {
  w = Math.floor(w * superscale);
  h = Math.floor(h * superscale);
  if (canv.width != w || canv.height != h) {
    canv.width = w;
    canv.height = h;
    return true;
  }
  return false;
}
function is2DRenderingContext(ctx) {
  return isDefined(ctx.textBaseline);
}
function setCanvas2DContextSize(ctx, w, h, superscale = 1) {
  const oldImageSmoothingEnabled = ctx.imageSmoothingEnabled, oldTextBaseline = ctx.textBaseline, oldTextAlign = ctx.textAlign, oldFont = ctx.font, resized = setCanvasSize(
    ctx.canvas,
    w,
    h,
    superscale
  );
  if (resized) {
    ctx.imageSmoothingEnabled = oldImageSmoothingEnabled;
    ctx.textBaseline = oldTextBaseline;
    ctx.textAlign = oldTextAlign;
    ctx.font = oldFont;
  }
  return resized;
}
function setContextSize(ctx, w, h, superscale = 1) {
  if (is2DRenderingContext(ctx)) {
    return setCanvas2DContextSize(ctx, w, h, superscale);
  } else {
    return setCanvasSize(
      ctx.canvas,
      w,
      h,
      superscale
    );
  }
}
function resizeCanvas(canv, superscale = 1) {
  if (false) {
    throw new Error("HTML Canvas is not supported in workers");
  }
  return setCanvasSize(
    canv,
    canv.clientWidth,
    canv.clientHeight,
    superscale
  );
}
function canvasToBlob(canvas, type2, quality) {
  if (type2 instanceof MediaType) {
    type2 = type2.value;
  }
  if (isOffscreenCanvas(canvas)) {
    return canvas.convertToBlob({ type: type2, quality });
  } else if (isHTMLCanvas(canvas)) {
    const blobCreated = new Task();
    canvas.toBlob(blobCreated.resolve, type2, quality);
    return blobCreated;
  } else {
    throw new Error("Cannot save image from canvas");
  }
}
function dispose2(val) {
  if (isCanvas(val)) {
    val.width = val.height = 0;
  } else {
    dispose(val);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/waitFor.ts
function waitFor(test) {
  const task = new Task();
  const handle = setInterval(() => {
    if (test()) {
      clearInterval(handle);
      task.resolve();
    }
  }, 100);
  return task;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/translateResponse.ts
async function translateResponse(response, translate) {
  const {
    status,
    requestPath,
    responsePath,
    content,
    contentType,
    contentLength,
    fileName,
    headers,
    date
  } = response;
  return {
    status,
    requestPath,
    responsePath,
    content: isDefined(translate) ? await translate(content) : void 0,
    contentType,
    contentLength,
    fileName,
    headers,
    date
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/RequestBuilder.ts
var testAudio = null;
function canPlay(type2) {
  if (testAudio === null) {
    testAudio = new Audio();
  }
  return testAudio.canPlayType(type2) !== "";
}
var RequestBuilder = class {
  constructor(fetcher2, method, path, useBLOBs = false) {
    this.fetcher = fetcher2;
    this.method = method;
    this.path = path;
    this.useBLOBs = useBLOBs;
    this.prog = null;
    this.request = {
      method,
      path: this.path.href,
      body: null,
      headers: null,
      timeout: null,
      withCredentials: false,
      useCache: false,
      retryCount: 3
    };
  }
  retries(count) {
    this.request.retryCount = count;
    return this;
  }
  query(name3, value2) {
    this.path.searchParams.set(name3, value2);
    this.request.path = this.path.href;
    return this;
  }
  header(name3, value2) {
    if (this.request.headers === null) {
      this.request.headers = /* @__PURE__ */ new Map();
    }
    this.request.headers.set(name3.toLowerCase(), value2);
    return this;
  }
  headers(headers) {
    for (const [name3, value2] of headers.entries()) {
      this.header(name3, value2);
    }
    return this;
  }
  timeout(value2) {
    this.request.timeout = value2;
    return this;
  }
  progress(prog) {
    this.prog = prog;
    return this;
  }
  body(body, contentType) {
    if (isDefined(body)) {
      const seen = /* @__PURE__ */ new Set();
      const queue = new Array();
      queue.push(body);
      let isForm = false;
      while (!isForm && queue.length > 0) {
        const here = queue.shift();
        if (here && !seen.has(here)) {
          seen.add(here);
          if (here instanceof Blob) {
            isForm = true;
            break;
          } else if (!isString(here)) {
            queue.push(...Object.values(here));
          }
        }
      }
      if (isForm) {
        const form = new FormData();
        const fileNames = /* @__PURE__ */ new Map();
        const toSkip = /* @__PURE__ */ new Set();
        for (const [key, value2] of Object.entries(body)) {
          if (value2 instanceof Blob) {
            const fileNameKey = key + ".name";
            const fileName = body[fileNameKey];
            if (isString(fileName)) {
              fileNames.set(value2, fileName);
              toSkip.add(fileNameKey);
            }
          }
        }
        for (let [key, value2] of Object.entries(body)) {
          if (toSkip.has(key)) {
            continue;
          }
          if (value2 instanceof Blob) {
            form.append(key, value2, fileNames.get(value2));
          } else if (isString(value2)) {
            form.append(key, value2);
          } else if (isDefined(value2) && isFunction(value2.toString)) {
            form.append(key, value2.toString());
          } else {
            console.warn("Can't serialize value to formdata", key, value2);
          }
        }
        body = form;
        contentType = void 0;
      }
      this.request.body = body;
      this.content(contentType);
    }
    return this;
  }
  withCredentials() {
    this.request.withCredentials = true;
    return this;
  }
  useCache(enabled = true) {
    this.request.useCache = enabled;
    return this;
  }
  media(key, mediaType) {
    if (isDefined(mediaType)) {
      if (!isString(mediaType)) {
        mediaType = mediaType.value;
      }
      this.header(key, mediaType);
    }
  }
  content(contentType) {
    this.media("content-type", contentType);
  }
  accept(acceptType) {
    this.media("accept", acceptType);
    return this;
  }
  blob(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetBlob(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetBlob(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  buffer(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetBuffer(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetBuffer(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  async file(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return await this.fetcher.sendObjectGetFile(this.request, this.prog);
    } else if (this.method === "GET") {
      if (this.useBLOBs) {
        return await this.fetcher.sendNothingGetFile(this.request, this.prog);
      } else {
        const response = await this.fetcher.sendNothingGetNothing(this.request);
        return translateResponse(response, () => this.request.path);
      }
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  text(acceptType) {
    this.accept(acceptType || Text_Plain);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetText(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetText(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  object(acceptType) {
    this.accept(acceptType || Application_Json);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetObject(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetObject(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  xml(acceptType) {
    this.accept(acceptType || Text_Xml);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetXml(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetXml(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  imageBitmap(acceptType) {
    this.accept(acceptType);
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetImageBitmap(this.request, this.prog);
    } else if (this.method === "GET") {
      return this.fetcher.sendNothingGetImageBitmap(this.request, this.prog);
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  exec() {
    if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE") {
      return this.fetcher.sendObjectGetNothing(this.request, this.prog);
    } else if (this.method === "GET") {
      throw new Exception("GET requests should expect a response type");
    } else if (this.method === "HEAD" || this.method === "OPTIONS") {
      return this.fetcher.sendNothingGetNothing(this.request);
    } else {
      assertNever(this.method);
    }
  }
  async audioBlob(acceptType) {
    if (isDefined(acceptType)) {
      if (!isString(acceptType)) {
        acceptType = acceptType.value;
      }
      if (!canPlay(acceptType)) {
        throw new Error(`Probably can't play file of type "${acceptType}" at path: ${this.request.path}`);
      }
    }
    const response = await this.blob(acceptType);
    if (canPlay(response.contentType)) {
      return response;
    }
    throw new Error(`Cannot play file of type "${response.contentType}" at path: ${this.request.path}`);
  }
  async audioBuffer(context, acceptType) {
    return translateResponse(
      await this.audioBlob(acceptType),
      async (blob) => await context.decodeAudioData(await blob.arrayBuffer())
    );
  }
  async htmlElement(element, resolveEvt, acceptType) {
    const response = await this.file(acceptType);
    const task = once(element, resolveEvt, "error");
    if (element instanceof HTMLLinkElement) {
      element.href = response.content;
    } else {
      element.src = response.content;
    }
    await task;
    return await translateResponse(response, () => element);
  }
  image(acceptType) {
    return this.htmlElement(
      Img(),
      "load",
      acceptType
    );
  }
  async htmlCanvas(acceptType) {
    if (false) {
      throw new Error("HTMLCanvasElement not supported in Workers.");
    }
    const canvas = createCanvas(1, 1);
    if (this.method === "GET") {
      if (hasOffscreenCanvas) {
        this.accept(acceptType);
        const response = await this.fetcher.drawImageToCanvas(this.request, canvas.transferControlToOffscreen(), this.prog);
        return await translateResponse(response, () => canvas);
      } else {
        const response = await (false ? this.imageBitmap(acceptType) : this.image(acceptType));
        return await translateResponse(response, (img) => {
          canvas.width = img.width;
          canvas.height = img.height;
          drawImageToCanvas(canvas, img);
          dispose(img);
          return canvas;
        });
      }
    } else if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE" || this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  canvas(acceptType) {
    if (hasOffscreenCanvas) {
      return this.offscreenCanvas(acceptType);
    } else {
      return this.htmlCanvas(acceptType);
    }
  }
  async offscreenCanvas(acceptType) {
    if (!hasOffscreenCanvas) {
      throw new Error("This system does not support OffscreenCanvas");
    }
    if (this.method === "GET") {
      const response = await (false ? this.imageBitmap(acceptType) : this.image(acceptType));
      return await translateResponse(response, (img) => {
        const canvas = createOffscreenCanvas(img.width, img.height);
        drawImageToCanvas(canvas, img);
        dispose(img);
        return canvas;
      });
    } else if (this.method === "POST" || this.method === "PUT" || this.method === "PATCH" || this.method === "DELETE" || this.method === "HEAD" || this.method === "OPTIONS") {
      throw new Error(`${this.method} responses do not contain bodies`);
    } else {
      assertNever(this.method);
    }
  }
  async style() {
    const tag2 = Link(
      type(Text_Css),
      rel("stylesheet")
    );
    document.head.append(tag2);
    const response = await this.htmlElement(
      tag2,
      "load",
      Text_Css
    );
    return translateResponse(response);
  }
  async getScript() {
    const tag2 = Script(type(Application_Javascript));
    document.head.append(tag2);
    const response = await this.htmlElement(
      tag2,
      "load",
      Application_Javascript
    );
    return translateResponse(response);
  }
  async script(test) {
    let response = null;
    const scriptPath = this.request.path;
    if (!test) {
      response = await this.getScript();
    } else if (!test()) {
      const scriptLoadTask = waitFor(test);
      response = await this.getScript();
      await scriptLoadTask;
    }
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return response;
  }
  async module() {
    const scriptPath = this.request.path;
    const response = await this.file(Application_Javascript);
    const value2 = await import(response.content);
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return translateResponse(response, () => value2);
  }
  async wasm(imports) {
    const response = await this.buffer(Application_Wasm);
    if (!Application_Wasm.matches(response.contentType)) {
      throw new Error(`Server did not respond with WASM file. Was: ${response.contentType}`);
    }
    const module2 = await WebAssembly.compile(response.content);
    const instance = await WebAssembly.instantiate(module2, imports);
    return translateResponse(response, () => instance.exports);
  }
  async worker(type2 = "module") {
    const scriptPath = this.request.path;
    const response = await this.file(Application_Javascript);
    this.prog = null;
    this.request.timeout = null;
    const worker2 = new Worker(response.content, { type: type2 });
    if (this.prog) {
      this.prog.end(scriptPath);
    }
    return translateResponse(response, () => worker2);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/Fetcher.ts
var Fetcher = class {
  constructor(service, useBLOBs = false) {
    this.service = service;
    this.useBLOBs = useBLOBs;
    if (true) {
      const antiforgeryToken = getInput("input[name=__RequestVerificationToken]");
      if (antiforgeryToken) {
        this.service.setRequestVerificationToken(antiforgeryToken.value);
      }
    }
  }
  clearCache() {
    return this.service.clearCache();
  }
  evict(path, base) {
    return this.service.evict(new URL(path, base || location.href).href);
  }
  request(method, path, base) {
    return new RequestBuilder(
      this.service,
      method,
      new URL(path, base || location.href),
      this.useBLOBs
    );
  }
  head(path, base) {
    return this.request("HEAD", path, base);
  }
  options(path, base) {
    return this.request("OPTIONS", path, base);
  }
  get(path, base) {
    return this.request("GET", path, base);
  }
  post(path, base) {
    return this.request("POST", path, base);
  }
  put(path, base) {
    return this.request("PUT", path, base);
  }
  patch(path, base) {
    return this.request("PATCH", path, base);
  }
  delete(path, base) {
    return this.request("DELETE", path, base);
  }
  async assets(progressOrAsset, firstAsset, ...assets) {
    if (isNullOrUndefined(assets)) {
      assets = [];
    }
    assets.unshift(firstAsset);
    let progress;
    if (isAsset(progressOrAsset)) {
      assets.unshift(progressOrAsset);
    } else if (isDefined(progressOrAsset)) {
      progress = progressOrAsset;
    }
    assets = assets.filter(isDefined);
    const sizes = await Promise.all(assets.map((asset) => asset.getSize(this)));
    const assetSizes = new Map(sizes);
    await progressTasksWeighted(
      progress,
      assets.map((asset) => [assetSizes.get(asset), (prog) => asset.fetch(this, prog)])
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/FetchingService.ts
var FetchingService = class {
  constructor(impl) {
    this.impl = impl;
    this.defaultPostHeaders = /* @__PURE__ */ new Map();
  }
  setRequestVerificationToken(value2) {
    this.defaultPostHeaders.set("RequestVerificationToken", value2);
  }
  clearCache() {
    return this.impl.clearCache();
  }
  evict(path) {
    return this.impl.evict(path);
  }
  sendNothingGetNothing(request) {
    return this.impl.sendNothingGetNothing(request);
  }
  sendNothingGetBlob(request, progress) {
    return this.impl.sendNothingGetSomething("blob", request, progress);
  }
  sendObjectGetBlob(request, progress) {
    return this.impl.sendSomethingGetSomething("blob", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetBuffer(request, progress) {
    return this.impl.sendNothingGetSomething("arraybuffer", request, progress);
  }
  sendObjectGetBuffer(request, progress) {
    return this.impl.sendSomethingGetSomething("arraybuffer", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetText(request, progress) {
    return this.impl.sendNothingGetSomething("text", request, progress);
  }
  sendObjectGetText(request, progress) {
    return this.impl.sendSomethingGetSomething("text", request, this.defaultPostHeaders, progress);
  }
  sendNothingGetObject(request, progress) {
    return this.impl.sendNothingGetSomething("json", request, progress);
  }
  sendObjectGetObject(request, progress) {
    return this.impl.sendSomethingGetSomething("json", request, this.defaultPostHeaders, progress);
  }
  sendObjectGetNothing(request, progress) {
    return this.impl.sendSomethingGetSomething("", request, this.defaultPostHeaders, progress);
  }
  drawImageToCanvas(request, canvas, progress) {
    return this.impl.drawImageToCanvas(request, canvas, progress);
  }
  async sendNothingGetFile(request, progress) {
    return translateResponse(
      await this.sendNothingGetBlob(request, progress),
      URL.createObjectURL
    );
  }
  async sendObjectGetFile(request, progress) {
    return translateResponse(
      await this.sendObjectGetBlob(request, progress),
      URL.createObjectURL
    );
  }
  async sendNothingGetXml(request, progress) {
    return translateResponse(
      await this.impl.sendNothingGetSomething("document", request, progress),
      (doc) => doc.documentElement
    );
  }
  async sendObjectGetXml(request, progress) {
    return translateResponse(
      await this.impl.sendSomethingGetSomething("document", request, this.defaultPostHeaders, progress),
      (doc) => doc.documentElement
    );
  }
  async sendNothingGetImageBitmap(request, progress) {
    return translateResponse(
      await this.sendNothingGetBlob(request, progress),
      createImageBitmap
    );
  }
  async sendObjectGetImageBitmap(request, progress) {
    return translateResponse(
      await this.sendObjectGetBlob(request, progress),
      createImageBitmap
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapMap.ts
function mapMap(items, makeID, makeValue) {
  return new Map(items.map((item) => [makeID(item), makeValue(item)]));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/makeLookup.ts
function makeLookup(items, makeID) {
  return mapMap(items, makeID, identity);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/PriorityList.ts
var PriorityList = class {
  constructor(init) {
    this.items = /* @__PURE__ */ new Map();
    this.defaultItems = new Array();
    if (isDefined(init)) {
      for (const [key, value2] of init) {
        this.add(key, value2);
      }
    }
  }
  add(key, ...values) {
    for (const value2 of values) {
      if (isNullOrUndefined(key)) {
        this.defaultItems.push(value2);
      } else {
        let list2 = this.items.get(key);
        if (isNullOrUndefined(list2)) {
          this.items.set(key, list2 = []);
        }
        list2.push(value2);
      }
    }
    return this;
  }
  entries() {
    return this.items.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  keys() {
    return this.items.keys();
  }
  *values() {
    for (const item of this.defaultItems) {
      yield item;
    }
    for (const list2 of this.items.values()) {
      for (const item of list2) {
        yield item;
      }
    }
  }
  has(key) {
    if (isDefined(key)) {
      return this.items.has(key);
    } else {
      return this.defaultItems.length > 0;
    }
  }
  get(key) {
    if (isNullOrUndefined(key)) {
      return this.defaultItems;
    }
    return this.items.get(key) || [];
  }
  count(key) {
    if (isNullOrUndefined(key)) {
      return this.defaultItems.length;
    }
    const list2 = this.get(key);
    if (isDefined(list2)) {
      return list2.length;
    }
    return 0;
  }
  get size() {
    let size4 = this.defaultItems.length;
    for (const list2 of this.items.values()) {
      size4 += list2.length;
    }
    return size4;
  }
  delete(key) {
    if (isNullOrUndefined(key)) {
      return arrayClear(this.defaultItems).length > 0;
    } else {
      return this.items.delete(key);
    }
  }
  remove(key, value2) {
    if (isNullOrUndefined(key)) {
      arrayRemove(this.defaultItems, value2);
    } else {
      const list2 = this.items.get(key);
      if (isDefined(list2)) {
        arrayRemove(list2, value2);
        if (list2.length === 0) {
          this.items.delete(key);
        }
      }
    }
  }
  clear() {
    this.items.clear();
    arrayClear(this.defaultItems);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/PriorityMap.ts
var PriorityMap = class {
  constructor(init) {
    this.items = /* @__PURE__ */ new Map();
    if (isDefined(init)) {
      for (const [key1, key2, value2] of init) {
        this.add(key1, key2, value2);
      }
    }
  }
  add(key1, key2, value2) {
    let level1 = this.items.get(key1);
    if (isNullOrUndefined(level1)) {
      this.items.set(key1, level1 = /* @__PURE__ */ new Map());
    }
    level1.set(key2, value2);
    return this;
  }
  *entries() {
    for (const [key1, level1] of this.items) {
      for (const [key2, value2] of level1) {
        yield [key1, key2, value2];
      }
    }
  }
  keys(key1) {
    if (isNullOrUndefined(key1)) {
      return this.items.keys();
    } else {
      return this.items.get(key1).keys();
    }
  }
  *values() {
    for (const level1 of this.items.values()) {
      for (const value2 of level1.values()) {
        yield value2;
      }
    }
  }
  has(key1, key2) {
    return this.items.has(key1) && (isNullOrUndefined(key2) || this.items.get(key1).has(key2));
  }
  get(key1, key2) {
    if (isNullOrUndefined(key2)) {
      return this.items.get(key1);
    } else if (this.items.has(key1)) {
      return this.items.get(key1).get(key2);
    } else {
      return null;
    }
  }
  count(key1) {
    if (this.items.has(key1)) {
      return this.items.get(key1).size;
    }
    return null;
  }
  get size() {
    let size4 = 0;
    for (const list2 of this.items.values()) {
      size4 += list2.size;
    }
    return size4;
  }
  delete(key1, key2) {
    if (isNullOrUndefined(key2)) {
      return this.items.delete(key1);
    } else if (this.items.has(key1)) {
      const items = this.items.get(key1);
      const deleted = items.delete(key2);
      if (items.size === 0) {
        this.items.delete(key1);
      }
      return deleted;
    } else {
      return false;
    }
  }
  clear() {
    this.items.clear();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/indexdb/index.ts
var IDexDB = class {
  constructor(db) {
    this.db = db;
  }
  static delete(dbName) {
    const deleteRequest = indexedDB.deleteDatabase(dbName);
    const task = once(deleteRequest, "success", "error", "blocked");
    return success(task);
  }
  static async open(name3, ...storeDefs) {
    const storesByName = makeLookup(storeDefs, (v) => v.name);
    const indexesByName = new PriorityMap(
      storeDefs.filter((storeDef) => isDefined(storeDef.indexes)).flatMap((storeDef) => storeDef.indexes.map((indexDef) => [storeDef.name, indexDef.name, indexDef]))
    );
    const storesToAdd = new Array();
    const storesToRemove = new Array();
    const storesToChange = new Array();
    const indexesToAdd = new PriorityList();
    const indexesToRemove = new PriorityList();
    let version5 = null;
    const D2 = indexedDB.open(name3);
    if (await success(once(D2, "success", "error", "blocked"))) {
      const db = D2.result;
      version5 = db.version;
      const storesToScrutinize = new Array();
      for (const storeName of db.objectStoreNames) {
        if (!storesByName.has(storeName)) {
          storesToRemove.push(storeName);
        }
      }
      for (const storeName of storesByName.keys()) {
        if (!db.objectStoreNames.contains(storeName)) {
          storesToAdd.push(storeName);
        } else {
          storesToScrutinize.push(storeName);
        }
      }
      if (storesToScrutinize.length > 0) {
        const transaction = db.transaction(storesToScrutinize);
        const transacting = once(transaction, "complete", "error", "abort");
        const transacted = success(transacting);
        for (const storeName of storesToScrutinize) {
          const store = transaction.objectStore(storeName);
          const storeDef = storesByName.get(storeName);
          if (isDefined(storeDef.options) && store.keyPath !== storeDef.options.keyPath) {
            storesToRemove.push(storeName);
            storesToAdd.push(storeName);
          }
          for (const indexName of store.indexNames) {
            if (!indexesByName.has(storeName, indexName)) {
              if (storesToChange.indexOf(storeName) === -1) {
                storesToChange.push(storeName);
              }
              indexesToRemove.add(storeName, indexName);
            }
          }
          if (indexesByName.has(storeName)) {
            for (const indexName of indexesByName.get(storeName).keys()) {
              if (!store.indexNames.contains(indexName)) {
                if (storesToChange.indexOf(storeName) === -1) {
                  storesToChange.push(storeName);
                }
                indexesToAdd.add(storeName, indexName);
              } else {
                const indexDef = indexesByName.get(storeName, indexName);
                const index = store.index(indexName);
                if (isString(indexDef.keyPath) !== isString(index.keyPath) || isString(indexDef.keyPath) && isString(index.keyPath) && indexDef.keyPath !== index.keyPath || isArray(indexDef.keyPath) && isArray(index.keyPath) && arrayCompare(indexDef.keyPath, index.keyPath)) {
                  if (storesToChange.indexOf(storeName) === -1) {
                    storesToChange.push(storeName);
                  }
                  indexesToRemove.add(storeName, indexName);
                  indexesToAdd.add(storeName, indexName);
                }
              }
            }
          }
        }
        transaction.commit();
        await transacted;
      }
      dispose(db);
    } else {
      version5 = 0;
      storesToAdd.push(...storesByName.keys());
      for (const storeDef of storeDefs) {
        if (isDefined(storeDef.indexes)) {
          for (const indexDef of storeDef.indexes) {
            indexesToAdd.add(storeDef.name, indexDef.name);
          }
        }
      }
    }
    if (storesToAdd.length > 0 || storesToRemove.length > 0 || indexesToAdd.size > 0 || indexesToRemove.size > 0) {
      ++version5;
    }
    const upgrading = new Task();
    const openRequest = isDefined(version5) ? indexedDB.open(name3, version5) : indexedDB.open(name3);
    const opening = once(openRequest, "success", "error", "blocked");
    const upgraded = success(upgrading);
    const opened = success(opening);
    const noUpgrade = upgrading.resolver(false);
    openRequest.addEventListener("success", noUpgrade);
    openRequest.addEventListener("upgradeneeded", () => {
      const transacting = once(openRequest.transaction, "complete", "error", "abort");
      const db = openRequest.result;
      for (const storeName of storesToRemove) {
        db.deleteObjectStore(storeName);
      }
      const stores = /* @__PURE__ */ new Map();
      for (const storeName of storesToAdd) {
        const storeDef = storesByName.get(storeName);
        const store = db.createObjectStore(storeName, storeDef.options);
        stores.set(storeName, store);
      }
      for (const storeName of storesToChange) {
        const store = openRequest.transaction.objectStore(storeName);
        stores.set(storeName, store);
      }
      for (const [storeName, store] of stores) {
        for (const indexName of indexesToRemove.get(storeName)) {
          store.deleteIndex(indexName);
        }
        for (const indexName of indexesToAdd.get(storeName)) {
          const indexDef = indexesByName.get(storeName, indexName);
          store.createIndex(indexName, indexDef.keyPath, indexDef.options);
        }
      }
      success(transacting).then(upgrading.resolve).catch(upgrading.reject).finally(() => openRequest.removeEventListener("success", noUpgrade));
    });
    if (!await upgraded) {
      throw upgrading.error;
    }
    if (!await opened) {
      throw opening.error;
    }
    return new IDexDB(openRequest.result);
  }
  dispose() {
    dispose(this.db);
  }
  get name() {
    return this.db.name;
  }
  get version() {
    return this.db.version;
  }
  get storeNames() {
    return Array.from(this.db.objectStoreNames);
  }
  getStore(storeName) {
    return new IDexStore(this.db, storeName);
  }
};
var IDexStore = class {
  constructor(db, storeName) {
    this.db = db;
    this.storeName = storeName;
  }
  async request(makeRequest, mode) {
    const transaction = this.db.transaction(this.storeName, mode);
    const transacting = once(transaction, "complete", "error");
    const store = transaction.objectStore(this.storeName);
    const request = makeRequest(store);
    const requesting = once(request, "success", "error");
    if (!await success(requesting)) {
      transaction.abort();
      throw requesting.error;
    }
    transaction.commit();
    if (!await success(transacting)) {
      throw transacting.error;
    }
    return request.result;
  }
  add(value2, key) {
    return this.request((store) => store.add(value2, key), "readwrite");
  }
  clear() {
    return this.request((store) => store.clear(), "readwrite");
  }
  getCount(query) {
    return this.request((store) => store.count(query), "readonly");
  }
  async has(query) {
    return await this.getCount(query) > 0;
  }
  delete(query) {
    return this.request((store) => store.delete(query), "readwrite");
  }
  get(key) {
    return this.request((store) => store.get(key), "readonly");
  }
  getAll() {
    return this.request((store) => store.getAll(), "readonly");
  }
  getAllKeys() {
    return this.request((store) => store.getAllKeys(), "readonly");
  }
  getKey(query) {
    return this.request((store) => store.getKey(query), "readonly");
  }
  openCursor(query, direction) {
    return this.request((store) => store.openCursor(query, direction), "readonly");
  }
  openKeyCursor(query, direction) {
    return this.request((store) => store.openKeyCursor(query, direction), "readonly");
  }
  put(value2, key) {
    return this.request((store) => store.put(value2, key), "readwrite");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapJoin.ts
function mapJoin(dest, ...sources) {
  for (const source of sources) {
    if (isDefined(source)) {
      for (const [key, value2] of source) {
        dest.set(key, value2);
      }
    }
  }
  return dest;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/sleep.ts
var SleepTask = class extends Task {
  constructor(milliseconds) {
    super(false);
    this.milliseconds = milliseconds;
    this._timer = null;
  }
  start() {
    super.start();
    this._timer = setTimeout(() => {
      this._timer = null;
      this.resolve();
    }, this.milliseconds);
  }
  reset() {
    super.reset();
    if (isDefined(this._timer)) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
};
function sleep(milliseconds) {
  const task = new SleepTask(milliseconds);
  task.start();
  return task;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/withRetry.ts
function withRetry(retryCount, action) {
  return async () => {
    let lastError = null;
    let retryTime = 500;
    for (let retry = 0; retry <= retryCount; ++retry) {
      try {
        if (retry > 0) {
          await sleep(retryTime);
          retryTime *= 2;
        }
        return await action();
      } catch (error) {
        lastError = error;
      }
    }
    throw lastError;
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/fetcher/FetchingServiceImplXHR.ts
function isXHRBodyInit(obj2) {
  return isString(obj2) || isArrayBufferView(obj2) || obj2 instanceof Blob || obj2 instanceof FormData || isArrayBuffer(obj2) || "Document" in globalThis && obj2 instanceof Document;
}
function trackProgress(name3, xhr, target, prog, skipLoading, prevTask) {
  let prevDone = !prevTask;
  if (prevTask) {
    prevTask.then(() => prevDone = true);
  }
  let done = false;
  let loaded = skipLoading;
  const requestComplete = new Task();
  target.addEventListener("loadstart", () => {
    if (prevDone && !done && prog) {
      prog.start(name3);
    }
  });
  target.addEventListener("progress", (ev) => {
    if (prevDone && !done) {
      const evt = ev;
      if (prog) {
        prog.report(evt.loaded, Math.max(evt.loaded, evt.total), name3);
      }
      if (evt.loaded === evt.total) {
        loaded = true;
        if (done) {
          requestComplete.resolve();
        }
      }
    }
  });
  target.addEventListener("load", () => {
    if (prevDone && !done) {
      if (prog) {
        prog.end(name3);
      }
      done = true;
      if (loaded) {
        requestComplete.resolve();
      }
    }
  });
  const onError = (msg) => () => {
    if (prevDone) {
      requestComplete.reject(`${msg} (${xhr.status})`);
    }
  };
  target.addEventListener("error", onError("error"));
  target.addEventListener("abort", onError("abort"));
  target.addEventListener("timeout", onError("timeout"));
  return requestComplete;
}
function sendRequest(xhr, method, path, timeout, headers, body) {
  xhr.open(method, path);
  xhr.responseType = "blob";
  xhr.timeout = timeout;
  if (headers) {
    for (const [key, value2] of headers) {
      xhr.setRequestHeader(key, value2);
    }
  }
  if (isDefined(body)) {
    xhr.send(body);
  } else {
    xhr.send();
  }
}
function readResponseHeader(headers, key, translate) {
  if (!headers.has(key)) {
    return null;
  }
  const value2 = headers.get(key);
  try {
    const translated = translate(value2);
    headers.delete(key);
    return translated;
  } catch (exp2) {
    console.warn(key, exp2);
  }
  return null;
}
var FILE_NAME_PATTERN = /filename=\"(.+)\"(;|$)/;
var DB_NAME = "Juniper:Fetcher:Cache";
var FetchingServiceImplXHR = class {
  constructor() {
    this.cache = null;
    this.store = null;
    this.tasks = new PriorityMap();
    this.cacheReady = this.openCache();
  }
  async drawImageToCanvas(request, canvas, progress) {
    const response = await this.sendNothingGetSomething("blob", request, progress);
    const blob = response.content;
    return using(await createImageBitmap(blob, {
      imageOrientation: "from-image"
    }), (img) => {
      canvas.width = img.width;
      canvas.height = img.height;
      const g = canvas.getContext("2d");
      g.drawImage(img, 0, 0);
      return translateResponse(response);
    });
  }
  async openCache() {
    const options = {
      keyPath: "requestPath"
    };
    this.cache = await IDexDB.open(DB_NAME, {
      name: "files",
      options
    });
    this.store = await this.cache.getStore("files");
  }
  async clearCache() {
    await this.cacheReady;
    await this.store.clear();
  }
  async evict(path) {
    await this.cacheReady;
    if (this.store.has(path)) {
      await this.store.delete(path);
    }
  }
  async readResponseHeaders(requestPath, xhr) {
    const headerParts = xhr.getAllResponseHeaders().split(/[\r\n]+/).map((v) => v.trim()).filter((v) => v.length > 0).map((line) => {
      const parts = line.split(": ");
      const key = parts.shift().toLowerCase();
      const value2 = parts.join(": ");
      return [key, value2];
    });
    const pList = new PriorityList(headerParts);
    const normalizedHeaderParts = Array.from(pList.keys()).map((key) => [
      key,
      pList.get(key).join(", ")
    ]);
    const headers = new Map(normalizedHeaderParts);
    const contentType = readResponseHeader(headers, "content-type", identity);
    const contentLength = readResponseHeader(headers, "content-length", parseFloat);
    const date = readResponseHeader(headers, "date", (v) => new Date(v));
    const fileName = readResponseHeader(headers, "content-disposition", (v) => {
      if (isDefined(v)) {
        const match = v.match(FILE_NAME_PATTERN);
        if (isDefined(match)) {
          return match[1];
        }
      }
      return null;
    });
    const response = {
      status: xhr.status,
      requestPath,
      responsePath: xhr.responseURL,
      content: void 0,
      contentType,
      contentLength,
      fileName,
      date,
      headers
    };
    return response;
  }
  async readResponse(requestPath, xhr) {
    const {
      responsePath,
      status,
      contentType,
      contentLength,
      fileName,
      date,
      headers
    } = await this.readResponseHeaders(requestPath, xhr);
    const response = {
      requestPath,
      responsePath,
      status,
      contentType,
      contentLength,
      fileName,
      date,
      headers,
      content: xhr.response
    };
    if (isDefined(response.content)) {
      response.contentType = response.contentType || response.content.type;
      response.contentLength = response.contentLength || response.content.size;
    }
    return response;
  }
  async decodeContent(xhrType, response) {
    return translateResponse(response, async (contentBlob) => {
      if (xhrType === "") {
        return null;
      } else if (isNullOrUndefined(response.contentType)) {
        const headerBlock = Array.from(response.headers.entries()).map((kv) => kv.join(": ")).join("\n  ");
        throw new Error("No content type found in headers: \n  " + headerBlock);
      } else if (xhrType === "blob") {
        return contentBlob;
      } else if (xhrType === "arraybuffer") {
        return await contentBlob.arrayBuffer();
      } else if (xhrType === "json") {
        const text2 = await contentBlob.text();
        if (text2.length > 0) {
          return JSON.parse(text2);
        } else {
          return null;
        }
      } else if (xhrType === "document") {
        const parser = new DOMParser();
        if (response.contentType === "application/xhtml+xml" || response.contentType === "text/html" || response.contentType === "application/xml" || response.contentType === "image/svg+xml" || response.contentType === "text/xml") {
          return parser.parseFromString(await contentBlob.text(), response.contentType);
        } else {
          throw new Error("Couldn't parse document");
        }
      } else if (xhrType === "text") {
        return await contentBlob.text();
      } else {
        assertNever(xhrType);
      }
    });
  }
  async withCachedTask(request, action) {
    if (request.method !== "GET" && request.method !== "HEAD" && request.method !== "OPTIONS") {
      return await action();
    }
    if (!this.tasks.has(request.method, request.path)) {
      this.tasks.add(
        request.method,
        request.path,
        action().finally(() => this.tasks.delete(request.method, request.path))
      );
    }
    return this.tasks.get(request.method, request.path);
  }
  sendNothingGetNothing(request) {
    return this.withCachedTask(
      request,
      withRetry(request.retryCount, async () => {
        const xhr = new XMLHttpRequest();
        const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, null, true);
        sendRequest(xhr, request.method, request.path, request.timeout, request.headers);
        await download;
        return await this.readResponseHeaders(request.path, xhr);
      })
    );
  }
  sendNothingGetSomething(xhrType, request, progress) {
    return this.withCachedTask(
      request,
      withRetry(request.retryCount, async () => {
        let response = null;
        const useCache = request.useCache && request.method === "GET";
        if (useCache) {
          if (isDefined(progress)) {
            progress.start();
          }
          await this.cacheReady;
          response = await this.store.get(request.path);
        }
        const noCachedResponse = isNullOrUndefined(response);
        if (noCachedResponse) {
          const xhr = new XMLHttpRequest();
          const download = trackProgress(`requesting: ${request.path}`, xhr, xhr, progress, true);
          sendRequest(xhr, request.method, request.path, request.timeout, request.headers);
          await download;
          response = await this.readResponse(request.path, xhr);
          if (useCache) {
            await this.store.add(response);
          }
        }
        const value2 = await this.decodeContent(xhrType, response);
        if (noCachedResponse && isDefined(progress)) {
          progress.end();
        }
        return value2;
      })
    );
  }
  sendSomethingGetSomething(xhrType, request, defaultPostHeaders, progress) {
    let body = null;
    const headers = mapJoin(/* @__PURE__ */ new Map(), defaultPostHeaders, request.headers);
    if (request.body instanceof FormData && isDefined(headers)) {
      const toDelete = new Array();
      for (const key of headers.keys()) {
        if (key.toLowerCase() === "content-type") {
          toDelete.push(key);
        }
      }
      for (const key of toDelete) {
        headers.delete(key);
      }
    }
    if (isXHRBodyInit(request.body) && !isString(request.body)) {
      body = request.body;
    } else if (isDefined(request.body)) {
      body = JSON.stringify(request.body);
    }
    const hasBody = isDefined(body);
    const progs = progressSplit(progress, hasBody ? 2 : 1);
    const [progUpload, progDownload] = progs;
    const query = async () => {
      const xhr = new XMLHttpRequest();
      const upload = hasBody ? trackProgress("uploading", xhr, xhr.upload, progUpload, false) : Promise.resolve();
      const download = trackProgress("saving", xhr, xhr, progDownload, true, upload);
      sendRequest(xhr, request.method, request.path, request.timeout, headers, body);
      await upload;
      await download;
      const response = await this.readResponse(request.path, xhr);
      return await this.decodeContent(xhrType, response);
    };
    return withRetry(request.retryCount, query)();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/workers/WorkerPool.ts
var WorkerPool = class extends TypedEventBase {
  /**
   * Creates a new pooled worker method executor.
   * @param options
   */
  constructor(options, WorkerClientClass) {
    super();
    this.scriptPath = options.scriptPath;
    let workerPoolSize = -1;
    const workersDef = options.workers;
    let workers = null;
    if (isNumber(workersDef)) {
      workerPoolSize = workersDef;
    } else if (isDefined(workersDef)) {
      this.taskCounter = workersDef.curTaskCounter;
      workers = workersDef.workers;
      workerPoolSize = workers.length;
    } else {
      workerPoolSize = navigator.hardwareConcurrency || 4;
    }
    if (workerPoolSize < 1) {
      throw new Error("Worker pool size must be a postive integer greater than 0");
    }
    this.workers = new Array(workerPoolSize);
    if (isNullOrUndefined(workers)) {
      this.taskCounter = 0;
      for (let i = 0; i < workerPoolSize; ++i) {
        this.workers[i] = new WorkerClientClass(new Worker(this.scriptPath, { type: "module" }));
      }
    } else {
      for (let i = 0; i < workerPoolSize; ++i) {
        this.workers[i] = new WorkerClientClass(workers[i]);
      }
    }
    for (const worker2 of this.workers) {
      worker2.addBubbler(this);
    }
  }
  dispose() {
    this.workers.forEach(dispose);
    arrayClear(this.workers);
  }
  nextWorker() {
    const worker2 = this.peekWorker();
    this.taskCounter++;
    return worker2;
  }
  peekWorker() {
    return this.workers[this.taskCounter % this.workers.length];
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/IProgress.ts
function isProgressCallback(obj2) {
  return isDefined(obj2) && isFunction(obj2.report) && isFunction(obj2.attach) && isFunction(obj2.end);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/flags.ts
function isChrome() {
  return "chrome" in globalThis && !navigator.userAgent.match("CriOS");
}
function isFirefox() {
  return "InstallTrigger" in globalThis;
}
function isSafari() {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
}
function isMacOS() {
  return /^mac/i.test(navigator.platform);
}
function isIOS() {
  return /iP(ad|hone|od)/.test(navigator.platform) || /Macintosh(.*?) FxiOS(.*?)\//.test(navigator.platform) || isMacOS() && "maxTouchPoints" in navigator && navigator.maxTouchPoints > 2;
}
function isMobileVR() {
  return /Mobile VR/.test(navigator.userAgent) || /Pico Neo 3 Link/.test(navigator.userAgent) || isOculusBrowser;
}
function hasWebXR() {
  return "xr" in navigator && "isSessionSupported" in navigator.xr;
}
function hasWebVR() {
  return "getVRDisplays" in navigator;
}
function hasVR() {
  return hasWebXR() || hasWebVR();
}
function isMobile() {
  return /Android/.test(navigator.userAgent) || /BlackBerry/.test(navigator.userAgent) || /(UC Browser |UCWEB)/.test(navigator.userAgent) || isIOS() || isMobileVR();
}
function isDesktop() {
  return !isMobile();
}
var oculusBrowserPattern = /OculusBrowser\/(\d+)\.(\d+)\.(\d+)/i;
var oculusMatch = /* @__PURE__ */ navigator.userAgent.match(oculusBrowserPattern);
var isOculusBrowser = !!oculusMatch;
var oculusBrowserVersion = isOculusBrowser && {
  major: parseFloat(oculusMatch[1]),
  minor: parseFloat(oculusMatch[2]),
  patch: parseFloat(oculusMatch[3])
};
var isOculusGo = isOculusBrowser && /pacific/i.test(navigator.userAgent);
var isOculusQuest = isOculusBrowser && /quest/i.test(navigator.userAgent);
var isOculusQuest2 = isOculusBrowser && /quest 2/i.test(navigator.userAgent);
var isWorkerSupported = "Worker" in globalThis;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/workers/WorkerClient.ts
var WorkerClient = class extends TypedEventBase {
  /**
   * Creates a new pooled worker method executor.
   * @param options
   */
  constructor(worker2) {
    super();
    this.worker = worker2;
    this.invocations = /* @__PURE__ */ new Map();
    this.tasks = new Array();
    this.taskCounter = 0;
    if (!isWorkerSupported) {
      console.warn("Workers are not supported on this system.");
    }
    this.worker.addEventListener("message", (evt) => {
      const data = evt.data;
      switch (data.type) {
        case "event":
          this.propogateEvent(data);
          break;
        case "progress":
          this.progressReport(data);
          break;
        case "return":
          this.methodReturned(data);
          break;
        case "error":
          this.invocationError(data);
          break;
        default:
          assertNever(data);
      }
    });
  }
  postMessage(message2, transferables) {
    if (message2.type !== "methodCall") {
      assertNever(message2.type);
    }
    if (transferables) {
      this.worker.postMessage(message2, transferables);
    } else {
      this.worker.postMessage(message2);
    }
  }
  dispose() {
    this.worker.terminate();
  }
  progressReport(data) {
    const invocation = this.invocations.get(data.taskID);
    if (invocation) {
      const { prog } = invocation;
      if (prog) {
        prog.report(data.soFar, data.total, data.msg, data.est);
      }
    }
  }
  methodReturned(data) {
    const messageHandler = this.removeInvocation(data.taskID);
    const { task } = messageHandler;
    task.resolve(data.returnValue);
  }
  invocationError(data) {
    const messageHandler = this.removeInvocation(data.taskID);
    const { task, methodName } = messageHandler;
    task.reject(new Error(`${methodName} failed. Reason: ${data.errorMessage}`));
  }
  /**
   * When the invocation has errored, we want to stop listening to the worker
   * message channel so we don't eat up processing messages that have no chance
   * ever pertaining to the invocation.
   **/
  removeInvocation(taskID) {
    const invocation = this.invocations.get(taskID);
    this.invocations.delete(taskID);
    return invocation;
  }
  /**
   * Execute a method on a round-robin selected worker thread.
   * @param methodName - the name of the method to execute.
   * @param parameters - the parameters to pass to the method.
   * @param transferables - any values in any of the parameters that should be transfered instead of copied to the worker thread.
   * @param prog - a callback for receiving progress reports on long-running invocations.
   */
  callMethod(methodName, parameters, transferables, prog) {
    if (!isWorkerSupported) {
      return Promise.reject(new Error("Workers are not supported on this system."));
    }
    let params = null;
    let tfers = null;
    if (isProgressCallback(parameters)) {
      prog = parameters;
      parameters = null;
      transferables = null;
    }
    if (isProgressCallback(transferables) && !prog) {
      prog = transferables;
      transferables = null;
    }
    if (isArray(parameters)) {
      params = parameters;
    }
    if (isArray(transferables)) {
      tfers = transferables;
    }
    const taskID = this.taskCounter++;
    let task = arrayScan(this.tasks, (t2) => t2.finished);
    if (task) {
      task.reset();
    } else {
      task = new Task();
      this.tasks.push(task);
    }
    const invocation = {
      methodName,
      task,
      prog
    };
    this.invocations.set(taskID, invocation);
    let message2 = null;
    if (isDefined(parameters)) {
      message2 = {
        type: "methodCall",
        taskID,
        methodName,
        params
      };
    } else {
      message2 = {
        type: "methodCall",
        taskID,
        methodName
      };
    }
    this.postMessage(message2, tfers);
    return task;
  }
};

// src/isDebug.ts
var url = /* @__PURE__ */ new URL(globalThis.location.href);
var isDebug = !url.searchParams.has("RELEASE");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/singleton.ts
function singleton(name3, create13) {
  const box = globalThis;
  let value2 = box[name3];
  if (isNullOrUndefined(value2)) {
    if (isNullOrUndefined(create13)) {
      throw new Error(`No value ${name3} found`);
    }
    value2 = create13();
    box[name3] = value2;
  }
  return value2;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/fonts.ts
var loadedFonts = singleton("juniper::loadedFonts", () => []);
function makeFont(style) {
  const fontParts = [];
  if (style.fontStyle && style.fontStyle !== "normal") {
    fontParts.push(style.fontStyle);
  }
  if (style.fontVariant && style.fontVariant !== "normal") {
    fontParts.push(style.fontVariant);
  }
  if (style.fontWeight && style.fontWeight !== "normal") {
    fontParts.push(style.fontWeight);
  }
  fontParts.push(px(style.fontSize));
  fontParts.push(style.fontFamily);
  return fontParts.join(" ");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/all.ts
function all(...tasks) {
  return Promise.all(tasks);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/strings/stringRandom.ts
var DEFAULT_CHAR_SET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZ";
function stringRandom(length8, charSet) {
  if (length8 < 0) {
    throw new Error("Length must be greater than 0");
  }
  if (isNullOrUndefined(charSet)) {
    charSet = DEFAULT_CHAR_SET;
  }
  let str5 = "";
  for (let i = 0; i < length8; ++i) {
    const idx = Math.floor(Math.random() * charSet.length);
    str5 += charSet[idx];
  }
  return str5;
}

// package.json
var version2 = "3.7.24";

// src/DataLogger.ts
var DataLogger = class {
  constructor(log) {
    this.log = log;
  }
  error(page, operation, exception) {
    console.error(page, operation, exception);
    this.log("error", {
      page,
      operation,
      exception
    });
  }
};

// src/settings.ts
var version3 = isDebug ? stringRandom(10) : version2;
var enableFullResolution = false;
var DEMO_PPI = 50;
var DEMO_DIM = 12;
var DEMO_PX = DEMO_PPI * DEMO_DIM;
var defaultFont = {
  fontFamily: "Lato",
  fontSize: 20
};
var DLSBlue = rgb(30, 67, 136);
var BasicLabelColor = rgb(78, 77, 77);
var baseTextStyle = {
  fontFamily: defaultFont.fontFamily,
  fontSize: defaultFont.fontSize,
  textFillColor: "white"
};
var textButtonStyle = Object.assign({}, baseTextStyle, {
  bgFillColor: rgb(0, 120, 215),
  bgStrokeColor: "black",
  bgStrokeSize: 0.02,
  padding: {
    top: 0.025,
    left: 0.05,
    bottom: 0.025,
    right: 0.05
  },
  minHeight: 0.2,
  maxHeight: 0.2,
  scale: 300
});
var textLabelStyle = Object.assign({}, baseTextStyle, {
  textStrokeColor: "black",
  textStrokeSize: 0.01,
  minHeight: 0.25,
  maxHeight: 0.25
});
function getUIImagePaths() {
  const imageNames = new PriorityList([
    ["arrow", "arrow-up"],
    ["arrow", "arrow-down"],
    ["arrow", "arrow-left"],
    ["arrow", "arrow-right"],
    ["chat", "user"],
    ["chat", "chat"],
    ["ui", "menu"],
    ["ui", "settings"],
    ["ui", "quit"],
    ["ui", "lobby"],
    ["zoom", "zoom-in"],
    ["zoom", "zoom-out"],
    ["zoom", "zoom-info"],
    ["environment-audio", "environment-audio-mute"],
    ["environment-audio", "environment-audio-unmute"],
    ["headphones", "headphones-unmuted"],
    ["headphones", "headphones-muted"],
    ["microphone", "microphone-mute"],
    ["microphone", "microphone-unmute"],
    ["volume", "volume-muted"],
    ["volume", "volume-low"],
    ["volume", "volume-medium"],
    ["volume", "volume-high"],
    ["media", "media-pause"],
    ["media", "media-play"],
    ["media", "media-stop"],
    ["media", "media-replay"],
    ["ar", "ar-enter"],
    ["ar", "ar-exit"],
    ["vr", "vr-enter"],
    ["vr", "vr-exit"],
    ["fullscreen", "fullscreen-enter"],
    ["fullscreen", "fullscreen-exit"]
  ]);
  const uiImagePaths = new PriorityMap();
  for (const [setName, iconNames] of imageNames.entries()) {
    for (const iconName of iconNames) {
      uiImagePaths.add(
        setName,
        iconName.replace(setName + "-", ""),
        `/images/ui/${iconName}.png`
      );
    }
  }
  return uiImagePaths;
}
var JS_EXT = isDebug ? ".js" : ".min.js";
function getAppUrl(ext, name3) {
  return `/js/${name3}/index${ext}?v=${version3}`;
}
function getScriptUrl(name3) {
  return getAppUrl(JS_EXT, name3);
}
function getAppScriptUrl(name3) {
  return getScriptUrl("vr-apps/" + name3);
}
function getWorkerUrl(name3) {
  return getScriptUrl("workers/" + name3);
}
function getLibScriptUrl(name3) {
  return getScriptUrl("libs/" + name3);
}
function createDataLogger(fetcher2) {
  let reportID = null;
  let lastTask = Promise.resolve();
  const log = async (key, value2) => {
    reportID = await fetcher2.post("/").body({ reportID, key, value: value2 }, Application_JsonUTF8).object().then(unwrapResponse);
  };
  return new DataLogger((key, value2) => {
    lastTask = lastTask.then(() => log(key, value2));
  });
}

// src/createFetcher.ts
function createFetcher(enableWorkers = true) {
  let fallback = new FetchingService(new FetchingServiceImplXHR());
  if (false) {
    fallback = new FetchingServicePool({
      scriptPath: getWorkerUrl2("fetcher")
    }, fallback);
  }
  return new Fetcher(fallback, !isDebug);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/Emoji.ts
var Emoji = class {
  /**
   * Creates a new Unicode-standardized pictograms.
   * @param value - a Unicode sequence.
   * @param desc - an English text description of the pictogram.
   * @param props - an optional set of properties to store with the emoji.
   */
  constructor(value2, desc, props = null) {
    this.value = value2;
    this.desc = desc;
    this.value = value2;
    this.desc = desc;
    this.props = props || {};
  }
  /**
   * Determines of the provided Emoji or EmojiGroup is a subset of
   * this emoji.
   */
  contains(e2) {
    if (e2 instanceof Emoji) {
      return this.contains(e2.value);
    } else {
      return this.value.indexOf(e2) >= 0;
    }
  }
  changeStyle(expected, wanted) {
    let value2 = this.value;
    if (value2.endsWith(expected)) {
      value2 = value2.substring(0, value2.length - expected.length);
    }
    value2 += wanted;
    return value2;
  }
  get textStyle() {
    return this.changeStyle("\uFE0F", "\uFE0E");
  }
  get emojiStyle() {
    return this.changeStyle("\uFE0E", "\uFE0F");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/index.ts
var star = /* @__PURE__ */ new Emoji("\u2B50", "Star");
var blackDiamondCentered = /* @__PURE__ */ new Emoji("\u2BC1", "Black Diamond Centred");
var clockwiseVerticalArrows = /* @__PURE__ */ new Emoji("\u{1F503}\uFE0F", "Clockwise Vertical Arrows");
var upArrow = /* @__PURE__ */ new Emoji("\u2B06\uFE0F", "Up Arrow");
var upArrowText = /* @__PURE__ */ new Emoji("\u2B06\uFE0E", "Up Arrow: Text");
var blackMediumDownPointingTriangleCentered = /* @__PURE__ */ new Emoji("\u2BC6", "Black Medium Down-Pointing Triangle Centered");
var blackMediumRightPointingTriangleCentered = /* @__PURE__ */ new Emoji("\u2BC8", "Black Medium Right-Pointing Triangle Centered");
var keycapDigitZero = /* @__PURE__ */ new Emoji("0\uFE0F\u20E3", "Keycap Digit Zero");
var keycapDigitOne = /* @__PURE__ */ new Emoji("1\uFE0F\u20E3", "Keycap Digit One");
var keycapDigitTwo = /* @__PURE__ */ new Emoji("2\uFE0F\u20E3", "Keycap Digit Two");
var keycapDigitThree = /* @__PURE__ */ new Emoji("3\uFE0F\u20E3", "Keycap Digit Three");
var keycapDigitFour = /* @__PURE__ */ new Emoji("4\uFE0F\u20E3", "Keycap Digit Four");
var keycapDigitFive = /* @__PURE__ */ new Emoji("5\uFE0F\u20E3", "Keycap Digit Five");
var keycapDigitSix = /* @__PURE__ */ new Emoji("6\uFE0F\u20E3", "Keycap Digit Six");
var keycapDigitSeven = /* @__PURE__ */ new Emoji("7\uFE0F\u20E3", "Keycap Digit Seven");
var keycapDigitEight = /* @__PURE__ */ new Emoji("8\uFE0F\u20E3", "Keycap Digit Eight");
var keycapDigitNine = /* @__PURE__ */ new Emoji("9\uFE0F\u20E3", "Keycap Digit Nine");
var keycap10 = /* @__PURE__ */ new Emoji("\u{1F51F}", "Keycap: 10");
var cancelTag = /* @__PURE__ */ new Emoji("\u{E007F}", "Cancel Tag");
var plus = /* @__PURE__ */ new Emoji("\u2795", "Plus");
var globeShowingAmericas = /* @__PURE__ */ new Emoji("\u{1F30E}", "Globe Showing Americas");
var megaphone = /* @__PURE__ */ new Emoji("\u{1F4E3}", "Megaphone");
var videoCamera = /* @__PURE__ */ new Emoji("\u{1F4F9}", "Video Camera");
var speakerHighVolume = /* @__PURE__ */ new Emoji("\u{1F50A}", "Speaker High Volume");
var lockedWithKey = /* @__PURE__ */ new Emoji("\u{1F510}", "Locked with Key");
var joystick = /* @__PURE__ */ new Emoji("\u{1F579}\uFE0F", "Joystick");
var wastebasket = /* @__PURE__ */ new Emoji("\u{1F5D1}", "Wastebasket");
var scroll = /* @__PURE__ */ new Emoji("\u{1F4DC}", "Scroll");
var memo = /* @__PURE__ */ new Emoji("\u{1F4DD}", "Memo");
var warning = /* @__PURE__ */ new Emoji("\u26A0\uFE0F", "Warning");
var framedPicture = /* @__PURE__ */ new Emoji("\u{1F5BC}\uFE0F", "Framed Picture");
var worldMap = /* @__PURE__ */ new Emoji("\u{1F5FA}\uFE0F", "World Map");
var questionMark = /* @__PURE__ */ new Emoji("\u2753", "Question Mark");

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/google-maps/conversion.ts
function y2g(p) {
  if (isNullOrUndefined(p)) {
    return null;
  }
  return {
    lat: p.lat,
    lng: p.lng
  };
}
function g2y(p) {
  if (isNullOrUndefined(p)) {
    return null;
  }
  if (p instanceof google.maps.LatLng) {
    return {
      lat: p.lat(),
      lng: p.lng()
    };
  } else {
    return {
      lat: p.lat,
      lng: p.lng
    };
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/evts.ts
function isModifierless(evt) {
  return !(evt.shiftKey || evt.altKey || evt.ctrlKey || evt.metaKey);
}
function makeEnterKeyEventHandler(callback) {
  return (ev) => {
    const evt = ev;
    if (isModifierless(evt) && evt.key === "Enter") {
      callback(evt);
    }
  };
}
var HtmlEvt = class {
  constructor(name3, callback, opts) {
    this.name = name3;
    this.callback = callback;
    if (!isFunction(callback)) {
      throw new Error("A function instance is required for this parameter");
    }
    this.opts = opts;
    Object.freeze(this);
  }
  applyToElement(elem) {
    this.add(elem);
  }
  /**
   * Add the encapsulate callback as an event listener to the give HTMLElement
   */
  add(elem) {
    elem.addEventListener(this.name, this.callback, this.opts);
  }
  /**
   * Remove the encapsulate callback as an event listener from the give HTMLElement
   */
  remove(elem) {
    elem.removeEventListener(this.name, this.callback);
  }
};
function onEvent(eventName, callback, opts) {
  return new HtmlEvt(eventName, callback, opts);
}
function onClick(callback, opts) {
  return onEvent("click", callback, opts);
}
function onContextMenu(callback, opts) {
  return onEvent("contextmenu", callback, opts);
}
function onDblClick(callback, opts) {
  return onEvent("dblclick", callback, opts);
}
function onDragEnd(callback, opts) {
  return onEvent("dragend", callback, opts);
}
function onDragLeave(callback, opts) {
  return onEvent("dragleave", callback, opts);
}
function onDragOver(callback, opts) {
  return onEvent("dragover", callback, opts);
}
function onDragStart(callback, opts) {
  return onEvent("dragstart", callback, opts);
}
function onDrop(callback, opts) {
  return onEvent("drop", callback, opts);
}
function onInput(callback, opts) {
  return onEvent("input", callback, opts);
}
function onKeyDown(callback, opts) {
  return onEvent("keydown", callback, opts);
}
function onKeyUp(callback, opts) {
  return onEvent("keyup", callback, opts);
}
function onEnterKeyPressed(callback, opts) {
  return onKeyUp((evt) => {
    if (evt.key === "Enter") {
      callback(evt);
    }
  }, opts);
}
function onPlay(callback, opts) {
  return onEvent("play", callback, opts);
}
function onToggle(callback, opts) {
  return onEvent("toggle", callback, opts);
}

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/common.js
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
var degree = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/mat3.js
function create2() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add3,
  calculateW: () => calculateW,
  clone: () => clone3,
  conjugate: () => conjugate,
  copy: () => copy3,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues3,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity2,
  invert: () => invert,
  len: () => len2,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul2,
  multiply: () => multiply2,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random2,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  rotationTo: () => rotationTo,
  scale: () => scale3,
  set: () => set3,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen2,
  squaredLength: () => squaredLength3,
  str: () => str2
});

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone,
  copy: () => copy,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals,
  exactEquals: () => exactEquals,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max2,
  min: () => min2,
  mul: () => mul,
  multiply: () => multiply,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  round: () => round,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len6 = x * x + y * y + z * z;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  out[2] = a[2] * len6;
  return out;
}
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t2) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t2) {
  var factorTimes2 = t2 * t2;
  var factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  var factor2 = factorTimes2 * (t2 - 2) + t2;
  var factor3 = factorTimes2 * (t2 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t2) {
  var inverseFactor = 1 - t2;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t2 * t2;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t2 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t2;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale8;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale8;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub = subtract;
var mul = multiply;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec4.js
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues2(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set2(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function scale2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len6 = x * x + y * y + z * z + w * w;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = x * len6;
  out[1] = y * len6;
  out[2] = z * len6;
  out[3] = w * len6;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function lerp2(out, a, b, t2) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  out[3] = aw + t2 * (b[3] - aw);
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot3(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply2(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX2(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY2(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ2(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t2 = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t2;
  out[1] = y * t2;
  out[2] = z * t2;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale3(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t2) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random2(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot8 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot8 ? 1 / dot8 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str2(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone3 = clone2;
var fromValues3 = fromValues2;
var copy3 = copy2;
var set3 = set2;
var add3 = add2;
var mul2 = multiply2;
var scale3 = scale2;
var dot3 = dot2;
var lerp3 = lerp2;
var length3 = length2;
var len2 = length3;
var squaredLength3 = squaredLength2;
var sqrLen2 = squaredLength3;
var normalize3 = normalize2;
var exactEquals3 = exactEquals2;
var equals3 = equals2;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function(out, a, b) {
    var dot8 = dot(a, b);
    if (dot8 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross(tmpvec3, yUnitVec3, a);
      normalize(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot8 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot8;
      return normalize3(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t2) {
    slerp(temp1, a, d, t2);
    slerp(temp2, b, c, t2);
    slerp(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes = function() {
  var matr = create2();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize3(out, fromMat3(out, matr));
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add4,
  angle: () => angle2,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create6,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot4,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach3,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len3,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate2,
  normalize: () => normalize4,
  random: () => random3,
  rotate: () => rotate,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set4,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen3,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength4,
  str: () => str3,
  sub: () => sub2,
  subtract: () => subtract2,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat42,
  zero: () => zero2
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function fromValues4(x, y) {
  var out = new ARRAY_TYPE(2);
  out[0] = x;
  out[1] = y;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
function set4(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
function min3(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max3(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return x * x + y * y;
}
function length4(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function squaredLength4(a) {
  var x = a[0], y = a[1];
  return x * x + y * y;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  return out;
}
function normalize4(out, a) {
  var x = a[0], y = a[1];
  var len6 = x * x + y * y;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  return out;
}
function dot4(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function cross2(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
function lerp4(out, a, b, t2) {
  var ax = a[0], ay = a[1];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  return out;
}
function random3(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r) * scale8;
  out[1] = Math.sin(r) * scale8;
  return out;
}
function transformMat2(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
function transformMat2d(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
function transformMat32(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
function rotate(out, a, b, rad) {
  var p0 = a[0] - b[0], p1 = a[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
function angle2(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str3(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1];
  var b0 = b[0], b1 = b[1];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
}
var len3 = length4;
var sub2 = subtract2;
var mul3 = multiply3;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var sqrLen3 = squaredLength4;
var forEach3 = function() {
  var vec = create6();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/math.ts
var Pi = Math.PI;
var HalfPi = 0.5 * Pi;
var Tau = 2 * Pi;
var TIME_MAX = 864e13;
var TIME_MIN = -TIME_MAX;
function radiansClamp(radians) {
  return (radians % Tau + Tau) % Tau;
}
function clamp(v, min5, max5) {
  return Math.min(max5, Math.max(min5, v));
}
function deg2rad(degrees) {
  return degrees * Tau / 360;
}
function rad2deg(radians) {
  return radians * 360 / Tau;
}
function minly(...numbers) {
  let min5 = Number.MAX_VALUE;
  for (const n2 of numbers) {
    if (Math.abs(n2) < min5) {
      min5 = n2;
    }
  }
  return min5;
}
function project(v, min5, max5) {
  const delta3 = max5 - min5;
  if (delta3 === 0) {
    return 0;
  } else {
    return (v - min5) / delta3;
  }
}
function unproject(v, min5, max5) {
  return v * (max5 - min5) + min5;
}
function formatNumber(value2, digits = 0) {
  if (isNumber(value2)) {
    return value2.toFixed(digits);
  } else {
    return "";
  }
}
function parseNumber(value2) {
  if (/\d+/.test(value2)) {
    return parseFloat(value2);
  } else {
    return null;
  }
}
function formatVolume(value2) {
  if (isNumber(value2)) {
    return clamp(unproject(value2, 0, 100), 0, 100).toFixed(0);
  } else {
    return "";
  }
}
function parseVolume(value2) {
  if (/\d+/.test(value2)) {
    return clamp(project(parseInt(value2, 10), 0, 100), 0, 1);
  } else {
    return null;
  }
}
function lerp5(a, b, p) {
  return (1 - p) * a + p * b;
}
function nextPowerOf2(v) {
  return Math.pow(2, Math.ceil(Math.log2(v)));
}
function truncate(v) {
  if (Math.abs(v) > 1e-4) {
    return v;
  }
  return 0;
}

// global-externals:three
var { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveAnimationBlendMode, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio: Audio3, AudioAnalyser, AudioContext: AudioContext2, AudioListener: AudioListener2, AudioLoader, AxesHelper, BackSide, BasicDepthPacking, BasicShadowMap, Bone, BooleanKeyframeTrack, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasTexture, CapsuleBufferGeometry, CapsuleGeometry, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, Color, ColorKeyframeTrack, ColorManagement, CompressedArrayTexture, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CustomToneMapping, CylinderBufferGeometry, CylinderGeometry, Cylindrical, Data3DTexture, DataArrayTexture, DataTexture, DataTextureLoader, DataUtils, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DiscreteInterpolant, DisplayP3ColorSpace, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, FileLoader, Float16BufferAttribute, Float32BufferAttribute, Float64BufferAttribute, FloatType, Fog, FogExp2, FramebufferTexture, FrontSide, Frustum, GLBufferAttribute, GLSL1, GLSL3, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16BufferAttribute, Int32BufferAttribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LineSegments, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearSRGBColorSpace, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColorSpace, NoToneMapping, NormalAnimationBlendMode, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, RED_GREEN_RGTC2_Format, RED_RGTC1_Format, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_BPTC_Format, RGBA_ETC2_EAC_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, SIGNED_RED_GREEN_RGTC2_Format, SIGNED_RED_RGTC1_Format, SRGBColorSpace, Scene, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, Source, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SplineCurve, SpotLight, SpotLightHelper, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, TwoPassDoubleSide, UVMapping, Uint16BufferAttribute, Uint32BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Uniform, UniformsGroup, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, VideoTexture, WebGL1Renderer, WebGL3DRenderTarget, WebGLArrayRenderTarget, WebGLCubeRenderTarget, WebGLMultipleRenderTargets, WebGLRenderTarget, WebGLRenderer, WebGLUtils, WireframeGeometry, WrapAroundEnding, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, _SRGBAFormat, sRGBEncoding } = THREE;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Cone.ts
var geom = /* @__PURE__ */ new ConeGeometry(1, 1, 10, 5);
geom.name = "ConeGeom";
geom.computeBoundingBox();
geom.computeBoundingSphere();
var Cone = class extends Mesh {
  constructor(sx, sy, sz, material) {
    super(geom, material);
    this.scale.set(sx, sy, sz);
  }
};
function cone(name3, sx, sy, sz, material) {
  const c = new Cone(sx, sy, sz, material);
  c.name = name3;
  return c;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/setGeometryUVsForCubemaps.ts
function setGeometryUVsForCubemaps(geom4) {
  const positions = geom4.attributes.position;
  const normals = geom4.attributes.normal;
  const uvs = geom4.attributes.uv;
  for (let n2 = 0; n2 < normals.count; ++n2) {
    const _x = n2 * normals.itemSize, _y = n2 * normals.itemSize + 1, _z = n2 * normals.itemSize + 2, nx = normals.array[_x], ny = normals.array[_y], nz = normals.array[_z], _nx_ = Math.abs(nx), _ny_ = Math.abs(ny), _nz_ = Math.abs(nz), px2 = positions.array[_x], py = positions.array[_y], pz = positions.array[_z], _px_ = Math.abs(px2), _py_ = Math.abs(py), _pz_ = Math.abs(pz), _u = n2 * uvs.itemSize, _v = n2 * uvs.itemSize + 1;
    let u2 = uvs.array[_u], v = uvs.array[_v], largest = 0, mx = _nx_, max5 = _px_;
    if (_ny_ > mx) {
      largest = 1;
      mx = _ny_;
      max5 = _py_;
    }
    if (_nz_ > mx) {
      largest = 2;
      mx = _nz_;
      max5 = _pz_;
    }
    if (largest === 0) {
      if (px2 < 0) {
        u2 = -pz;
        v = py;
      } else {
        u2 = pz;
        v = py;
      }
    } else if (largest === 1) {
      if (py < 0) {
        u2 = px2;
        v = -pz;
      } else {
        u2 = px2;
        v = pz;
      }
    } else {
      if (pz < 0) {
        u2 = px2;
        v = py;
      } else {
        u2 = -px2;
        v = py;
      }
    }
    u2 = (u2 / max5 + 1) / 8;
    v = (v / max5 + 1) / 6;
    if (largest === 0) {
      if (px2 < 0) {
        u2 += 0;
        v += 1 / 3;
      } else {
        u2 += 0.5;
        v += 1 / 3;
      }
    } else if (largest === 1) {
      if (py < 0) {
        u2 += 0.25;
        v += 0;
      } else {
        u2 += 0.25;
        v += 2 / 3;
      }
    } else {
      if (pz < 0) {
        u2 += 0.25;
        v += 1 / 3;
      } else {
        u2 += 0.75;
        v += 1 / 3;
      }
    }
    const arr = uvs.array;
    arr[_u] = u2;
    arr[_v] = v;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Cube.ts
var cubeGeom = /* @__PURE__ */ new BoxGeometry(1, 1, 1, 1, 1, 1);
cubeGeom.name = "CubeGeom";
cubeGeom.computeBoundingBox();
cubeGeom.computeBoundingSphere();
var invCubeGeom = /* @__PURE__ */ cubeGeom.clone();
invCubeGeom.name = "InvertedCubeGeom";
setGeometryUVsForCubemaps(invCubeGeom);
var Cube = class extends Mesh {
  constructor(sx, sy, sz, material) {
    super(cubeGeom, material);
    this.scale.set(sx, sy, sz);
  }
};
function cube(name3, sx, sy, sz, material) {
  const c = new Cube(sx, sy, sz, material);
  c.name = name3;
  return c;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/typeChecks.ts
function isMesh(obj2) {
  return isDefined(obj2) && obj2.isMesh;
}
function isMaterial(obj2) {
  return isDefined(obj2) && obj2.isMaterial;
}
function isNamedMaterial(name3, obj2) {
  return isMaterial(obj2) && obj2.type === name3;
}
function isMeshBasicMaterial(obj2) {
  return isNamedMaterial("MeshBasicMaterial", obj2);
}
function isMeshStandardMaterial(obj2) {
  return isNamedMaterial("MeshStandardMaterial", obj2);
}
function isMeshPhongMaterial(obj2) {
  return isNamedMaterial("MeshPhongMaterial", obj2);
}
function isMeshPhysicalMaterial(obj2) {
  return isNamedMaterial("MeshPhysicalMaterial", obj2);
}
function isObject3D(obj2) {
  return isDefined(obj2) && obj2.isObject3D;
}
function isQuaternion(obj2) {
  return isDefined(obj2) && obj2.isQuaternion;
}
function isEuler(obj2) {
  return isDefined(obj2) && obj2.isEuler;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/objects.ts
function isErsatzObject(obj2) {
  return isDefined(obj2) && isObject3D(obj2.object);
}
function isObjects(obj2) {
  return isErsatzObject(obj2) || isObject3D(obj2);
}
function objectResolve(obj2) {
  if (isErsatzObject(obj2)) {
    return obj2.object;
  }
  return obj2;
}
function objectSetVisible(obj2, visible) {
  obj2 = objectResolve(obj2);
  obj2.visible = visible;
  return visible;
}
function objectIsVisible(obj2) {
  obj2 = objectResolve(obj2);
  return obj2.visible;
}
function objectIsFullyVisible(obj2) {
  if (!obj2) {
    return false;
  }
  obj2 = objectResolve(obj2);
  while (obj2) {
    if (!obj2.visible) {
      return false;
    }
    obj2 = obj2.parent;
  }
  return true;
}
function objGraph(obj2, ...children) {
  const toAdd = children.filter(isDefined).map(objectResolve);
  if (toAdd.length > 0) {
    objectResolve(obj2).add(...toAdd);
  }
  return obj2;
}
function objRemoveFromParent(obj2) {
  obj2 = objectResolve(obj2);
  if (isDefined(obj2)) {
    obj2.removeFromParent();
  }
}
function obj(name3, ...rest) {
  const obj2 = new Object3D();
  obj2.name = name3;
  objGraph(obj2, ...rest);
  return obj2;
}
function objectSetEnabled(obj2, enabled) {
  obj2 = objectResolve(obj2);
  if (isDisableable(obj2)) {
    obj2.disabled = !enabled;
  }
}
function objectSetWorldPosition(obj2, pos) {
  obj2 = objectResolve(obj2);
  const parent = obj2.parent;
  obj2.removeFromParent();
  obj2.position.copy(pos);
  if (isDefined(parent)) {
    parent.attach(obj2);
  }
}
function mesh(name3, geom4, mat) {
  const mesh2 = new Mesh(geom4, mat);
  mesh2.name = name3;
  return mesh2;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/RayTarget.ts
var RAY_TARGET_KEY = "Juniper:ThreeJS:EventSystem:RayTarget";
var RayTarget = class extends TypedEventBase {
  constructor(object) {
    super();
    this.object = object;
    this.meshes = new Array();
    this._disabled = false;
    this._clickable = false;
    this._draggable = false;
    this._navigable = false;
    this.object.userData[RAY_TARGET_KEY] = this;
  }
  addMesh(mesh2) {
    mesh2.userData[RAY_TARGET_KEY] = this;
    this.meshes.push(mesh2);
    return this;
  }
  removeMesh(mesh2) {
    if (arrayRemove(this.meshes, mesh2)) {
      delete mesh2.userData[RAY_TARGET_KEY];
    }
    return this;
  }
  addMeshes(...meshes) {
    for (const mesh2 of meshes) {
      this.addMesh(mesh2);
    }
    return this;
  }
  removeMeshes(...meshes) {
    for (const mesh2 of meshes) {
      this.removeMesh(mesh2);
    }
    return this;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    this._disabled = v;
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  get clickable() {
    return this._clickable;
  }
  set clickable(v) {
    this._clickable = v;
  }
  get draggable() {
    return this._draggable;
  }
  set draggable(v) {
    this._draggable = v;
  }
  get navigable() {
    return this._navigable;
  }
  set navigable(v) {
    this._navigable = v;
  }
};
function isRayTarget(obj2) {
  return obj2 instanceof RayTarget;
}
function getRayTarget(obj2) {
  let target = null;
  if (obj2) {
    if (isRayTarget(obj2)) {
      target = obj2;
    } else {
      obj2 = objectResolve(obj2);
      if (obj2) {
        target = obj2.userData[RAY_TARGET_KEY];
      }
    }
    if (target && !objectIsFullyVisible(target)) {
      target = null;
    }
  }
  return target;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    Object.defineProperties(this, {
      color: {
        enumerable: true,
        get: function() {
          return this.uniforms.diffuse.value;
        },
        set: function(value2) {
          this.uniforms.diffuse.value = value2;
        }
      },
      worldUnits: {
        enumerable: true,
        get: function() {
          return "WORLD_UNITS" in this.defines;
        },
        set: function(value2) {
          if (value2 === true) {
            this.defines.WORLD_UNITS = "";
          } else {
            delete this.defines.WORLD_UNITS;
          }
        }
      },
      linewidth: {
        enumerable: true,
        get: function() {
          return this.uniforms.linewidth.value;
        },
        set: function(value2) {
          this.uniforms.linewidth.value = value2;
        }
      },
      dashed: {
        enumerable: true,
        get: function() {
          return Boolean("USE_DASH" in this.defines);
        },
        set(value2) {
          if (Boolean(value2) !== Boolean("USE_DASH" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value2 === true) {
            this.defines.USE_DASH = "";
          } else {
            delete this.defines.USE_DASH;
          }
        }
      },
      dashScale: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashScale.value;
        },
        set: function(value2) {
          this.uniforms.dashScale.value = value2;
        }
      },
      dashSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashSize.value;
        },
        set: function(value2) {
          this.uniforms.dashSize.value = value2;
        }
      },
      dashOffset: {
        enumerable: true,
        get: function() {
          return this.uniforms.dashOffset.value;
        },
        set: function(value2) {
          this.uniforms.dashOffset.value = value2;
        }
      },
      gapSize: {
        enumerable: true,
        get: function() {
          return this.uniforms.gapSize.value;
        },
        set: function(value2) {
          this.uniforms.gapSize.value = value2;
        }
      },
      opacity: {
        enumerable: true,
        get: function() {
          return this.uniforms.opacity.value;
        },
        set: function(value2) {
          this.uniforms.opacity.value = value2;
        }
      },
      resolution: {
        enumerable: true,
        get: function() {
          return this.uniforms.resolution.value;
        },
        set: function(value2) {
          this.uniforms.resolution.value.copy(value2);
        }
      },
      alphaToCoverage: {
        enumerable: true,
        get: function() {
          return Boolean("USE_ALPHA_TO_COVERAGE" in this.defines);
        },
        set: function(value2) {
          if (Boolean(value2) !== Boolean("USE_ALPHA_TO_COVERAGE" in this.defines)) {
            this.needsUpdate = true;
          }
          if (value2 === true) {
            this.defines.USE_ALPHA_TO_COVERAGE = "";
            this.extensions.derivatives = true;
          } else {
            delete this.defines.USE_ALPHA_TO_COVERAGE;
            this.extensions.derivatives = false;
          }
        }
      }
    });
    this.setValues(parameters);
  }
};
LineMaterial.prototype.isLineMaterial = true;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/materials.ts
var materials = singleton("Juniper:Three:Materials", () => /* @__PURE__ */ new Map());
function del(obj2, name3) {
  if (name3 in obj2) {
    delete obj2[name3];
  }
}
function makeMaterial(slug, material, options) {
  const key = `${slug}_${Object.keys(options).map((k) => `${k}:${options[k]}`).join(",")}`;
  if (!materials.has(key)) {
    del(options, "name");
    materials.set(key, new material(options));
  }
  return materials.get(key);
}
function trans(options) {
  return Object.assign(options, {
    transparent: true
  });
}
function solid(options) {
  return makeMaterial("solid", MeshBasicMaterial, options);
}
function solidTransparent(options) {
  return makeMaterial("solidTransparent", MeshBasicMaterial, trans(options));
}
function lit(options) {
  return makeMaterial("lit", MeshPhongMaterial, options);
}
function litTransparent(options) {
  return makeMaterial("litTransparent", MeshPhongMaterial, trans(options));
}
function line2(options) {
  return makeMaterial("line2", LineMaterial, options);
}
function convertMaterials(root, convertMaterial) {
  const oldMats = /* @__PURE__ */ new Set();
  root.traverse((obj2) => {
    if (isMesh(obj2) && isMaterial(obj2.material)) {
      const oldMat = obj2.material;
      const newMat = convertMaterial(oldMat);
      if (oldMat !== newMat) {
        oldMats.add(oldMat);
        obj2.material = newMat;
      }
    }
  });
  for (const oldMat of oldMats) {
    dispose2(oldMat);
  }
}
function materialStandardToBasic(oldMat) {
  if (oldMat.type !== "MeshStandardMaterial") {
    throw new Error("Input material is not MeshStandardMaterial");
  }
  const params = {
    alphaMap: oldMat.alphaMap,
    alphaTest: oldMat.alphaTest,
    alphaToCoverage: oldMat.alphaToCoverage,
    aoMap: oldMat.aoMap,
    aoMapIntensity: oldMat.aoMapIntensity,
    blendDst: oldMat.blendDst,
    blendDstAlpha: oldMat.blendDstAlpha,
    blendEquation: oldMat.blendEquation,
    blendEquationAlpha: oldMat.blendEquationAlpha,
    blending: oldMat.blending,
    blendSrc: oldMat.blendSrc,
    blendSrcAlpha: oldMat.blendSrcAlpha,
    clipIntersection: oldMat.clipIntersection,
    clippingPlanes: oldMat.clippingPlanes,
    clipShadows: oldMat.clipShadows,
    color: oldMat.color,
    colorWrite: oldMat.colorWrite,
    depthFunc: oldMat.depthFunc,
    depthTest: oldMat.depthTest,
    depthWrite: oldMat.depthWrite,
    dithering: oldMat.dithering,
    envMap: oldMat.envMap,
    fog: oldMat.fog,
    lightMap: oldMat.lightMap,
    lightMapIntensity: oldMat.lightMapIntensity,
    map: oldMat.emissiveMap || oldMat.map,
    name: oldMat.name + "-Standard-To-Basic",
    opacity: oldMat.opacity,
    polygonOffset: oldMat.polygonOffset,
    polygonOffsetFactor: oldMat.polygonOffsetFactor,
    polygonOffsetUnits: oldMat.polygonOffsetUnits,
    precision: oldMat.precision,
    premultipliedAlpha: oldMat.premultipliedAlpha,
    shadowSide: oldMat.shadowSide,
    side: oldMat.side,
    stencilFail: oldMat.stencilFail,
    stencilFunc: oldMat.stencilFunc,
    stencilFuncMask: oldMat.stencilFuncMask,
    stencilRef: oldMat.stencilRef,
    stencilWrite: oldMat.stencilWrite,
    stencilWriteMask: oldMat.stencilWriteMask,
    stencilZFail: oldMat.stencilZFail,
    stencilZPass: oldMat.stencilZPass,
    toneMapped: oldMat.toneMapped,
    transparent: oldMat.transparent,
    userData: oldMat.userData,
    vertexColors: oldMat.vertexColors,
    visible: oldMat.visible,
    wireframe: oldMat.wireframe,
    wireframeLinecap: oldMat.wireframeLinecap,
    wireframeLinejoin: oldMat.wireframeLinejoin,
    wireframeLinewidth: oldMat.wireframeLinewidth
  };
  for (const [key, value2] of Object.entries(params)) {
    if (isNullOrUndefined(value2)) {
      delete params[key];
    }
  }
  return new MeshBasicMaterial(params);
}
function materialStandardToPhong(oldMat) {
  if (oldMat.type !== "MeshStandardMaterial") {
    throw new Error("Input material is not MeshStandardMaterial");
  }
  const params = {
    alphaMap: oldMat.alphaMap,
    alphaTest: oldMat.alphaTest,
    alphaToCoverage: oldMat.alphaToCoverage,
    aoMap: oldMat.aoMap,
    aoMapIntensity: oldMat.aoMapIntensity,
    blendDst: oldMat.blendDst,
    blendDstAlpha: oldMat.blendDstAlpha,
    blendEquation: oldMat.blendEquation,
    blendEquationAlpha: oldMat.blendEquationAlpha,
    blending: oldMat.blending,
    blendSrc: oldMat.blendSrc,
    blendSrcAlpha: oldMat.blendSrcAlpha,
    bumpMap: oldMat.bumpMap,
    bumpScale: oldMat.bumpScale,
    clipIntersection: oldMat.clipIntersection,
    clippingPlanes: oldMat.clippingPlanes,
    clipShadows: oldMat.clipShadows,
    color: oldMat.color,
    colorWrite: oldMat.colorWrite,
    depthFunc: oldMat.depthFunc,
    depthTest: oldMat.depthTest,
    depthWrite: oldMat.depthWrite,
    displacementBias: oldMat.displacementBias,
    displacementMap: oldMat.displacementMap,
    displacementScale: oldMat.displacementScale,
    dithering: oldMat.dithering,
    emissive: oldMat.emissive,
    emissiveIntensity: oldMat.emissiveIntensity,
    emissiveMap: oldMat.emissiveMap,
    envMap: oldMat.envMap,
    flatShading: oldMat.flatShading,
    fog: oldMat.fog,
    lightMap: oldMat.lightMap,
    lightMapIntensity: oldMat.lightMapIntensity,
    map: oldMat.map,
    name: oldMat.name + "-Standard-To-Phong",
    normalMap: oldMat.normalMap,
    normalMapType: oldMat.normalMapType,
    normalScale: oldMat.normalScale,
    opacity: oldMat.opacity,
    polygonOffset: oldMat.polygonOffset,
    polygonOffsetFactor: oldMat.polygonOffsetFactor,
    polygonOffsetUnits: oldMat.polygonOffsetUnits,
    precision: oldMat.precision,
    premultipliedAlpha: oldMat.premultipliedAlpha,
    shadowSide: oldMat.shadowSide,
    side: oldMat.side,
    stencilFail: oldMat.stencilFail,
    stencilFunc: oldMat.stencilFunc,
    stencilFuncMask: oldMat.stencilFuncMask,
    stencilRef: oldMat.stencilRef,
    stencilWrite: oldMat.stencilWrite,
    stencilWriteMask: oldMat.stencilWriteMask,
    stencilZFail: oldMat.stencilZFail,
    stencilZPass: oldMat.stencilZPass,
    toneMapped: oldMat.toneMapped,
    transparent: oldMat.transparent,
    userData: oldMat.userData,
    vertexColors: oldMat.vertexColors,
    visible: oldMat.visible,
    wireframe: oldMat.wireframe,
    wireframeLinecap: oldMat.wireframeLinecap,
    wireframeLinejoin: oldMat.wireframeLinejoin,
    wireframeLinewidth: oldMat.wireframeLinewidth
  };
  for (const [key, value2] of Object.entries(params)) {
    if (isNullOrUndefined(value2)) {
      delete params[key];
    }
  }
  return new MeshPhongMaterial(params);
}
function materialPhysicalToPhong(oldMat) {
  if (oldMat.type !== "MeshPhysicalMaterial") {
    throw new Error("Input material is not MeshPhysicalMaterial");
  }
  const params = {
    alphaMap: oldMat.alphaMap,
    alphaTest: oldMat.alphaTest,
    alphaToCoverage: oldMat.alphaToCoverage,
    aoMap: oldMat.aoMap,
    aoMapIntensity: oldMat.aoMapIntensity,
    blendDst: oldMat.blendDst,
    blendDstAlpha: oldMat.blendDstAlpha,
    blendEquation: oldMat.blendEquation,
    blendEquationAlpha: oldMat.blendEquationAlpha,
    blending: oldMat.blending,
    blendSrc: oldMat.blendSrc,
    blendSrcAlpha: oldMat.blendSrcAlpha,
    bumpMap: oldMat.bumpMap,
    bumpScale: oldMat.bumpScale,
    clipIntersection: oldMat.clipIntersection,
    clippingPlanes: oldMat.clippingPlanes,
    clipShadows: oldMat.clipShadows,
    color: oldMat.color,
    colorWrite: oldMat.colorWrite,
    depthFunc: oldMat.depthFunc,
    depthTest: oldMat.depthTest,
    depthWrite: oldMat.depthWrite,
    displacementBias: oldMat.displacementBias,
    displacementMap: oldMat.displacementMap,
    displacementScale: oldMat.displacementScale,
    dithering: oldMat.dithering,
    emissive: oldMat.emissive,
    emissiveIntensity: oldMat.emissiveIntensity,
    emissiveMap: oldMat.emissiveMap,
    envMap: oldMat.envMap,
    flatShading: oldMat.flatShading,
    fog: oldMat.fog,
    lightMap: oldMat.lightMap,
    lightMapIntensity: oldMat.lightMapIntensity,
    map: oldMat.map,
    name: oldMat.name + "-Standard-To-Phong",
    normalMap: oldMat.normalMap,
    normalMapType: oldMat.normalMapType,
    normalScale: oldMat.normalScale,
    opacity: oldMat.opacity,
    polygonOffset: oldMat.polygonOffset,
    polygonOffsetFactor: oldMat.polygonOffsetFactor,
    polygonOffsetUnits: oldMat.polygonOffsetUnits,
    precision: oldMat.precision,
    premultipliedAlpha: oldMat.premultipliedAlpha,
    reflectivity: oldMat.reflectivity,
    shadowSide: oldMat.shadowSide,
    shininess: oldMat.sheen,
    side: oldMat.side,
    specular: oldMat.specularColor,
    specularMap: oldMat.specularColorMap,
    stencilFail: oldMat.stencilFail,
    stencilFunc: oldMat.stencilFunc,
    stencilFuncMask: oldMat.stencilFuncMask,
    stencilRef: oldMat.stencilRef,
    stencilWrite: oldMat.stencilWrite,
    stencilWriteMask: oldMat.stencilWriteMask,
    stencilZFail: oldMat.stencilZFail,
    stencilZPass: oldMat.stencilZPass,
    toneMapped: oldMat.toneMapped,
    transparent: oldMat.transparent,
    userData: oldMat.userData,
    vertexColors: oldMat.vertexColors,
    visible: oldMat.visible,
    wireframe: oldMat.wireframe,
    wireframeLinecap: oldMat.wireframeLinecap,
    wireframeLinejoin: oldMat.wireframeLinejoin,
    wireframeLinewidth: oldMat.wireframeLinewidth
  };
  for (const [key, value2] of Object.entries(params)) {
    if (isNullOrUndefined(value2)) {
      delete params[key];
    }
  }
  return new MeshPhongMaterial(params);
}
var blue = 255;
var green = 65280;
var red = 16711680;
var grey = 12632256;
var white = 16777215;
var solidWhite = /* @__PURE__ */ solid({ color: white });
var litGrey = /* @__PURE__ */ lit({ color: grey });
var litWhite = /* @__PURE__ */ lit({ color: white });

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Sphere.ts
var geom2 = /* @__PURE__ */ new SphereGeometry(0.5);
geom2.name = "SphereGeom";
geom2.computeBoundingBox();
geom2.computeBoundingSphere();
var invSphere = /* @__PURE__ */ geom2.clone();
invSphere.name = "InvertedSphereGeom";
setGeometryUVsForCubemaps(invSphere);
var Sphere2 = class extends Mesh {
  constructor(size4, material) {
    super(geom2, material);
    this.scale.setScalar(0.5 * size4);
  }
};
function sphere(name3, size4, material) {
  const s = new Sphere2(size4, material);
  s.name = name3;
  return s;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/TransformEditor.ts
var orderedTransformModes = [
  "View Rotate" /* RotateViewSpace */,
  "View Move" /* MoveViewSpace */,
  "Resize" /* Resize */,
  "Orbit" /* Orbit */,
  "Object Rotate" /* RotateObjectSpace */,
  "Object Move" /* MoveObjectSpace */,
  "Global Rotate" /* RotateGlobalSpace */,
  "Global Move" /* MoveGlobalSpace */
];
var Axes = ["x", "y", "z"];
var size = 0.1;
var correction = /* @__PURE__ */ new Map([
  [1, new Quaternion().setFromEuler(new Euler(0, -HalfPi, 0))],
  [-1, new Quaternion().setFromEuler(new Euler(0, HalfPi, 0))]
]);
var TransformEditor = class extends TypedEventBase {
  constructor(env) {
    super();
    this.env = env;
    this.buttons = /* @__PURE__ */ new Map();
    this.movingEvt = new TypedEvent("moving");
    this.movedEvt = new TypedEvent("moved");
    this.dragging = false;
    this.rotationAxisWorld = new Vector3();
    this.startWorld = new Vector3();
    this.endWorld = new Vector3();
    this.startLocal = new Vector3();
    this.endLocal = new Vector3();
    this.lookDirectionWorld = new Vector3();
    this.deltaPosition = new Vector3();
    this.deltaQuaternion = new Quaternion();
    this.motionAxisWorld = new Vector3();
    this.testObj = new Object3D();
    this._mode = null;
    this._target = null;
    this.modes = new Array();
    this.prioritizeTransformerSort = (a, b) => {
      const rayTargetA = getRayTarget(a);
      const rayTargetB = getRayTarget(b);
      const isTranslatorA = isDefined(rayTargetA) && this.translators.indexOf(rayTargetA) >= 0;
      const isTranslatorB = isDefined(rayTargetB) && this.translators.indexOf(rayTargetB) >= 0;
      if (isTranslatorA === isTranslatorB) {
        return a.distance - b.distance;
      } else if (isTranslatorA) {
        return -1;
      } else {
        return 1;
      }
    };
    this.object = obj(
      "Translator",
      ...this.translators = [
        this.setTranslator("x", "x", red),
        this.setTranslator("y", "y", green),
        this.setTranslator("z", "x", blue)
      ]
    );
    objectSetVisible(this, false);
    env.timer.addTickHandler(() => this.refresh());
    this.modeButtons = orderedTransformModes.map((mode) => {
      const btn = ButtonSecondary(
        mode,
        onClick(() => this.mode = btn.classList.contains("btn-secondary") ? mode : "None" /* None */)
      );
      this.buttons.set(mode, btn);
      elementSetDisplay(btn, false);
      return btn;
    });
  }
  get target() {
    return this._target;
  }
  setTarget(v, modes) {
    v = objectResolve(v);
    if (v !== this.target) {
      this._target = v;
      const hasTarget = isDefined(this.target);
      objectSetVisible(this, hasTarget);
      this.refresh();
    }
    if (isDefined(v) && isDefined(modes)) {
      arrayReplace(this.modes, ...modes);
      for (const [mode, btn] of this.buttons) {
        elementSetDisplay(btn, this.modes.indexOf(mode) !== -1);
      }
      if (this.modes.indexOf(this.mode) === -1) {
        this.mode = "None" /* None */;
      }
    }
  }
  get mode() {
    return this._mode;
  }
  set mode(v) {
    if (v !== this.mode) {
      this._mode = v;
      if (this.mode === "None") {
        this.env.eventSys.sortFunction = null;
      } else {
        this.env.eventSys.sortFunction = this.prioritizeTransformerSort;
      }
      for (const translator of this.translators) {
        translator.mode = v;
      }
      this.translators[2].object.visible = this.mode !== "None" /* None */ && this.mode !== "Resize" /* Resize */;
      for (const [mode, btn] of this.buttons) {
        elementSetClass(btn, mode === this.mode, "btn-primary");
        elementSetClass(btn, mode !== this.mode, "btn-secondary");
      }
      this.refresh();
    }
  }
  setTranslator(motionAxis, interactionAxis, color2) {
    const translator = new Translator(motionAxis, interactionAxis, color2);
    translator.addEventListener("down", (evt) => {
      if (evt.pointer.isPressed(0 /* Primary */)) {
        this.dragging = true;
        this.startWorld.copy(evt.point);
        if (this.mode !== "Object Move" /* MoveObjectSpace */ && this.mode !== "Global Move" /* MoveGlobalSpace */ && this.mode !== "View Move" /* MoveViewSpace */ && this.mode !== "Orbit" /* Orbit */) {
          this.env.avatar.lockMovement = true;
        }
        if (isDefined(evt.hit)) {
          translator.selected = evt.hit.object;
        } else {
          translator.selected = null;
        }
      }
    });
    translator.addEventListener("move", (evt) => {
      if (this.dragging && evt.point) {
        this.endWorld.copy(evt.point);
        if (this.startWorld.manhattanDistanceTo(this.endWorld) > 0) {
          this.object.worldToLocal(this.startLocal.copy(this.startWorld));
          this.object.worldToLocal(this.endLocal.copy(this.endWorld));
          if (this.mode === "Resize" /* Resize */) {
            const startDist = this.startLocal.length();
            const endDist = this.endLocal.length();
            this.target.scale.addScalar(endDist - startDist);
          } else if (this.mode === "Object Rotate" /* RotateObjectSpace */ || this.mode === "Global Rotate" /* RotateGlobalSpace */ || this.mode === "View Rotate" /* RotateViewSpace */) {
            this.startLocal.normalize();
            this.endLocal.normalize();
            const mag = this.startLocal.dot(this.endLocal);
            if (-1 <= mag && mag <= 1) {
              const sign = this.startLocal.cross(this.endLocal).dot(translator.rotationAxisLocal);
              const radians = Math.sign(sign) * Math.acos(mag);
              this.rotationAxisWorld.copy(translator.rotationAxisLocal).applyQuaternion(this.object.quaternion);
              this.deltaQuaternion.setFromAxisAngle(this.rotationAxisWorld, radians);
              this.target.quaternion.premultiply(this.deltaQuaternion);
            }
          } else {
            this.motionAxisWorld.copy(translator.motionAxisLocal).applyQuaternion(this.object.quaternion);
            this.lookDirectionWorld.copy(this.env.avatar.worldPos).sub(this.object.position).normalize();
            this.deltaPosition.copy(this.endWorld).sub(this.startWorld);
            const parallelity = this.lookDirectionWorld.dot(this.motionAxisWorld);
            if (Math.abs(parallelity) > 0.7) {
              const side = Math.abs(parallelity) < 0.98 && Math.sign(this.lookDirectionWorld.cross(this.motionAxisWorld).y) || 1;
              this.deltaPosition.applyQuaternion(correction.get(Math.sign(parallelity) * side));
            }
            const mag = this.size * this.deltaPosition.dot(this.motionAxisWorld);
            this.deltaPosition.copy(this.motionAxisWorld).multiplyScalar(mag);
            if (this.mode === "Orbit" /* Orbit */) {
              this.target.parent.add(this.testObj);
              this.testObj.position.copy(this.target.position);
              this.testObj.lookAt(this.env.avatar.worldPos);
              this.testObj.attach(this.target);
              this.testObj.position.add(this.deltaPosition);
              this.testObj.lookAt(this.env.avatar.worldPos);
              this.testObj.parent.attach(this.target);
              this.testObj.removeFromParent();
            } else {
              this.target.position.add(this.deltaPosition);
            }
          }
          this.refresh();
          this.dispatchEvent(this.movingEvt);
        }
        this.startWorld.copy(this.endWorld);
      }
    });
    translator.addEventListener("up", (evt) => {
      if (!evt.pointer.isPressed(0 /* Primary */)) {
        this.dragging = false;
        if (this.mode !== "Object Move" /* MoveObjectSpace */ && this.mode !== "Global Move" /* MoveGlobalSpace */ && this.mode !== "View Move" /* MoveViewSpace */ && this.mode !== "Orbit" /* Orbit */) {
          this.env.avatar.lockMovement = false;
        }
        translator.selected = null;
        this.dispatchEvent(this.movedEvt);
      }
    });
    return translator;
  }
  get size() {
    return this.object.scale.x;
  }
  set size(v) {
    this.object.scale.setScalar(v);
  }
  refresh() {
    if (this.target) {
      this.target.getWorldPosition(this.object.position);
      const dist4 = this.object.position.distanceTo(this.env.avatar.worldPos);
      this.size = 0.5 * dist4;
      if (this.mode === "Object Move" /* MoveObjectSpace */ || this.mode === "Object Rotate" /* RotateObjectSpace */) {
        this.target.getWorldQuaternion(this.object.quaternion);
      } else if (this.mode === "Global Rotate" /* RotateGlobalSpace */ || this.mode === "Global Move" /* MoveGlobalSpace */) {
        this.object.quaternion.identity();
      } else {
        this.object.lookAt(this.env.avatar.worldPos);
      }
      for (const translator of this.translators) {
        translator.refresh(this.object.position, this.env.avatar.worldPos);
      }
    }
  }
};
var arcPointsForward = new Array();
var arcPointsBack = new Array();
for (let a = 5; a <= 85; a += 5) {
  const rad = deg2rad(a);
  arcPointsForward.push(new Vector2(0.5 * Math.cos(rad), 0.5 * Math.sin(rad)));
  arcPointsBack.unshift(new Vector2(0.48 * Math.cos(rad), 0.48 * Math.sin(rad)));
}
var arcPoints = [...arcPointsForward, ...arcPointsBack];
var arcShape = new Shape(arcPoints);
var arcGeom = new ExtrudeGeometry(arcShape, {
  steps: 1,
  depth: 0.02,
  bevelEnabled: false
});
arcGeom.computeBoundingBox();
arcGeom.computeBoundingSphere();
var _Translator = class extends RayTarget {
  constructor(motionAxis, interactionAxis, color2) {
    const axisIndex = Axes.indexOf(motionAxis);
    const rotationAxisIndex = (axisIndex + 2) % Axes.length;
    const rotationAxis = Axes[rotationAxisIndex];
    const ringAxisIndex = Axes.length - axisIndex - 1;
    const ringAxis = Axes[ringAxisIndex];
    const materialFront = litTransparent({
      color: color2,
      depthTest: false,
      opacity: 0.75
    });
    const materialBack = litTransparent({
      color: color2,
      depthTest: false,
      opacity: 0.25
    });
    const materialSelected = litTransparent({
      color: color2,
      depthTest: false,
      opacity: 1
    });
    const bars = [
      cube(`Bar_${motionAxis}1`, 1, 1, 1, materialFront),
      cube(`Bar_${motionAxis}1`, 1, 1, 1, materialFront)
    ];
    const spherePads = [
      sphere(`ScalePad_${motionAxis}1`, 1, materialFront),
      sphere(`ScalePad_${motionAxis}2`, 1, materialFront)
    ];
    const conePads = [
      cone(`TranslatePad_${motionAxis}1`, 1, 1, 1, materialFront),
      cone(`TranslatePad_${motionAxis}2`, 1, 1, 1, materialFront)
    ];
    const arcPads = [
      mesh(`RotatePad_${motionAxis}1`, arcGeom, materialFront),
      mesh(`RotatePad_${motionAxis}2`, arcGeom, materialFront),
      mesh(`RotatePad_${motionAxis}3`, arcGeom, materialFront),
      mesh(`RotatePad_${motionAxis}4`, arcGeom, materialFront)
    ];
    super(obj(
      `Transformer_${motionAxis}`,
      ...bars,
      ...spherePads,
      ...conePads,
      ...arcPads
    ));
    this.worldPos = new Vector3();
    this.worldQuat = new Quaternion();
    this.center = new Vector3();
    this.interactionAxisLocal = new Vector3();
    this.motionAxisLocal = new Vector3();
    this.rotationAxisLocal = new Vector3();
    this._mode = null;
    this.selected = null;
    this.delta = new Vector3();
    for (const obj2 of this.object.children) {
      if (isMesh(obj2)) {
        obj2.renderOrder = Number.MAX_SAFE_INTEGER;
      }
    }
    this.bars = bars;
    this.spherePads = spherePads;
    this.conePads = conePads;
    this.arcPads = arcPads;
    this.interactionAxisLocal[interactionAxis] = 1;
    this.motionAxisLocal[motionAxis] = 1;
    this.rotationAxisLocal[rotationAxis] = 1;
    this.materialFront = materialFront;
    this.materialBack = materialBack;
    this.materialSelected = materialSelected;
    this.enabled = true;
    this.draggable = true;
    for (let i = 0; i < this.spherePads.length; ++i) {
      const dir = 2 * i - 1;
      this.spherePads[i].scale.setScalar(size * 0.4);
      this.spherePads[i].position.copy(this.motionAxisLocal).multiplyScalar(dir * size * 1.5);
    }
    const V = new Vector3();
    for (let i = 0; i < this.conePads.length; ++i) {
      const dir = 2 * i - 1;
      V.copy(this.conePads[i].up).multiplyScalar(dir);
      this.conePads[i].quaternion.setFromUnitVectors(V, this.motionAxisLocal);
      this.conePads[i].position.copy(this.motionAxisLocal).multiplyScalar(dir * size * 1.5);
      this.conePads[i].scale.set(0.2, 0.4, 0.2).multiplyScalar(size);
    }
    for (let i = 0; i < this.bars.length; ++i) {
      const dir = 2 * i - 1;
      this.bars[i].scale.copy(this.motionAxisLocal).multiplyScalar(1.2).add(_Translator.small).multiplyScalar(size);
      this.bars[i].position.copy(this.motionAxisLocal).multiplyScalar(dir * size * 0.7);
    }
    const Q4 = new Quaternion();
    const Z = new Vector3(0, 0, -1);
    const ringRotAxis = new Vector3();
    ringRotAxis[ringAxis] = 1;
    for (let i = 0; i < this.arcPads.length; ++i) {
      const a = i * Math.PI / 2;
      Q4.setFromAxisAngle(Z, a);
      this.arcPads[i].quaternion.setFromAxisAngle(ringRotAxis, Math.PI / 2).multiply(Q4);
      this.arcPads[i].scale.setScalar(size * 4);
    }
    this.addMeshes(
      ...this.bars,
      ...this.spherePads,
      ...this.conePads,
      ...this.arcPads
    );
  }
  get mode() {
    return this._mode;
  }
  set mode(v) {
    if (v !== this.mode) {
      this._mode = v;
      const isRotate = this.mode === "Object Rotate" /* RotateObjectSpace */ || this.mode === "Global Rotate" /* RotateGlobalSpace */ || this.mode === "View Rotate" /* RotateViewSpace */;
      const isLateral = this.mode !== "None" /* None */ && !isRotate;
      for (const arcPad of this.arcPads) {
        arcPad.visible = isRotate;
      }
      for (const bar of this.bars) {
        bar.visible = isLateral;
      }
      for (const spherePad of this.spherePads) {
        spherePad.visible = this.mode === "Resize" /* Resize */;
      }
      for (const conePad of this.conePads) {
        conePad.visible = this.mode !== "Resize" /* Resize */ && isLateral;
      }
      for (const mesh2 of this.meshes) {
        if (mesh2.visible !== isDefined(mesh2.parent)) {
          if (mesh2.visible) {
            this.object.add(mesh2);
          } else {
            mesh2.removeFromParent();
          }
        }
      }
    }
  }
  refresh(center, lookAt) {
    this.delta.subVectors(lookAt, center);
    this.checkMeshes(center, this.bars);
    this.checkMeshes(center, this.spherePads);
    this.checkMeshes(center, this.conePads);
    this.checkMeshes(center, this.arcPads);
  }
  checkMeshes(center, arr) {
    for (const pad of arr) {
      if (pad === this.selected) {
        pad.material = this.materialSelected;
      } else {
        pad.getWorldPosition(this.worldPos);
        pad.getWorldQuaternion(this.worldQuat);
        pad.geometry.boundingBox.getCenter(this.center);
        this.center.add(pad.position);
        pad.localToWorld(this.center);
        this.center.sub(center);
        const distB = this.center.dot(this.delta);
        pad.material = distB < 0 ? this.materialBack : this.materialFront;
      }
    }
  }
};
var Translator = _Translator;
Translator.small = new Vector3(0.1, 0.1, 0.1);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/onUserGesture.ts
var USER_GESTURE_EVENTS = [
  "change",
  "click",
  "contextmenu",
  "dblclick",
  "mouseup",
  "pointerup",
  "reset",
  "submit",
  "touchend"
];
function onUserGesture(callback, perpetual = false) {
  const check = async (evt) => {
    if (evt.isTrusted) {
      if (!perpetual) {
        for (const gesture of USER_GESTURE_EVENTS) {
          window.removeEventListener(gesture, check);
        }
      }
      callback();
    }
  };
  for (const gesture of USER_GESTURE_EVENTS) {
    window.addEventListener(gesture, check);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/strings/stringToName.ts
function stringToName(...parts) {
  const goodParts = [];
  for (const part of parts) {
    if (isDefined(part) && part.length > 0 && goodParts.indexOf(part) === -1) {
      goodParts.push(part);
    }
  }
  return goodParts.join("-");
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/IAudioNode.ts
function isEndpoint(obj2) {
  return isDefined(obj2) && "_resolveInput" in obj2;
}
function isIAudioNode(obj2) {
  return isEndpoint(obj2) && "_resolveOutput" in obj2;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/BaseNode.ts
var BaseNode = class extends TypedEventBase {
  constructor(nodeType, context) {
    super();
    this.nodeType = nodeType;
    this.context = context;
    this._name = null;
    this.disposed = false;
  }
  get name() {
    return this._name;
  }
  set name(v) {
    this._name = v;
    this.context._name(this, v);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.onDisposing();
    }
  }
  onDisposing() {
  }
  isConnected(dest, output, input) {
    return this.context._isConnected(this, dest, output, input);
  }
  resolveOutput(output) {
    let resolution = {
      source: this,
      output
    };
    while (isIAudioNode(resolution.source)) {
      resolution = resolution.source._resolveOutput(resolution.output);
    }
    return resolution;
  }
  resolveInput(input) {
    let resolution = {
      destination: this,
      input
    };
    while (isEndpoint(resolution.destination)) {
      resolution = resolution.destination._resolveInput(resolution.input);
    }
    return resolution;
  }
  toggle(dest, outp, inp) {
    this._toggle(dest, outp, inp);
  }
  _toggle(dest, outp, inp) {
    if (this.isConnected(dest, outp, inp)) {
      this._disconnect(dest, outp, inp);
    } else {
      return this._connect(dest, outp, inp);
    }
  }
  connect(dest, outp, inp) {
    return this._connect(dest, outp, inp);
  }
  _connect(dest, outp, inp) {
    return this.context._connect(this, dest, outp, inp);
  }
  disconnect(destinationOrOutput, outp, inp) {
    this._disconnect(destinationOrOutput, outp, inp);
  }
  _disconnect(destinationOrOutput, outp, inp) {
    this.context._disconnect(this, destinationOrOutput, outp, inp);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/BaseNodeCluster.ts
var BaseNodeCluster = class extends BaseNode {
  constructor(type2, context, inputs, endpoints, extras) {
    super(type2, context);
    inputs = inputs || [];
    extras = extras || [];
    const exits = endpoints || inputs;
    this.inputs = inputs;
    const entries = inputs.filter(isIAudioNode).map((o) => o);
    this.outputs = exits.filter(isIAudioNode).map((o) => o);
    this.allNodes = Array.from(/* @__PURE__ */ new Set([
      ...entries,
      ...this.outputs,
      ...extras
    ]));
  }
  get exemplar() {
    return this.allNodes[0];
  }
  add(node) {
    this.allNodes.push(node);
    this.context._parent(this, node);
  }
  remove(node) {
    arrayRemove(this.allNodes, node);
    this.context._unparent(this, node);
  }
  onDisposing() {
    this.allNodes.forEach(dispose);
    super.onDisposing();
  }
  get channelCount() {
    return this.exemplar.channelCount;
  }
  set channelCount(v) {
    this.allNodes.forEach((n2) => n2.channelCount = v);
  }
  get channelCountMode() {
    return this.exemplar.channelCountMode;
  }
  set channelCountMode(v) {
    this.allNodes.forEach((n2) => n2.channelCountMode = v);
    ;
  }
  get channelInterpretation() {
    return this.exemplar.channelInterpretation;
  }
  set channelInterpretation(v) {
    this.allNodes.forEach((n2) => n2.channelInterpretation = v);
  }
  get numberOfInputs() {
    return this.inputs.length;
  }
  get numberOfOutputs() {
    return this.outputs.length;
  }
  static resolve(source, index) {
    index = index || 0;
    if (index < 0 || source.length <= index) {
      return null;
    }
    return source[index];
  }
  _resolveInput(input) {
    return {
      destination: BaseNodeCluster.resolve(this.inputs, input)
    };
  }
  _resolveOutput(output) {
    return {
      source: BaseNodeCluster.resolve(this.outputs, output)
    };
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/BaseGraphNode.ts
function breadthFirstPeek(arr) {
  return arr[0];
}
function breadthFirstRemove(arr) {
  return arr.shift();
}
function depthFirstPeek(arr) {
  return arr[arr.length - 1];
}
function depthFirstRemove(arr) {
  return arr.pop();
}
var BaseGraphNode = class {
  constructor(value2) {
    this.value = value2;
    this._forward = new Array();
    this._reverse = new Array();
  }
  connectSorted(child, keySelector) {
    if (isDefined(keySelector)) {
      arraySortedInsert(this._forward, child, (n2) => keySelector(n2.value));
      arraySortedInsert(child._reverse, this, (n2) => keySelector(n2.value));
    } else {
      this.connectTo(child);
    }
  }
  connectTo(child) {
    this.connectAt(child, this._forward.length);
  }
  connectAt(child, index) {
    arrayInsertAt(this._forward, child, index);
    child._reverse.push(this);
  }
  disconnectFrom(child) {
    arrayRemove(this._forward, child);
    arrayRemove(child._reverse, this);
  }
  isConnectedTo(node) {
    return this._forward.indexOf(node) >= 0 || this._reverse.indexOf(node) >= 0;
  }
  flatten() {
    const visited = /* @__PURE__ */ new Set();
    const queue = [this];
    while (queue.length > 0) {
      const here = queue.shift();
      if (isDefined(here) && !visited.has(here)) {
        visited.add(here);
        queue.push(...here._forward);
      }
    }
    return Array.from(visited);
  }
  *traverse(breadthFirst) {
    const visited = /* @__PURE__ */ new Set();
    const queue = [this];
    const peek = breadthFirst ? breadthFirstPeek : depthFirstPeek;
    const remove = breadthFirst ? breadthFirstRemove : depthFirstRemove;
    while (queue.length > 0) {
      const here = peek(queue);
      if (!visited.has(here)) {
        visited.add(here);
        if (breadthFirst) {
          remove(queue);
          yield here;
        }
        if (here._forward.length > 0) {
          queue.push(...here._forward);
        }
      } else if (!breadthFirst) {
        remove(queue);
        yield here;
      }
    }
  }
  breadthFirst() {
    return this.traverse(true);
  }
  depthFirst() {
    return this.traverse(false);
  }
  search(predicate, breadthFirst = true) {
    for (const node of this.traverse(breadthFirst)) {
      if (predicate(node)) {
        return node;
      }
    }
    return null;
  }
  *searchAll(predicate, breadthFirst = true) {
    for (const node of this.traverse(breadthFirst)) {
      if (predicate(node)) {
        yield node;
      }
    }
  }
  find(v, breadthFirst = true) {
    return this.search((n2) => n2.value === v, breadthFirst);
  }
  findAll(v, breadthFirst = true) {
    return this.searchAll((n2) => n2.value === v, breadthFirst);
  }
  contains(node, breadthFirst = true) {
    for (const child of this.traverse(breadthFirst)) {
      if (child === node) {
        return true;
      }
    }
    return false;
  }
  containsValue(v, breadthFirst = true) {
    for (const child of this.traverse(breadthFirst)) {
      if (child.value === v) {
        return true;
      }
    }
    return false;
  }
  get _isEntryPoint() {
    return this._reverse.length === 0;
  }
  get _isExitPoint() {
    return this._forward.length === 0;
  }
  get isDisconnected() {
    return this._isEntryPoint && this._isExitPoint;
  }
  get isConnected() {
    return !this._isExitPoint || !this._isEntryPoint;
  }
  get isTerminus() {
    return this._isEntryPoint || this._isExitPoint;
  }
  get isInternal() {
    return !this._isEntryPoint && !this._isExitPoint;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/GraphNode.ts
var GraphNode = class extends BaseGraphNode {
  get connections() {
    return this._forward;
  }
  get isEntryPoint() {
    return this._isEntryPoint;
  }
  get isExitPoint() {
    return this._isExitPoint;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioNode.ts
var JuniperAudioNode = class extends BaseNode {
  constructor(type2, context, _node) {
    super(type2, context);
    this._node = _node;
    this.context._init(this._node, this.nodeType);
  }
  onDisposing() {
    this.disconnect();
    this.context._dispose(this._node);
    super.onDisposing();
  }
  parent(param) {
    this.context._parent(this, param);
  }
  get channelCount() {
    return this._node.channelCount;
  }
  set channelCount(v) {
    this._node.channelCount = v;
  }
  get channelCountMode() {
    return this._node.channelCountMode;
  }
  set channelCountMode(v) {
    this._node.channelCountMode = v;
  }
  get channelInterpretation() {
    return this._node.channelInterpretation;
  }
  set channelInterpretation(v) {
    this._node.channelInterpretation = v;
  }
  get numberOfInputs() {
    return this._node.numberOfInputs;
  }
  get numberOfOutputs() {
    return this._node.numberOfOutputs;
  }
  _resolveInput(input) {
    return {
      destination: this._node,
      input
    };
  }
  _resolveOutput(output) {
    return {
      source: this._node,
      output
    };
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAnalyserNode.ts
var JuniperAnalyserNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("analyser", context, new AnalyserNode(context, options));
  }
  get fftSize() {
    return this._node.fftSize;
  }
  set fftSize(v) {
    this._node.fftSize = v;
  }
  get frequencyBinCount() {
    return this._node.frequencyBinCount;
  }
  get maxDecibels() {
    return this._node.maxDecibels;
  }
  set maxDecibels(v) {
    this._node.maxDecibels = v;
  }
  get minDecibels() {
    return this._node.minDecibels;
  }
  set minDecibels(v) {
    this._node.minDecibels = v;
  }
  get smoothingTimeConstant() {
    return this._node.smoothingTimeConstant;
  }
  set smoothingTimeConstant(v) {
    this._node.smoothingTimeConstant = v;
  }
  getByteFrequencyData(array) {
    this._node.getByteFrequencyData(array);
  }
  getByteTimeDomainData(array) {
    this._node.getByteTimeDomainData(array);
  }
  getFloatFrequencyData(array) {
    this._node.getFloatFrequencyData(array);
  }
  getFloatTimeDomainData(array) {
    this._node.getFloatTimeDomainData(array);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioParam.ts
var JuniperAudioParam = class {
  constructor(nodeType, context, param) {
    this.nodeType = nodeType;
    this.context = context;
    this.param = param;
    this._name = null;
    this.disposed = false;
    this.context._init(this.param, this.nodeType);
  }
  get name() {
    return this._name;
  }
  set name(v) {
    this._name = v;
    this.context._name(this, v);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.onDisposing();
    }
  }
  onDisposing() {
    this.context._dispose(this.param);
  }
  get automationRate() {
    return this.param.automationRate;
  }
  set automationRate(v) {
    this.param.automationRate = v;
  }
  get defaultValue() {
    return this.param.defaultValue;
  }
  get maxValue() {
    return this.param.maxValue;
  }
  get minValue() {
    return this.param.minValue;
  }
  get value() {
    return this.param.value;
  }
  set value(v) {
    this.param.value = v;
  }
  cancelAndHoldAtTime(cancelTime) {
    this.param.cancelAndHoldAtTime(cancelTime);
    return this;
  }
  cancelScheduledValues(cancelTime) {
    this.param.cancelScheduledValues(cancelTime);
    return this;
  }
  exponentialRampToValueAtTime(value2, endTime) {
    this.param.exponentialRampToValueAtTime(value2, endTime);
    return this;
  }
  linearRampToValueAtTime(value2, endTime) {
    this.param.linearRampToValueAtTime(value2, endTime);
    return this;
  }
  setTargetAtTime(target, startTime, timeConstant) {
    this.param.setTargetAtTime(target, startTime, timeConstant);
    return this;
  }
  setValueAtTime(value2, startTime) {
    this.param.setValueAtTime(value2, startTime);
    return this;
  }
  setValueCurveAtTime(values, startTime, duration) {
    this.param.setValueCurveAtTime(values, startTime, duration);
    return this;
  }
  _resolveInput() {
    return {
      destination: this.param
    };
  }
  resolveInput() {
    return this._resolveInput();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioBufferSourceNode.ts
var JuniperAudioBufferSourceNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("audio-buffer-source", context, new AudioBufferSourceNode(context, options));
    this._node.addEventListener("ended", () => this.dispatchEvent(new TypedEvent("ended")));
    this.parent(this.playbackRate = new JuniperAudioParam("playbackRate", context, this._node.playbackRate));
    this.parent(this.detune = new JuniperAudioParam("detune", context, this._node.detune));
  }
  get buffer() {
    return this._node.buffer;
  }
  set buffer(v) {
    this._node.buffer = v;
  }
  get loop() {
    return this._node.loop;
  }
  set loop(v) {
    this._node.loop = v;
  }
  get loopEnd() {
    return this._node.loopEnd;
  }
  set loopEnd(v) {
    this._node.loopEnd = v;
  }
  get loopStart() {
    return this._node.loopStart;
  }
  set loopStart(v) {
    this._node.loopStart = v;
  }
  get onended() {
    return this._node.onended;
  }
  set onended(v) {
    this._node.onended = v;
  }
  start(when, offset, duration) {
    this._node.start(when, offset, duration);
  }
  stop(when) {
    this._node.stop(when);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioDestinationNode.ts
var JuniperAudioDestinationNode = class extends JuniperAudioNode {
  constructor(context, destination) {
    super("destination", context, destination);
  }
  get maxChannelCount() {
    return this._node.maxChannelCount;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperBiquadFilterNode.ts
var JuniperBiquadFilterNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("biquad-filter", context, new BiquadFilterNode(context, options));
    this.parent(this.Q = new JuniperAudioParam("Q", this.context, this._node.Q));
    this.parent(this.detune = new JuniperAudioParam("detune", this.context, this._node.detune));
    this.parent(this.frequency = new JuniperAudioParam("frequency", this.context, this._node.frequency));
    this.parent(this.gain = new JuniperAudioParam("gain", this.context, this._node.gain));
  }
  get type() {
    return this._node.type;
  }
  set type(v) {
    this._node.type = v;
  }
  getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
    this._node.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperChannelMergerNode.ts
var JuniperChannelMergerNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("channel-merger", context, new ChannelMergerNode(context, options));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperChannelSplitterNode.ts
var JuniperChannelSplitterNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("channel-splitter", context, new ChannelSplitterNode(context, options));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperConstantSourceNode.ts
var JuniperConstantSourceNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("constant-source", context, new ConstantSourceNode(context, options));
    this._node.addEventListener("ended", () => this.dispatchEvent(new TypedEvent("ended")));
    this.parent(this.offset = new JuniperAudioParam("offset", this.context, this._node.offset));
  }
  get onended() {
    return this._node.onended;
  }
  set onended(v) {
    this._node.onended = v;
  }
  start(when) {
    this._node.start(when);
  }
  stop(when) {
    this._node.stop(when);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperConvolverNode.ts
var JuniperConvolverNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("convolver", context, new ConvolverNode(context, options));
  }
  get buffer() {
    return this._node.buffer;
  }
  set buffer(v) {
    this._node.buffer = v;
  }
  get normalize() {
    return this._node.normalize;
  }
  set normalize(v) {
    this._node.normalize = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperDelayNode.ts
var JuniperDelayNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("delay", context, new DelayNode(context, options));
    this.parent(this.delayTime = new JuniperAudioParam("delay", this.context, this._node.delayTime));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperDynamicsCompressorNode.ts
var JuniperDynamicsCompressorNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("dynamics-compressor", context, new DynamicsCompressorNode(context, options));
    this.parent(this.attack = new JuniperAudioParam("attack", this.context, this._node.attack));
    this.parent(this.knee = new JuniperAudioParam("knee", this.context, this._node.knee));
    this.parent(this.ratio = new JuniperAudioParam("ratio", this.context, this._node.ratio));
    this.parent(this.release = new JuniperAudioParam("release", this.context, this._node.release));
    this.parent(this.threshold = new JuniperAudioParam("threshold", this.context, this._node.threshold));
  }
  get reduction() {
    return this._node.reduction;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperGainNode.ts
var JuniperGainNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("gain", context, new GainNode(context, options));
    this.parent(this.gain = new JuniperAudioParam("gain", this.context, this._node.gain));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperIIRFilterNode.ts
var JuniperIIRFilterNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("iir-filter", context, new IIRFilterNode(context, options));
  }
  getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
    this._node.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperMediaElementAudioSourceNode.ts
var JuniperMediaElementAudioSourceNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("media-element-audio-source", context, new MediaElementAudioSourceNode(context, options));
  }
  get mediaElement() {
    return this._node.mediaElement;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperMediaStreamAudioDestinationNode.ts
var JuniperMediaStreamAudioDestinationNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("media-stream-audio-destination", context, new MediaStreamAudioDestinationNode(context, options));
  }
  get stream() {
    return this._node.stream;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/util.ts
var hasAudioContext = "AudioContext" in globalThis;
var hasAudioListener = hasAudioContext && "AudioListener" in globalThis;
var hasOldAudioListener = hasAudioListener && "setPosition" in AudioListener.prototype;
var hasNewAudioListener = hasAudioListener && "positionX" in AudioListener.prototype;
var hasStreamSources = "createMediaStreamSource" in AudioContext.prototype;
var canCaptureStream = /* @__PURE__ */ isFunction(HTMLMediaElement.prototype.captureStream) || isFunction(HTMLMediaElement.prototype.mozCaptureStream);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperMediaStreamAudioSourceNode.ts
var JuniperMediaStreamAudioSourceNode = class extends JuniperAudioNode {
  constructor(context, options) {
    const element = Audio2(
      controls(false),
      muted(hasStreamSources),
      autoPlay(true),
      loop(false),
      display("none"),
      srcObject(options.mediaStream)
    );
    let node;
    if (hasStreamSources) {
      node = new MediaStreamAudioSourceNode(context, options);
    } else {
      node = new MediaElementAudioSourceNode(context, {
        mediaElement: element
      });
    }
    super("media-stream-audio-source", context, node);
    this._stream = options.mediaStream;
    this._element = element;
  }
  onDisposing() {
    this._element.pause();
    super.onDisposing();
  }
  get mediaStream() {
    return this._stream;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperOscillatorNode.ts
var JuniperOscillatorNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("oscillator", context, new OscillatorNode(context, options));
    this._node.addEventListener("ended", () => this.dispatchEvent(new TypedEvent("ended")));
    this.parent(this.detune = new JuniperAudioParam("detune", this.context, this._node.detune));
    this.parent(this.frequency = new JuniperAudioParam("frequency", this.context, this._node.frequency));
  }
  get type() {
    return this._node.type;
  }
  set type(v) {
    this._node.type = v;
  }
  get onended() {
    return this._node.onended;
  }
  set onended(v) {
    this._node.onended = v;
  }
  setPeriodicWave(periodicWave) {
    this._node.setPeriodicWave(periodicWave);
  }
  start(when) {
    this._node.start(when);
  }
  stop(when) {
    this._node.stop(when);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperPannerNode.ts
var JuniperPannerNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("panner", context, new PannerNode(context, options));
    this.parent(this.positionX = new JuniperAudioParam("positionX", this.context, this._node.positionX));
    this.parent(this.positionY = new JuniperAudioParam("positionY", this.context, this._node.positionY));
    this.parent(this.positionZ = new JuniperAudioParam("positionZ", this.context, this._node.positionZ));
    this.parent(this.orientationX = new JuniperAudioParam("orientationX", this.context, this._node.orientationX));
    this.parent(this.orientationY = new JuniperAudioParam("orientationY", this.context, this._node.orientationY));
    this.parent(this.orientationZ = new JuniperAudioParam("orientationZ", this.context, this._node.orientationZ));
  }
  get coneInnerAngle() {
    return this._node.coneInnerAngle;
  }
  set coneInnerAngle(v) {
    this._node.coneInnerAngle = v;
  }
  get coneOuterAngle() {
    return this._node.coneOuterAngle;
  }
  set coneOuterAngle(v) {
    this._node.coneOuterAngle = v;
  }
  get coneOuterGain() {
    return this._node.coneOuterGain;
  }
  set coneOuterGain(v) {
    this._node.coneOuterGain = v;
  }
  get distanceModel() {
    return this._node.distanceModel;
  }
  set distanceModel(v) {
    this._node.distanceModel = v;
  }
  get maxDistance() {
    return this._node.maxDistance;
  }
  set maxDistance(v) {
    this._node.maxDistance = v;
  }
  get panningModel() {
    return this._node.panningModel;
  }
  set panningModel(v) {
    this._node.panningModel = v;
  }
  get refDistance() {
    return this._node.refDistance;
  }
  set refDistance(v) {
    this._node.refDistance = v;
  }
  get rolloffFactor() {
    return this._node.rolloffFactor;
  }
  set rolloffFactor(v) {
    this._node.rolloffFactor = v;
  }
  setOrientation(x, y, z) {
    this._node.setOrientation(x, y, z);
  }
  setPosition(x, y, z) {
    this._node.setPosition(x, y, z);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperStereoPannerNode.ts
var JuniperStereoPannerNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("stereo-panner", context, new StereoPannerNode(context, options));
    this.parent(this.pan = new JuniperAudioParam("pan", this.context, this._node.pan));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperWaveShaperNode.ts
var JuniperWaveShaperNode = class extends JuniperAudioNode {
  constructor(context, options) {
    super("wave-shaper", context, new WaveShaperNode(context, options));
  }
  get curve() {
    return this._node.curve;
  }
  set curve(v) {
    this._node.curve = v;
  }
  get oversample() {
    return this._node.oversample;
  }
  set oversample(v) {
    this._node.oversample = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/context/JuniperAudioContext.ts
if (!("AudioContext" in globalThis) && "webkitAudioContext" in globalThis) {
  globalThis.AudioContext = globalThis.webkitAudioContext;
}
if (!("OfflineAudioContext" in globalThis) && "webkitOfflineAudioContext" in globalThis) {
  globalThis.OfflineAudioContext = globalThis.webkitOfflineAudioContext;
}
var NodeInfo = class {
  constructor(type2, name3) {
    this.type = type2;
    this.name = name3;
    this.connections = /* @__PURE__ */ new Set();
  }
};
function isMatchingConnection(conn, type2, destination, output, input) {
  return conn.type === type2 && (isNullOrUndefined(destination) || destination === conn.destination) && (isNullOrUndefined(output) || output === conn.output) && (isNullOrUndefined(input) || input === conn.input);
}
function resolveInput(dest, inp) {
  let destination = null;
  let input = null;
  if (isDefined(dest)) {
    ({ destination, input } = dest.resolveInput(inp));
  }
  return { destination, input };
}
var JuniperAudioContext = class extends AudioContext {
  constructor(contextOptions) {
    super(contextOptions);
    this.counters = /* @__PURE__ */ new Map();
    this.nodes = /* @__PURE__ */ new Map();
    this._ready = new Task();
    this._destination = new JuniperAudioDestinationNode(this, super.destination);
    if (this.state === "running") {
      this._ready.resolve();
    } else if (this.state === "closed") {
      this.resume().then(() => this._ready.resolve());
    } else {
      onUserGesture(() => this.resume().then(() => this._ready.resolve()));
    }
    this.ready.then(() => console.log("Audio is now ready"));
  }
  get ready() {
    return this._ready;
  }
  get isReady() {
    return this._ready.finished && this._ready.resolved;
  }
  _init(node, type2) {
    if (!this.nodes.has(node)) {
      if (!this.counters.has(type2)) {
        this.counters.set(type2, 0);
      }
      const count = this.counters.get(type2);
      const name3 = `${type2}-${count}`;
      this.nodes.set(node, new NodeInfo(type2, name3));
      if (isEndpoint(node)) {
        node.name = name3;
      }
      this.counters.set(type2, count + 1);
    }
  }
  _name(dest, name3) {
    const { destination } = resolveInput(dest);
    if (this.nodes.has(destination)) {
      const info = this.nodes.get(destination);
      info.name = `${name3}-${info.type}`;
    }
  }
  _dispose(node) {
    this.nodes.delete(node);
  }
  _isConnected(src2, dest, outp, inp) {
    const { source, output } = src2.resolveOutput(outp);
    const { destination, input } = resolveInput(dest, inp);
    if (isNullOrUndefined(source) || !this.nodes.has(source)) {
      return null;
    } else {
      const info = this.nodes.get(source);
      for (const conn of info.connections) {
        if (isMatchingConnection(conn, "conn", destination, output, input)) {
          return true;
        }
      }
      return false;
    }
  }
  _parent(src2, dest) {
    const { source } = src2.resolveOutput();
    const { destination } = resolveInput(dest);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      conns.add({
        type: "parent",
        src: src2,
        dest,
        destination,
        source
      });
    }
  }
  _unparent(src2, dest) {
    const { source } = src2.resolveOutput();
    const { destination } = resolveInput(dest);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      const toDelete = /* @__PURE__ */ new Set();
      for (const conn of conns) {
        if (isMatchingConnection(conn, "parent", destination)) {
          toDelete.add(conn);
        }
      }
      for (const conn of toDelete) {
        conns.delete(conn);
      }
    }
  }
  _getConnections(node) {
    if (!this.nodes.has(node)) {
      return null;
    }
    return this.nodes.get(node).connections;
  }
  _connect(src2, dest, outp, inp) {
    const { source, output } = src2.resolveOutput(outp);
    const { destination, input } = resolveInput(dest, inp);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      let matchFound = false;
      for (const conn of conns) {
        if (isMatchingConnection(conn, "conn", destination, output, input)) {
          matchFound = true;
        }
      }
      if (!matchFound) {
        conns.add({
          type: "conn",
          src: src2,
          dest,
          outp,
          inp,
          source,
          destination,
          output,
          input
        });
      }
    }
    if (destination instanceof AudioNode) {
      dest = dest;
      if (isDefined(input)) {
        source.connect(destination, output, input);
        return dest;
      } else if (isDefined(output)) {
        source.connect(destination, output);
        return dest;
      } else {
        source.connect(destination);
        return dest;
      }
    } else if (destination instanceof AudioParam) {
      if (isDefined(output)) {
        source.connect(destination, output);
      } else if (isDefined(destination)) {
        source.connect(destination);
      } else {
        assertNever(destination);
      }
    } else {
      assertNever(destination);
    }
  }
  _disconnect(src2, destinationOrOutput, outp, inp) {
    let dest;
    if (isNumber(destinationOrOutput)) {
      dest = void 0;
      outp = destinationOrOutput;
    } else {
      dest = destinationOrOutput;
    }
    const { source, output } = src2.resolveOutput(outp);
    const { destination, input } = resolveInput(dest, inp);
    if (this.nodes.has(source)) {
      const conns = this.nodes.get(source).connections;
      const toDelete = /* @__PURE__ */ new Set();
      for (const conn of conns) {
        if (isMatchingConnection(conn, "conn", destination, output, input)) {
          toDelete.add(conn);
        }
      }
      for (const conn of toDelete) {
        conns.delete(conn);
      }
    }
    if (destination instanceof AudioNode) {
      if (isDefined(inp)) {
        source.disconnect(destination, outp, inp);
      } else if (isDefined(outp)) {
        source.disconnect(destination, outp);
      } else if (isDefined(destination)) {
        source.disconnect(destination);
      } else {
        source.disconnect();
      }
    } else if (isDefined(outp)) {
      source.disconnect(destination, outp);
    } else if (isDefined(destination)) {
      source.disconnect(destination);
    } else {
      source.disconnect();
    }
  }
  getAudioGraph(includeParams) {
    const nodes = /* @__PURE__ */ new Map();
    for (const [node, info] of this.nodes) {
      const nodeClass = node instanceof AudioNode ? "node" : node instanceof AudioParam ? "param" : "unknown";
      if (includeParams || nodeClass !== "param") {
        nodes.set(node, new GraphNode({
          name: info.name,
          type: info.type,
          nodeClass
        }));
      }
    }
    for (const [source, info] of this.nodes) {
      const branch = nodes.get(source);
      for (const child of info.connections) {
        const destination = child.destination;
        if (nodes.has(destination)) {
          const cnode = nodes.get(destination);
          branch.connectTo(cnode);
          cnode.connectTo(branch);
        }
      }
    }
    return Array.from(nodes.values());
  }
  get destination() {
    return this._destination;
  }
  createAnalyser() {
    return new JuniperAnalyserNode(this);
  }
  createBiquadFilter() {
    return new JuniperBiquadFilterNode(this);
  }
  createBufferSource() {
    return new JuniperAudioBufferSourceNode(this);
  }
  createChannelMerger(numberOfInputs) {
    return new JuniperChannelMergerNode(this, {
      numberOfInputs
    });
  }
  createChannelSplitter(numberOfOutputs) {
    return new JuniperChannelSplitterNode(this, {
      numberOfOutputs
    });
  }
  createConstantSource() {
    return new JuniperConstantSourceNode(this);
  }
  createConvolver() {
    return new JuniperConvolverNode(this);
  }
  createDelay(maxDelayTime) {
    return new JuniperDelayNode(this, {
      maxDelayTime
    });
  }
  createDynamicsCompressor() {
    return new JuniperDynamicsCompressorNode(this);
  }
  createGain() {
    return new JuniperGainNode(this);
  }
  createIIRFilter(feedforward, feedback) {
    return new JuniperIIRFilterNode(this, {
      feedforward,
      feedback
    });
  }
  createMediaElementSource(mediaElement) {
    return new JuniperMediaElementAudioSourceNode(this, {
      mediaElement
    });
  }
  createMediaStreamDestination() {
    return new JuniperMediaStreamAudioDestinationNode(this);
  }
  createMediaStreamSource(mediaStream) {
    return new JuniperMediaStreamAudioSourceNode(this, {
      mediaStream
    });
  }
  createOscillator() {
    return new JuniperOscillatorNode(this);
  }
  createPanner() {
    return new JuniperPannerNode(this);
  }
  createStereoPanner() {
    return new JuniperStereoPannerNode(this);
  }
  createWaveShaper() {
    return new JuniperWaveShaperNode(this);
  }
  createScriptProcessor() {
    throw new Error("Script processor nodes are deprecated");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/listeners/BaseListener.ts
var BaseListener = class {
  constructor(type2, context) {
    this.type = type2;
    this.context = context;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/listeners/BaseWebAudioListener.ts
var f = vec3_exports.create();
var u = vec3_exports.create();
var BaseWebAudioListener = class extends BaseListener {
  get listener() {
    return this.context.listener;
  }
  /**
   * Performs the spatialization operation for the audio source's latest location.
   */
  readPose(loc) {
    const { p, q } = loc;
    vec3_exports.set(f, 0, 0, -1);
    vec3_exports.transformQuat(f, f, q);
    vec3_exports.set(u, 0, 1, 0);
    vec3_exports.transformQuat(u, u, q);
    this.setPosition(p[0], p[1], p[2]);
    this.setOrientation(f[0], f[1], f[2], u[0], u[1], u[2]);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/listeners/WebAudioListenerNew.ts
var WebAudioListenerNew = class extends BaseWebAudioListener {
  /**
   * Creates a new positioner that uses WebAudio's playback dependent time progression.
   */
  constructor(context) {
    if (!hasNewAudioListener) {
      throw new Error("Latest WebAudio Listener API is not supported");
    }
    super("web-audio-listener-new", context);
    Object.seal(this);
  }
  setPosition(x, y, z) {
    const t2 = this.context.currentTime;
    this.listener.positionX.setValueAtTime(x, t2);
    this.listener.positionY.setValueAtTime(y, t2);
    this.listener.positionZ.setValueAtTime(z, t2);
  }
  setOrientation(fx, fy, fz, ux, uy, uz) {
    const t2 = this.context.currentTime;
    this.listener.forwardX.setValueAtTime(fx, t2);
    this.listener.forwardY.setValueAtTime(fy, t2);
    this.listener.forwardZ.setValueAtTime(fz, t2);
    this.listener.upX.setValueAtTime(ux, t2);
    this.listener.upY.setValueAtTime(uy, t2);
    this.listener.upZ.setValueAtTime(uz, t2);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/listeners/WebAudioListenerOld.ts
var WebAudioListenerOld = class extends BaseWebAudioListener {
  /**
   * Creates a new positioner that uses WebAudio's playback dependent time progression.
   */
  constructor(context) {
    if (!hasOldAudioListener) {
      throw new Error("WebAudio Listener API is not supported");
    }
    super("web-audio-listener-old", context);
    Object.seal(this);
  }
  setPosition(x, y, z) {
    this.listener.setPosition(x, y, z);
  }
  setOrientation(fx, fy, fz, ux, uy, uz) {
    this.listener.setOrientation(
      fx,
      fy,
      fz,
      ux,
      uy,
      uz
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/Pose.ts
var Pose = class {
  /**
   * Creates a new position and orientation, at a given time.
   **/
  constructor() {
    this.p = vec3_exports.create();
    this.q = quat_exports.create();
    Object.seal(this);
  }
  /**
   * Sets the components of the pose.
   */
  set(px2, py, pz, qx, qy, qz, qw) {
    this.setPosition(px2, py, pz);
    this.setOrientation(qx, qy, qz, qw);
  }
  setPosition(px2, py, pz) {
    vec3_exports.set(this.p, px2, py, pz);
  }
  setOrientation(qx, qy, qz, qw) {
    quat_exports.set(this.q, qx, qy, qz, qw);
  }
  /**
   * Copies the components of another pose into this pose.
   */
  copy(other) {
    vec3_exports.copy(this.p, other.p);
    quat_exports.copy(this.q, other.q);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/BaseSpatializer.ts
var BaseSpatializer = class extends BaseNodeCluster {
  constructor(type2, context, spatialized, input, output, nodes) {
    super(type2, context, input, output, nodes);
    this.spatialized = spatialized;
    this._minDistance = 1;
    this._maxDistance = 10;
    this._algorithm = "inverse";
  }
  get minDistance() {
    return this._minDistance;
  }
  get maxDistance() {
    return this._maxDistance;
  }
  get algorithm() {
    return this._algorithm;
  }
  /**
   * Sets parameters that alter spatialization.
   **/
  setAudioProperties(minDistance, maxDistance, algorithm) {
    this._minDistance = minDistance;
    this._maxDistance = maxDistance;
    this._algorithm = algorithm;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/BaseWebAudioPanner.ts
var fwd = vec3_exports.create();
var BaseWebAudioPanner = class extends BaseSpatializer {
  /**
   * Creates a new spatializer that uses WebAudio's PannerNode.
   */
  constructor(type2, context) {
    const panner = new JuniperPannerNode(context, {
      panningModel: "HRTF",
      distanceModel: "inverse",
      coneInnerAngle: 360,
      coneOuterAngle: 0,
      coneOuterGain: 0
    });
    super(type2, context, true, [panner]);
    this.lpx = 0;
    this.lpy = 0;
    this.lpz = 0;
    this.lqx = 0;
    this.lqy = 0;
    this.lqz = 0;
    this.lqw = 0;
    this.panner = panner;
  }
  /**
   * Sets parameters that alter spatialization.
   **/
  setAudioProperties(minDistance, maxDistance, algorithm) {
    super.setAudioProperties(minDistance, maxDistance, algorithm);
    this.panner.refDistance = this.minDistance;
    this.panner.distanceModel = algorithm;
    if (algorithm === "linear") {
      this.panner.rolloffFactor = 1;
    } else {
      if (this.maxDistance <= 0) {
        this.panner.rolloffFactor = Infinity;
      } else if (algorithm === "inverse") {
        this.panner.rolloffFactor = 1 / this.maxDistance;
      } else {
        this.panner.rolloffFactor = Math.pow(this.maxDistance, -0.2);
      }
    }
  }
  /**
   * Performs the spatialization operation for the audio source's latest location.
   */
  readPose(loc) {
    const { p, q } = loc;
    const [px2, py, pz] = p;
    const [qx, qy, qz, qw] = q;
    if (px2 !== this.lpx || py !== this.lpy || pz !== this.lpz) {
      this.lpx = px2;
      this.lpy = py;
      this.lpz = pz;
      this.setPosition(px2, py, pz, this.context.currentTime);
    }
    if (qx !== this.lqx || qy !== this.lqy || qz !== this.lqz || qw !== this.lqw) {
      this.lqx = qx;
      this.lqy = qy;
      this.lqz = qz;
      this.lqw = qw;
      vec3_exports.transformQuat(fwd, vec3_exports.set(fwd, 0, 0, -1), q);
      this.setOrientation(fwd[0], fwd[1], fwd[2], this.context.currentTime);
    }
  }
  /**
   * Computes an expected level of gain at a given distance based on the
   * algorithms expressed in the WebAudio API standard.
   * @param distance the distance to check
   * @returns the multiplicative gain that the panner node will end up applying to the audio signal
   * @see https://developer.mozilla.org/en-US/docs/Web/API/PannerNode/distanceModel
   **/
  getGainAtDistance(distance4) {
    const { rolloffFactor, refDistance, maxDistance, distanceModel } = this.panner;
    if (distance4 <= refDistance) {
      return 1;
    } else {
      const dDist = distance4 - refDistance;
      const dRef = maxDistance - refDistance;
      if (distanceModel === "linear") {
        return 1 - rolloffFactor * dDist / dRef;
      } else if (distanceModel === "inverse") {
        return refDistance / (refDistance + rolloffFactor * dDist);
      } else if (distanceModel === "exponential") {
        return Math.pow(distance4 / refDistance, -rolloffFactor);
      } else {
        assertNever(distanceModel);
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/WebAudioPannerNew.ts
var WebAudioPannerNew = class extends BaseWebAudioPanner {
  /**
   * Creates a new positioner that uses WebAudio's playback dependent time progression.
   */
  constructor(context) {
    super("web-audio-panner-new", context);
    Object.seal(this);
  }
  setPosition(x, y, z, t2) {
    if (isGoodNumber(x) && isGoodNumber(y) && isGoodNumber(z)) {
      if (isBadNumber(t2)) {
        t2 = 0;
      }
      this.panner.positionX.setValueAtTime(x, t2);
      this.panner.positionY.setValueAtTime(y, t2);
      this.panner.positionZ.setValueAtTime(z, t2);
    }
  }
  setOrientation(x, y, z, t2) {
    if (isGoodNumber(x) && isGoodNumber(y) && isGoodNumber(z)) {
      if (isBadNumber(t2)) {
        t2 = 0;
      }
      this.panner.orientationX.setValueAtTime(-x, t2);
      this.panner.orientationY.setValueAtTime(-y, t2);
      this.panner.orientationZ.setValueAtTime(-z, t2);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/WebAudioPannerOld.ts
var WebAudioPannerOld = class extends BaseWebAudioPanner {
  /**
   * Creates a new positioner that uses the WebAudio API's old setPosition method.
   */
  constructor(context) {
    super("web-audio-panner-old", context);
    Object.seal(this);
  }
  setPosition(x, y, z) {
    this.panner.setPosition(x, y, z);
  }
  setOrientation(x, y, z) {
    this.panner.setOrientation(x, y, z);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/destinations/WebAudioDestination.ts
var WebAudioDestination = class extends BaseNodeCluster {
  constructor(context) {
    const listener = hasNewAudioListener ? new WebAudioListenerNew(context) : new WebAudioListenerOld(context);
    const remoteUserInput = new JuniperGainNode(context);
    remoteUserInput.name = "remote-user-input";
    const spatializedInput = new JuniperGainNode(context);
    spatializedInput.name = "spatialized-input";
    const nonSpatializedInput = new JuniperGainNode(context);
    nonSpatializedInput.name = "non-spatialized-input";
    const destination = new JuniperMediaStreamAudioDestinationNode(context);
    const ready = new Task();
    const element = Audio2(
      id("Audio-Device-Manager"),
      display("none"),
      autoPlay(true),
      controls(true),
      srcObject(destination.stream),
      onPlay(() => ready.resolve())
    );
    onUserGesture(() => element.play());
    super(
      "web-audio-destination",
      context,
      [nonSpatializedInput, spatializedInput, remoteUserInput],
      [],
      [destination]
    );
    this.pose = new Pose();
    this._ready = ready;
    this.listener = listener;
    this.remoteUserInput = remoteUserInput;
    this.spatializedInput = spatializedInput;
    this.nonSpatializedInput = nonSpatializedInput;
    this.volumeControl = nonSpatializedInput;
    this.destination = destination;
    this.element = element;
    remoteUserInput.connect(spatializedInput).connect(this.volumeControl).connect(destination);
  }
  get ready() {
    return this._ready;
  }
  get isReady() {
    return this._ready.finished && this._ready.resolved;
  }
  createSpatializer(isRemoteStream) {
    const destination = isRemoteStream ? this.remoteUserInput : this.spatializedInput;
    const spatializer = hasNewAudioListener ? new WebAudioPannerNew(this.context) : new WebAudioPannerOld(this.context);
    spatializer.connect(destination);
    return spatializer;
  }
  setPosition(px2, py, pz) {
    this.pose.setPosition(px2, py, pz);
    this.listener.readPose(this.pose);
  }
  setOrientation(qx, qy, qz, qw) {
    this.pose.setOrientation(qx, qy, qz, qw);
    this.listener.readPose(this.pose);
  }
  set(px2, py, pz, qx, qy, qz, qw) {
    this.pose.set(px2, py, pz, qx, qy, qz, qw);
    this.listener.readPose(this.pose);
  }
  get stream() {
    return this.destination.stream;
  }
  get volume() {
    return this.volumeControl.gain.value;
  }
  set volume(v) {
    this.volumeControl.gain.value = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/effects/RadioEffect.ts
var RadioEffectNode = class extends BaseNodeCluster {
  constructor(context) {
    const filter = new JuniperBiquadFilterNode(context, {
      type: "bandpass",
      frequency: 2500,
      Q: 4.5
    });
    const gain = new JuniperGainNode(context, {
      gain: 10
    });
    filter.connect(gain);
    super("radio-effect", context, [filter], [gain]);
  }
};
function RadioEffect(name3, context) {
  const node = new RadioEffectNode(context);
  node.name = `${name3}-radio-effect`;
  return node;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/effects/WallEffect.ts
function WallEffect(name3, context) {
  const node = new JuniperBiquadFilterNode(context, {
    type: "bandpass",
    frequency: 400,
    Q: 4.5
  });
  node.name = `${name3}-wall-effect`;
  return node;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/effects/index.ts
var effectStore = /* @__PURE__ */ new Map([
  ["Radio", RadioEffect],
  ["Wall", WallEffect]
]);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/BaseAudioSource.ts
var BaseAudioSource = class extends BaseNodeCluster {
  constructor(type2, context, spatializer, effectNames, extras) {
    const volumeControl = new JuniperGainNode(context);
    volumeControl.name = "volume-control";
    extras = extras || [];
    super(type2, context, [], [spatializer], extras);
    this.spatializer = spatializer;
    this.effects = new Array();
    this.pose = new Pose();
    this.volumeControl = volumeControl;
    this.setEffects(...effectNames);
  }
  onDisposing() {
    arrayClear(this.effects);
    super.onDisposing();
  }
  setEffects(...effectNames) {
    this.disable();
    for (const effect of this.effects) {
      this.remove(effect);
      dispose(effect);
    }
    arrayClear(this.effects);
    let last = this.volumeControl;
    for (const effectName of effectNames) {
      if (isDefined(effectName)) {
        const createEffect = effectStore.get(effectName);
        if (isDefined(createEffect)) {
          const effect = createEffect(effectName, this.context);
          this.add(effect);
          this.effects.push(effect);
          last = last.connect(effect);
        }
      }
    }
    this.enable();
  }
  get spatialized() {
    return this.spatializer.spatialized;
  }
  get lastInternal() {
    return this.effects[this.effects.length - 1] || this.volumeControl;
  }
  enable() {
    if (!this.lastInternal.isConnected()) {
      this.lastInternal.connect(this.spatializer);
    }
  }
  disable() {
    if (this.lastInternal.isConnected()) {
      this.lastInternal.disconnect();
    }
  }
  tog() {
    if (this.lastInternal.isConnected()) {
      this.disable();
    } else {
      this.enable();
    }
  }
  get volume() {
    return this.volumeControl.gain.value;
  }
  set volume(v) {
    this.volumeControl.gain.value = v;
  }
  get minDistance() {
    if (isDefined(this.spatializer)) {
      return this.spatializer.minDistance;
    }
    return null;
  }
  get maxDistance() {
    if (isDefined(this.spatializer)) {
      return this.spatializer.maxDistance;
    }
    return null;
  }
  get algorithm() {
    if (isDefined(this.spatializer)) {
      return this.spatializer.algorithm;
    }
    return null;
  }
  setPosition(px2, py, pz) {
    if (isDefined(this.spatializer)) {
      this.pose.setPosition(px2, py, pz);
      this.spatializer.readPose(this.pose);
    }
  }
  setOrientation(qx, qy, qz, qw) {
    if (isDefined(this.spatializer)) {
      this.pose.setOrientation(qx, qy, qz, qw);
      this.spatializer.readPose(this.pose);
    }
  }
  set(px2, py, pz, qx, qy, qz, qw) {
    if (isDefined(this.spatializer)) {
      this.pose.set(px2, py, pz, qx, qy, qz, qw);
      this.spatializer.readPose(this.pose);
    }
  }
  setAudioProperties(minDistance, maxDistance, algorithm) {
    if (isDefined(this.spatializer)) {
      this.spatializer.setAudioProperties(minDistance, maxDistance, algorithm);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/IPlayable.ts
var MediaElementSourceEvent = class extends TypedEvent {
  constructor(type2, source) {
    super(type2);
    this.source = source;
  }
};
var MediaElementSourceLoadedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("loaded", source);
  }
};
var MediaElementSourceErroredEvent = class extends MediaElementSourceEvent {
  constructor(source, error) {
    super("errored", source);
    this.error = error;
  }
};
var MediaElementSourcePlayedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("played", source);
  }
};
var MediaElementSourcePausedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("paused", source);
  }
};
var MediaElementSourceStoppedEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("stopped", source);
  }
};
var MediaElementSourceProgressEvent = class extends MediaElementSourceEvent {
  constructor(source) {
    super("progress", source);
    this.value = 0;
    this.total = 0;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/AudioElementSource.ts
var DISPOSING_EVT = new TypedEvent("disposing");
var AudioElementSource = class extends BaseAudioSource {
  constructor(context, source, randomizeStart, randomizePitch, spatializer, ...effectNames) {
    super("audio-element-source", context, spatializer, effectNames);
    source.connect(this.volumeControl);
    this.audio = source.mediaElement;
    this.disable();
    this.loadEvt = new MediaElementSourceLoadedEvent(this);
    this.playEvt = new MediaElementSourcePlayedEvent(this);
    this.pauseEvt = new MediaElementSourcePausedEvent(this);
    this.stopEvt = new MediaElementSourceStoppedEvent(this);
    this.progEvt = new MediaElementSourceProgressEvent(this);
    const halt = (evt) => {
      if (this.audio.currentTime === 0 || evt.type === "ended") {
        this.dispatchEvent(this.stopEvt);
      } else {
        this.dispatchEvent(this.pauseEvt);
      }
    };
    this.audio.addEventListener("ended", halt);
    this.audio.addEventListener("pause", halt);
    if (randomizeStart) {
      this.audio.addEventListener("play", () => {
        if (this.audio.loop && this.audio.duration > 1) {
          const startTime = this.audio.duration * Math.random();
          this.audio.currentTime = startTime;
        }
      });
    }
    if (randomizePitch) {
      source.mediaElement.preservesPitch = false;
      this.audio.addEventListener("play", () => {
        source.mediaElement.playbackRate = 1 + 0.1 * (2 * Math.random() - 1);
      });
    }
    this.audio.addEventListener("play", () => {
      this.dispatchEvent(this.playEvt);
    });
    this.audio.addEventListener("timeupdate", () => {
      this.progEvt.value = this.audio.currentTime;
      this.progEvt.total = this.audio.duration;
      this.dispatchEvent(this.progEvt);
    });
    if (this.audio.autoplay) {
      this.play().catch(() => onUserGesture(() => this.play()));
    }
    mediaElementCanPlay(this.audio).then((success2) => this.dispatchEvent(success2 ? this.loadEvt : new MediaElementSourceErroredEvent(this, this.audio.error)));
  }
  onDisposing() {
    this.dispatchEvent(DISPOSING_EVT);
    super.onDisposing();
  }
  get playbackState() {
    if (this.audio.error) {
      return "errored";
    }
    if (this.audio.ended || this.audio.paused && this.audio.currentTime === 0) {
      return "stopped";
    }
    if (this.audio.paused) {
      return "paused";
    }
    return "playing";
  }
  async play() {
    this.enable();
    await this.context.ready;
    await this.audio.play();
  }
  async playThrough() {
    const endTask = once(this, "stopped");
    await this.play();
    await endTask;
  }
  pause() {
    this.disable();
    this.audio.pause();
  }
  stop() {
    this.audio.currentTime = 0;
    this.pause();
  }
  restart() {
    this.stop();
    return this.play();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/AudioStreamSource.ts
var AudioSourceAddedEvent = class extends TypedEvent {
  constructor(source) {
    super("sourceadded");
    this.source = source;
  }
};
var AudioStreamSource = class extends BaseAudioSource {
  constructor(context, spatializer, ...effectNames) {
    super("audio-stream-source", context, spatializer, effectNames);
    this._stream = null;
    this._node = null;
  }
  get stream() {
    return this._stream;
  }
  set stream(mediaStream) {
    if (mediaStream !== this.stream) {
      if (isDefined(this.stream)) {
        this.remove(this._node);
        dispose(this._node);
        this._node = null;
      }
      if (isDefined(mediaStream)) {
        this._node = new JuniperMediaStreamAudioSourceNode(
          this.context,
          {
            mediaStream
          }
        );
        this._node.name = stringToName("media-stream-source", mediaStream.id);
        this._node.connect(this.volumeControl);
        this.add(this._node);
        this.dispatchEvent(new AudioSourceAddedEvent(this));
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/spatializers/NoSpatializer.ts
var NoSpatializer = class extends BaseSpatializer {
  constructor(node) {
    super("no-spatializer", node.context, false, [node], [node]);
  }
  readPose(_loc) {
  }
  getGainAtDistance(_) {
    return 1;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/filterDeviceDuplicates.ts
function filterDeviceDuplicates(devices) {
  const filtered = [];
  for (let i = 0; i < devices.length; ++i) {
    const a = devices[i];
    let found = false;
    for (let j = 0; j < filtered.length && !found; ++j) {
      const b = filtered[j];
      found = a.kind === b.kind && b.label.indexOf(a.label) > 0;
    }
    if (!found) {
      filtered.push(a);
    }
  }
  return filtered;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/SpeakerManager.ts
var canChangeAudioOutput = /* @__PURE__ */ isFunction(HTMLAudioElement.prototype.setSinkId);
var AudioOutputChangedEvent = class extends TypedEvent {
  constructor(device) {
    super("audiooutputchanged");
    this.device = device;
  }
};
var PREFERRED_AUDIO_OUTPUT_ID_KEY = "calla:preferredAudioOutputID";
var SpeakerManager = class extends TypedEventBase {
  constructor(element) {
    super();
    this.element = element;
    this._hasAudioPermission = false;
    this._ready = new Task();
    this.start();
    Object.seal(this);
  }
  get hasAudioPermission() {
    return this._hasAudioPermission;
  }
  get ready() {
    return this._ready;
  }
  get isReady() {
    return this._ready.finished && this._ready.resolved;
  }
  async start() {
    if (canChangeAudioOutput) {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const anyDevice = arrayScan(devices, (dev) => dev.kind === "audiooutput" && dev.label.length > 0);
      if (isDefined(anyDevice)) {
        this._hasAudioPermission = true;
        const device = await this.getPreferredAudioOutput();
        if (device) {
          await this.setAudioOutputDevice(device);
        }
      }
    }
    this._ready.resolve();
  }
  get preferredAudioOutputID() {
    if (!canChangeAudioOutput) {
      return null;
    }
    return localStorage.getItem(PREFERRED_AUDIO_OUTPUT_ID_KEY);
  }
  async getAudioOutputDevices(filterDuplicates = false) {
    if (!canChangeAudioOutput) {
      return [];
    }
    const devices = await this.getAvailableDevices(filterDuplicates);
    return devices || [];
  }
  async getAudioOutputDevice() {
    if (!canChangeAudioOutput) {
      return null;
    }
    const curId = this.element && this.element.sinkId;
    if (isNullOrUndefined(curId)) {
      return null;
    }
    const devices = await this.getAudioOutputDevices(), device = arrayScan(
      devices,
      (d) => d.deviceId === curId
    );
    return device;
  }
  async getPreferredAudioOutput() {
    if (!canChangeAudioOutput) {
      return null;
    }
    const devices = await this.getAudioOutputDevices();
    const device = arrayScan(
      devices,
      (d) => d.deviceId === this.preferredAudioOutputID,
      (d) => d.deviceId === "default",
      (d) => d.deviceId.length > 0
    );
    return device;
  }
  async setAudioOutputDevice(device) {
    if (canChangeAudioOutput) {
      if (isDefined(device) && device.kind !== "audiooutput") {
        throw new Error(`Device is not an audio output device. Was: ${device.kind}. Label: ${device.label}`);
      }
      localStorage.setItem(PREFERRED_AUDIO_OUTPUT_ID_KEY, device && device.deviceId || null);
      const curDevice = this.element;
      const curDeviceID = curDevice && curDevice.sinkId;
      if (this.preferredAudioOutputID !== curDeviceID) {
        if (isDefined(this.preferredAudioOutputID)) {
          await this.element.setSinkId(this.preferredAudioOutputID);
        }
        this.dispatchEvent(new AudioOutputChangedEvent(device));
      }
    }
  }
  async getAvailableDevices(filterDuplicates = false) {
    let devices = null;
    let testStream = null;
    for (let i = 0; i < 3; ++i) {
      devices = await navigator.mediaDevices.enumerateDevices();
      for (const device of devices) {
        if (device.deviceId.length > 0) {
          if (!this.hasAudioPermission) {
            this._hasAudioPermission = device.kind === "audioinput" && device.label.length > 0;
          }
        }
      }
      if (this.hasAudioPermission) {
        break;
      }
      try {
        testStream = await this.startStream();
      } catch (exp2) {
        console.warn(exp2);
      }
    }
    if (testStream) {
      for (const track of testStream.getTracks()) {
        track.stop();
      }
    }
    devices = arraySortByKey(devices || [], (d) => d.label);
    if (filterDuplicates) {
      devices = filterDeviceDuplicates(devices);
    }
    return canChangeAudioOutput ? devices.filter((d) => d.kind === "audiooutput") : [];
  }
  startStream() {
    return navigator.mediaDevices.getUserMedia({
      audio: true
    });
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/AudioManager.ts
var USE_HEADPHONES_KEY = "juniper::useHeadphones";
var useHeadphonesToggledEvt = new TypedEvent("useheadphonestoggled");
var POOL_SIZE = 10;
var RELEASE_EVT = new TypedEvent("released");
var HAX_SRC = "data:audio/mpeg;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY29tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLm9yZwBURU5DAAAAHQAAA1N3aXRjaCBQbHVzIMKpIE5DSCBTb2Z0d2FyZQBUSVQyAAAABgAAAzIyMzUAVFNTRQAAAA8AAANMYXZmNTcuODMuMTAwAAAAAAAAAAAAAAD/80DEAAAAA0gAAAAATEFNRTMuMTAwVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQsRbAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/zQMSkAAADSAAAAABVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV";
var AudioManager = class extends BaseNodeCluster {
  /**
   * Creates a new manager of audio sources, destinations, and their spatialization.
   **/
  constructor(fetcher2, defaultLocalUserID) {
    const context = new JuniperAudioContext();
    if ("THREE" in globalThis) {
      globalThis.THREE.AudioContext.setContext(context);
    }
    const destination = new WebAudioDestination(context);
    const noSpatializer = new NoSpatializer(destination.nonSpatializedInput);
    const speakers = new SpeakerManager(destination.element);
    super("audio-manager", context, null, null, [noSpatializer, destination]);
    this.fetcher = fetcher2;
    this.users = /* @__PURE__ */ new Map();
    this.clips = /* @__PURE__ */ new Map();
    this.pendingAudio = new Array();
    this.audioPool = new Array();
    this.elements = /* @__PURE__ */ new Map();
    this.elementCounts = /* @__PURE__ */ new Map();
    this._minDistance = 0.25;
    this._maxDistance = 100;
    this._algorithm = "inverse";
    this._useHeadphones = false;
    this.destination = null;
    this._ready = new Task();
    this.localUserID = null;
    this.destination = destination;
    this.noSpatializer = noSpatializer;
    this.speakers = speakers;
    all(
      this.context.ready,
      this.destination.ready,
      this.speakers.ready
    ).then(() => this._ready.resolve());
    this.setLocalUserID(defaultLocalUserID);
    const useHeadphones = localStorage.getItem(USE_HEADPHONES_KEY);
    if (isDefined(useHeadphones)) {
      this._useHeadphones = useHeadphones === "true";
    } else {
      this._useHeadphones = isMobileVR();
    }
    this.enpool();
    if (isIOS()) {
      onUserGesture(() => {
        const depooling = [...this.pendingAudio];
        arrayClear(this.pendingAudio);
        for (const p of depooling) {
          p();
        }
      }, true);
    }
    Object.seal(this);
  }
  get algorithm() {
    return this._algorithm;
  }
  get element() {
    return this.destination.element;
  }
  get ready() {
    return this._ready;
  }
  get isReady() {
    return this._ready.finished && this._ready.resolved;
  }
  enpool() {
    for (let i = 0; i < POOL_SIZE; ++i) {
      const task = new Task();
      const audio2 = Audio2(
        src(HAX_SRC),
        controls(false),
        onEvent("released", () => {
          audio2.pause();
          audio2.src = HAX_SRC;
        })
      );
      this.audioPool.push(task);
      if (isIOS()) {
        this.pendingAudio.push(() => {
          audio2.play();
          task.resolve(audio2);
        });
      } else {
        task.resolve(audio2);
      }
    }
  }
  preparePool(size4) {
    while (this.audioPool.length < size4) {
      this.enpool();
    }
  }
  async getPooledAudio(...rest) {
    if (this.audioPool.length === 0) {
      throw new Exception("Audio pool exhausted!");
    }
    const audioTask = this.audioPool.shift();
    if (this.audioPool.length <= POOL_SIZE / 2) {
      this.enpool();
    }
    const audio2 = await audioTask;
    audio2.pause();
    elementApply(audio2, ...rest);
    return audio2;
  }
  async getPooledSource(key, path, looping) {
    if (!this.elements.has(key)) {
      const mediaElement = await this.getPooledAudio(
        src(path),
        loop(looping && !isIOS())
      );
      if (isIOS() && looping) {
        mediaElement.addEventListener("ended", () => mediaElement.play());
      }
      const node = new JuniperMediaElementAudioSourceNode(
        this.context,
        { mediaElement }
      );
      node.name = stringToName("media-element-source", key);
      this.elements.set(key, node);
      this.elementCounts.set(key, 0);
    }
    const source = this.elements.get(key);
    this.elementCounts.set(key, this.elementCounts.get(key) + 1);
    return source;
  }
  releasePooledSource(key) {
    const source = this.elements.get(key);
    this.elementCounts.set(key, this.elementCounts.get(key) - 1);
    if (this.elementCounts.get(key) === 0) {
      source.mediaElement.dispatchEvent(RELEASE_EVT);
      this.elementCounts.delete(key);
      this.elements.delete(key);
    }
  }
  get useHeadphones() {
    return this._useHeadphones;
  }
  set useHeadphones(v) {
    if (v !== this.useHeadphones) {
      this._useHeadphones = v;
      localStorage.setItem(USE_HEADPHONES_KEY, this.useHeadphones.toString());
      this.dispatchEvent(useHeadphonesToggledEvt);
    }
  }
  onDisposing() {
    this.context.suspend();
    for (const userID of this.users.keys()) {
      this.removeUser(userID);
    }
    for (const clipID of this.clips.keys()) {
      this.removeClip(clipID);
    }
    super.onDisposing();
  }
  /**
   * Gets the current playback time.
   */
  get currentTime() {
    return this.context.currentTime;
  }
  /**
   * Creates a spatialzer for an audio source.
   * @param spatialize - whether the audio stream should be spatialized. Stereo audio streams that are spatialized will get down-mixed to a single channel.
   * @param isRemoteStream - whether the audio stream is coming from a remote user.
   */
  createSpatializer(spatialize, isRemoteStream) {
    if (!spatialize) {
      return this.noSpatializer;
    } else {
      const spatializer = this.destination.createSpatializer(isRemoteStream);
      spatializer.setAudioProperties(this._minDistance, this._maxDistance, this._algorithm);
      return spatializer;
    }
  }
  /**
   * Create a new user for audio processing.
   */
  createUser(userID, userName) {
    if (!this.users.has(userID)) {
      const user = new AudioStreamSource(this.context, this.createSpatializer(true, true));
      user.name = stringToName(userName, userID);
      this.users.set(userID, user);
    }
    return this.users.get(userID);
  }
  /**
   * Create a new user for the audio listener.
   */
  setLocalUserID(id2) {
    if (this.destination) {
      this.localUserID = id2;
    }
    return this.destination;
  }
  createBasicClip(id2, asset, vol) {
    return this.createClip(id2, asset, false, false, false, true, vol, []);
  }
  hasClip(id2) {
    return this.clips.has(id2);
  }
  /**
   * Creates a new sound effect from a series of fallback paths
   * for media files.
   * @param id - the name of the sound effect, to reference when executing playback.
   * @param asset - the element to register as a clip
   * @param looping - whether the sound effect should be played on loop.
   * @param spatialize - whether the sound effect should be spatialized.
   * @param randomizeStart - whether the looping sound effect should be started somewhere in the middle.
   * @param randomizePitch - whether the sound effect should be pitch-bent whenever it is played.
   * @param vol - the volume at which to set the clip.
   * @param effectNames - names of pre-canned effects to load on the control.
   * @param path - a path for loading the media of the sound effect, or the sound effect that has already been loaded.
   * @param prog - an optional callback function to use for tracking progress of loading the clip.
   */
  async createClip(id2, asset, looping, spatialize, randomizeStart, randomizePitch, vol, effectNames, prog) {
    await this.ready;
    let key;
    let path;
    if (isString(asset)) {
      key = asset;
      path = await this.fetcher.get(asset).progress(prog).file().then(unwrapResponse);
    } else {
      key = asset.path;
      path = asset.result;
    }
    const source = await this.getPooledSource(key, path, looping);
    const clip = new AudioElementSource(
      this.context,
      source,
      randomizeStart,
      randomizePitch,
      this.createSpatializer(spatialize, false),
      ...effectNames
    );
    clip.addEventListener("disposing", () => this.releasePooledSource(key));
    clip.name = stringToName("audio-clip-element", id2);
    clip.volume = vol;
    this.clips.set(id2, clip);
    return clip;
  }
  /**
   * Plays a named sound effect, with the returned promise resolving when the clip has started playing.
   * @param id - the name of the effect to play.
   */
  async playClip(id2) {
    if (this.hasClip(id2)) {
      const clip = this.clips.get(id2);
      await clip.play();
    }
  }
  /**
   * Plays a named sound effect, with the returned promise resolving when the clip has finished playing.
   * @param id - the name of the effect to play.
   */
  async playClipThrough(id2) {
    if (this.hasClip(id2)) {
      const clip = this.clips.get(id2);
      await clip.playThrough();
    }
  }
  stopClip(id2) {
    if (this.hasClip(id2)) {
      const clip = this.clips.get(id2);
      clip.stop();
    }
  }
  /**
   * Get an existing user.
   */
  getUser(userID) {
    return this.users.get(userID);
  }
  /**
   * Get an existing audio clip.
   */
  getClip(id2) {
    return this.clips.get(id2);
  }
  /**
   * Remove an audio source from audio processing.
   * @param sources - the collection of audio sources from which to remove.
   * @param id - the id of the audio source to remove
   **/
  removeSource(sources, id2) {
    const source = sources.get(id2);
    if (isDefined(source)) {
      sources.delete(id2);
      dispose(source);
    }
    return source;
  }
  /**
   * Remove a user from audio processing.
   **/
  removeUser(userID) {
    const user = this.removeSource(this.users, userID);
    if (isDefined(user.stream)) {
      user.stream = null;
    }
  }
  /**
   * Remove an audio clip from audio processing.
   **/
  removeClip(id2) {
    const clip = this.removeSource(this.clips, id2);
    dispose(clip);
    return clip;
  }
  setUserStream(userID, stream) {
    if (this.users.has(userID)) {
      const user = this.users.get(userID);
      user.stream = stream;
    }
  }
  /**
   * Sets parameters that alter spatialization.
   **/
  setAudioProperties(minDistance, maxDistance, algorithm) {
    this._minDistance = minDistance;
    this._maxDistance = maxDistance;
    this._algorithm = algorithm;
    for (const user of this.users.values()) {
      user.setAudioProperties(this._minDistance, this._maxDistance, this.algorithm);
    }
    for (const clip of this.clips.values()) {
      clip.setAudioProperties(clip.minDistance, clip.maxDistance, this.algorithm);
    }
  }
  /**
   * Get a pose, normalize the transition time, and perform on operation on it, if it exists.
   * @param sources - the collection of poses from which to retrieve the pose.
   * @param id - the id of the pose for which to perform the operation.
   * @param poseCallback
   */
  withPoser(sources, id2, poseCallback) {
    const source = sources.get(id2);
    const poser = source || this.destination;
    return poseCallback(poser);
  }
  /**
   * Get a user pose, normalize the transition time, and perform on operation on it, if it exists.
   * @param id - the id of the user for which to perform the operation.
   * @param poseCallback
   */
  withUser(id2, poseCallback) {
    return this.withPoser(this.users, id2, poseCallback);
  }
  /**
   * Get an audio clip pose, normalize the transition time, and perform on operation on it, if it exists.
   * @param id - the id of the audio clip for which to perform the operation.
   * @param dt - the amount of time to take to make the transition. Defaults to this AudioManager's `transitionTime`.
   * @param poseCallback
   */
  withClip(id2, poseCallback) {
    return this.withPoser(this.clips, id2, poseCallback);
  }
  /**
   * Set the position and orientation of a user.
   * @param id - the id of the user for which to set the position.
   * @param px - the horizontal component of the position.
   * @param py - the vertical component of the position.
   * @param pz - the lateral component of the position.
   * @param qx - the rotation quaternion x component.
   * @param qy - the rotation quaternion y component.
   * @param qz - the rotation quaternion z component.
   * @param qw - the rotation quaternion w component.
   **/
  setUserPose(id2, px2, py, pz, qx, qy, qz, qw) {
    this.withUser(id2, (poser) => {
      poser.set(px2, py, pz, qx, qy, qz, qw);
    });
  }
  /**
   * Set the position and orientation of a user.
   * @param id - the id of the user for which to set the position.
   * @param px - the horizontal component of the position.
   * @param py - the vertical component of the position.
   * @param pz - the lateral component of the position.
   **/
  setUserPosition(id2, px2, py, pz) {
    this.withUser(id2, (poser) => {
      poser.setPosition(px2, py, pz);
    });
  }
  /**
   * Set the position and orientation of a user.
   * @param id - the id of the user for which to set the position.
   * @param qx - the rotation quaternion x component.
   * @param qy - the rotation quaternion y component.
   * @param qz - the rotation quaternion z component.
   * @param qw - the rotation quaternion w component.
   **/
  setUserOrientation(id2, qx, qy, qz, qw) {
    this.withUser(id2, (poser) => {
      poser.setOrientation(qx, qy, qz, qw);
    });
  }
  /**
   * Set the position and orientation of an audio clip.
   * @param id - the id of the audio clip for which to set the position.
   * @param px - the horizontal component of the position.
   * @param py - the vertical component of the position.
   * @param pz - the lateral component of the position.
   * @param qx - the rotation quaternion x component.
   * @param qy - the rotation quaternion y component.
   * @param qz - the rotation quaternion z component.
   * @param qw - the rotation quaternion w component.
   **/
  setClipPose(id2, px2, py, pz, qx, qy, qz, qw) {
    this.withClip(id2, (poser) => {
      poser.set(px2, py, pz, qx, qy, qz, qw);
    });
  }
  /**
   * Set the position and orientation of a clip.
   * @param id - the id of the user for which to set the position.
   * @param px - the horizontal component of the position.
   * @param py - the vertical component of the position.
   * @param pz - the lateral component of the position.
   **/
  setClipPosition(id2, px2, py, pz) {
    this.withClip(id2, (poser) => {
      poser.setPosition(px2, py, pz);
    });
  }
  /**
   * Set the position and orientation of a clip.
   * @param id - the id of the user for which to set the position.
   * @param qx - the rotation quaternion x component.
   * @param qy - the rotation quaternion y component.
   * @param qz - the rotation quaternion z component.
   * @param qw - the rotation quaternion w component.
   **/
  setClipOrientation(id2, qx, qy, qz, qw) {
    this.withClip(id2, (poser) => {
      poser.setOrientation(qx, qy, qz, qw);
    });
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/DeviceManager.ts
var DeviceSettingsChangedEvent = class extends TypedEvent {
  constructor() {
    super("devicesettingschanged");
  }
};
var DeviceManager = class {
  constructor(...managers) {
    this.permissed = /* @__PURE__ */ new Set();
    this.managers = managers;
  }
  get hasPermissions() {
    for (const manager of this.managers) {
      if (!this.permissed.has(manager)) {
        return false;
      }
    }
    return true;
  }
  async init() {
    if (!this.hasPermissions) {
      const devices = await this.getDevices();
      await Promise.all(this.managers.map((m) => m.setDevice(
        arrayScan(
          devices,
          (d) => d.kind === m.deviceKind && d.deviceId === m.preferredDeviceID,
          (d) => d.kind === m.deviceKind && d.deviceId === "default",
          (d) => d.kind === m.deviceKind && d.deviceId.length > 0
        )
      )));
    }
  }
  async getDevices(filterDuplicates = false) {
    let devices = null;
    let testStream = null;
    for (let i = 0; i < 3; ++i) {
      devices = await navigator.mediaDevices.enumerateDevices();
      if (!this.hasPermissions) {
        const constraints = {};
        for (const manager of this.managers) {
          if (!this.permissed.has(manager)) {
            for (const device of devices) {
              if (device.kind === manager.deviceKind && device.deviceId.length > 0 && device.label.length > 0) {
                this.permissed.add(manager);
                break;
              }
            }
            if (!this.permissed.has(manager)) {
              constraints[manager.mediaType] = true;
            }
          }
        }
        if (!this.hasPermissions) {
          try {
            testStream = await navigator.mediaDevices.getUserMedia(constraints);
          } catch (exp2) {
            console.warn(exp2);
          }
        }
      }
    }
    if (testStream) {
      for (const track of testStream.getTracks()) {
        track.stop();
      }
    }
    devices = arraySortByKey(devices || [], (d) => d.label);
    if (filterDuplicates) {
      devices = filterDeviceDuplicates(devices);
    }
    return devices;
  }
  get outStreams() {
    return this.managers.map((m) => m.outStream);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/StreamChangedEvent.ts
var StreamChangedEvent = class extends TypedEvent {
  constructor(oldStream, newStream) {
    super("streamchanged");
    this.oldStream = oldStream;
    this.newStream = newStream;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/LocalUserMicrophone.ts
var PREFERRED_AUDIO_INPUT_ID_KEY = "calla:preferredAudioInputID";
var LocalUserMicrophone = class extends BaseNodeCluster {
  constructor(context) {
    const volume = context.createGain();
    volume.name = "local-mic-user-gain";
    const autoGainNode = context.createGain();
    autoGainNode.name = "local-mic-auto-gain";
    const filter = new JuniperBiquadFilterNode(context, {
      type: "bandpass",
      frequency: 1500,
      Q: 0.25
    });
    filter.name = "local-mic-filter";
    const compressor = new JuniperDynamicsCompressorNode(context, {
      threshold: -15,
      knee: 40,
      ratio: 17
    });
    compressor.name = "local-mic-compressor";
    const localOutput = new JuniperMediaStreamAudioDestinationNode(context);
    localOutput.name = "local-mic-destination";
    super("local-user-microphone", context, [], [compressor], [
      volume,
      filter,
      localOutput
    ]);
    this.localStreamNode = null;
    this._hasPermission = false;
    this._usingHeadphones = false;
    this._device = null;
    this._enabled = false;
    this.volume = volume;
    this.autoGainNode = autoGainNode;
    this.compressor = compressor;
    this.output = localOutput;
    volume.connect(autoGainNode).connect(filter).connect(compressor).connect(localOutput);
    Object.seal(this);
  }
  get mediaType() {
    return "audio";
  }
  get deviceKind() {
    return `${this.mediaType}input`;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(v) {
    if (v !== this.enabled) {
      this._enabled = v;
      this.onChange();
    }
  }
  get hasPermission() {
    return this._hasPermission;
  }
  get preferredDeviceID() {
    return localStorage.getItem(PREFERRED_AUDIO_INPUT_ID_KEY);
  }
  get device() {
    return this._device;
  }
  async setDevice(device) {
    if (isDefined(device) && device.kind !== this.deviceKind) {
      throw new Error(`Device is not an audio input device. Was: ${device.kind}. Label: ${device.label}`);
    }
    const curAudioID = this.device && this.device.deviceId || null;
    const nextAudioID = device && device.deviceId || null;
    if (nextAudioID !== curAudioID) {
      this._device = device;
      localStorage.setItem(PREFERRED_AUDIO_INPUT_ID_KEY, nextAudioID);
      this.onChange();
    }
  }
  get inStream() {
    return this.localStreamNode && this.localStreamNode.mediaStream || null;
  }
  set inStream(mediaStream) {
    if (mediaStream !== this.inStream) {
      if (this.localStreamNode) {
        this.remove(this.localStreamNode);
        dispose(this.localStreamNode);
        this.localStreamNode = null;
      }
      if (mediaStream) {
        this.localStreamNode = new JuniperMediaStreamAudioSourceNode(this.context, {
          mediaStream
        });
        this.add(this.localStreamNode);
        this.localStreamNode.connect(this.volume);
      }
    }
  }
  get outStream() {
    return this.output.stream;
  }
  get gain() {
    return this.volume.gain;
  }
  get muted() {
    return this.compressor.isConnected(this.output);
  }
  set muted(v) {
    if (v !== this.muted) {
      if (v) {
        this.compressor.connect(this.output);
      } else {
        this.compressor.disconnect(this.output);
      }
    }
  }
  get usingHeadphones() {
    return this._usingHeadphones;
  }
  set usingHeadphones(v) {
    if (v !== this.usingHeadphones) {
      this._usingHeadphones = v;
      this.onChange();
    }
  }
  async onChange() {
    this.dispatchEvent(new DeviceSettingsChangedEvent());
    const oldStream = this.inStream;
    if (this.device && this.enabled) {
      this.inStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          deviceId: this.device.deviceId,
          echoCancellation: !this.usingHeadphones,
          autoGainControl: true,
          noiseSuppression: true
        }
      });
    } else {
      this.inStream = null;
    }
    if (this.inStream !== oldStream) {
      this.dispatchEvent(new StreamChangedEvent(oldStream, this.outStream));
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/URLBuilder.ts
function parsePort(portString) {
  if (isDefined(portString) && portString.length > 0) {
    return parseFloat(portString);
  }
  return null;
}
var URLBuilder = class {
  constructor(url2, base) {
    this._url = null;
    this._base = void 0;
    this._protocol = null;
    this._host = null;
    this._hostName = null;
    this._userName = null;
    this._password = null;
    this._port = null;
    this._pathName = null;
    this._hash = null;
    this._query = /* @__PURE__ */ new Map();
    if (url2 !== void 0) {
      this._url = new URL(url2, base);
      this.rehydrate();
    }
  }
  rehydrate() {
    if (isDefined(this._protocol) && this._protocol !== this._url.protocol) {
      this._url.protocol = this._protocol;
    }
    if (isDefined(this._host) && this._host !== this._url.host) {
      this._url.host = this._host;
    }
    if (isDefined(this._hostName) && this._hostName !== this._url.hostname) {
      this._url.hostname = this._hostName;
    }
    if (isDefined(this._userName) && this._userName !== this._url.username) {
      this._url.username = this._userName;
    }
    if (isDefined(this._password) && this._password !== this._url.password) {
      this._url.password = this._password;
    }
    if (isDefined(this._port) && this._port.toFixed(0) !== this._url.port) {
      this._url.port = this._port.toFixed(0);
    }
    if (isDefined(this._pathName) && this._pathName !== this._url.pathname) {
      this._url.pathname = this._pathName;
    }
    if (isDefined(this._hash) && this._hash !== this._url.hash) {
      this._url.hash = this._hash;
    }
    for (const [k, v] of this._query) {
      this._url.searchParams.set(k, v);
    }
    this._protocol = this._url.protocol;
    this._host = this._url.host;
    this._hostName = this._url.hostname;
    this._userName = this._url.username;
    this._password = this._url.password;
    this._port = parsePort(this._url.port);
    this._pathName = this._url.pathname;
    this._hash = this._url.hash;
    this._url.searchParams.forEach((v, k) => this._query.set(k, v));
  }
  refresh() {
    if (this._url === null) {
      if (isDefined(this._protocol) && (isDefined(this._host) || isDefined(this._hostName))) {
        if (isDefined(this._host)) {
          this._url = new URL(`${this._protocol}//${this._host}`, this._base);
          this._port = parsePort(this._url.port);
          this.rehydrate();
          return false;
        } else if (isDefined(this._hostName)) {
          this._url = new URL(`${this._protocol}//${this._hostName}`, this._base);
          this.rehydrate();
          return false;
        }
      } else if (isDefined(this._pathName) && isDefined(this._base)) {
        this._url = new URL(this._pathName, this._base);
        this.rehydrate();
        return false;
      }
    }
    return isDefined(this._url);
  }
  base(base) {
    if (this._url !== null) {
      throw new Error("Cannot redefine base after defining the protocol and domain");
    }
    this._base = base;
    this.refresh();
    return this;
  }
  protocol(protocol) {
    this._protocol = protocol;
    if (this.refresh()) {
      this._url.protocol = protocol;
    }
    return this;
  }
  host(host) {
    this._host = host;
    if (this.refresh()) {
      this._url.host = host;
      this._hostName = this._url.hostname;
      this._port = parsePort(this._url.port);
    }
    return this;
  }
  hostName(hostName) {
    this._hostName = hostName;
    if (this.refresh()) {
      this._url.hostname = hostName;
      this._host = `${this._url.hostname}:${this._url.port}`;
    }
    return this;
  }
  port(port) {
    this._port = port;
    if (this.refresh()) {
      this._url.port = port.toFixed(0);
      this._host = `${this._url.hostname}:${this._url.port}`;
    }
    return this;
  }
  userName(userName) {
    this._userName = userName;
    if (this.refresh()) {
      this._url.username = userName;
    }
    return this;
  }
  password(password) {
    this._password = password;
    if (this.refresh()) {
      this._url.password = password;
    }
    return this;
  }
  path(path) {
    this._pathName = path;
    if (this.refresh()) {
      this._url.pathname = path;
    }
    return this;
  }
  pathPop(pattern) {
    pattern = pattern || /\/[^/]+\/?$/;
    return this.path(this._pathName.replace(pattern, ""));
  }
  pathPush(part) {
    let path = this._pathName;
    if (!path.endsWith("/")) {
      path += "/";
    }
    path += part;
    return this.path(path);
  }
  query(name3, value2) {
    this._query.set(name3, value2);
    if (this.refresh()) {
      this._url.searchParams.set(name3, value2);
    }
    return this;
  }
  hash(hash) {
    this._hash = hash;
    if (this.refresh()) {
      this._url.hash = hash;
    }
    return this;
  }
  toURL() {
    return this._url;
  }
  toString() {
    return this._url.href;
  }
  [Symbol.toStringTag]() {
    return this.toString();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/IPlayer.ts
var MediaPlayerEvent = class extends MediaElementSourceEvent {
  constructor(type2, source) {
    super(type2, source);
  }
};
var MediaPlayerLoadingEvent = class extends MediaPlayerEvent {
  constructor(source) {
    super("loading", source);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/sources/AudioPlayer.ts
var AudioPlayer = class extends BaseAudioSource {
  constructor(context, spatializer) {
    const mediaElement = Audio2(
      autoPlay(false),
      loop(false),
      controls(true)
    );
    const elementNode = new JuniperMediaElementAudioSourceNode(context, {
      mediaElement
    });
    elementNode.name = "JuniperAudioPlayer-Input";
    super("audio-player", context, spatializer, [], [elementNode]);
    this.cacheBustSources = /* @__PURE__ */ new Map();
    this._data = null;
    this._loaded = false;
    this.sourcesByURL = /* @__PURE__ */ new Map();
    this.sources = new Array();
    this.potatoes = new Array();
    elementNode.connect(this.volumeControl);
    this.element = mediaElement;
    this.loadingEvt = new MediaPlayerLoadingEvent(this);
    this.loadEvt = new MediaElementSourceLoadedEvent(this);
    this.playEvt = new MediaElementSourcePlayedEvent(this);
    this.pauseEvt = new MediaElementSourcePausedEvent(this);
    this.stopEvt = new MediaElementSourceStoppedEvent(this);
    this.progEvt = new MediaElementSourceProgressEvent(this);
    this.onPlay = async () => {
      this.enable();
      this.dispatchEvent(this.playEvt);
    };
    this.onPause = (evt) => {
      this.disable();
      if (this.element.currentTime === 0 || evt.type === "ended") {
        this.dispatchEvent(this.stopEvt);
      } else {
        this.dispatchEvent(this.pauseEvt);
      }
    };
    this.onTimeUpdate = async () => {
      this.progEvt.value = this.element.currentTime;
      this.progEvt.total = this.element.duration;
      this.dispatchEvent(this.progEvt);
    };
    this.onError = () => this.loadAudio();
    this.element.addEventListener("play", this.onPlay);
    this.element.addEventListener("pause", this.onPause);
    this.element.addEventListener("ended", this.onPause);
    this.element.addEventListener("error", this.onError);
    this.element.addEventListener("waiting", this.onWaiting);
    this.element.addEventListener("canplay", this.onCanPlay);
    this.element.addEventListener("timeupdate", this.onTimeUpdate);
    Object.assign(window, { audioPlayer: this });
  }
  get data() {
    return this._data;
  }
  get loaded() {
    return this._loaded;
  }
  get title() {
    return this.element.title;
  }
  setTitle(v) {
    this.element.title = v;
  }
  get hasAudio() {
    const source = this.sourcesByURL.get(this.element.src);
    return isDefined(source) && source.acodec !== "none" || isDefined(this.element.audioTracks) && this.element.audioTracks.length > 0 || isDefined(this.element.webkitAudioDecodedByteCount) && this.element.webkitAudioDecodedByteCount > 0 || isDefined(this.element.mozHasAudio) && this.element.mozHasAudio;
  }
  onDisposing() {
    super.onDisposing();
    this.clear();
    this.element.removeEventListener("play", this.onPlay);
    this.element.removeEventListener("pause", this.onPause);
    this.element.removeEventListener("ended", this.onPause);
    this.element.removeEventListener("error", this.onError);
    this.element.removeEventListener("waiting", this.onWaiting);
    this.element.removeEventListener("canplay", this.onCanPlay);
    this.element.removeEventListener("timeupdate", this.onTimeUpdate);
    this.element.dispatchEvent(RELEASE_EVT);
  }
  clear() {
    this.stop();
    this.sourcesByURL.clear();
    arrayClear(this.sources);
    arrayClear(this.potatoes);
    this.element.src = "";
    this._data = null;
    this._loaded = false;
  }
  cacheBust(data) {
    const curCount = this.cacheBustSources.get(data) || 0;
    this.cacheBustSources.set(data, curCount + 1);
  }
  async load(data, prog) {
    this.clear();
    this._data = data;
    if (isString(data)) {
      this.setTitle(data);
      this.potatoes.push(data);
    } else {
      this.setTitle(data.title);
      arraySortByKeyInPlace(data.audios, (f2) => -f2.resolution);
      arrayReplace(this.sources, ...data.audios);
    }
    for (const audio2 of this.sources) {
      this.sourcesByURL.set(audio2.url, audio2);
    }
    if (!this.hasSources) {
      throw new Error("No audio sources");
    }
    this.dispatchEvent(this.loadingEvt);
    await this.loadAudio(prog);
    if (!this.hasSources) {
      throw new Error("No audio sources");
    }
    this._loaded = true;
    this.dispatchEvent(this.loadEvt);
    return this;
  }
  async getMediaCapabilities(source) {
    const config = {
      type: "file",
      audio: {
        contentType: source.contentType,
        bitrate: source.abr * 1024,
        samplerate: source.asr
      }
    };
    try {
      return await navigator.mediaCapabilities.decodingInfo(config);
    } catch {
      return {
        supported: true,
        powerEfficient: false,
        smooth: false,
        configuration: config
      };
    }
  }
  get hasSources() {
    return this.sources.length > 0 || this.potatoes.length > 0;
  }
  async loadAudio(prog) {
    if (isDefined(prog)) {
      prog.start();
    }
    this.element.removeEventListener("error", this.onError);
    while (this.hasSources) {
      let url2 = null;
      const source = this.sources.shift();
      if (isDefined(source)) {
        const caps = await this.getMediaCapabilities(source);
        if (!caps.smooth || !caps.powerEfficient) {
          this.potatoes.push(source.url);
          continue;
        } else {
          url2 = source.url;
        }
      } else {
        url2 = this.potatoes.shift();
      }
      const cacheV = this.cacheBustSources.get(this.data);
      if (isDefined(cacheV)) {
        const uri = new URLBuilder(url2, location.href);
        uri.query("v", cacheV.toString());
        url2 = uri.toString();
      }
      this.element.src = url2;
      this.element.load();
      if (await mediaElementCanPlayThrough(this.element)) {
        if (isDefined(source)) {
          this.sources.unshift(source);
        } else {
          this.potatoes.unshift(url2);
        }
        this.element.addEventListener("error", this.onError);
        if (isDefined(prog)) {
          prog.end();
        }
        return;
      }
    }
  }
  get playbackState() {
    if (isNullOrUndefined(this.data)) {
      return "empty";
    }
    if (!this.loaded) {
      return "loading";
    }
    if (this.element.error) {
      return "errored";
    }
    if (this.element.ended || this.element.paused && this.element.currentTime === 0) {
      return "stopped";
    }
    if (this.element.paused) {
      return "paused";
    }
    return "playing";
  }
  async play() {
    await this.context.ready;
    await this.element.play();
  }
  async playThrough() {
    const endTask = once(this, "stopped");
    await this.play();
    await endTask;
  }
  pause() {
    this.element.pause();
  }
  stop() {
    this.pause();
    this.element.currentTime = 0;
  }
  restart() {
    this.stop();
    return this.play();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/CanvasImage.ts
var CanvasImage = class extends TypedEventBase {
  constructor(width2, height2, options) {
    super();
    this._scale = 250;
    this._visible = true;
    this.wasVisible = null;
    this.redrawnEvt = new TypedEvent("redrawn");
    this.element = null;
    if (isDefined(options)) {
      if (isDefined(options.scale)) {
        this._scale = options.scale;
      }
    }
    this._canvas = createUICanvas(width2, height2);
    this._g = this.canvas.getContext("2d");
    if (isHTMLCanvas(this._canvas)) {
      this.element = this._canvas;
    }
  }
  fillRect(color2, x, y, width2, height2, margin2) {
    this.g.fillStyle = color2;
    this.g.fillRect(x + margin2, y + margin2, width2 - 2 * margin2, height2 - 2 * margin2);
  }
  drawText(text2, x, y, align) {
    this.g.textAlign = align;
    this.g.strokeText(text2, x, y);
    this.g.fillText(text2, x, y);
  }
  redraw() {
    if ((this.visible || this.wasVisible) && this.onRedraw()) {
      this.wasVisible = this.visible;
      this.dispatchEvent(this.redrawnEvt);
    }
  }
  onClear() {
    this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  clear() {
    this.onClear();
    this.dispatchEvent(this.redrawnEvt);
  }
  get canvas() {
    return this._canvas;
  }
  get g() {
    return this._g;
  }
  get imageWidth() {
    return this.canvas.width;
  }
  get imageHeight() {
    return this.canvas.height;
  }
  get aspectRatio() {
    return this.imageWidth / this.imageHeight;
  }
  get width() {
    return this.imageWidth / this.scale;
  }
  get height() {
    return this.imageHeight / this.scale;
  }
  get scale() {
    return this._scale;
  }
  set scale(v) {
    if (this.scale !== v) {
      this._scale = v;
      this.redraw();
    }
  }
  get visible() {
    return this._visible;
  }
  set visible(v) {
    if (this.visible !== v) {
      this.wasVisible = this._visible;
      this._visible = v;
      this.redraw();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/ArtificialHorizon.ts
var ArtificialHorizon = class extends CanvasImage {
  constructor() {
    super(128, 128);
    this._pitchDegrees = 0;
    this._headingDegrees = 0;
    this.redraw();
  }
  get pitchDegrees() {
    return this._pitchDegrees;
  }
  set pitchDegrees(v) {
    if (v !== this.pitchDegrees) {
      this._pitchDegrees = v;
      this.redraw();
    }
  }
  get headingDegrees() {
    return this._headingDegrees;
  }
  set headingDegrees(v) {
    if (v !== this.headingDegrees) {
      this._headingDegrees = v;
      this.redraw();
    }
  }
  setPitchAndHeading(pitchDegrees, headingDegrees) {
    if (pitchDegrees !== this.pitchDegrees || headingDegrees !== this.headingDegrees) {
      this._pitchDegrees = pitchDegrees;
      this._headingDegrees = headingDegrees;
      this.redraw();
    }
  }
  onRedraw() {
    const a = deg2rad(this.pitchDegrees);
    const b = deg2rad(this.headingDegrees - 180);
    const p = 5;
    const w = this.canvas.width - 2 * p;
    const h = this.canvas.height - 2 * p;
    const hw = 0.5 * w;
    const hh = 0.5 * h;
    const y = Math.sin(a);
    const g = this.g;
    g.save();
    {
      g.clearRect(0, 0, this.canvas.width, this.canvas.height);
      g.translate(p, p);
      g.scale(hw, hh);
      g.translate(1, 1);
      g.fillStyle = "gray";
      g.beginPath();
      g.arc(0, 0, 1, 0, Tau);
      g.fill();
      g.fillStyle = "lightgrey";
      g.beginPath();
      g.arc(0, 0, 1, 0, Pi, true);
      g.fill();
      g.save();
      {
        g.scale(1, Math.abs(y));
        if (y < 0) {
          g.fillStyle = "gray";
        }
        g.beginPath();
        g.arc(0, 0, 1, 0, Pi, y < 0);
        g.fill();
      }
      g.restore();
      g.save();
      {
        g.shadowColor = rgb(64, 64, 64);
        g.shadowBlur = 4;
        g.shadowOffsetX = 3;
        g.shadowOffsetY = 3;
        g.rotate(b);
        g.fillStyle = "red";
        g.beginPath();
        g.moveTo(-0.1, 0);
        g.lineTo(0, -0.667);
        g.lineTo(0.1, 0);
        g.closePath();
        g.fill();
        g.fillStyle = "white";
        g.beginPath();
        g.moveTo(-0.1, 0);
        g.lineTo(0, 0.667);
        g.lineTo(0.1, 0);
        g.closePath();
        g.fill();
      }
      g.restore();
      g.beginPath();
      g.strokeStyle = "black";
      g.lineWidth = 0.1;
      g.arc(0, 0, 1, 0, Tau);
      g.stroke();
    }
    g.restore();
    return true;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapBuild.ts
function mapBuild(items, makeValue) {
  return mapMap(items, identity, makeValue);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/timers/ITimer.ts
var BaseTimerTickEvent = class extends TypedEvent {
  constructor() {
    super("update");
    this.t = 0;
    this.dt = 0;
    this.sdt = 0;
    this.fps = 0;
  }
  set(t2, dt) {
    this.t = t2;
    this.dt = dt;
    this.sdt = lerp5(this.sdt, dt, 0.01);
    if (dt > 0) {
      this.fps = 1e3 / dt;
    }
  }
};
var TimerTickEvent = class extends BaseTimerTickEvent {
  constructor() {
    super();
    Object.seal(this);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/timers/BaseTimer.ts
var BaseTimer = class {
  constructor(targetFrameRate) {
    this.timer = null;
    this.lt = -1;
    this.tickHandlers = new Array();
    this._targetFPS = null;
    this.targetFPS = targetFrameRate;
    const tickEvt = new TimerTickEvent();
    let dt = 0;
    this.onTick = (t2) => {
      if (this.lt >= 0) {
        dt = t2 - this.lt;
        tickEvt.set(t2, dt);
        this.tick(tickEvt);
      }
      this.lt = t2;
    };
  }
  get targetFPS() {
    return this._targetFPS;
  }
  set targetFPS(v) {
    this._targetFPS = v;
  }
  addTickHandler(onTick) {
    this.tickHandlers.push(onTick);
  }
  removeTickHandler(onTick) {
    arrayRemove(this.tickHandlers, onTick);
  }
  tick(evt) {
    for (const handler of this.tickHandlers) {
      handler(evt);
    }
  }
  restart() {
    this.stop();
    this.start();
  }
  get isRunning() {
    return this.timer != null;
  }
  stop() {
    this.timer = null;
    this.lt = -1;
  }
  get targetFrameTime() {
    return 1e3 / this.targetFPS;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/timers/RequestAnimationFrameTimer.ts
var RequestAnimationFrameTimer = class extends BaseTimer {
  constructor() {
    super();
  }
  start() {
    if (!this.isRunning) {
      const updater = (t2) => {
        this.timer = requestAnimationFrame(updater);
        this.onTick(t2);
      };
      this.timer = requestAnimationFrame(updater);
    }
  }
  stop() {
    if (this.isRunning) {
      cancelAnimationFrame(this.timer);
      super.stop();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/DialogBox/index.ts
var DialogBox = class {
  constructor(title2) {
    this.task = new Task(false);
    this.element = Div(
      className("dialog"),
      display("none"),
      customData("dialogname", title2),
      this.container = Div(
        className("dialog-container"),
        this.titleElement = H1(className("title-bar"), title2),
        this.contentArea = Div(className("dialog-content")),
        Div(
          className("dialog-controls"),
          this.confirmButton = ButtonPrimary("Confirm", classList("confirm-button")),
          this.cancelButton = ButtonSecondary("Cancel", classList("cancel-button"))
        )
      )
    );
    this.confirmButton.addEventListener("click", this.task.resolver(true));
    this.cancelButton.addEventListener("click", this.task.resolver(false));
    elementApply(document.body, this);
  }
  get title() {
    return this._title;
  }
  set title(v) {
    elementSetText(this.titleElement, this._title = v);
  }
  async onShowing() {
  }
  onShown() {
  }
  async onConfirm() {
  }
  onCancel() {
  }
  async onClosing() {
  }
  onClosed() {
  }
  show(v) {
    elementSetDisplay(this, v);
  }
  get isOpen() {
    return elementIsDisplayed(this);
  }
  hide() {
    this.show(false);
  }
  async toggle() {
    if (this.isOpen) {
      this.hide();
    } else {
      this.showDialog();
    }
  }
  async showDialog() {
    await this.onShowing();
    this.show(true);
    this.onShown();
    this.task.restart();
    if (await this.task) {
      await this.onConfirm();
    } else {
      this.onCancel();
    }
    await this.onClosing();
    this.show(false);
    this.onClosed();
    return this.task.result;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/BaseGraphDialog.ts
var size2 = 20;
var mid = size2 / 2;
var delta = vec2_exports.create();
function clamp2(a, b) {
  if (a < 0) {
    return 0;
  } else if (a > b) {
    return b;
  } else if (!Number.isFinite(a)) {
    console.trace("To infinity... and beyond!");
    return b;
  } else {
    return a;
  }
}
var BaseGraphDialog = class extends DialogBox {
  constructor(title2, getNodeName, getNodeColor, getWeightMod2) {
    super(title2);
    this.getNodeName = getNodeName;
    this.getNodeColor = getNodeColor;
    this.getWeightMod = getWeightMod2;
    this.timer = new RequestAnimationFrameTimer();
    this.positions = /* @__PURE__ */ new Map();
    this.forces = /* @__PURE__ */ new Map();
    this.wasGrabbed = /* @__PURE__ */ new Set();
    this.mousePoint = vec2_exports.create();
    this.grabbed = null;
    this.graph = null;
    this.cancelButton.style.display = "none";
    const idPostfix = stringRandom(5);
    elementApply(
      this.container,
      width(perc(100)),
      height(perc(100))
    );
    elementApply(
      this.contentArea,
      Div(
        display("grid"),
        gridTemplateColumns("repeat(11, auto)", fr(1)),
        columnGap(px(5)),
        alignItems("center"),
        ...PreLabeled(
          "limit" + idPostfix,
          "Limit",
          this.t = InputNumber(
            min(0),
            max(1e3),
            step(0.1),
            value(5)
          )
        ),
        ...PreLabeled(
          "cooling" + idPostfix,
          "Cooling",
          this.cooling = InputCheckbox()
        ),
        ...PreLabeled(
          "attract" + idPostfix,
          "Attract",
          this.attract = InputNumber(
            min(-100),
            max(100),
            step(0.1),
            value(1)
          )
        ),
        ...PreLabeled(
          "repel" + idPostfix,
          "Repel",
          this.repel = InputNumber(
            min(-100),
            max(100),
            step(0.1),
            value(1)
          )
        ),
        ...PreLabeled(
          "hideBare" + idPostfix,
          "Hide bare nodes",
          this.hideBare = InputCheckbox(
            checked(true)
          )
        )
      ),
      this.canvas = Canvas(
        display("block"),
        width(perc(100)),
        height(`calc(${perc(100)} - ${em(2)})`)
      )
    );
    this.g = this.canvas.getContext("2d");
    this.g.textAlign = "center";
    this.g.textBaseline = "middle";
    this.timer.addTickHandler(() => {
      resizeCanvas(this.canvas);
      this.fr91();
      this.draw();
    });
    const delta3 = vec2_exports.create();
    this.canvas.addEventListener("mousedown", (evt) => {
      this.setMouse(evt);
      this.grabbed = null;
      let dist4 = 0.7071067811865475 * size2;
      for (const node of this.graph) {
        const point = this.positions.get(node);
        vec2_exports.sub(delta3, point, this.mousePoint);
        const d = vec2_exports.length(delta3);
        if (d < dist4) {
          this.grabbed = node;
          if (this.wasGrabbed.has(node)) {
            this.wasGrabbed.delete(node);
          } else {
            this.wasGrabbed.add(node);
          }
          dist4 = d;
        }
      }
    });
    this.canvas.addEventListener("mousemove", (evt) => {
      this.setMouse(evt);
    });
    this.canvas.addEventListener("mouseup", () => {
      this.grabbed = null;
    });
  }
  get w() {
    return this.canvas.width - 2 * size2 - 200;
  }
  get h() {
    return this.canvas.height - 2 * size2;
  }
  setMouse(evt) {
    const x = evt.offsetX * this.canvas.width / this.canvas.clientWidth - size2;
    const y = evt.offsetY * this.canvas.height / this.canvas.clientHeight - size2;
    vec2_exports.set(this.mousePoint, x, y);
  }
  draw() {
    this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.g.fillStyle = "black";
    this.g.strokeStyle = "black";
    this.g.save();
    this.g.translate(size2, size2);
    for (const n1 of this.graph) {
      const p1 = this.positions.get(n1);
      for (const node2 of n1.connections) {
        const p2 = this.positions.get(node2);
        this.g.beginPath();
        this.g.moveTo(p1[0], p1[1]);
        this.g.lineTo(p2[0], p2[1]);
        this.g.stroke();
      }
    }
    this.g.strokeStyle = "lightgrey";
    this.g.save();
    this.g.translate(-mid, -mid);
    for (const n1 of this.graph) {
      if (n1.isConnected || !this.hideBare.checked) {
        this.g.fillStyle = rgb(243, 243, 243);
        const p1 = this.positions.get(n1);
        this.g.fillStyle = this.getNodeColor(n1.value);
        this.g.fillRect(p1[0], p1[1], size2, size2);
        this.g.strokeRect(p1[0], p1[1], size2, size2);
        this.g.fillStyle = "black";
        this.g.fillText(this.getNodeName(n1.value), p1[0] + mid, p1[1] + mid);
      }
    }
    this.g.restore();
    this.g.restore();
  }
  applyForces(attract, repel) {
    const forces = mapBuild(this.graph, () => vec2_exports.create());
    for (const n1 of this.graph) {
      const p1 = this.positions.get(n1);
      if (n1 === this.grabbed) {
        vec2_exports.copy(p1, this.mousePoint);
      } else if (!this.wasGrabbed.has(n1)) {
        const f1 = forces.get(n1);
        const f0 = this.forces.get(n1);
        if (f0) {
          vec2_exports.add(f1, f1, f0);
        }
        vec2_exports.set(delta, this.w, this.h);
        vec2_exports.scaleAndAdd(delta, p1, delta, -0.5);
        const len6 = vec2_exports.length(delta);
        if (len6 > 0) {
          vec2_exports.normalize(delta, delta);
          let f2 = -1e4 * len6;
          f2 = Math.sign(f2) * Math.pow(Math.abs(f2), 0.2);
          vec2_exports.scaleAndAdd(f1, f1, delta, f2);
        }
        for (const n2 of this.graph) {
          if (n1 !== n2) {
            const p2 = this.positions.get(n2);
            vec2_exports.sub(delta, p2, p1);
            const len7 = vec2_exports.length(delta);
            if (len7 > 0) {
              vec2_exports.normalize(delta, delta);
              const connected = n1.isConnectedTo(n2);
              const weight = this.getWeightMod(n1.value, n2.value, connected);
              const invWeight = 2 - weight;
              const f2 = weight * this.attract.valueAsNumber * attract(connected, len7) - invWeight * this.repel.valueAsNumber * repel(connected, len7);
              vec2_exports.scaleAndAdd(f1, f1, delta, f2);
            }
          }
        }
      }
    }
    for (const n1 of this.graph) {
      const f1 = forces.get(n1);
      f1[1] *= this.h / this.w;
      const len6 = vec2_exports.length(f1);
      if (len6 > 0) {
        vec2_exports.scale(f1, f1, Math.min(this.t.valueAsNumber, len6) / len6);
        const p1 = this.positions.get(n1);
        vec2_exports.add(p1, p1, f1);
        p1[0] = clamp2(p1[0], this.w);
        p1[1] = clamp2(p1[1], this.h);
      }
    }
    if (this.cooling.checked) {
      this.t.valueAsNumber *= 0.975;
    }
  }
  fr91() {
    const area = this.w * this.h * 0.1;
    const c1 = 1;
    const c2 = 1.5;
    const c3 = 0.1;
    const k = c1 * Math.sqrt(area / this.graph.length);
    for (let i = 0; i < 2; ++i) {
      this.applyForces(
        (connected, len6) => connected ? c2 * Math.sqrt(len6) * len6 / k : 0,
        (_, len6) => c3 * k * k / len6
      );
    }
  }
  onShown() {
    super.onShown();
    this.refreshData();
    this.t.valueAsNumber = 5;
    resizeCanvas(this.canvas);
    if (!this.timer.isRunning) {
      this.timer.start();
    }
  }
  refreshData() {
    this.positions.clear();
    this.forces.clear();
    this.wasGrabbed.clear();
    const R2 = Math.min(this.w, this.h) / 2;
    for (let i = 0; i < this.graph.length; ++i) {
      const node = this.graph[i];
      const a = Tau * i / this.graph.length;
      const r = R2;
      const x = r * Math.cos(a) + this.w / 2;
      const y = r * Math.sin(a) + this.h / 2;
      this.positions.set(node, vec2_exports.fromValues(x, y));
    }
  }
  setGraph(graph) {
    this.graph = graph;
  }
  onClosed() {
    this.timer.stop();
    super.onClosed();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/AudioGraphDialog.ts
function getVertexName(n2) {
  return n2.name;
}
function getVertexColor(n2) {
  if (n2.nodeClass === "node") {
    return "lightgreen";
  } else if (n2.nodeClass === "param") {
    return "lightyellow";
  } else if (n2.nodeClass === "unknown") {
    return "pink";
  } else {
    assertNever(n2.nodeClass);
  }
}
function getWeightMod(a, b, connected) {
  return !connected || a.nodeClass === b.nodeClass ? 1 : 1.8;
}
var AudioGraphDialog = class extends BaseGraphDialog {
  constructor(context) {
    super("Audio graph", getVertexName, getVertexColor, getWeightMod);
    this.context = context;
  }
  refreshData() {
    const graph = this.context.getAudioGraph(false);
    this.setGraph(graph);
    super.refreshData();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/BatteryImage.ts
function isBatteryNavigator(nav) {
  return "getBattery" in nav;
}
var chargeLabels = [
  "",
  "N/A",
  "charging"
];
var BatteryImage = class extends CanvasImage {
  constructor() {
    super(256, 128);
    this.battery = null;
    this.lastChargeDirection = null;
    this.lastLevel = null;
    this.chargeDirection = 0;
    this.level = 0.5;
    if (isBatteryNavigator(navigator)) {
      this.readBattery(navigator);
    } else {
      this.redraw();
    }
  }
  onRedraw() {
    if (this.battery) {
      this.chargeDirection = this.battery.charging ? 1 : -1;
      this.level = this.battery.level;
    } else {
      this.level += 0.1;
      if (this.level > 1) {
        this.level = 0;
      }
    }
    const directionChanged = this.chargeDirection !== this.lastChargeDirection;
    const levelChanged = this.level !== this.lastLevel;
    if (!directionChanged && !levelChanged) {
      return false;
    }
    this.lastChargeDirection = this.chargeDirection;
    this.lastLevel = this.level;
    const levelColor = this.level < 0.1 ? "red" : "silver";
    const padding2 = 7;
    const scale8 = 0.7;
    const invScale = (1 - scale8) / 2;
    const bodyWidth = this.canvas.width - 2 * padding2;
    const width2 = bodyWidth - 4 * padding2;
    const height2 = this.canvas.height - 4 * padding2;
    const midX = bodyWidth / 2;
    const midY = this.canvas.height / 2;
    const label = chargeLabels[this.chargeDirection + 1];
    this.g.clearRect(0, 0, bodyWidth, this.canvas.height);
    this.g.save();
    this.g.translate(invScale * this.canvas.width, invScale * this.canvas.height);
    this.g.globalAlpha = 0.75;
    this.g.scale(scale8, scale8);
    this.fillRect("silver", 0, 0, bodyWidth, this.canvas.height, 0);
    this.fillRect("silver", bodyWidth, midY - 2 * padding2 - 10, padding2 + 10, 4 * padding2 + 20, 0);
    this.g.clearRect(padding2, padding2, bodyWidth - 2 * padding2, this.canvas.height - 2 * padding2);
    this.fillRect("black", padding2, padding2, bodyWidth - 2 * padding2, this.canvas.height - 2 * padding2, 0);
    this.g.clearRect(2 * padding2, 2 * padding2, width2 * this.level, height2);
    this.fillRect(levelColor, 2 * padding2, 2 * padding2, width2 * this.level, height2, 0);
    this.g.fillStyle = "white";
    this.g.strokeStyle = "black";
    this.g.lineWidth = 4;
    this.g.textBaseline = "middle";
    this.g.font = makeFont({
      fontSize: height2 / 2,
      fontFamily: "Lato"
    });
    this.drawText(label, midX, midY, "center");
    this.g.restore();
    return true;
  }
  async readBattery(navigator2) {
    const redraw = this.redraw.bind(this);
    redraw();
    this.battery = await navigator2.getBattery();
    this.battery.addEventListener("chargingchange", redraw);
    this.battery.addEventListener("levelchange", redraw);
    setInterval(redraw, 1e3);
    redraw();
  }
};
BatteryImage.isAvailable = isBatteryNavigator(navigator);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/TextImage.ts
var TextImage = class extends CanvasImage {
  constructor(options) {
    super(10, 10, options);
    this.trueWidth = null;
    this.trueHeight = null;
    this.trueFontSize = null;
    this.dx = null;
    this._minWidth = null;
    this._maxWidth = null;
    this._minHeight = null;
    this._maxHeight = null;
    this._freezeDimensions = false;
    this._dimensionsFrozen = false;
    this._bgFillColor = null;
    this._bgStrokeColor = null;
    this._bgStrokeSize = null;
    this._textStrokeColor = null;
    this._textStrokeSize = null;
    this._textFillColor = "black";
    this._textDirection = "horizontal";
    this._fontStyle = "normal";
    this._fontVariant = "normal";
    this._fontWeight = "normal";
    this._fontFamily = "sans-serif";
    this._fontSize = 20;
    this._value = null;
    this.lastValue = null;
    if (isDefined(options)) {
      if (isDefined(options.minWidth)) {
        this._minWidth = options.minWidth;
      }
      if (isDefined(options.maxWidth)) {
        this._maxWidth = options.maxWidth;
      }
      if (isDefined(options.minHeight)) {
        this._minHeight = options.minHeight;
      }
      if (isDefined(options.maxHeight)) {
        this._maxHeight = options.maxHeight;
      }
      if (isDefined(options.freezeDimensions)) {
        this._freezeDimensions = options.freezeDimensions;
      }
      if (isDefined(options.textStrokeColor)) {
        this._textStrokeColor = options.textStrokeColor;
      }
      if (isDefined(options.textStrokeSize)) {
        this._textStrokeSize = options.textStrokeSize;
      }
      if (isDefined(options.bgFillColor)) {
        this._bgFillColor = options.bgFillColor;
      }
      if (isDefined(options.bgStrokeColor)) {
        this._bgStrokeColor = options.bgStrokeColor;
      }
      if (isDefined(options.bgStrokeSize)) {
        this._bgStrokeSize = options.bgStrokeSize;
      }
      if (isDefined(options.value)) {
        this._value = options.value;
      }
      if (isDefined(options.textFillColor)) {
        this._textFillColor = options.textFillColor;
      }
      if (isDefined(options.textDirection)) {
        this._textDirection = options.textDirection;
      }
      if (isDefined(options.fontStyle)) {
        this._fontStyle = options.fontStyle;
      }
      if (isDefined(options.fontVariant)) {
        this._fontVariant = options.fontVariant;
      }
      if (isDefined(options.fontWeight)) {
        this._fontWeight = options.fontWeight;
      }
      if (isDefined(options.fontFamily)) {
        this._fontFamily = options.fontFamily;
      }
      if (isDefined(options.fontSize)) {
        this._fontSize = options.fontSize;
      }
      if (isDefined(options.padding)) {
        if (isNumber(options.padding)) {
          this._padding = {
            left: options.padding,
            right: options.padding,
            top: options.padding,
            bottom: options.padding
          };
        } else {
          this._padding = options.padding;
        }
      }
    }
    if (isNullOrUndefined(this._padding)) {
      this._padding = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    this.redraw();
  }
  get minWidth() {
    return this._minWidth;
  }
  set minWidth(v) {
    if (this.minWidth !== v) {
      this._minWidth = v;
      this.redraw();
    }
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(v) {
    if (this.maxWidth !== v) {
      this._maxWidth = v;
      this.redraw();
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  set minHeight(v) {
    if (this.minHeight !== v) {
      this._minHeight = v;
      this.redraw();
    }
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set maxHeight(v) {
    if (this.maxHeight !== v) {
      this._maxHeight = v;
      this.redraw();
    }
  }
  get padding() {
    return this._padding;
  }
  set padding(v) {
    if (v instanceof Array) {
      throw new Error("Invalid padding");
    }
    if (this.padding.top !== v.top || this.padding.right != v.right || this.padding.bottom != v.bottom || this.padding.left != v.left) {
      this._padding = v;
      this.redraw();
    }
  }
  get textDirection() {
    return this._textDirection;
  }
  set textDirection(v) {
    if (this.textDirection !== v) {
      this._textDirection = v;
      this.redraw();
    }
  }
  get fontStyle() {
    return this._fontStyle;
  }
  set fontStyle(v) {
    if (this.fontStyle !== v) {
      this._fontStyle = v;
      this.redraw();
    }
  }
  get fontVariant() {
    return this._fontVariant;
  }
  set fontVariant(v) {
    if (this.fontVariant !== v) {
      this._fontVariant = v;
      this.redraw();
    }
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(v) {
    if (this.fontWeight !== v) {
      this._fontWeight = v;
      this.redraw();
    }
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(v) {
    if (this.fontSize !== v) {
      this._fontSize = v;
      this.redraw();
    }
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(v) {
    if (this.fontFamily !== v) {
      this._fontFamily = v;
      this.redraw();
    }
  }
  get textFillColor() {
    return this._textFillColor;
  }
  set textFillColor(v) {
    if (this.textFillColor !== v) {
      this._textFillColor = v;
      this.redraw();
    }
  }
  get textStrokeColor() {
    return this._textStrokeColor;
  }
  set textStrokeColor(v) {
    if (this.textStrokeColor !== v) {
      this._textStrokeColor = v;
      this.redraw();
    }
  }
  get textStrokeSize() {
    return this._textStrokeSize;
  }
  set textStrokeSize(v) {
    if (this.textStrokeSize !== v) {
      this._textStrokeSize = v;
      this.redraw();
    }
  }
  get bgFillColor() {
    return this._bgFillColor;
  }
  set bgFillColor(v) {
    if (this.bgFillColor !== v) {
      this._bgFillColor = v;
      this.redraw();
    }
  }
  get bgStrokeColor() {
    return this._bgStrokeColor;
  }
  set bgStrokeColor(v) {
    if (this.bgStrokeColor !== v) {
      this._bgStrokeColor = v;
      this.redraw();
    }
  }
  get bgStrokeSize() {
    return this._bgStrokeSize;
  }
  set bgStrokeSize(v) {
    if (this.bgStrokeSize !== v) {
      this._bgStrokeSize = v;
      this.redraw();
    }
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (this.value !== v) {
      this._value = v;
      this.redraw();
    }
  }
  split(value2) {
    return value2.replace(/\r\n/g, "\n").split("\n");
  }
  unfreeze() {
    this._dimensionsFrozen = false;
  }
  onRedraw() {
    this.onClear();
    if (this.visible && this.fontFamily && this.fontSize && (this.textFillColor || this.textStrokeColor && this.textStrokeSize) && this.value && this.value !== this.lastValue) {
      const lines = this.split(this.value);
      const isVertical = this.textDirection && this.textDirection.indexOf("vertical") === 0;
      if (this.trueWidth === null || this.trueHeight === null || this.dx === null || this.trueFontSize === null || !this._dimensionsFrozen) {
        this._dimensionsFrozen = this._freezeDimensions;
        const autoResize = this.minWidth != null || this.maxWidth != null || this.minHeight != null || this.maxHeight != null;
        const _targetMinWidth = ((this.minWidth || 0) - this.padding.right - this.padding.left) * this.scale;
        const _targetMaxWidth = ((this.maxWidth || 4096) - this.padding.right - this.padding.left) * this.scale;
        const _targetMinHeight = ((this.minHeight || 0) - this.padding.top - this.padding.bottom) * this.scale;
        const _targetMaxHeight = ((this.maxHeight || 4096) - this.padding.top - this.padding.bottom) * this.scale;
        const targetMinWidth = isVertical ? _targetMinHeight : _targetMinWidth;
        const targetMaxWidth = isVertical ? _targetMaxHeight : _targetMaxWidth;
        const targetMinHeight = isVertical ? _targetMinWidth : _targetMinHeight;
        const targetMaxHeight = isVertical ? _targetMaxWidth : _targetMaxHeight;
        const tried = [];
        this.trueWidth = 0;
        this.trueHeight = 0;
        this.dx = 0;
        let tooBig = false, tooSmall = false, highFontSize = 1e4, lowFontSize = 0;
        this.trueFontSize = clamp(this.fontSize * this.scale, lowFontSize, highFontSize);
        let minFont = null, minFontDelta = Number.MAX_VALUE;
        do {
          const realFontSize = this.fontSize;
          this._fontSize = this.trueFontSize;
          const font2 = makeFont(this);
          this._fontSize = realFontSize;
          this.g.textAlign = "center";
          this.g.textBaseline = "middle";
          this.g.font = font2;
          this.trueWidth = 0;
          this.trueHeight = 0;
          for (const line of lines) {
            const metrics = this.g.measureText(line);
            this.trueWidth = Math.max(this.trueWidth, metrics.width);
            this.trueHeight += this.trueFontSize;
            if (isNumber(metrics.actualBoundingBoxLeft) && isNumber(metrics.actualBoundingBoxRight) && isNumber(metrics.actualBoundingBoxAscent) && isNumber(metrics.actualBoundingBoxDescent)) {
              if (!autoResize) {
                this.trueWidth = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;
                this.trueHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                this.dx = (metrics.actualBoundingBoxLeft - this.trueWidth / 2) / 2;
              }
            }
          }
          if (autoResize) {
            const dMinWidth = this.trueWidth - targetMinWidth;
            const dMaxWidth = this.trueWidth - targetMaxWidth;
            const dMinHeight = this.trueHeight - targetMinHeight;
            const dMaxHeight = this.trueHeight - targetMaxHeight;
            const mdMinWidth = Math.abs(dMinWidth);
            const mdMaxWidth = Math.abs(dMaxWidth);
            const mdMinHeight = Math.abs(dMinHeight);
            const mdMaxHeight = Math.abs(dMaxHeight);
            tooBig = dMaxWidth > 1 || dMaxHeight > 1;
            tooSmall = dMinWidth < -1 && dMinHeight < -1;
            const minDif = Math.min(mdMinWidth, Math.min(mdMaxWidth, Math.min(mdMinHeight, mdMaxHeight)));
            if (minDif < minFontDelta) {
              minFontDelta = minDif;
              minFont = this.g.font;
            }
            if ((tooBig || tooSmall) && tried.indexOf(this.g.font) > -1 && minFont) {
              this.g.font = minFont;
              tooBig = false;
              tooSmall = false;
            }
            if (tooBig) {
              highFontSize = this.trueFontSize;
              this.trueFontSize = (lowFontSize + this.trueFontSize) / 2;
            } else if (tooSmall) {
              lowFontSize = this.trueFontSize;
              this.trueFontSize = (this.trueFontSize + highFontSize) / 2;
            }
          }
          tried.push(this.g.font);
        } while (tooBig || tooSmall);
        if (autoResize) {
          if (this.trueWidth < targetMinWidth) {
            this.trueWidth = targetMinWidth;
          } else if (this.trueWidth > targetMaxWidth) {
            this.trueWidth = targetMaxWidth;
          }
          if (this.trueHeight < targetMinHeight) {
            this.trueHeight = targetMinHeight;
          } else if (this.trueHeight > targetMaxHeight) {
            this.trueHeight = targetMaxHeight;
          }
        }
        const newW = this.trueWidth + this.scale * (this.padding.right + this.padding.left);
        const newH = this.trueHeight + this.scale * (this.padding.top + this.padding.bottom);
        try {
          setContextSize(this.g, newW, newH);
        } catch (exp2) {
          console.error(exp2);
          throw exp2;
        }
      }
      if (this.bgFillColor) {
        this.g.fillStyle = this.bgFillColor;
        this.g.fillRect(0, 0, this.canvas.width, this.canvas.height);
      } else {
        this.g.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
      if (this.textStrokeColor && this.textStrokeSize) {
        this.g.lineWidth = this.textStrokeSize * this.scale;
        this.g.strokeStyle = this.textStrokeColor;
      }
      if (this.textFillColor) {
        this.g.fillStyle = this.textFillColor;
      }
      const di = 0.5 * (lines.length - 1);
      for (let i = 0; i < lines.length; ++i) {
        const line = lines[i];
        const dy = (i - di) * this.trueFontSize;
        const x = this.dx + this.trueWidth / 2 + this.scale * this.padding.left;
        const y = dy + this.trueHeight / 2 + this.scale * this.padding.top;
        if (this.textStrokeColor && this.textStrokeSize) {
          this.g.strokeText(line, x, y);
        }
        if (this.textFillColor) {
          this.g.fillText(line, x, y);
        }
      }
      if (this.bgStrokeColor && this.bgStrokeSize) {
        this.g.strokeStyle = this.bgStrokeColor;
        this.g.lineWidth = this.bgStrokeSize * this.scale;
        const s = this.bgStrokeSize / 2;
        this.g.strokeRect(s, s, this.canvas.width - this.bgStrokeSize, this.canvas.height - this.bgStrokeSize);
      }
      if (isVertical) {
        const canv = createUtilityCanvas(this.canvas.height, this.canvas.width);
        const g = canv.getContext("2d");
        if (g) {
          g.translate(canv.width / 2, canv.height / 2);
          if (this.textDirection === "vertical" || this.textDirection === "vertical-left") {
            g.rotate(HalfPi);
          } else if (this.textDirection === "vertical-right") {
            g.rotate(-HalfPi);
          }
          g.translate(-this.canvas.width / 2, -this.canvas.height / 2);
          g.drawImage(this.canvas, 0, 0);
          setContextSize(this.g, canv.width, canv.height);
        } else {
          console.warn("Couldn't rotate the TextImage");
        }
        this.g.drawImage(canv, 0, 0);
      }
      this.lastValue = this.value;
      return true;
    } else {
      const changed = this.value !== this.lastValue;
      this.lastValue = this.value;
      return changed;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/ClockImage.ts
var ClockImage = class extends TextImage {
  constructor() {
    super({
      textFillColor: "white",
      textStrokeColor: rgb(0, 0, 0, 0.5),
      textStrokeSize: 0.025,
      fontFamily: getMonospaceFonts(),
      fontSize: 20,
      minHeight: 1,
      maxHeight: 1,
      padding: 0.3,
      freezeDimensions: true
    });
    const updater = this.update.bind(this);
    setInterval(updater, 500);
    updater();
  }
  update() {
    const time = /* @__PURE__ */ new Date();
    const value2 = time.toLocaleTimeString();
    if (isNullOrUndefined(this.value) || value2.length !== this.value.length) {
      this.unfreeze();
    }
    this.value = value2;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/StatsImage.ts
var StatsImage = class extends TextImage {
  constructor() {
    super({
      textFillColor: "white",
      textStrokeColor: rgb(0, 0, 0, 0.5),
      textStrokeSize: 0.025,
      fontFamily: getMonospaceFonts(),
      fontSize: 20,
      minHeight: 1,
      maxHeight: 1,
      padding: 0.3,
      freezeDimensions: true
    });
    this.fps = null;
    this.drawCalls = null;
    this.triangles = null;
  }
  setStats(fps, drawCalls, triangles) {
    this.fps = fps;
    this.drawCalls = drawCalls;
    this.triangles = triangles;
    const value2 = ` ${Math.round(this.fps).toFixed(0)}hz ${this.drawCalls}c ${this.triangles}t`;
    if (isNullOrUndefined(this.value) || value2.length !== this.value.length) {
      this.unfreeze();
    }
    this.value = value2;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/LocalUserWebcam.ts
var PREFERRED_VIDEO_INPUT_ID_KEY = "calla:preferredVideoInputID";
var LocalUserWebcam = class extends TypedEventBase {
  constructor() {
    super();
    this.element = Video(muted(true));
    this._hasPermission = false;
    this._device = null;
    this._enabled = false;
    Object.seal(this);
  }
  get mediaType() {
    return "video";
  }
  get deviceKind() {
    return `${this.mediaType}input`;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(v) {
    if (v !== this.enabled) {
      this._enabled = v;
      this.onChange();
    }
  }
  get hasPermission() {
    return this._hasPermission;
  }
  get preferredDeviceID() {
    return localStorage.getItem(PREFERRED_VIDEO_INPUT_ID_KEY);
  }
  get device() {
    return this._device;
  }
  checkDevices(devices) {
    if (!this.hasPermission) {
      for (const device of devices) {
        if (device.kind === this.deviceKind && device.deviceId.length > 0 && device.label.length > 0) {
          this._hasPermission = true;
          break;
        }
      }
    }
  }
  async setDevice(device) {
    if (isDefined(device) && device.kind !== this.deviceKind) {
      throw new Error(`Device is not an vide input device. Was: ${device.kind}. Label: ${device.label}`);
    }
    const curVideoID = this.device && this.device.deviceId || null;
    const nextVideoID = device && device.deviceId || null;
    if (nextVideoID !== curVideoID) {
      this._device = device;
      localStorage.setItem(PREFERRED_VIDEO_INPUT_ID_KEY, nextVideoID);
      await this.onChange();
    }
  }
  async onChange() {
    this.dispatchEvent(new DeviceSettingsChangedEvent());
    const oldStream = this.inStream;
    if (this.device && this.enabled) {
      this.inStream = await navigator.mediaDevices.getUserMedia({
        video: {
          deviceId: this.device.deviceId,
          autoGainControl: true,
          height: 640,
          noiseSuppression: true
        }
      });
    } else {
      this.inStream = null;
    }
    if (this.inStream !== oldStream) {
      this.dispatchEvent(new StreamChangedEvent(oldStream, this.outStream));
    }
  }
  get inStream() {
    return this.element.srcObject;
  }
  set inStream(v) {
    if (v !== this.inStream) {
      if (this.inStream) {
        this.element.pause();
      }
      this.element.srcObject = v;
      if (this.inStream) {
        this.element.play();
      }
    }
  }
  get outStream() {
    return this.inStream;
  }
  stop() {
    this.inStream = null;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/webrtc/constants.ts
var DEFAULT_LOCAL_USER_ID = "local-user";

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/InteractionAudio.ts
function makeClipName(type2, isDisabled) {
  if (type2 === "click" && isDisabled) {
    type2 = "error";
  }
  return `InteractionAudio-${type2}`;
}
var InteractionAudio = class {
  constructor(audio2, eventSys) {
    this.audio = audio2;
    this.eventSys = eventSys;
    const playClip = (evt) => {
      if (evt.pointer.type !== "nose" && evt.rayTarget && evt.rayTarget.clickable) {
        const clipName = makeClipName(evt.type, !evt.rayTarget.enabled);
        if (this.audio.hasClip(clipName)) {
          const { x, y, z } = evt.point;
          this.audio.setClipPosition(clipName, x, y, z);
          this.audio.playClip(clipName);
        }
      }
    };
    this.eventSys.addEventListener("enter", playClip);
    this.eventSys.addEventListener("exit", playClip);
    this.eventSys.addEventListener("click", playClip);
  }
  create(type2, asset, volume) {
    return this.audio.createClip(makeClipName(type2, false), asset, false, true, false, true, volume, []);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/ScreenMode.ts
var ScreenMode = /* @__PURE__ */ ((ScreenMode2) => {
  ScreenMode2["None"] = "None";
  ScreenMode2["Fullscreen"] = "Fullscreen";
  ScreenMode2["VR"] = "VR";
  ScreenMode2["AR"] = "AR";
  return ScreenMode2;
})(ScreenMode || {});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/ScreenUI/index.ts
var ScreenUI = class {
  constructor(buttonFillColor) {
    singleton(
      "Juniper.ThreeJS.ScreenUI.ButtonFillColor",
      () => Style(
        rule(
          "#appContainer > .row > .cell > .btn",
          backgroundColor(buttonFillColor)
        )
      )
    );
    this.elements = [
      this.topLeft = Div(classList("cell", "top", "left")),
      this.topCenter = Div(classList("cell", "top", "center")),
      this.topRight = Div(classList("cell", "top", "right")),
      this.middleLeft = Div(classList("cell", "middle", "left")),
      this.middleCenter = Div(classList("cell", "middle", "center")),
      this.middleRight = Div(classList("cell", "middle", "right")),
      this.bottomLeft = Div(classList("cell", "bottom", "left")),
      this.bottomCenter = Div(classList("cell", "bottom", "center")),
      this.bottomRight = Div(classList("cell", "bottom", "right"))
    ];
    this.cells = [
      [this.topLeft, this.topCenter, this.topRight],
      [this.middleLeft, this.middleCenter, this.middleRight],
      [this.bottomLeft, this.bottomCenter, this.bottomRight]
    ];
    this.hide();
  }
  show() {
    this.elements.forEach((v) => v.style.removeProperty("display"));
  }
  hide() {
    this.elements.forEach((v) => v.style.display = "none");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/SpaceUI.ts
function isPoint2DHeight(v) {
  return "height" in v;
}
function isPoint2DWidth(v) {
  return "width" in v;
}
var radius = 1.25;
var dAngleH = deg2rad(30);
var dAngleV = deg2rad(32);
var SpaceUI = class extends Object3D {
  constructor() {
    super();
    this.name = "SpaceUI";
    this.position.y = -0.25;
  }
  addItem(child, position) {
    child = objectResolve(child);
    objGraph(this, child);
    child.rotation.set(
      position.y * dAngleV,
      -position.x * dAngleH,
      0,
      "YXZ"
    );
    child.position.set(0, 0, -radius).applyEuler(child.rotation);
    if (isPoint2DHeight(position) && isPoint2DWidth(position)) {
      child.scale.set(position.width, position.height, 1);
    } else if (isPoint2DHeight(position)) {
      child.scale.multiplyScalar(position.height / child.scale.y);
    } else if (isPoint2DWidth(position)) {
      child.scale.multiplyScalar(position.width / child.scale.x);
    } else {
      child.scale.setScalar(position.scale);
    }
    child.scale.z = 1;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/data.ts
function isVideoRecord(obj2) {
  return isString(obj2.vcodec);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/BaseVideoPlayer.ts
var BaseVideoPlayer = class extends BaseAudioSource {
  constructor(type2, context, spatializer) {
    const video2 = BaseVideoPlayer.createMediaElement(Video, controls(true));
    const audio2 = BaseVideoPlayer.createMediaElement(Audio2, controls(false));
    const videoNode = new JuniperMediaElementAudioSourceNode(
      context,
      {
        mediaElement: video2
      }
    );
    videoNode.name = `${type2}-video`;
    const audioNode = new JuniperMediaElementAudioSourceNode(
      context,
      {
        mediaElement: audio2
      }
    );
    audioNode.name = `${type2}-audio`;
    super(type2, context, spatializer, [], [videoNode, audioNode]);
    this.onTimeUpdate = null;
    this.wasUsingAudioElement = false;
    this.nextStartTime = null;
    this._data = null;
    this._loaded = false;
    this.onError = /* @__PURE__ */ new Map();
    this.sourcesByURL = /* @__PURE__ */ new Map();
    this.sources = new PriorityList();
    this.potatoes = new PriorityList();
    videoNode.connect(this.volumeControl);
    audioNode.connect(this.volumeControl);
    this.video = video2;
    this.audio = audio2;
    this.loadingEvt = new MediaPlayerLoadingEvent(this);
    this.loadEvt = new MediaElementSourceLoadedEvent(this);
    this.playEvt = new MediaElementSourcePlayedEvent(this);
    this.pauseEvt = new MediaElementSourcePausedEvent(this);
    this.stopEvt = new MediaElementSourceStoppedEvent(this);
    this.progEvt = new MediaElementSourceProgressEvent(this);
    this.onSeeked = () => {
      if (this.useAudioElement) {
        this.audio.currentTime = this.video.currentTime;
      }
    };
    this.onPlay = async () => {
      this.onSeeked();
      if (this.useAudioElement) {
        await this.context.ready;
        await this.audio.play();
      }
      this.dispatchEvent(this.playEvt);
    };
    this.onPause = (evt) => {
      if (this.useAudioElement) {
        this.onSeeked();
        this.audio.pause();
      }
      if (this.video.currentTime === 0 || evt.type === "ended") {
        this.dispatchEvent(this.stopEvt);
      } else {
        this.dispatchEvent(this.pauseEvt);
      }
    };
    let wasWaiting = false;
    this.onWaiting = () => {
      if (this.useAudioElement) {
        wasWaiting = true;
        this.audio.pause();
      }
    };
    this.onCanPlay = async () => {
      if (this.useAudioElement && wasWaiting) {
        await this.context.ready;
        await this.audio.play();
        wasWaiting = false;
      }
    };
    this.wasUsingAudioElement = false;
    this.onTimeUpdate = async () => {
      const quality = this.video.getVideoPlaybackQuality();
      if (quality.totalVideoFrames === 0) {
        const onError = this.onError.get(this.video);
        if (isDefined(onError)) {
          await onError();
        }
      } else if (this.useAudioElement) {
        this.wasUsingAudioElement = false;
        const delta3 = this.video.currentTime - this.audio.currentTime;
        if (Math.abs(delta3) > 0.25) {
          this.audio.currentTime = this.video.currentTime;
        }
      } else if (!this.wasUsingAudioElement) {
        this.wasUsingAudioElement = true;
        this.audio.pause();
      }
      this.progEvt.value = this.video.currentTime;
      this.progEvt.total = this.video.duration;
      this.dispatchEvent(this.progEvt);
    };
    this.video.addEventListener("seeked", this.onSeeked);
    this.video.addEventListener("play", this.onPlay);
    this.video.addEventListener("pause", this.onPause);
    this.video.addEventListener("ended", this.onPause);
    this.video.addEventListener("waiting", this.onWaiting);
    this.video.addEventListener("canplay", this.onCanPlay);
    this.video.addEventListener("timeupdate", this.onTimeUpdate);
    Object.assign(window, { videoPlayer: this });
  }
  get data() {
    return this._data;
  }
  get loaded() {
    return this._loaded;
  }
  get title() {
    return this.video.title;
  }
  setTitle(v) {
    this.video.title = v;
    this.audio.title = v;
  }
  elementHasAudio(elem) {
    const source = this.sourcesByURL.get(elem.src);
    return isDefined(source) && source.acodec !== "none" || isDefined(elem.audioTracks) && elem.audioTracks.length > 0 || isDefined(elem.webkitAudioDecodedByteCount) && elem.webkitAudioDecodedByteCount > 0 || isDefined(elem.mozHasAudio) && elem.mozHasAudio;
  }
  get useAudioElement() {
    return !this.elementHasAudio(this.video) && this.elementHasAudio(this.audio);
  }
  onDisposing() {
    this.clear();
    this.video.removeEventListener("seeked", this.onSeeked);
    this.video.removeEventListener("play", this.onPlay);
    this.video.removeEventListener("pause", this.onPause);
    this.video.removeEventListener("ended", this.onPause);
    this.video.removeEventListener("waiting", this.onWaiting);
    this.video.removeEventListener("canplay", this.onCanPlay);
    this.video.removeEventListener("timeupdate", this.onTimeUpdate);
    super.onDisposing();
    this.audio.dispatchEvent(RELEASE_EVT);
    this.video.dispatchEvent(RELEASE_EVT);
  }
  clear() {
    this.stop();
    for (const [elem, onError] of this.onError) {
      elem.removeEventListener("error", onError);
    }
    this.onError.clear();
    this.sourcesByURL.clear();
    this.sources.clear();
    this.potatoes.clear();
    this.video.src = "";
    this.audio.src = "";
    this.wasUsingAudioElement = false;
    this._data = null;
    this._loaded = false;
  }
  async load(data, prog) {
    this.clear();
    this._data = data;
    if (isString(data)) {
      this.setTitle(data);
      this.potatoes.add(this.video, data);
    } else {
      this.setTitle(data.title);
      this.fillSources(this.video, data.videos);
      this.fillSources(this.audio, data.audios);
    }
    if (!this.hasSources(this.video)) {
      throw new Error("No video sources found");
    }
    this.dispatchEvent(this.loadingEvt);
    await progressTasks(
      prog,
      (prog2) => this.loadMediaElement(this.audio, prog2),
      (prog2) => this.loadMediaElement(this.video, prog2)
    );
    if (isString(data)) {
      this.nextStartTime = null;
    } else {
      this.nextStartTime = data.startTime;
    }
    if (!this.hasSources(this.video)) {
      throw new Error("No video playable sources");
    }
    this._loaded = true;
    this.dispatchEvent(this.loadEvt);
    return this;
  }
  fillSources(elem, formats) {
    arraySortByKeyInPlace(formats, (f2) => -f2.resolution);
    for (const format of formats) {
      if (!Video_Vendor_Mpeg_Dash_Mpd.matches(format.contentType)) {
        this.sources.add(elem, format);
        this.sourcesByURL.set(format.url, format);
      }
    }
  }
  static createMediaElement(MediaElement, ...rest) {
    return MediaElement(
      autoPlay(false),
      loop(false),
      ...rest
    );
  }
  async getMediaCapabilities(source) {
    const config = {
      type: "file"
    };
    if (isVideoRecord(source)) {
      config.video = {
        contentType: source.contentType,
        bitrate: source.vbr * 1024,
        framerate: source.fps,
        width: source.width,
        height: source.height
      };
    } else if (source.acodec !== "none") {
      config.audio = {
        contentType: source.contentType,
        bitrate: source.abr * 1024,
        samplerate: source.asr
      };
    }
    try {
      return await navigator.mediaCapabilities.decodingInfo(config);
    } catch {
      return {
        supported: true,
        powerEfficient: false,
        smooth: false,
        configuration: config
      };
    }
  }
  hasSources(elem) {
    return this.sources.get(elem).length > 0 || this.potatoes.count(elem) > 0;
  }
  async loadMediaElement(elem, prog) {
    if (isDefined(prog)) {
      prog.start();
    }
    if (this.onError.has(elem)) {
      elem.removeEventListener("error", this.onError.get(elem));
      this.onError.delete(elem);
    }
    while (this.hasSources(elem)) {
      let url2 = null;
      const source = this.sources.get(elem).shift();
      if (isDefined(source)) {
        const caps = await this.getMediaCapabilities(source);
        if (!caps.smooth || !caps.powerEfficient) {
          this.potatoes.add(elem, source.url);
          continue;
        } else {
          url2 = source.url;
        }
      } else {
        url2 = this.potatoes.get(elem).shift();
      }
      elem.src = url2;
      elem.load();
      if (await mediaElementCanPlayThrough(elem)) {
        if (isDefined(source)) {
          this.sources.get(elem).unshift(source);
        } else {
          this.potatoes.get(elem).unshift(url2);
        }
        const onError = () => this.loadMediaElement(elem, prog);
        elem.addEventListener("error", onError);
        this.onError.set(elem, onError);
        this.wasUsingAudioElement = this.wasUsingAudioElement;
        if (isDefined(prog)) {
          prog.end();
        }
        return;
      }
    }
  }
  get width() {
    return this.video.videoWidth;
  }
  get height() {
    return this.video.videoHeight;
  }
  get playbackState() {
    if (isNullOrUndefined(this.data)) {
      return "empty";
    }
    if (!this.loaded) {
      return "loading";
    }
    if (this.video.error) {
      return "errored";
    }
    if (this.video.ended || this.video.paused && this.video.currentTime === 0) {
      return "stopped";
    }
    if (this.video.paused) {
      return "paused";
    }
    return "playing";
  }
  async play() {
    await this.context.ready;
    if (isDefined(this.nextStartTime) && this.nextStartTime > 0) {
      this.video.pause();
      this.video.currentTime = this.nextStartTime;
      this.nextStartTime = null;
    }
    await this.video.play();
  }
  async playThrough() {
    const endTask = once(this, "stopped");
    await this.play();
    await endTask;
  }
  pause() {
    this.video.pause();
  }
  stop() {
    this.pause();
    this.video.currentTime = 0;
  }
  restart() {
    this.stop();
    return this.play();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/animation/tween.ts
function bump(t2, k) {
  const a = t2 * Pi;
  return 0.5 * (1 - Math.cos(a)) - k * Math.sin(2 * a);
}
function jump(t2, k) {
  const a = (t2 - 0.5) * Pi;
  return t2 * t2 + k * Math.cos(a);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/animation/scaleOnHover.ts
var scaledItems = singleton("Juniper:ScaledItems", () => /* @__PURE__ */ new Map());
var start = 1;
var end = 1.1;
var timeScale = 5e-3;
var ScaleState = class {
  constructor(target) {
    this.target = target;
    this.obj = objectResolve(this.target);
    this.base = this.obj.scale.clone();
    this.p = 0;
    this.dir = 0;
    this.running = false;
    this.wasDisabled = this.disabled;
    this.target.addScopedEventListener(this, "enter", (evt) => {
      if (evt.pointer.type !== "nose") {
        this.run(1);
      }
    });
    this.target.addScopedEventListener(this, "exit", (evt) => {
      if (evt.pointer.type !== "nose") {
        this.run(-1);
      }
    });
    this.obj.traverse((child) => {
      if (isMesh(child)) {
        this.target.addMesh(child);
      }
    });
  }
  get disabled() {
    return this.target.disabled;
  }
  run(d) {
    if (!this.disabled || (d === -1 || this.p > 0)) {
      this.dir = d;
      this.running = true;
    }
  }
  updateScaling(dt) {
    if (this.disabled !== this.wasDisabled) {
      this.wasDisabled = this.disabled;
      if (this.disabled) {
        this.run(-1);
      }
    }
    if (this.running) {
      this.p += this.dir * dt;
      if (this.dir > 0 && this.p >= 1 || this.dir < 0 && this.p < 0) {
        this.p = Math.max(0, Math.min(1, this.p));
        this.running = false;
      }
      const q = bump(this.p, 1.1);
      this.obj.scale.copy(this.base).multiplyScalar(q * (end - start) + start);
    }
  }
  dispose() {
    this.target.removeScope(this);
  }
};
function updateScalings(dt) {
  dt *= timeScale;
  for (const state of scaledItems.values()) {
    state.updateScaling(dt);
  }
}
function removeScaledObj(obj2) {
  const state = scaledItems.get(obj2);
  if (state) {
    scaledItems.delete(obj2);
    dispose(state);
  }
}
function scaleOnHover(target, enabled) {
  const has = scaledItems.has(target);
  if (enabled != has) {
    if (enabled) {
      scaledItems.set(target, new ScaleState(target));
      ;
    } else {
      const scaler = scaledItems.get(target);
      dispose(scaler);
      scaledItems.delete(target);
    }
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/cleanup.ts
function cleanup(obj2) {
  const cleanupQ = new Array();
  const cleanupSeen = /* @__PURE__ */ new Set();
  cleanupQ.push(obj2);
  while (cleanupQ.length > 0) {
    const here = cleanupQ.shift();
    if (here && !cleanupSeen.has(here)) {
      cleanupSeen.add(here);
      if (here.isMesh) {
        cleanupQ.push(
          here.material,
          here.geometry
        );
      }
      if (here.isMaterial) {
        cleanupQ.push(...Object.values(here));
      }
      if (here.isObject3D) {
        cleanupQ.push(...here.children);
        here.clear();
        removeScaledObj(here);
      }
      if (isArray(here)) {
        cleanupQ.push(...here);
      }
      dispose2(here);
    }
  }
  cleanupSeen.clear();
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/CustomGeometry.ts
function normalizeQuad(quad) {
  return [
    normalizeTriangle([quad[1], quad[0], quad[2]]),
    normalizeTriangle([quad[2], quad[0], quad[3]])
  ];
}
function normalizeQuads(quads) {
  return quads.map(normalizeQuad).flat();
}
var A = new Vector3();
var B = new Vector3();
var C = new Vector3();
function normalizeTriangle(tria) {
  const positions = [
    [tria[0][0], tria[0][1], tria[0][2]],
    [tria[1][0], tria[1][1], tria[1][2]],
    [tria[2][0], tria[2][1], tria[2][2]]
  ];
  const uvs = [
    [tria[0][3], tria[0][4]],
    [tria[1][3], tria[1][4]],
    [tria[2][3], tria[2][4]]
  ];
  C.fromArray(positions[0]);
  A.fromArray(positions[1]).sub(C);
  C.fromArray(positions[2]);
  B.fromArray(positions[1]).sub(C);
  A.cross(B);
  const normal = A.toArray();
  return {
    positions,
    uvs,
    normal
  };
}
function createGeometry(nFaces) {
  const positions = nFaces.map((f2) => f2.positions).flat(2);
  const uvs = nFaces.map((f2) => f2.uvs).flat(2);
  const normals = nFaces.flatMap((f2) => f2.normal);
  const geom4 = new BufferGeometry();
  geom4.setAttribute("position", new BufferAttribute(new Float32Array(positions), 3, false));
  geom4.setAttribute("uv", new BufferAttribute(new Float32Array(uvs), 2, false));
  geom4.setAttribute("normal", new BufferAttribute(new Float32Array(normals), 3, true));
  return geom4;
}
function createQuadGeometry(...quads) {
  const faces = normalizeQuads(quads);
  return createGeometry(faces);
}
function createEACGeometry(subDivs, ...quads) {
  let remappingQuads = mapEACSubdivision(quads);
  for (let i = 0; i < subDivs; ++i) {
    remappingQuads = subdivide(remappingQuads);
  }
  quads = unmapEACSubdivision(remappingQuads);
  const faces = normalizeQuads(quads);
  return createGeometry(faces);
}
function mapEACSubdivision(quads) {
  return quads.map((quad) => {
    let minU = Number.MAX_VALUE;
    let maxU = Number.MIN_VALUE;
    let minV = Number.MAX_VALUE;
    let maxV = Number.MIN_VALUE;
    for (const vert of quad) {
      const u2 = vert[3];
      const v = vert[4];
      minU = Math.min(minU, u2);
      maxU = Math.max(maxU, u2);
      minV = Math.min(minV, v);
      maxV = Math.max(maxV, v);
    }
    const minUV = [minU, minV];
    const deltaUV = [maxU - minU, maxV - minV];
    return {
      minUV,
      deltaUV,
      verts: [
        mapEACSubdivVert(minUV, deltaUV, quad[0]),
        mapEACSubdivVert(minUV, deltaUV, quad[1]),
        mapEACSubdivVert(minUV, deltaUV, quad[2]),
        mapEACSubdivVert(minUV, deltaUV, quad[3])
      ]
    };
  });
}
function mapEACSubdivVert(minUV, deltaUV, vert) {
  return {
    pos: [vert[0], vert[1], vert[2]],
    uv: [vert[3], vert[4]],
    pUV: [
      (vert[3] - minUV[0]) / deltaUV[0],
      (vert[4] - minUV[1]) / deltaUV[1]
    ]
  };
}
function unmapEACSubdivision(quadsx) {
  return quadsx.map((quadx) => [
    unmapEACSubdivVert(quadx, 0),
    unmapEACSubdivVert(quadx, 1),
    unmapEACSubdivVert(quadx, 2),
    unmapEACSubdivVert(quadx, 3)
  ]);
}
function unmapEACSubdivVert(quadx, i) {
  const vert = quadx.verts[i];
  return [
    vert.pos[0],
    vert.pos[1],
    vert.pos[2],
    vert.uv[0],
    vert.uv[1]
  ];
}
function subdivide(quadsx) {
  return quadsx.flatMap((quadx) => {
    const midU1 = midpoint(quadx, quadx.verts[0], quadx.verts[1]);
    const midU2 = midpoint(quadx, quadx.verts[2], quadx.verts[3]);
    const midV1 = midpoint(quadx, quadx.verts[0], quadx.verts[3]);
    const midV2 = midpoint(quadx, quadx.verts[1], quadx.verts[2]);
    const mid2 = midpoint(quadx, midU1, midU2);
    return [{
      minUV: quadx.minUV,
      deltaUV: quadx.deltaUV,
      verts: [quadx.verts[0], midU1, mid2, midV1]
    }, {
      minUV: quadx.minUV,
      deltaUV: quadx.deltaUV,
      verts: [midU1, quadx.verts[1], midV2, mid2]
    }, {
      minUV: quadx.minUV,
      deltaUV: quadx.deltaUV,
      verts: [mid2, midV2, quadx.verts[2], midU2]
    }, {
      minUV: quadx.minUV,
      deltaUV: quadx.deltaUV,
      verts: [midV1, mid2, midU2, quadx.verts[3]]
    }];
  });
}
function midpoint(quadx, from, to) {
  const dx = to.pos[0] - from.pos[0];
  const dy = to.pos[1] - from.pos[1];
  const dz = to.pos[2] - from.pos[2];
  const x = from.pos[0] + 0.5 * dx;
  const y = from.pos[1] + 0.5 * dy;
  const z = from.pos[2] + 0.5 * dz;
  const dpu = to.pUV[0] - from.pUV[0];
  const dpv = to.pUV[1] - from.pUV[1];
  const pu = from.pUV[0] + 0.5 * dpu;
  const pv = from.pUV[1] + 0.5 * dpv;
  const mu = mapEACUV(pu - 0.5) + 0.5;
  const mv = mapEACUV(pv - 0.5) + 0.5;
  const u2 = mu * quadx.deltaUV[0] + quadx.minUV[0];
  const v = mv * quadx.deltaUV[1] + quadx.minUV[1];
  return {
    pos: [x, y, z],
    pUV: [pu, pv],
    uv: [u2, v]
  };
}
function mapEACUV(uv) {
  return Math.atan(2 * uv) / HalfPi;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/units/length.ts
var MICROMETERS_PER_MILLIMETER = 1e3;
var MILLIMETERS_PER_CENTIMETER = 10;
var CENTIMETERS_PER_INCH = 2.54;
var CENTIMETERS_PER_METER = 100;
var INCHES_PER_HAND = 4;
var HANDS_PER_FOOT = 3;
var FEET_PER_YARD = 3;
var FEET_PER_ROD = 16.5;
var METERS_PER_KILOMETER = 1e3;
var RODS_PER_FURLONG = 40;
var FURLONGS_PER_MILE = 8;
var MICROMETERS_PER_CENTIMETER = MICROMETERS_PER_MILLIMETER * MILLIMETERS_PER_CENTIMETER;
var MICROMETERS_PER_INCH = MICROMETERS_PER_CENTIMETER * CENTIMETERS_PER_INCH;
var MICROMETERS_PER_HAND = MICROMETERS_PER_INCH * INCHES_PER_HAND;
var MICROMETERS_PER_FOOT = MICROMETERS_PER_HAND * HANDS_PER_FOOT;
var MICROMETERS_PER_YARD = MICROMETERS_PER_FOOT * FEET_PER_YARD;
var MICROMETERS_PER_METER = MICROMETERS_PER_CENTIMETER * CENTIMETERS_PER_METER;
var MICROMETERS_PER_ROD = MICROMETERS_PER_FOOT * FEET_PER_ROD;
var MICROMETERS_PER_FURLONG = MICROMETERS_PER_ROD * RODS_PER_FURLONG;
var MICROMETERS_PER_KILOMETER = MICROMETERS_PER_METER * METERS_PER_KILOMETER;
var MICROMETERS_PER_MILE = MICROMETERS_PER_FURLONG * FURLONGS_PER_MILE;
var MILLIMETERS_PER_INCH = MILLIMETERS_PER_CENTIMETER * CENTIMETERS_PER_INCH;
var MILLIMETERS_PER_HAND = MILLIMETERS_PER_INCH * INCHES_PER_HAND;
var MILLIMETERS_PER_FOOT = MILLIMETERS_PER_HAND * HANDS_PER_FOOT;
var MILLIMETERS_PER_YARD = MILLIMETERS_PER_FOOT * FEET_PER_YARD;
var MILLIMETERS_PER_METER = MILLIMETERS_PER_CENTIMETER * CENTIMETERS_PER_METER;
var MILLIMETERS_PER_ROD = MILLIMETERS_PER_FOOT * FEET_PER_ROD;
var MILLIMETERS_PER_FURLONG = MILLIMETERS_PER_ROD * RODS_PER_FURLONG;
var MILLIMETERS_PER_KILOMETER = MILLIMETERS_PER_METER * METERS_PER_KILOMETER;
var MILLIMETERS_PER_MILE = MILLIMETERS_PER_FURLONG * FURLONGS_PER_MILE;
var CENTIMETERS_PER_HAND = CENTIMETERS_PER_INCH * INCHES_PER_HAND;
var CENTIMETERS_PER_FOOT = CENTIMETERS_PER_HAND * HANDS_PER_FOOT;
var CENTIMETERS_PER_YARD = CENTIMETERS_PER_FOOT * FEET_PER_YARD;
var CENTIMETERS_PER_ROD = CENTIMETERS_PER_FOOT * FEET_PER_ROD;
var CENTIMETERS_PER_FURLONG = CENTIMETERS_PER_ROD * RODS_PER_FURLONG;
var CENTIMETERS_PER_KILOMETER = CENTIMETERS_PER_METER * METERS_PER_KILOMETER;
var CENTIMETERS_PER_MILE = CENTIMETERS_PER_FURLONG * FURLONGS_PER_MILE;
var INCHES_PER_FOOT = INCHES_PER_HAND * HANDS_PER_FOOT;
var INCHES_PER_YARD = INCHES_PER_FOOT * FEET_PER_YARD;
var INCHES_PER_METER = CENTIMETERS_PER_METER / CENTIMETERS_PER_INCH;
var INCHES_PER_ROD = INCHES_PER_FOOT * FEET_PER_ROD;
var INCHES_PER_FURLONG = INCHES_PER_ROD * RODS_PER_FURLONG;
var INCHES_PER_KILOMETER = INCHES_PER_METER * METERS_PER_KILOMETER;
var INCHES_PER_MILE = INCHES_PER_FURLONG * FURLONGS_PER_MILE;
var HANDS_PER_YARD = HANDS_PER_FOOT * FEET_PER_YARD;
var HANDS_PER_METER = CENTIMETERS_PER_METER / CENTIMETERS_PER_HAND;
var HANDS_PER_ROD = HANDS_PER_FOOT * FEET_PER_ROD;
var HANDS_PER_FURLONG = HANDS_PER_ROD * RODS_PER_FURLONG;
var HANDS_PER_KILOMETER = HANDS_PER_METER * METERS_PER_KILOMETER;
var HANDS_PER_MILE = HANDS_PER_FURLONG * FURLONGS_PER_MILE;
var FEET_PER_METER = INCHES_PER_METER / INCHES_PER_FOOT;
var FEET_PER_FURLONG = FEET_PER_ROD * RODS_PER_FURLONG;
var FEET_PER_KILOMETER = FEET_PER_METER * METERS_PER_KILOMETER;
var FEET_PER_MILE = FEET_PER_FURLONG * FURLONGS_PER_MILE;
var YARDS_PER_METER = INCHES_PER_METER / INCHES_PER_YARD;
var YARDS_PER_ROD = FEET_PER_ROD / FEET_PER_YARD;
var YARDS_PER_FURLONG = YARDS_PER_ROD * RODS_PER_FURLONG;
var YARDS_PER_KILOMETER = YARDS_PER_METER * METERS_PER_KILOMETER;
var YARDS_PER_MILE = YARDS_PER_FURLONG * FURLONGS_PER_MILE;
var METERS_PER_ROD = FEET_PER_ROD / FEET_PER_METER;
var METERS_PER_FURLONG = METERS_PER_ROD * RODS_PER_FURLONG;
var METERS_PER_MILE = METERS_PER_FURLONG * FURLONGS_PER_MILE;
var RODS_PER_KILOMETER = METERS_PER_KILOMETER / METERS_PER_ROD;
var RODS_PER_MILE = RODS_PER_FURLONG * FURLONGS_PER_MILE;
var FURLONGS_PER_KILOMETER = METERS_PER_KILOMETER / METERS_PER_FURLONG;
var KILOMETERS_PER_MILE = FURLONGS_PER_MILE / FURLONGS_PER_KILOMETER;
function feet2Meters(feet) {
  return feet / FEET_PER_METER;
}
function inches2Meters(inches) {
  return inches / INCHES_PER_METER;
}
function meters2Millimeters(meters) {
  return meters * MILLIMETERS_PER_METER;
}
function meters2Inches(meters) {
  return meters * INCHES_PER_METER;
}
function millimeters2Meters(millimeters) {
  return millimeters / MILLIMETERS_PER_METER;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/getRelativeXRRigidTransform.ts
var M = new Matrix4();
var P3 = new Vector3();
var P4 = new Vector4();
var Q = new Quaternion();
function getRelativeXRRigidTransform(ref, obj2, scale8) {
  M.copy(ref.matrixWorld).invert().multiply(obj2.matrixWorld).decompose(P3, Q, scale8);
  P4.set(P3.x, P3.y, P3.z, 1);
  return new XRRigidTransform(P4, Q);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Plane.ts
var plane = /* @__PURE__ */ new PlaneGeometry(1, 1, 1, 1);
plane.name = "PlaneGeom";

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/Image2D.ts
var S = new Vector3();
var copyCounter = 0;
var Image2D = class extends Object3D {
  constructor(env, name3, webXRLayerType, materialOrOptions = null) {
    super();
    this.webXRLayerType = webXRLayerType;
    this.lastMatrixWorld = new Matrix4();
    this._imageWidth = 0;
    this._imageHeight = 0;
    this.forceUpdate = false;
    this.wasUsingLayer = false;
    this.layer = null;
    this.curImage = null;
    this.lastImage = null;
    this.lastWidth = null;
    this.lastHeight = null;
    this.env = null;
    this.mesh = null;
    this.stereoLayoutName = "mono";
    this.sizeMode = "none";
    if (env) {
      this.setEnvAndName(env, name3);
      let material = isMeshBasicMaterial(materialOrOptions) ? materialOrOptions : solidTransparent(Object.assign(
        {},
        materialOrOptions,
        { name: this.name }
      ));
      objGraph(
        this,
        this.mesh = mesh(name3 + "-Mesh", plane, material)
      );
    }
  }
  copy(source, recursive = true) {
    super.copy(source, recursive);
    this.webXRLayerType = source.webXRLayerType;
    this.setImageSize(source.imageWidth, source.imageHeight);
    this.setEnvAndName(source.env, source.name + ++copyCounter);
    this.mesh = arrayScan(this.children, isMesh);
    if (isNullOrUndefined(this.mesh)) {
      this.mesh = source.mesh.clone();
      objGraph(this, this.mesh);
    }
    this.setTextureMap(source.curImage);
    return this;
  }
  dispose() {
    this.env.removeScope(this);
    this.disposeImage();
    cleanup(this.mesh);
  }
  disposeImage() {
    this.removeWebXRLayer();
    cleanup(this.mesh.material.map);
    this.curImage = null;
  }
  setImageSize(width2, height2) {
    if (width2 !== this.imageWidth || height2 !== this.imageHeight) {
      const { objectWidth, objectHeight } = this;
      this._imageWidth = width2;
      this._imageHeight = height2;
      if (this.sizeMode !== "none") {
        if (this.sizeMode === "fixed-width") {
          this.objectWidth = objectWidth;
        } else {
          this.objectHeight = objectHeight;
        }
      }
    }
  }
  get imageWidth() {
    return this._imageWidth;
  }
  get imageHeight() {
    return this._imageHeight;
  }
  get imageAspectRatio() {
    return this.imageWidth / this.imageHeight;
  }
  get objectWidth() {
    return this.scale.x;
  }
  set objectWidth(v) {
    this.scale.set(v, this.scale.y = v / this.imageAspectRatio, 1);
  }
  get objectHeight() {
    return this.scale.y;
  }
  set objectHeight(v) {
    this.scale.set(this.imageAspectRatio * v, v, 1);
  }
  get pixelDensity() {
    const inches = meters2Inches(this.objectWidth);
    const ppi = this.imageWidth / inches;
    return ppi;
  }
  set pixelDensity(ppi) {
    const inches = this.imageWidth / ppi;
    const meters = inches2Meters(inches);
    this.objectWidth = meters;
  }
  setEnvAndName(env, name3) {
    this.env = env;
    this.name = name3;
    this.env.addScopedEventListener(this, "update", (evt) => this.checkWebXRLayer(evt.frame));
  }
  get needsLayer() {
    if (!objectIsFullyVisible(this) || isNullOrUndefined(this.mesh.material.map) || isNullOrUndefined(this.curImage)) {
      return false;
    }
    if (!(this.curImage instanceof HTMLVideoElement)) {
      return true;
    }
    return !this.curImage.paused || this.curImage.currentTime > 0;
  }
  removeWebXRLayer() {
    if (isDefined(this.layer)) {
      this.wasUsingLayer = false;
      this.env.removeWebXRLayer(this.layer);
      this.mesh.visible = true;
      const layer = this.layer;
      this.layer = null;
      setTimeout(() => dispose2(layer), 100);
    }
  }
  setTextureMap(img) {
    if (this.curImage) {
      this.disposeImage();
    }
    if (img) {
      if (isImageBitmap(img)) {
        img = createUtilityCanvasFromImageBitmap(img);
      } else if (isImageData(img)) {
        img = createUtilityCanvasFromImageData(img);
      }
      if (isOffscreenCanvas(img)) {
        img = img;
      }
      this.curImage = img;
      if (img instanceof HTMLVideoElement) {
        this.setImageSize(img.videoWidth, img.videoHeight);
        this.mesh.material.map = new VideoTexture(img);
      } else {
        this.setImageSize(img.width, img.height);
        this.mesh.material.map = new Texture(img);
        this.mesh.material.map.needsUpdate = true;
      }
    }
    this.mesh.material.needsUpdate = true;
  }
  get isVideo() {
    return this.curImage instanceof HTMLVideoElement;
  }
  updateTexture() {
    if (isDefined(this.curImage)) {
      const curVideo = this.curImage;
      const newWidth = this.isVideo ? curVideo.videoWidth : this.curImage.width;
      const newHeight = this.isVideo ? curVideo.videoHeight : this.curImage.height;
      if (this.imageWidth !== newWidth || this.imageHeight !== newHeight) {
        const img = this.curImage;
        this.disposeImage();
        this.setTextureMap(img);
      } else {
        this.mesh.material.map.needsUpdate = this.forceUpdate = true;
      }
    }
  }
  checkWebXRLayer(frame) {
    if (this.mesh.material.map && this.curImage) {
      const isLayersAvailable = this.webXRLayerType !== "none" && this.env.hasXRCompositionLayers && this.env.showWebXRLayers && isDefined(frame) && (this.isVideo && isDefined(this.env.xrMediaBinding) || !this.isVideo && isDefined(this.env.xrBinding));
      const useLayer = isLayersAvailable && this.needsLayer;
      const useLayerChanged = useLayer !== this.wasUsingLayer;
      const imageChanged = this.curImage !== this.lastImage || this.mesh.material.needsUpdate || this.mesh.material.map.needsUpdate || this.forceUpdate;
      const sizeChanged = this.imageWidth !== this.lastWidth || this.imageHeight !== this.lastHeight;
      this.wasUsingLayer = useLayer;
      this.lastImage = this.curImage;
      this.lastWidth = this.imageWidth;
      this.lastHeight = this.imageHeight;
      if (useLayerChanged || sizeChanged) {
        if ((!useLayer || sizeChanged) && this.layer) {
          this.removeWebXRLayer();
        }
        if (useLayer) {
          const space = this.env.referenceSpace;
          const transform2 = getRelativeXRRigidTransform(this.env.stage, this.mesh, S);
          this.lastMatrixWorld.copy(this.matrixWorld);
          const width2 = S.x / 2;
          const height2 = S.y / 2;
          const layout = this.stereoLayoutName === "mono" ? "mono" : this.stereoLayoutName === "left-right" || this.stereoLayoutName === "right-left" ? "stereo-left-right" : "stereo-top-bottom";
          if (this.isVideo) {
            const invertStereo = this.stereoLayoutName === "right-left" || this.stereoLayoutName === "bottom-top";
            this.layer = this.env.xrMediaBinding.createQuadLayer(this.curImage, {
              space,
              layout,
              invertStereo,
              transform: transform2,
              width: width2,
              height: height2
            });
          } else {
            this.layer = this.env.xrBinding.createQuadLayer({
              space,
              layout,
              textureType: "texture",
              isStatic: this.webXRLayerType === "static",
              viewPixelWidth: this.curImage.width,
              viewPixelHeight: this.curImage.height,
              transform: transform2,
              width: width2,
              height: height2
            });
          }
          this.env.addWebXRLayer(this.layer, 500);
          this.mesh.visible = false;
        }
      }
      if (this.layer) {
        if (imageChanged || this.layer.needsRedraw) {
          const gl = this.env.gl;
          const gLayer = this.env.xrBinding.getSubImage(this.layer, frame);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.bindTexture(gl.TEXTURE_2D, gLayer.colorTexture);
          gl.texSubImage2D(
            gl.TEXTURE_2D,
            0,
            0,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            this.curImage
          );
          gl.generateMipmap(gl.TEXTURE_2D);
          gl.bindTexture(gl.TEXTURE_2D, null);
          this.forceUpdate = false;
        }
        if (arrayCompare(this.matrixWorld.elements, this.lastMatrixWorld.elements) >= 0) {
          this.layer.transform = getRelativeXRRigidTransform(this.env.stage, this.mesh, S);
          this.lastMatrixWorld.copy(this.matrixWorld);
          this.layer.width = S.x / 2;
          this.layer.height = S.y / 2;
        }
      } else {
        this.forceUpdate = false;
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/VideoPlayer3D.ts
var SphereEncodingNames = [
  "N/A",
  "Cubemap",
  "Cubemap Strips",
  "Equi-Angular Cubemap (YouTube)",
  "Equirectangular",
  "Half Equirectangular",
  "Panoramic"
];
var StereoLayoutNames = [
  "mono",
  "left-right",
  "right-left",
  "top-bottom",
  "bottom-top"
];
var VideoPlayer3D = class extends BaseVideoPlayer {
  constructor(env, context, spatializer) {
    super("video-player-3d", context, spatializer);
    this.material = solidTransparent({ name: "videoPlayer-material" });
    this.vidMeshes = [];
    for (let i = 0; i < 2; ++i) {
      const vidMesh = new Image2D(env, `videoPlayer-view${i + 1}`, "none", this.material);
      vidMesh.setTextureMap(this.video);
      vidMesh.mesh.renderOrder = 4;
      if (i > 0) {
        vidMesh.mesh.layers.disable(0);
      } else {
        vidMesh.mesh.layers.enable(0);
      }
      this.vidMeshes.push(vidMesh);
    }
    this.object = obj(
      "videoPlayer",
      ...this.vidMeshes
    );
  }
  get meshes() {
    return this.vidMeshes.map((v) => v.mesh);
  }
  onDisposing() {
    super.onDisposing();
    cleanup(this.object);
    arrayClear(this.vidMeshes);
  }
  isSupported(encoding, layout) {
    return layout.split("-").map((name3) => GeomPacks.has(encoding, name3)).reduce(and, true);
  }
  setStereoParameters(encoding, layout) {
    if (!this.isSupported(encoding, layout)) {
      throw new Error(`Not supported [encoding: ${encoding}, layout: ${layout}]`);
    }
    for (let i = 0; i < this.vidMeshes.length; ++i) {
      const vidMesh = this.vidMeshes[i];
      vidMesh.webXRLayerType = "none";
      vidMesh.mesh.layers.disable(1);
      vidMesh.mesh.layers.disable(2);
      if (layout === "left-right" || layout === "top-bottom") {
        vidMesh.mesh.layers.enable(this.vidMeshes.length - i);
      } else if (layout !== "mono") {
        vidMesh.mesh.layers.enable(i + 1);
      }
    }
    const aspect = this.height / this.width;
    if (encoding !== "N/A") {
      this.vidMeshes[0].scale.setScalar(100);
    } else if (layout === "mono") {
      this.vidMeshes[0].scale.set(1, aspect, 1);
    } else if (layout === "left-right" || layout === "right-left") {
      this.vidMeshes[0].scale.set(1, 2 * aspect, 1);
    } else {
      this.vidMeshes[0].scale.set(1, 0.5 * aspect, 1);
    }
    for (let i = 1; i < this.vidMeshes.length; ++i) {
      this.vidMeshes[i].scale.copy(this.vidMeshes[0].scale);
    }
    const names = layout.split("-");
    for (let i = 0; i < names.length; ++i) {
      const name3 = names[i];
      const geom4 = GeomPacks.get(encoding, name3);
      const vidMesh = this.vidMeshes[i];
      vidMesh.webXRLayerType = "dynamic";
      vidMesh.visible = true;
      if (vidMesh.mesh.geometry !== geom4) {
        cleanup(vidMesh.mesh.geometry);
        vidMesh.mesh.geometry = geom4;
      }
    }
  }
};
var PlaneGeom_Mono = createQuadGeometry([
  [-1 / 2, 1 / 2, 0, 0, 1],
  [1 / 2, 1 / 2, 0, 1, 1],
  [1 / 2, -1 / 2, 0, 1, 0],
  [-1 / 2, -1 / 2, 0, 0, 0]
]);
var PlaneDef_Left = [
  [-1 / 2, 1 / 2, 0, 0, 1],
  [1 / 2, 1 / 2, 0, 0.5, 1],
  [1 / 2, -1 / 2, 0, 0.5, 0],
  [-1 / 2, -1 / 2, 0, 0, 0]
];
var PlanDef_Right = [
  [-1 / 2, 1 / 2, 0, 0.5, 1],
  [1 / 2, 1 / 2, 0, 1, 1],
  [1 / 2, -1 / 2, 0, 1, 0],
  [-1 / 2, -1 / 2, 0, 0.5, 0]
];
var CubeStripDef_Mono = [[
  [-1 / 2, 1 / 2, -1 / 2, 1 / 3, 1],
  [1 / 2, 1 / 2, -1 / 2, 2 / 3, 1],
  [1 / 2, -1 / 2, -1 / 2, 2 / 3, 1 / 2],
  [-1 / 2, -1 / 2, -1 / 2, 1 / 3, 1 / 2]
], [
  [1 / 2, 1 / 2, -1 / 2, 2 / 3, 1],
  [1 / 2, 1 / 2, 1 / 2, 1, 1],
  [1 / 2, -1 / 2, 1 / 2, 1, 1 / 2],
  [1 / 2, -1 / 2, -1 / 2, 2 / 3, 1 / 2]
], [
  [-1 / 2, 1 / 2, 1 / 2, 0, 1],
  [-1 / 2, 1 / 2, -1 / 2, 1 / 3, 1],
  [-1 / 2, -1 / 2, -1 / 2, 1 / 3, 1 / 2],
  [-1 / 2, -1 / 2, 1 / 2, 0, 1 / 2]
], [
  [1 / 2, 1 / 2, 1 / 2, 2 / 3, 1 / 2],
  [-1 / 2, 1 / 2, 1 / 2, 2 / 3, 0],
  [-1 / 2, -1 / 2, 1 / 2, 1 / 3, 0],
  [1 / 2, -1 / 2, 1 / 2, 1 / 3, 1 / 2]
], [
  [1 / 2, 1 / 2, -1 / 2, 1, 1 / 2],
  [-1 / 2, 1 / 2, -1 / 2, 1, 0],
  [-1 / 2, 1 / 2, 1 / 2, 2 / 3, 0],
  [1 / 2, 1 / 2, 1 / 2, 2 / 3, 1 / 2]
], [
  [1 / 2, -1 / 2, 1 / 2, 1 / 3, 1 / 2],
  [-1 / 2, -1 / 2, 1 / 2, 1 / 3, 0],
  [-1 / 2, -1 / 2, -1 / 2, 0, 0],
  [1 / 2, -1 / 2, -1 / 2, 0, 1 / 2]
]];
var CubeStripDef_Left = [[
  [-1 / 2, 1 / 2, -1 / 2, 0, 1 / 3],
  [1 / 2, 1 / 2, -1 / 2, 0, 2 / 3],
  [1 / 2, -1 / 2, -1 / 2, 1 / 4, 2 / 3],
  [-1 / 2, -1 / 2, -1 / 2, 1 / 4, 1 / 3]
], [
  [1 / 2, 1 / 2, -1 / 2, 0, 2 / 3],
  [1 / 2, 1 / 2, 1 / 2, 0, 1],
  [1 / 2, -1 / 2, 1 / 2, 1 / 4, 1],
  [1 / 2, -1 / 2, -1 / 2, 1 / 4, 2 / 3]
], [
  [-1 / 2, 1 / 2, 1 / 2, 0, 0],
  [-1 / 2, 1 / 2, -1 / 2, 0, 1 / 3],
  [-1 / 2, -1 / 2, -1 / 2, 1 / 4, 1 / 3],
  [-1 / 2, -1 / 2, 1 / 2, 1 / 4, 0]
], [
  [1 / 2, 1 / 2, 1 / 2, 1 / 4, 2 / 3],
  [-1 / 2, 1 / 2, 1 / 2, 1 / 2, 2 / 3],
  [-1 / 2, -1 / 2, 1 / 2, 1 / 2, 1 / 3],
  [1 / 2, -1 / 2, 1 / 2, 1 / 4, 1 / 3]
], [
  [1 / 2, 1 / 2, -1 / 2, 1 / 4, 1],
  [-1 / 2, 1 / 2, -1 / 2, 1 / 2, 1],
  [-1 / 2, 1 / 2, 1 / 2, 1 / 2, 2 / 3],
  [1 / 2, 1 / 2, 1 / 2, 1 / 4, 2 / 3]
], [
  [1 / 2, -1 / 2, 1 / 2, 1 / 4, 1 / 3],
  [-1 / 2, -1 / 2, 1 / 2, 1 / 2, 1 / 3],
  [-1 / 2, -1 / 2, -1 / 2, 1 / 2, 0],
  [1 / 2, -1 / 2, -1 / 2, 1 / 4, 0]
]];
var CubeStripDef_Right = [[
  [-1 / 2, 1 / 2, -1 / 2, 1 / 2, 1 / 3],
  [1 / 2, 1 / 2, -1 / 2, 1 / 2, 2 / 3],
  [1 / 2, -1 / 2, -1 / 2, 3 / 4, 2 / 3],
  [-1 / 2, -1 / 2, -1 / 2, 3 / 4, 1 / 3]
], [
  [1 / 2, 1 / 2, -1 / 2, 1 / 2, 2 / 3],
  [1 / 2, 1 / 2, 1 / 2, 1 / 2, 1],
  [1 / 2, -1 / 2, 1 / 2, 3 / 4, 1],
  [1 / 2, -1 / 2, -1 / 2, 3 / 4, 2 / 3]
], [
  [-1 / 2, 1 / 2, 1 / 2, 1 / 2, 0],
  [-1 / 2, 1 / 2, -1 / 2, 1 / 2, 1 / 3],
  [-1 / 2, -1 / 2, -1 / 2, 3 / 4, 1 / 3],
  [-1 / 2, -1 / 2, 1 / 2, 3 / 4, 0]
], [
  [1 / 2, 1 / 2, 1 / 2, 3 / 4, 2 / 3],
  [-1 / 2, 1 / 2, 1 / 2, 1, 2 / 3],
  [-1 / 2, -1 / 2, 1 / 2, 1, 1 / 3],
  [1 / 2, -1 / 2, 1 / 2, 3 / 4, 1 / 3]
], [
  [1 / 2, 1 / 2, -1 / 2, 3 / 4, 1],
  [-1 / 2, 1 / 2, -1 / 2, 1, 1],
  [-1 / 2, 1 / 2, 1 / 2, 1, 2 / 3],
  [1 / 2, 1 / 2, 1 / 2, 3 / 4, 2 / 3]
], [
  [1 / 2, -1 / 2, 1 / 2, 3 / 4, 1 / 3],
  [-1 / 2, -1 / 2, 1 / 2, 1, 1 / 3],
  [-1 / 2, -1 / 2, -1 / 2, 1, 0],
  [1 / 2, -1 / 2, -1 / 2, 3 / 4, 0]
]];
var PlaneGeom_Left = createQuadGeometry(PlaneDef_Left);
var PlaneGeom_Right = createQuadGeometry(PlanDef_Right);
var PlaneGeom_Top = createQuadGeometry(rotQuad(PlaneDef_Left));
var PlaneGeom_Bottom = createQuadGeometry(rotQuad(PlanDef_Right));
var CubeStripDef_Top = rot(CubeStripDef_Left);
var CubeStripDef_Bottom = rot(CubeStripDef_Right);
var CubeStripGeom_Mono = createQuadGeometry(...CubeStripDef_Mono);
var CubeStripGeom_Left = createQuadGeometry(...CubeStripDef_Left);
var CubeStripGeom_Right = createQuadGeometry(...CubeStripDef_Right);
var CubeStripGeom_Top = createQuadGeometry(...CubeStripDef_Top);
var CubeStripGeom_Bottom = createQuadGeometry(...CubeStripDef_Bottom);
var EACSubDivisions = 4;
var EACGeom_Mono = createEACGeometry(EACSubDivisions, ...CubeStripDef_Mono);
var EACGeom_Left = createEACGeometry(EACSubDivisions, ...CubeStripDef_Left);
var EACGeom_Right = createEACGeometry(EACSubDivisions, ...CubeStripDef_Right);
var EACGeom_Top = createEACGeometry(EACSubDivisions, ...CubeStripDef_Top);
var EACGeom_Bottom = createEACGeometry(EACSubDivisions, ...CubeStripDef_Bottom);
var GeomPacks = new PriorityMap([
  ["N/A", "mono", PlaneGeom_Mono],
  ["N/A", "left", PlaneGeom_Left],
  ["N/A", "right", PlaneGeom_Right],
  ["N/A", "top", PlaneGeom_Top],
  ["N/A", "bottom", PlaneGeom_Bottom],
  ["Cubemap Strips", "mono", CubeStripGeom_Mono],
  ["Cubemap Strips", "left", CubeStripGeom_Left],
  ["Cubemap Strips", "right", CubeStripGeom_Right],
  ["Cubemap Strips", "top", CubeStripGeom_Top],
  ["Cubemap Strips", "bottom", CubeStripGeom_Bottom],
  ["Equi-Angular Cubemap (YouTube)", "mono", EACGeom_Mono],
  ["Equi-Angular Cubemap (YouTube)", "left", EACGeom_Left],
  ["Equi-Angular Cubemap (YouTube)", "right", EACGeom_Right],
  ["Equi-Angular Cubemap (YouTube)", "top", EACGeom_Top],
  ["Equi-Angular Cubemap (YouTube)", "bottom", EACGeom_Bottom]
]);
function rotVert(vert) {
  return [vert[0], vert[1], vert[2], vert[4], 1 - vert[3]];
}
function rotQuad(quad) {
  return [
    rotVert(quad[0]),
    rotVert(quad[1]),
    rotVert(quad[2]),
    rotVert(quad[3])
  ];
}
function rot(def) {
  return def.map(rotQuad);
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/AssetGltfModel.ts
var AssetGltfModel = class extends BaseFetchedAsset {
  constructor(env, path, type2, useCache) {
    if (!Model_Gltf_Binary.matches(type2) && !Model_Gltf_Json.matches(type2)) {
      throw new Error("Only GLTF model types are currently supported");
    }
    super(path, type2, useCache);
    this.env = env;
  }
  async getResponse(request) {
    const response = await request.file();
    return translateResponse(response, (file) => this.env.loadGltf(file));
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/objectScan.ts
function objectScan(obj2, test) {
  const queue = [obj2];
  while (queue.length > 0) {
    const here = queue.shift();
    if (test(here)) {
      return here;
    }
    if (here.children.length > 0) {
      queue.push(...here.children);
    }
  }
  return null;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Watch.ts
var Watch = class {
  constructor(env, modelPath) {
    this.disposed = false;
    this.asset = new AssetGltfModel(env, modelPath, Model_Gltf_Binary, !env.DEBUG);
    this.asset.then(() => {
      this._model = objectScan(this.asset.result.scene, isMesh);
      const roughnessMap = this._model.material.roughnessMap;
      convertMaterials(this._model, materialStandardToPhong);
      this._model.material.specularMap = roughnessMap;
      env.timer.addTickHandler(update);
    });
    function isGood(hand) {
      return hand.enabled && (hand.grip.visible || hand.hand.visible && hand.hand.joints.wrist && hand.hand.joints.wrist.visible);
    }
    let wasDebug = env.DEBUG;
    let hadSession = env.xrUI.visible;
    let lastHandCount = 0;
    const update = () => {
      const hasSession = env.xrUI.visible;
      let handCount = 0;
      for (const hand of env.eventSys.hands) {
        if (isGood(hand)) {
          ++handCount;
        }
      }
      if (hasSession !== hadSession || handCount !== lastHandCount || wasDebug !== env.DEBUG) {
        env.clockImage.isVisible = hasSession || env.DEBUG;
        if (hasSession && handCount > 0) {
          let bestHand = null;
          for (const hand of env.eventSys.hands) {
            if (isGood(hand) && (isNullOrUndefined(bestHand) || hand.handedness === "left")) {
              bestHand = hand;
            }
          }
          const parent = bestHand.grip.visible ? bestHand.grip : bestHand.hand.joints.wrist;
          if (parent !== env.clockImage.object.parent) {
            objGraph(
              parent,
              objGraph(
                this,
                env.clockImage,
                env.batteryImage
              )
            );
            const rotate2 = bestHand.handedness === "left" ? 1 : 0;
            if (parent === bestHand.grip) {
              this.object.rotation.set(0, rotate2 * Pi, -HalfPi, "XYZ");
              this.object.position.set(0, 0, 0.07);
            } else {
              this.object.rotation.set(0, rotate2 * Pi, 0, "XYZ");
              this.object.position.set(0, 0, 0);
            }
            env.clockImage.scale.setScalar(0.0175);
            env.clockImage.position.set(0, 0.029, 0);
            env.clockImage.rotation.set(-HalfPi, 0, -HalfPi);
            if (isDefined(env.batteryImage)) {
              env.batteryImage.scale.set(2, 1, 1).multiplyScalar(8e-3);
              env.batteryImage.position.set(75e-4, 0.029, 0);
              env.batteryImage.rotation.set(-HalfPi, 0, -HalfPi);
            }
          }
        } else {
          env.xrUI.addItem(env.clockImage, { x: -1, y: 1, height: 0.1 });
          if (isDefined(env.batteryImage)) {
            env.xrUI.addItem(env.batteryImage, { x: 0.75, y: -1, width: 0.2, height: 0.1 });
          }
        }
        hadSession = hasSession;
        lastHandCount = handCount;
        wasDebug = env.DEBUG;
      }
    };
  }
  get object() {
    return this._model;
  }
  dispose() {
    if (!this.disposed) {
      if (isDefined(this.object)) {
        this.object.removeFromParent();
        cleanup(this.object);
        this._model = null;
      }
      this.disposed = true;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/MeshButton.ts
var MeshButton = class extends RayTarget {
  constructor(name3, geometry, enabledMaterial, disabledMaterial, size4) {
    name3 = name3 + stringRandom(16);
    super(obj(name3));
    this.enabledMaterial = enabledMaterial;
    this.disabledMaterial = disabledMaterial;
    this.mesh = mesh(`Mesh-${name3}-enabled`, geometry, enabledMaterial);
    this.size = size4;
    objGraph(this, this.mesh);
    this.addMesh(this.mesh);
    this.clickable = true;
    this.disabled = this.disabled;
    scaleOnHover(this, true);
  }
  get size() {
    return this.mesh.scale.x;
  }
  set size(v) {
    this.mesh.scale.setScalar(v);
  }
  get disabled() {
    return super.disabled;
  }
  set disabled(v) {
    super.disabled = v;
    this.mesh.material = v ? this.disabledMaterial : this.enabledMaterial;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/ButtonFactory.ts
var ButtonFactory = class {
  constructor(imagePaths, padding2, buttonFillColor, labelFillColor, debug) {
    this.imagePaths = imagePaths;
    this.padding = padding2;
    this.buttonFillColor = buttonFillColor;
    this.labelFillColor = labelFillColor;
    this.uvDescrips = new PriorityMap();
    this.geoms = new PriorityMap();
    this.canvas = null;
    this.texture = null;
    this.enabledMaterial = null;
    this.disabledMaterial = null;
    this.assetSets = new PriorityMap(Array.from(this.imagePaths.entries()).map(([setName, iconName, path]) => [
      setName,
      iconName,
      new AssetImage(path, Image_Png, !debug)
    ]));
    this.assets = Array.from(this.assetSets.values());
    this.ready = Promise.all(this.assets).then(() => {
      const images = this.assets.map((asset) => asset.result);
      const iconWidth = Math.max(...images.map((img) => img.width));
      const iconHeight = Math.max(...images.map((img) => img.height));
      const area = iconWidth * iconHeight * images.length;
      const squareDim = Math.sqrt(area);
      const cols = Math.floor(squareDim / iconWidth);
      const rows = Math.ceil(images.length / cols);
      const width2 = cols * iconWidth;
      const height2 = rows * iconHeight;
      const canvWidth = nextPowerOf2(width2);
      const canvHeight = nextPowerOf2(height2);
      const widthRatio = width2 / canvWidth;
      const heightRatio = height2 / canvHeight;
      const du = iconWidth / canvWidth;
      const dv = iconHeight / canvHeight;
      this.canvas = createUICanvas(canvWidth, canvHeight);
      const g = this.canvas.getContext("2d", { alpha: false });
      g.fillStyle = this.buttonFillColor;
      g.fillRect(0, 0, canvWidth, canvHeight);
      let i = 0;
      for (const [setName, imgName, asset] of this.assetSets.entries()) {
        const img = asset.result;
        const c = i % cols;
        const r = (i - c) / cols;
        const u2 = widthRatio * (c * iconWidth / width2);
        const v = heightRatio * (1 - r / rows) - dv;
        const x = c * iconWidth;
        const y = r * iconHeight + canvHeight - height2;
        const w = iconWidth - 2 * this.padding;
        const h = iconHeight - 2 * this.padding;
        g.drawImage(
          img,
          0,
          0,
          img.width,
          img.height,
          x + this.padding,
          y + this.padding,
          w,
          h
        );
        this.uvDescrips.add(setName, imgName, { u: u2, v, du, dv });
        ++i;
      }
      this.texture = new CanvasTexture(this.canvas);
      this.enabledMaterial = new MeshBasicMaterial({
        map: this.texture
      });
      this.enabledMaterial.needsUpdate = true;
      this.disabledMaterial = new MeshBasicMaterial({
        map: this.texture,
        transparent: true,
        opacity: 0.5
      });
      this.disabledMaterial.needsUpdate = true;
    });
  }
  getImageSrc(setName, iconName) {
    const imageSet = this.imagePaths.get(setName);
    const imgSrc = imageSet && imageSet.get(iconName);
    if (!imgSrc) {
      throw new Exception(`Button ${setName}/${iconName} does not exist`, this.uvDescrips);
    }
    return imgSrc;
  }
  async getMeshButton(setName, iconName, size4) {
    await this.ready;
    const uvSet = this.uvDescrips.get(setName);
    const uv = uvSet && uvSet.get(iconName);
    if (!uvSet || !uv) {
      throw new Exception(`Button ${setName}/${iconName} does not exist`, this.uvDescrips);
    }
    let geom4 = this.geoms.get(setName, iconName);
    if (!geom4) {
      geom4 = new PlaneGeometry(1, 1, 1, 1);
      geom4.name = `Geometry:${setName}/${iconName}`;
      this.geoms.add(setName, iconName, geom4);
      const uvBuffer = geom4.getAttribute("uv");
      for (let i = 0; i < uvBuffer.count; ++i) {
        const u2 = uvBuffer.getX(i) * uv.du + uv.u;
        const v = uvBuffer.getY(i) * uv.dv + uv.v;
        uvBuffer.setX(i, u2);
        uvBuffer.setY(i, v);
      }
    }
    const mesh2 = new MeshButton(iconName, geom4, this.enabledMaterial, this.disabledMaterial, size4);
    return mesh2;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/widgets.ts
function widgetSetEnabled(obj2, enabled) {
  if (obj2.element instanceof HTMLButtonElement) {
    obj2.element.disabled = !enabled;
  }
  objectSetEnabled(obj2, enabled);
}
function widgetApply(obj2, ...children) {
  elementApply(obj2, ...children.filter(isElementChild));
  objGraph(obj2, ...children.filter(isObjects));
}
function widgetRemoveFromParent(obj2) {
  elementRemoveFromParent(obj2);
  objRemoveFromParent(obj2);
}
var Widget = class {
  constructor(element, object, displayType) {
    this.element = element;
    this.object = object;
    this.displayType = displayType;
  }
  get name() {
    return this.object.name;
  }
  addEventListener(type2, listener, options) {
    this.element.addEventListener(type2, listener, options);
  }
  dispatchEvent(event) {
    return this.element.dispatchEvent(event);
  }
  removeEventListener(type2, callback, options) {
    this.element.removeEventListener(type2, callback, options);
  }
  click() {
    this.element.click();
  }
  get visible() {
    return elementIsDisplayed(this);
  }
  set visible(visible) {
    elementSetDisplay(this, visible, this.displayType);
    this.object.visible = visible;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/ButtonImageWidget.ts
var ButtonImageWidget = class extends Widget {
  constructor(buttons, setName, iconName) {
    const t2 = title(`${setName} ${iconName}`);
    super(
      ButtonPrimary(
        t2,
        Img(t2, src(buttons.getImageSrc(setName, iconName)))
      ),
      obj(`${name}-button`),
      "inline-block"
    );
    this.mesh = null;
    this.load(buttons, setName, iconName);
  }
  async load(buttons, setName, iconName) {
    this.mesh = await buttons.getMeshButton(setName, iconName, 0.2);
    this.mesh.disabled = this.disabled;
    objGraph(this, this.mesh);
    this.mesh.object.visible = this.visible;
    this.mesh.addEventListener("click", () => {
      this.element.click();
    });
  }
  get disabled() {
    return this.element.disabled;
  }
  set disabled(v) {
    this.element.disabled = v;
    if (this.mesh) {
      this.mesh.disabled = v;
    }
  }
  get visible() {
    return super.visible;
  }
  set visible(v) {
    super.visible = v;
    if (this.mesh) {
      objectSetVisible(this.mesh, v);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/CanvasImageMesh.ts
var redrawnEvt = { type: "redrawn" };
var CanvasImageMesh = class extends Image2D {
  constructor(env, name3, webXRLayerType, image2, materialOptions) {
    super(env, name3, webXRLayerType, materialOptions);
    this._image = null;
    this.image = image2;
  }
  get object() {
    return this;
  }
  get element() {
    if (isHTMLCanvas(this.image.canvas)) {
      return this.image.canvas;
    } else {
      return null;
    }
  }
  onRedrawn() {
    this.updateTexture();
    this.dispatchEvent(redrawnEvt);
  }
  get image() {
    return this._image;
  }
  set image(v) {
    if (this.image) {
      this.image.removeScope(this);
    }
    this._image = v;
    if (this.image) {
      this.image.addScopedEventListener(this, "redrawn", () => this.onRedrawn());
      this.setTextureMap(this.image.canvas);
      this.onRedrawn();
    }
  }
  get imageWidth() {
    return this.image.width;
  }
  get imageHeight() {
    return this.image.height;
  }
  copy(source, recursive = true) {
    super.copy(source, recursive);
    this.image = source.image;
    return this;
  }
  get isVisible() {
    return elementIsDisplayed(this);
  }
  set isVisible(v) {
    elementSetDisplay(this, v, "inline-block");
    objectSetVisible(this, v);
    objectSetVisible(this.mesh, v);
    this.image.visible = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/animation/Animator.ts
function isDead(task) {
  return !task.started || task.finished;
}
var AnimationTask = class extends Task {
  constructor() {
    super(false);
    this.time = 0;
    this.duration = 0;
    this.onTick = null;
  }
  begin(delay, duration, onTick) {
    this.restart();
    this.time = -delay;
    this.duration = duration;
    this.onTick = onTick;
    this.onTick(0);
  }
  update(dt) {
    if (!isDead(this)) {
      this.time += dt / this.duration;
      if (this.time >= 1) {
        this.onTick(1);
        this.resolve();
      } else if (this.time >= 0) {
        this.onTick(this.time);
      }
    }
  }
};
var Animator = class {
  constructor() {
    this.animations = new Array();
  }
  update(dt) {
    dt = 1e-3 * dt;
    for (const animation of this.animations) {
      animation.update(dt);
    }
  }
  clear() {
    for (const animation of this.animations) {
      animation.resolve();
    }
  }
  start(delay, duration, update) {
    let task = arrayScan(this.animations, isDead);
    if (!task) {
      this.animations.push(task = new AnimationTask());
    }
    task.begin(delay, duration, update);
    return task;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/TextMesh.ts
var TextMesh = class extends CanvasImageMesh {
  constructor(env, name3, webXRLayerType, textOptions, materialOptions) {
    let image2;
    if (textOptions instanceof TextImage) {
      image2 = textOptions;
    } else {
      image2 = new TextImage(textOptions);
    }
    super(env, name3, webXRLayerType, image2, materialOptions);
  }
  onRedrawn() {
    this.objectHeight = this.imageHeight;
    super.onRedrawn();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/TextMeshButton.ts
var TextMeshButton = class extends RayTarget {
  constructor(env, name3, value2, textImageOptions) {
    super(obj(name3));
    this.env = env;
    if (isDefined(value2)) {
      textImageOptions = Object.assign({
        textFillColor: "white",
        fontFamily: "Segoe UI Emoji",
        fontSize: 20,
        minHeight: 0.25,
        maxHeight: 0.25
      }, textImageOptions, {
        value: value2
      });
      this.image = new TextImage(textImageOptions);
      const id2 = stringRandom(16);
      this.enabledImage = this.createImage(`${id2}-enabled`, 1);
      this.disabledImage = this.createImage(`${id2}-disabled`, 0.5);
      this.disabledImage.visible = false;
      objGraph(this, this.enabledImage, this.disabledImage);
    }
    this.addMesh(this.enabledImage.mesh);
    this.addMesh(this.disabledImage.mesh);
    this.clickable = true;
    if (isDefined(value2)) {
      scaleOnHover(this, true);
    }
  }
  createImage(id2, opacity2) {
    const image2 = new TextMesh(
      this.env,
      `text-${id2}`,
      "none",
      this.image,
      {
        side: FrontSide,
        opacity: opacity2
      }
    );
    return image2;
  }
  get disabled() {
    return super.disabled;
  }
  set disabled(v) {
    super.disabled = v;
    this.enabledImage.visible = !v;
    this.disabledImage.visible = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/ConfirmationDialog.ts
var baseTextStyle2 = {
  bgStrokeColor: "black",
  bgStrokeSize: 0.04,
  textFillColor: "white",
  scale: 150
};
var textButtonStyle2 = Object.assign({}, baseTextStyle2, {
  padding: {
    left: 0.1,
    right: 0.1,
    top: 0.025,
    bottom: 0.025
  },
  fontSize: 20,
  minHeight: 0.5,
  maxHeight: 0.5
});
var confirmButton3DStyle = Object.assign({}, textButtonStyle2, {
  bgFillColor: rgb(0, 117, 215)
});
var cancelButton3DStyle = Object.assign({}, textButtonStyle2, {
  bgFillColor: rgb(117, 0, 0)
});
var textLabelStyle2 = Object.assign({}, baseTextStyle2, {
  bgFillColor: "white",
  textFillColor: "black",
  padding: {
    top: 0.1,
    left: 0.1,
    bottom: 0.4,
    right: 0.1
  },
  fontSize: 25,
  minHeight: 1,
  maxHeight: 1
});
var JUMP_FACTOR = 0.9;
function newStyle(baseStyle, fontFamily) {
  return Object.assign({}, baseStyle, { fontFamily });
}
var ConfirmationDialog = class extends DialogBox {
  constructor(env, fontFamily) {
    super("Confirm action");
    this.env = env;
    this.object = obj("ConfirmationDialog");
    this.root = obj("Root");
    this.animator = new Animator();
    this.a = 0;
    this.b = 0;
    this.confirmButton.innerText = "Yes";
    this.cancelButton.innerText = "No";
    this.mesh = new TextMesh(this.env, "confirmationDialogLabel", "none", newStyle(textLabelStyle2, fontFamily));
    this.confirmButton3D = new TextMeshButton(this.env, "confirmationDialogConfirmButton", "Yes", newStyle(confirmButton3DStyle, fontFamily));
    this.confirmButton3D.addEventListener("click", () => this.confirmButton.click());
    this.confirmButton3D.object.position.set(1, -0.5, 0.5);
    this.cancelButton3D = new TextMeshButton(this.env, "confirmationDialogCancelButton", "No", newStyle(cancelButton3DStyle, fontFamily));
    this.cancelButton3D.addEventListener("click", () => this.cancelButton.click());
    this.cancelButton3D.object.position.set(2, -0.5, 0.5);
    elementApply(
      this.container,
      maxWidth(`calc(${perc(100)} - ${em(2)})`),
      width("max-content")
    );
    elementApply(
      this.contentArea,
      fontSize(pt(18)),
      textAlign("center"),
      padding(em(1))
    );
    objGraph(
      this,
      objGraph(
        this.root,
        this.mesh,
        this.confirmButton3D,
        this.cancelButton3D
      )
    );
    objectSetVisible(this.root, false);
    this.root.scale.setScalar(0);
    this.onTick = (t2) => {
      const scale8 = jump(this.a + this.b * t2, JUMP_FACTOR);
      this.root.scale.set(scale8, scale8, 0.01);
    };
  }
  get name() {
    return this.object.name;
  }
  get visible() {
    return elementIsDisplayed(this);
  }
  set visible(visible) {
    elementSetDisplay(this, visible, "inline-block");
    this.mesh.visible = visible;
  }
  update(dt) {
    this.animator.update(dt);
  }
  async showHide(a, b) {
    this.a = a;
    this.b = b;
    await this.animator.start(0, 0.25, this.onTick);
    this.animator.clear();
  }
  get use3D() {
    return this.env.renderer.xr.isPresenting || this.env.testSpaceLayout;
  }
  async onShowing() {
    await super.onShowing();
    if (this.use3D) {
      this.root.visible = true;
      await this.showHide(0, 1);
    }
  }
  onShown() {
    if (this.use3D) {
      this.element.style.display = "none";
    }
  }
  async onClosing() {
    if (this.use3D) {
      await this.showHide(1, -1);
      this.root.visible = false;
    }
    await super.onClosing();
  }
  prompt(title2, message2) {
    this.title = title2;
    elementSetText(this.contentArea, message2);
    this.mesh.image.value = message2;
    return this.showDialog();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/ToggleButton.ts
var ToggleButton = class extends Widget {
  constructor(buttons, setName, activeName, inactiveName) {
    super(
      ButtonPrimary(),
      obj(`${setName}-button`),
      "inline-block"
    );
    this.buttons = buttons;
    this.setName = setName;
    this.activeName = activeName;
    this.inactiveName = inactiveName;
    this.enterButton = null;
    this.exitButton = null;
    this._isAvailable = true;
    this._isEnabled = true;
    this._isActive = false;
    elementApply(this, this.btnImage = Img());
    this.load();
  }
  async load() {
    const [enter, exit] = await all(
      this.buttons.getMeshButton(this.setName, this.activeName, 0.2),
      this.buttons.getMeshButton(this.setName, this.inactiveName, 0.2)
    );
    objGraph(
      this.object,
      this.enterButton = enter,
      this.exitButton = exit
    );
    this.enterButton.addEventListener("click", () => this.element.click());
    this.exitButton.addEventListener("click", () => this.element.click());
    this.refreshState();
  }
  get mesh() {
    return this.active ? this.enterButton : this.exitButton;
  }
  get available() {
    return this._isAvailable;
  }
  set available(v) {
    this._isAvailable = v;
    this.refreshState();
  }
  get active() {
    return this._isActive;
  }
  set active(v) {
    this._isActive = v;
    this.refreshState();
  }
  get enabled() {
    return this._isEnabled;
  }
  set enabled(v) {
    this._isEnabled = v;
    this.refreshState();
  }
  get visible() {
    return super.visible;
  }
  set visible(v) {
    super.visible = v;
    this.refreshState();
  }
  refreshState() {
    const type2 = this.active ? this.inactiveName : this.activeName;
    const text2 = `${type2} ${this.setName}`;
    this.element.title = this.btnImage.title = text2;
    this.btnImage.src = this.buttons.getImageSrc(this.setName, type2);
    this.element.disabled = !this.available || !this.visible || !this.enabled;
    elementSetDisplay(this, this.available && this.visible, "inline-block");
    if (this.enterButton && this.exitButton) {
      objectSetEnabled(this, this.available && this.visible && this.enabled);
      const visible = objectSetVisible(this.object, this.available && this.visible);
      objectSetVisible(this.enterButton, visible && !this.active);
      objectSetVisible(this.exitButton, visible && this.active);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/ScreenModeToggleButton.ts
var ScreenModeToggleButton = class extends ToggleButton {
  constructor(buttons, mode) {
    const name3 = ScreenMode[mode];
    super(buttons, name3.toLowerCase(), "enter", "exit");
    this.mode = mode;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressPopper.ts
function progressPopper(progress) {
  return new PoppableParentProgressCallback(progress);
}
var PoppableParentProgressCallback = class extends BaseParentProgressCallback {
  pop(weight) {
    return this.addSubProgress(weight);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/environment/ApplicationLoader.ts
var ApplicationLoaderEvent = class extends TypedEvent {
  constructor(type2, appName) {
    super(type2);
    this.appName = appName;
  }
};
var ApplicationLoaderAppLoadingEvent = class extends ApplicationLoaderEvent {
  constructor(appName, appLoadParams) {
    super("apploading", appName);
    this.appLoadParams = appLoadParams;
  }
};
var ApplicationLoaderAppLoadedEvent = class extends ApplicationLoaderEvent {
  constructor(appName, app) {
    super("apploaded", appName);
    this.app = app;
  }
};
var ApplicationLoaderAppShownEvent = class extends ApplicationLoaderEvent {
  constructor(appName, app) {
    super("appshown", appName);
    this.app = app;
  }
};
var ApplicationLoadRequest = class {
  constructor(loader2, name3) {
    this.loader = loader2;
    this.name = name3;
    this.params = /* @__PURE__ */ new Map();
  }
  param(name3, value2) {
    this.params.set(name3, value2);
    return this;
  }
  load(prog) {
    return this.loader(this.name, this.params, prog);
  }
};
var ApplicationLoader = class extends TypedEventBase {
  constructor(env, getAppUrl2) {
    super();
    this.env = env;
    this.getAppUrl = getAppUrl2;
    this.loadedModules = /* @__PURE__ */ new Map();
    this.loadingApps = /* @__PURE__ */ new Map();
    this.currentApps = /* @__PURE__ */ new Map();
    this.cacheBustString = null;
  }
  [Symbol.iterator]() {
    return this.currentApps.values();
  }
  isLoaded(name3) {
    return this.currentApps.has(name3);
  }
  get(name3) {
    return this.currentApps.get(name3);
  }
  waitFor(name3) {
    if (this.isLoaded(name3)) {
      return Promise.resolve(this.get(name3));
    }
    const task = new Task();
    this.addScopedEventListener(this, "apploaded", (evt) => {
      if (evt.appName === name3) {
        this.removeScope(this);
        task.resolve(evt.app);
      }
    });
    return task;
  }
  async loadAppConstructor(name3, prog) {
    if (!this.loadedModules.has(name3)) {
      let url2 = this.getAppUrl(name3);
      if (isDefined(this.cacheBustString)) {
        const uri = new URLBuilder(url2, location.href);
        uri.query("v", this.cacheBustString);
        url2 = uri.toString();
      }
      const task = this.env.fetcher.get(url2).progress(prog).useCache(!this.env.DEBUG).module().then(unwrapResponse);
      this.loadedModules.set(name3, task);
    } else if (isDefined(prog)) {
      prog.end();
    }
    const { default: AppConstructor } = await this.loadedModules.get(name3);
    return AppConstructor;
  }
  app(name3) {
    return new ApplicationLoadRequest(this.loadApp.bind(this), name3);
  }
  loadApp(name3, paramsOrProg, prog) {
    let params = null;
    if (paramsOrProg instanceof Map) {
      params = paramsOrProg;
    } else {
      prog = paramsOrProg;
    }
    prog = prog || this.env.loadingBar;
    const evt = new ApplicationLoaderAppLoadingEvent(name3, params);
    this.dispatchEvent(evt);
    if (!this.loadingApps.has(name3)) {
      const progs = progressPopper(prog);
      const appTask = this.loadAppInstance(this.env, name3, params, progs.pop(10));
      this.loadingApps.set(name3, appTask);
      prog = progs.pop(1);
    }
    return this.loadingApps.get(name3);
  }
  async loadAppInstance(env, name3, params, prog) {
    if (!this.currentApps.has(name3)) {
      const [appLoad, assetLoad] = progressSplitWeighted(prog, [1, 10]);
      const App = await this.loadAppConstructor(name3, appLoad);
      const app = new App(env);
      app.addEventListener("quit", () => this.unloadApp(name3));
      app.addEventListener("shown", () => this.dispatchEvent(new ApplicationLoaderAppShownEvent(name3, app)));
      if (isDefined(params)) {
        await app.init(params);
      }
      await app.load(assetLoad);
      this.currentApps.set(name3, app);
      this.dispatchEvent(new ApplicationLoaderAppLoadedEvent(name3, app));
    }
    if (isDefined(prog)) {
      prog.end();
    }
    return this.currentApps.get(name3);
  }
  unloadApp(name3) {
    const app = this.currentApps.get(name3);
    setTimeout(() => app.clearEventListeners(), 100);
    dispose(app);
    this.currentApps.delete(name3);
    this.loadingApps.delete(name3);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/animation/lookAngles.ts
var D = new Vector3();
function getLookHeadingRadians(dir) {
  D.copy(dir);
  D.y = 0;
  D.normalize();
  return radiansClamp(Math.atan2(D.x, D.z));
}
function getLookPitchRadians(dir) {
  return radiansClamp(Math.asin(dir.y));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/resolveCamera.ts
function resolveCamera(renderer, camera) {
  if (renderer.xr.isPresenting) {
    return renderer.xr.getCamera();
  } else {
    return camera;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/setUpFwdPosFromMatrix.ts
function setUpFwdPosFromMatrix(matrix, U2, F, P2) {
  const m = matrix.elements;
  U2.set(m[4], m[5], m[6]);
  F.set(-m[8], -m[9], -m[10]);
  P2.set(m[12], m[13], m[14]);
  U2.normalize();
  F.normalize();
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/AvatarLocal.ts
function isPermissionedDeviceOrientationEvent(obj2) {
  return obj2 === DeviceOrientationEvent && "requestPermission" in obj2 && isFunction(obj2.requestPermission);
}
var AvatarResetEvent = class extends TypedEvent {
  constructor() {
    super("avatarreset");
  }
};
var AvatarLocal = class extends TypedEventBase {
  constructor(env, fader) {
    super();
    this.env = env;
    this.avatarResetEvt = new AvatarResetEvent();
    this.controlMode = "none" /* None */;
    this.snapTurnRadians = deg2rad(30);
    this.sensitivities = /* @__PURE__ */ new Map([
      /**
       * The mouse is not as sensitive as the gamepad, so we have to bump up the
       * sensitivity quite a bit.
       **/
      ["mousedrag" /* MouseDrag */, 100],
      ["mousefirstperson" /* MouseFPS */, -100],
      /**
       * The touch points are not as sensitive as the gamepad, so we have to bump up the
       * sensitivity quite a bit.
       **/
      ["touchswipe" /* Touch */, 50],
      ["gamepad" /* Gamepad */, 1]
    ]);
    this.B = new Vector3(0, 0, 1);
    this.F = new Vector3();
    this.U = new Vector3();
    this.P = new Vector3();
    this.M = new Matrix4();
    this.E = new Euler();
    this.Q1 = new Quaternion();
    this.Q2 = new Quaternion();
    this.Q3 = new Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
    // - PI/2 around the x-axis
    this.Q4 = new Quaternion();
    this.motion = new Vector2();
    this.rotStage = new Matrix4();
    this.axisControl = new Vector2(0, 0);
    this.deviceQ = new Quaternion().identity();
    this.uv = new Vector2();
    this.duv = new Vector2();
    this.move = new Vector3();
    this.move2 = new Vector3();
    this.radialAcceleration = new Vector2(1.5, 1.5);
    this.radialSpeed = new Vector2(1, 1);
    this.radialEdgeFactor = 3 / 4;
    this.minFOVDegrees = 15;
    this.maxFOVDegrees = 120;
    this.minPitchRadians = deg2rad(-85);
    this.maxPitchRadians = deg2rad(85);
    this.followers = new Array();
    this.dz = 0;
    this._headingRadians = 0;
    this._pitchRadians = 0;
    this._rollRadians = 0;
    this.headX = 0;
    this.headZ = 0;
    this._worldHeadingRadians = 0;
    this._worldPitchRadians = 0;
    this.fwrd = false;
    this.back = false;
    this.left = false;
    this.rght = false;
    this.fwrd2 = false;
    this.back2 = false;
    this.left2 = false;
    this.rght2 = false;
    this.up = false;
    this.down = false;
    this.grow = false;
    this.shrk = false;
    this._keyboardControlEnabled = false;
    this.worldPos = new Vector3();
    this.worldQuat = new Quaternion();
    this.lockMovement = false;
    this.fovZoomEnabled = true;
    this.deviceOrientation = null;
    this.screenOrientation = 0;
    this.alphaOffset = 0;
    this.onDeviceOrientationChangeEvent = null;
    this.onScreenOrientationChangeEvent = null;
    this.motionEnabled = false;
    this.pointersToSend = new Array();
    this.disableHorizontal = false;
    this.disableVertical = false;
    this.invertHorizontal = false;
    this.invertVertical = true;
    this._height = this.env.defaultAvatarHeight;
    this.head = obj("Head", fader);
    let homeHit = false;
    const setKey = (key, ok) => {
      if (key === "w")
        this.fwrd = ok;
      if (key === "s")
        this.back = ok;
      if (key === "a")
        this.left = ok;
      if (key === "d")
        this.rght = ok;
      if (key === "e")
        this.up = ok;
      if (key === "q")
        this.down = ok;
      if (key === "ArrowUp")
        this.fwrd2 = ok;
      if (key === "ArrowDown")
        this.back2 = ok;
      if (key === "ArrowLeft")
        this.left2 = ok;
      if (key === "ArrowRight")
        this.rght2 = ok;
      if (key === "r")
        this.grow = ok;
      if (key === "f")
        this.shrk = ok;
      if (key === "Home") {
        const wasHome = homeHit;
        homeHit = ok;
        if (wasHome && !homeHit) {
          this.reset();
          this.dispatchEvent(this.avatarResetEvt);
        }
      }
    };
    this.onKeyDown = (evt) => setKey(evt.key, isModifierless(evt));
    this.onKeyUp = (evt) => setKey(evt.key, false);
    this.keyboardControlEnabled = true;
    if (matchMedia("(pointer: coarse)").matches) {
      this.controlMode = "touchswipe" /* Touch */;
    } else if (matchMedia("(pointer: fine)").matches) {
      this.controlMode = "mousedrag" /* MouseDrag */;
    }
    if (globalThis.isSecureContext && isMobile() && !isMobileVR()) {
      this.onDeviceOrientationChangeEvent = (event) => {
        this.deviceOrientation = event;
      };
      this.onScreenOrientationChangeEvent = () => {
        if ("screen" in globalThis && "orientation" in screen) {
          this.screenOrientation = screen.orientation.angle;
        } else if ("window" in globalThis && "orientation" in globalThis.window) {
          this.screenOrientation = globalThis.window.orientation || 0;
        }
      };
      if (isSafari) {
        onUserGesture(() => this.startMotionControl());
      } else {
        this.startMotionControl();
      }
    }
  }
  set disableVertical(v) {
    this._disableVertical = v;
    this.axisControl.x = this._disableVertical ? 0 : this._invertVertical ? 1 : -1;
  }
  set invertVertical(v) {
    this._invertVertical = v;
    this.axisControl.x = this._disableVertical ? 0 : this._invertVertical ? 1 : -1;
  }
  set disableHorizontal(v) {
    this._disableHorizontal = v;
    this.axisControl.y = this._disableHorizontal ? 0 : this._invertHorizontal ? 1 : -1;
  }
  set invertHorizontal(v) {
    this._invertHorizontal = v;
    this.axisControl.y = this._disableHorizontal ? 0 : this._invertHorizontal ? 1 : -1;
  }
  get height() {
    return this.head.position.y;
  }
  get object() {
    return this.head;
  }
  get worldHeadingRadians() {
    return this._worldHeadingRadians;
  }
  get worldPitchRadians() {
    return this._worldPitchRadians;
  }
  get fov() {
    return this.env.camera.fov;
  }
  set fov(v) {
    if (v !== this.fov) {
      this.env.camera.fov = v;
      this.env.camera.updateProjectionMatrix();
    }
  }
  get stage() {
    return this.head.parent;
  }
  snapTurn(direction) {
    this.setHeading(this.headingRadians - this.snapTurnRadians * direction);
  }
  get keyboardControlEnabled() {
    return this._keyboardControlEnabled;
  }
  set keyboardControlEnabled(v) {
    if (this._keyboardControlEnabled !== v) {
      this._keyboardControlEnabled = v;
      if (this._keyboardControlEnabled) {
        this.env.renderer.domElement.addEventListener("keydown", this.onKeyDown);
        this.env.renderer.domElement.addEventListener("keyup", this.onKeyUp);
      } else {
        this.env.renderer.domElement.removeEventListener("keydown", this.onKeyDown);
        this.env.renderer.domElement.removeEventListener("keyup", this.onKeyUp);
      }
    }
  }
  addFollower(follower) {
    this.followers.push(follower);
  }
  onMove(pointer, uv, duv) {
    this.setMode(pointer);
    if (pointer.canMoveView && this.controlMode !== "none" /* None */ && this.gestureSatisfied(pointer)) {
      this.uv.copy(uv);
      this.duv.copy(duv);
    }
  }
  setMode(pointer) {
    if (pointer.type === "remote" || pointer.type === "nose") {
    } else if (pointer.type === "hand") {
      this.controlMode = "none" /* None */;
    } else if (pointer.type === "gamepad") {
      this.controlMode = "gamepad" /* Gamepad */;
    } else if (pointer.rayTarget && pointer.rayTarget.draggable && !this.env.eventSys.mouse.isPointerLocked && pointer.isPressed(0 /* Primary */)) {
      this.controlMode = "mouseedge" /* ScreenEdge */;
    } else if (pointer.type === "touch" || pointer.type === "pen") {
      this.controlMode = "touchswipe" /* Touch */;
    } else if (pointer.type === "mouse") {
      this.controlMode = this.env.eventSys.mouse.isPointerLocked ? "mousefirstperson" /* MouseFPS */ : "mousedrag" /* MouseDrag */;
    } else {
      assertNever(pointer.type);
    }
  }
  gestureSatisfied(pointer) {
    if (this.controlMode === "none" /* None */) {
      return false;
    }
    return this.controlMode === "gamepad" /* Gamepad */ || this.controlMode === "mousefirstperson" /* MouseFPS */ || this.controlMode === "mouseedge" /* ScreenEdge */ || pointer.isPressed(0 /* Primary */);
  }
  get name() {
    return this.object.name;
  }
  set name(v) {
    this.object.name = v;
  }
  get headingRadians() {
    return this._headingRadians;
  }
  setHeading(radians) {
    this._headingRadians = radiansClamp(radians);
  }
  get pitchRadians() {
    return this._pitchRadians;
  }
  setPitch(radians, min5, max5) {
    this._pitchRadians = radiansClamp(radians + Pi) - Pi;
    this._pitchRadians = clamp(this._pitchRadians, min5, max5);
  }
  get rollRadians() {
    return this._rollRadians;
  }
  setRoll(radians) {
    this._rollRadians = radiansClamp(radians);
  }
  setHeadingImmediate(radians) {
    this.setHeading(radians);
    this.updateOrientation();
    this.resetFollowers();
  }
  setOrientationImmediate(headingRadians, pitchRadians) {
    this.setHeading(headingRadians);
    this._pitchRadians = radiansClamp(pitchRadians);
    this.updateOrientation();
  }
  zoom(dz) {
    this.dz = dz;
  }
  update(dt) {
    dt *= 1e-3;
    const device = this.deviceOrientation;
    if (device && isGoodNumber(device.alpha) && isGoodNumber(device.beta) && isGoodNumber(device.gamma)) {
      const alpha = deg2rad(device.alpha) + this.alphaOffset;
      const beta2 = deg2rad(device.beta);
      const gamma = deg2rad(device.gamma);
      const orient = this.screenOrientation ? deg2rad(this.screenOrientation) : 0;
      this.E.set(beta2, alpha, -gamma, "YXZ");
      this.Q2.setFromAxisAngle(this.B, -orient);
      this.Q4.setFromEuler(this.E).multiply(this.Q3).multiply(this.Q2);
      this.deviceQ.slerp(this.Q4, 0.8);
    }
    if (!this.lockMovement) {
      if (this.fovZoomEnabled && Math.abs(this.dz) > 0) {
        const smoothing = Math.pow(0.95, 5e3 * dt);
        this.dz = truncate(smoothing * this.dz);
        this.fov = clamp(this.env.camera.fov - this.dz, this.minFOVDegrees, this.maxFOVDegrees);
      }
      if (this.controlMode === "mouseedge" /* ScreenEdge */) {
        if (this.uv.manhattanLength() > 0) {
          this.motion.set(
            this.scaleRadialComponent(-this.uv.x, this.radialSpeed.x, this.radialAcceleration.x),
            this.scaleRadialComponent(this.uv.y, this.radialSpeed.y, this.radialAcceleration.y)
          ).multiplyScalar(dt);
          this.setHeading(this.headingRadians + this.motion.x);
          this.setPitch(this.pitchRadians + this.motion.y, this.minPitchRadians, this.maxPitchRadians);
          this.setRoll(0);
        }
      } else if (this.sensitivities.has(this.controlMode)) {
        if (this.duv.manhattanLength() > 0) {
          const sensitivity = this.sensitivities.get(this.controlMode) || 1;
          this.motion.copy(this.duv).multiplyScalar(sensitivity * dt).multiply(this.axisControl);
          this.setHeading(this.headingRadians + this.motion.x);
          this.setPitch(this.pitchRadians + this.motion.y, this.minPitchRadians, this.maxPitchRadians);
          this.setRoll(0);
        }
      }
      this.Q1.setFromAxisAngle(this.stage.up, this.worldHeadingRadians);
      if (this.fwrd || this.back || this.left || this.rght || this.up || this.down) {
        const dx = (this.left ? 1 : 0) + (this.rght ? -1 : 0);
        const dy = (this.down ? 1 : 0) + (this.up ? -1 : 0);
        const dz = (this.fwrd ? 1 : 0) + (this.back ? -1 : 0);
        this.move.set(dx, dy, dz);
        const d = this.move.length();
        if (d > 0) {
          this.move.multiplyScalar(dt / d).applyQuaternion(this.Q1);
          this.stage.position.add(this.move);
        }
      }
      if (this.fwrd2 || this.back2 || this.left2 || this.rght2) {
        const dx = (this.left2 ? 1 : 0) + (this.rght2 ? -1 : 0);
        const dz = (this.fwrd2 ? 1 : 0) + (this.back2 ? -1 : 0);
        this.move2.set(dx, 0, dz);
        const d = this.move2.length();
        if (d > 0) {
          this.move2.multiplyScalar(dt / d).applyQuaternion(this.Q1);
          this.headX += this.move2.x;
          this.headZ += this.move2.z;
        }
      }
      if (this.grow || this.shrk) {
        const dy = (this.shrk ? -1 : 0) + (this.grow ? 1 : 0);
        this._height += dy * dt;
        this._height = clamp(this._height, 1, 2);
      }
      this.updateOrientation();
      const decay = Math.pow(0.95, 100 * dt);
      this.duv.multiplyScalar(decay);
      if (this.duv.manhattanLength() <= 1e-4) {
        this.duv.setScalar(0);
      }
    }
  }
  scaleRadialComponent(n2, dn, ddn) {
    const absN = Math.abs(n2);
    return Math.sign(n2) * Math.pow(Math.max(0, absN - this.radialEdgeFactor) / (1 - this.radialEdgeFactor), ddn) * dn;
  }
  lookAt(obj2) {
    obj2.getWorldPosition(this.P);
    this.P.sub(this.worldPos);
    const heading = 3 * HalfPi - Math.atan2(this.P.z, this.P.x);
    const pitch = Math.atan2(this.P.y, this.P.length());
    this.setOrientationImmediate(heading, pitch);
  }
  updateOrientation() {
    const cam = resolveCamera(this.env.renderer, this.env.camera);
    this.rotStage.makeRotationY(this._headingRadians);
    this.stage.matrix.makeTranslation(
      this.stage.position.x,
      this.stage.position.y,
      this.stage.position.z
    ).multiply(this.rotStage);
    this.stage.matrix.decompose(
      this.stage.position,
      this.stage.quaternion,
      this.stage.scale
    );
    if (this.env.renderer.xr.isPresenting) {
      this.M.copy(this.stage.matrixWorld).invert();
      this.head.position.copy(cam.position).applyMatrix4(this.M);
      this.head.quaternion.copy(this.stage.quaternion).invert().multiply(cam.quaternion);
    } else {
      this.head.position.set(this.headX, this._height, this.headZ);
      this.E.set(this._pitchRadians, 0, this._rollRadians, "XYZ");
      this.head.quaternion.setFromEuler(this.E).premultiply(this.deviceQ);
    }
    this.env.camera.position.copy(this.head.position);
    this.env.camera.quaternion.copy(this.head.quaternion);
    this.head.getWorldPosition(this.worldPos);
    this.head.getWorldQuaternion(this.worldQuat);
    this.F.set(0, 0, -1).applyQuaternion(this.worldQuat);
    this._worldHeadingRadians = getLookHeadingRadians(this.F);
    this._worldPitchRadians = getLookPitchRadians(this.F);
    setUpFwdPosFromMatrix(this.head.matrixWorld, this.U, this.F, this.P);
  }
  reset() {
    this.stage.position.setScalar(0);
    this.setHeadingImmediate(0);
  }
  resetFollowers() {
    for (const follower of this.followers) {
      follower.reset(this.height, this.worldPos, this.worldHeadingRadians);
    }
  }
  async getPermission() {
    if (!("DeviceOrientationEvent" in window)) {
      return "not-supported";
    }
    if (isPermissionedDeviceOrientationEvent(DeviceOrientationEvent)) {
      return await DeviceOrientationEvent.requestPermission();
    }
    return "granted";
  }
  async startMotionControl() {
    if (!this.motionEnabled) {
      this.onScreenOrientationChangeEvent();
      const permission = await this.getPermission();
      this.motionEnabled = permission === "granted";
      if (this.motionEnabled) {
        if ("ScreenOrientation" in window) {
          screen.orientation.addEventListener("change", this.onScreenOrientationChangeEvent);
        } else {
          window.addEventListener("orientationchange", this.onScreenOrientationChangeEvent);
        }
        window.addEventListener("deviceorientation", this.onDeviceOrientationChangeEvent);
      }
    }
  }
  stopMotionControl() {
    if (this.motionEnabled) {
      if ("ScreenOrientation" in window) {
        screen.orientation.removeEventListener("change", this.onScreenOrientationChangeEvent);
      } else {
        window.removeEventListener("orientationchange", this.onScreenOrientationChangeEvent);
      }
      window.removeEventListener("deviceorientation", this.onDeviceOrientationChangeEvent);
      this.motionEnabled = false;
    }
  }
  dispose() {
    this.stopMotionControl();
  }
  get bufferSize() {
    return 133;
  }
  writeState(buffer) {
    arrayClear(this.pointersToSend);
    let size4 = this.env.avatar.bufferSize;
    for (const pointer of this.env.eventSys.pointers) {
      if (pointer.canSend) {
        size4 += pointer.bufferSize;
        this.pointersToSend.push(pointer);
      }
    }
    buffer.length = size4;
    buffer.position = 0;
    buffer.writeFloat32(this.height);
    buffer.writeMatrix512(this.stage.matrix);
    buffer.writeMatrix512(this.head.matrixWorld);
    buffer.writeUint8(this.pointersToSend.length);
    for (const pointer of this.pointersToSend) {
      pointer.writeState(buffer);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Fader.ts
var Fader = class {
  constructor(name3, t2 = 0.15) {
    this.opacity = 1;
    this.direction = 0;
    this.task = new Task(false);
    this.material = solidTransparent({
      name: "FaderMaterial",
      color: 0,
      side: BackSide
    });
    this.object = cube(name3, 1, 1, 1, this.material);
    this.object.renderOrder = Number.MAX_SAFE_INTEGER;
    this.speed = 1 / t2;
    this.object.layers.enableAll();
  }
  async start(direction) {
    this.direction = direction;
    this.task.restart();
    await this.task;
  }
  async fadeOut() {
    if (this.direction != 1) {
      await this.start(1);
    }
  }
  async fadeIn() {
    if (this.direction != -1) {
      await this.start(-1);
    }
  }
  update(dt) {
    if (this.direction !== 0) {
      const dOpacity = this.direction * this.speed * dt / 1e3;
      if (0 <= this.opacity && this.opacity <= 1) {
        this.opacity += dOpacity;
      }
      if (this.direction === 1 && this.opacity >= 1 || this.direction === -1 && this.opacity <= 0) {
        this.opacity = clamp(this.opacity, 0, 1);
        this.direction = 0;
        this.task.resolve();
      }
    }
    this.material.opacity = this.opacity;
    this.material.transparent = this.opacity < 1;
    this.material.needsUpdate = true;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/layers.ts
var FOREGROUND = 0;
var PURGATORY = 3;
function deepSetLayer(obj2, level) {
  obj2 = objectResolve(obj2);
  obj2.traverse((o) => o.layers.set(level));
}
function deepEnableLayer(obj2, level) {
  obj2 = objectResolve(obj2);
  obj2.traverse((o) => o.layers.enable(level));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/LoadingBar.ts
function chrome(x, y, z, w, h, d) {
  const chromeMesh = new Cube(w, h, d, litWhite);
  chromeMesh.position.set(x, y, z);
  return chromeMesh;
}
var velocity = 0.1;
var LoadingBar = class extends BaseProgress {
  constructor() {
    super();
    this.value = 0;
    this.targetValue = 0;
    this.object = obj("LoadingBar");
    this._enabled = true;
    this.valueBar = new Cube(0, 1, 1, litGrey);
    this.valueBar.scale.set(0, 1, 1);
    const valueBarContainer = obj("ValueBarContainer");
    valueBarContainer.scale.set(1, 0.1, 0.1);
    objGraph(
      this,
      objGraph(
        valueBarContainer,
        this.valueBar
      ),
      chrome(-0.5, 0, -0.05, 0.01, 0.1, 0.01),
      chrome(-0.5, 0, 0.05, 0.01, 0.1, 0.01),
      chrome(0.5, 0, -0.05, 0.01, 0.1, 0.01),
      chrome(0.5, 0, 0.05, 0.01, 0.1, 0.01),
      chrome(-0.5, -0.05, 0, 0.01, 0.01, 0.1),
      chrome(0.5, -0.05, 0, 0.01, 0.01, 0.1),
      chrome(-0.5, 0.05, 0, 0.01, 0.01, 0.1),
      chrome(0.5, 0.05, 0, 0.01, 0.01, 0.1),
      chrome(0, -0.05, -0.05, 1, 0.01, 0.01),
      chrome(0, 0.05, -0.05, 1, 0.01, 0.01),
      chrome(0, -0.05, 0.05, 1, 0.01, 0.01),
      chrome(0, 0.05, 0.05, 1, 0.01, 0.01)
    );
    deepSetLayer(this, PURGATORY);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(v) {
    if (v !== this._enabled) {
      this._enabled = v;
      objectSetVisible(this, objectIsVisible(this) || this.enabled);
    }
  }
  report(soFar, total, msg) {
    super.report(soFar, total, msg);
    this.targetValue = this.p;
  }
  update(dt) {
    if (this.object.parent.visible) {
      this.value = Math.min(this.targetValue, this.value + velocity * dt);
      this.valueBar.scale.set(this.value, 1, 1);
      this.valueBar.position.x = this.value / 2 - 0.5;
      objectSetVisible(this, this.enabled && this.value > 0);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/fullscreen.ts
if (!hasFullscreenAPI()) {
  const Elm = Element.prototype;
  const Doc = Document.prototype;
  if ("webkitRequestFullscreen" in Elm) {
    Elm.requestFullscreen = Elm.webkitRequestFullscreen;
    Doc.exitFullscreen = Doc.webkitRequestFullscreen;
    Object.defineProperties(Doc, {
      "fullscreenEnabled": {
        get: function() {
          return this.webkitFullscreenEnabled;
        }
      },
      "fullscreenElement": {
        get: function() {
          return this.webkitFullscreenElement;
        }
      }
    });
  } else if ("mozRequestFullScreen" in Elm) {
    Elm.requestFullscreen = Elm.mozRequestFullScreen;
    Doc.exitFullscreen = Doc.mozCancelFullScreen;
    Object.defineProperties(Doc, {
      "fullscreenEnabled": {
        get: function() {
          return this.mozFullScreenEnabled;
        }
      },
      "fullscreenElement": {
        get: function() {
          return this.mozFullScreenElement;
        }
      }
    });
  } else if ("msRequestFullscreen" in Elm) {
    Elm.requestFullscreen = Elm.msRequestFullscreen;
    Doc.exitFullscreen = Doc.msExitFullscreen;
    Object.defineProperties(Doc, {
      "fullscreenEnabled": {
        get: function() {
          return this.msFullscreenEnabled;
        }
      },
      "fullscreenElement": {
        get: function() {
          return this.msFullscreenElement;
        }
      }
    });
  }
}
function hasFullscreenAPI() {
  return "requestFullscreen" in HTMLElement.prototype;
}

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/lib/global.js
var _global = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
var global_default = _global;

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/lib/EventTarget.js
var PRIVATE = Symbol("@@webxr-polyfill/EventTarget");
var EventTarget = class {
  constructor() {
    this[PRIVATE] = {
      listeners: /* @__PURE__ */ new Map()
    };
  }
  /**
   * @param {string} type
   * @param {Function} listener
   */
  addEventListener(type2, listener) {
    if (typeof type2 !== "string") {
      throw new Error("`type` must be a string");
    }
    if (typeof listener !== "function") {
      throw new Error("`listener` must be a function");
    }
    const typedListeners = this[PRIVATE].listeners.get(type2) || [];
    typedListeners.push(listener);
    this[PRIVATE].listeners.set(type2, typedListeners);
  }
  /**
   * @param {string} type
   * @param {Function} listener
   */
  removeEventListener(type2, listener) {
    if (typeof type2 !== "string") {
      throw new Error("`type` must be a string");
    }
    if (typeof listener !== "function") {
      throw new Error("`listener` must be a function");
    }
    const typedListeners = this[PRIVATE].listeners.get(type2) || [];
    for (let i = typedListeners.length; i >= 0; i--) {
      if (typedListeners[i] === listener) {
        typedListeners.pop();
      }
    }
  }
  /**
   * @param {string} type
   * @param {object} event
   */
  dispatchEvent(type2, event) {
    const typedListeners = this[PRIVATE].listeners.get(type2) || [];
    const queue = [];
    for (let i = 0; i < typedListeners.length; i++) {
      queue[i] = typedListeners[i];
    }
    for (let listener of queue) {
      listener(event);
    }
    if (typeof this[`on${type2}`] === "function") {
      this[`on${type2}`](event);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/node_modules/gl-matrix/src/gl-matrix/common.js
var EPSILON2 = 1e-6;
var ARRAY_TYPE2 = typeof Float32Array !== "undefined" ? Float32Array : Array;
var degree2 = Math.PI / 180;

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/node_modules/gl-matrix/src/gl-matrix/mat4.js
function create7() {
  let out = new ARRAY_TYPE2(16);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function copy5(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function invert2(out, a) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  let b00 = a00 * a11 - a01 * a10;
  let b01 = a00 * a12 - a02 * a10;
  let b02 = a00 * a13 - a03 * a10;
  let b03 = a01 * a12 - a02 * a11;
  let b04 = a01 * a13 - a03 * a11;
  let b05 = a02 * a13 - a03 * a12;
  let b06 = a20 * a31 - a21 * a30;
  let b07 = a20 * a32 - a22 * a30;
  let b08 = a20 * a33 - a23 * a30;
  let b09 = a21 * a32 - a22 * a31;
  let b10 = a21 * a33 - a23 * a31;
  let b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function multiply4(out, a, b) {
  let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function fromRotationTranslation(out, q, v) {
  let x = q[0], y = q[1], z = q[2], w = q[3];
  let x2 = x + x;
  let y2 = y + y;
  let z2 = z + z;
  let xx = x * x2;
  let xy = x * y2;
  let xz = x * z2;
  let yy = y * y2;
  let yz = y * z2;
  let zz = z * z2;
  let wx = w * x2;
  let wy = w * y2;
  let wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getRotation(out, mat) {
  let trace = mat[0] + mat[5] + mat[10];
  let S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (mat[6] - mat[9]) / S2;
    out[1] = (mat[8] - mat[2]) / S2;
    out[2] = (mat[1] - mat[4]) / S2;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S2 = Math.sqrt(1 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S2;
    out[0] = 0.25 * S2;
    out[1] = (mat[1] + mat[4]) / S2;
    out[2] = (mat[8] + mat[2]) / S2;
  } else if (mat[5] > mat[10]) {
    S2 = Math.sqrt(1 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S2;
    out[0] = (mat[1] + mat[4]) / S2;
    out[1] = 0.25 * S2;
    out[2] = (mat[6] + mat[9]) / S2;
  } else {
    S2 = Math.sqrt(1 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S2;
    out[0] = (mat[8] + mat[2]) / S2;
    out[1] = (mat[6] + mat[9]) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function perspective(out, fovy, aspect, near, far) {
  let f2 = 1 / Math.tan(fovy / 2), nf;
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/node_modules/gl-matrix/src/gl-matrix/vec3.js
function create8() {
  let out = new ARRAY_TYPE2(3);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone5(a) {
  var out = new ARRAY_TYPE2(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length5(a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
function fromValues5(x, y, z) {
  let out = new ARRAY_TYPE2(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy6(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function scale5(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function normalize5(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let len6 = x * x + y * y + z * z;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    out[0] = a[0] * len6;
    out[1] = a[1] * len6;
    out[2] = a[2] * len6;
  }
  return out;
}
function dot5(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross3(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2];
  let bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function transformQuat2(out, a, q) {
  let qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  let x = a[0], y = a[1], z = a[2];
  let uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  let uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  let w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function angle3(a, b) {
  let tempA = fromValues5(a[0], a[1], a[2]);
  let tempB = fromValues5(b[0], b[1], b[2]);
  normalize5(tempA, tempA);
  normalize5(tempB, tempB);
  let cosine = dot5(tempA, tempB);
  if (cosine > 1) {
    return 0;
  } else if (cosine < -1) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
var len4 = length5;
var forEach4 = function() {
  let vec = create8();
  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/node_modules/gl-matrix/src/gl-matrix/mat3.js
function create9() {
  let out = new ARRAY_TYPE2(9);
  if (ARRAY_TYPE2 != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/node_modules/gl-matrix/src/gl-matrix/vec4.js
function create10() {
  let out = new ARRAY_TYPE2(4);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone6(a) {
  let out = new ARRAY_TYPE2(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues6(x, y, z, w) {
  let out = new ARRAY_TYPE2(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy7(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function normalize6(out, a) {
  let x = a[0];
  let y = a[1];
  let z = a[2];
  let w = a[3];
  let len6 = x * x + y * y + z * z + w * w;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
    out[0] = x * len6;
    out[1] = y * len6;
    out[2] = z * len6;
    out[3] = w * len6;
  }
  return out;
}
var forEach5 = function() {
  let vec = create10();
  return function(a, stride, offset, count, fn, arg) {
    let i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/node_modules/gl-matrix/src/gl-matrix/quat.js
function create11() {
  let out = new ARRAY_TYPE2(4);
  if (ARRAY_TYPE2 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function setAxisAngle2(out, axis, rad) {
  rad = rad * 0.5;
  let s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function multiply5(out, a, b) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function slerp2(out, a, b, t2) {
  let ax = a[0], ay = a[1], az = a[2], aw = a[3];
  let bx = b[0], by = b[1], bz = b[2], bw = b[3];
  let omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON2) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t2) * omega) / sinom;
    scale1 = Math.sin(t2 * omega) / sinom;
  } else {
    scale0 = 1 - t2;
    scale1 = t2;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function invert3(out, a) {
  let a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  let dot8 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  let invDot = dot8 ? 1 / dot8 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function fromMat32(out, m) {
  let fTrace = m[0] + m[4] + m[8];
  let fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    let i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    let j = (i + 1) % 3;
    let k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler2(out, x, y, z) {
  let halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  let sx = Math.sin(x);
  let cx = Math.cos(x);
  let sy = Math.sin(y);
  let cy = Math.cos(y);
  let sz = Math.sin(z);
  let cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
var clone7 = clone6;
var fromValues7 = fromValues6;
var copy8 = copy7;
var normalize7 = normalize6;
var rotationTo2 = function() {
  let tmpvec3 = create8();
  let xUnitVec3 = fromValues5(1, 0, 0);
  let yUnitVec3 = fromValues5(0, 1, 0);
  return function(out, a, b) {
    let dot8 = dot5(a, b);
    if (dot8 < -0.999999) {
      cross3(tmpvec3, xUnitVec3, a);
      if (len4(tmpvec3) < 1e-6)
        cross3(tmpvec3, yUnitVec3, a);
      normalize5(tmpvec3, tmpvec3);
      setAxisAngle2(out, tmpvec3, Math.PI);
      return out;
    } else if (dot8 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross3(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot8;
      return normalize7(out, out);
    }
  };
}();
var sqlerp2 = function() {
  let temp1 = create11();
  let temp2 = create11();
  return function(out, a, b, c, d, t2) {
    slerp2(temp1, a, d, t2);
    slerp2(temp2, b, c, t2);
    slerp2(out, temp1, temp2, 2 * t2 * (1 - t2));
    return out;
  };
}();
var setAxes2 = function() {
  let matr = create9();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize7(out, fromMat32(out, matr));
  };
}();

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRRigidTransform.js
var PRIVATE2 = Symbol("@@webxr-polyfill/XRRigidTransform");
var XRRigidTransform2 = class {
  // no arguments: identity transform
  // (Float32Array): transform based on matrix
  // (DOMPointReadOnly): transform based on position without any rotation
  // (DOMPointReadOnly, DOMPointReadOnly): transform based on position and
  // orientation quaternion
  constructor() {
    this[PRIVATE2] = {
      matrix: null,
      position: null,
      orientation: null,
      inverse: null
    };
    if (arguments.length === 0) {
      this[PRIVATE2].matrix = identity3(new Float32Array(16));
    } else if (arguments.length === 1) {
      if (arguments[0] instanceof Float32Array) {
        this[PRIVATE2].matrix = arguments[0];
      } else {
        this[PRIVATE2].position = this._getPoint(arguments[0]);
        this[PRIVATE2].orientation = DOMPointReadOnly.fromPoint({
          x: 0,
          y: 0,
          z: 0,
          w: 1
        });
      }
    } else if (arguments.length === 2) {
      this[PRIVATE2].position = this._getPoint(arguments[0]);
      this[PRIVATE2].orientation = this._getPoint(arguments[1]);
    } else {
      throw new Error("Too many arguments!");
    }
    if (this[PRIVATE2].matrix) {
      let position = create8();
      getTranslation(position, this[PRIVATE2].matrix);
      this[PRIVATE2].position = DOMPointReadOnly.fromPoint({
        x: position[0],
        y: position[1],
        z: position[2]
      });
      let orientation = create11();
      getRotation(orientation, this[PRIVATE2].matrix);
      this[PRIVATE2].orientation = DOMPointReadOnly.fromPoint({
        x: orientation[0],
        y: orientation[1],
        z: orientation[2],
        w: orientation[3]
      });
    } else {
      this[PRIVATE2].matrix = identity3(new Float32Array(16));
      fromRotationTranslation(
        this[PRIVATE2].matrix,
        fromValues7(
          this[PRIVATE2].orientation.x,
          this[PRIVATE2].orientation.y,
          this[PRIVATE2].orientation.z,
          this[PRIVATE2].orientation.w
        ),
        fromValues5(
          this[PRIVATE2].position.x,
          this[PRIVATE2].position.y,
          this[PRIVATE2].position.z
        )
      );
    }
  }
  /**
   * Try to convert arg to a DOMPointReadOnly if it isn't already one.
   * @param {*} arg
   * @return {DOMPointReadOnly}
   */
  _getPoint(arg) {
    if (arg instanceof DOMPointReadOnly) {
      return arg;
    }
    return DOMPointReadOnly.fromPoint(arg);
  }
  /**
   * @return {Float32Array}
   */
  get matrix() {
    return this[PRIVATE2].matrix;
  }
  /**
   * @return {DOMPointReadOnly}
   */
  get position() {
    return this[PRIVATE2].position;
  }
  /**
   * @return {DOMPointReadOnly}
   */
  get orientation() {
    return this[PRIVATE2].orientation;
  }
  /**
   * @return {XRRigidTransform}
   */
  get inverse() {
    if (this[PRIVATE2].inverse === null) {
      let invMatrix = identity3(new Float32Array(16));
      invert2(invMatrix, this[PRIVATE2].matrix);
      this[PRIVATE2].inverse = new XRRigidTransform2(invMatrix);
      this[PRIVATE2].inverse[PRIVATE2].inverse = this;
    }
    return this[PRIVATE2].inverse;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRSpace.js
var PRIVATE3 = Symbol("@@webxr-polyfill/XRSpace");
var XRSpace = class {
  /**
   * @param {string?} specialType
   * @param {XRInputSource?} inputSource 
   */
  constructor(specialType = null, inputSource = null) {
    this[PRIVATE3] = {
      specialType,
      inputSource,
      // The transform for the space in the base space, along with it's inverse
      baseMatrix: null,
      inverseBaseMatrix: null,
      lastFrameId: -1
    };
  }
  /**
   * @return {string?}
   */
  get _specialType() {
    return this[PRIVATE3].specialType;
  }
  /**
   * @return {XRInputSource?}
   */
  get _inputSource() {
    return this[PRIVATE3].inputSource;
  }
  /**
   * NON-STANDARD
   * Trigger an update for this space's base pose if necessary
   * @param {XRDevice} device
   * @param {Number} frameId
   */
  _ensurePoseUpdated(device, frameId) {
    if (frameId == this[PRIVATE3].lastFrameId)
      return;
    this[PRIVATE3].lastFrameId = frameId;
    this._onPoseUpdate(device);
  }
  /**
   * NON-STANDARD
   * Called when this space's base pose needs to be updated
   * @param {XRDevice} device
   */
  _onPoseUpdate(device) {
    if (this[PRIVATE3].specialType == "viewer") {
      this._baseMatrix = device.getBasePoseMatrix();
    }
  }
  /**
   * NON-STANDARD
   * @param {Float32Array(16)} matrix
   */
  set _baseMatrix(matrix) {
    this[PRIVATE3].baseMatrix = matrix;
    this[PRIVATE3].inverseBaseMatrix = null;
  }
  /**
   * NON-STANDARD
   * @return {Float32Array(16)}
   */
  get _baseMatrix() {
    if (!this[PRIVATE3].baseMatrix) {
      if (this[PRIVATE3].inverseBaseMatrix) {
        this[PRIVATE3].baseMatrix = new Float32Array(16);
        invert2(this[PRIVATE3].baseMatrix, this[PRIVATE3].inverseBaseMatrix);
      }
    }
    return this[PRIVATE3].baseMatrix;
  }
  /**
   * NON-STANDARD
   * @param {Float32Array(16)} matrix
   */
  set _inverseBaseMatrix(matrix) {
    this[PRIVATE3].inverseBaseMatrix = matrix;
    this[PRIVATE3].baseMatrix = null;
  }
  /**
   * NON-STANDARD
   * @return {Float32Array(16)}
   */
  get _inverseBaseMatrix() {
    if (!this[PRIVATE3].inverseBaseMatrix) {
      if (this[PRIVATE3].baseMatrix) {
        this[PRIVATE3].inverseBaseMatrix = new Float32Array(16);
        invert2(this[PRIVATE3].inverseBaseMatrix, this[PRIVATE3].baseMatrix);
      }
    }
    return this[PRIVATE3].inverseBaseMatrix;
  }
  /**
   * NON-STANDARD
   * Gets the transform of the given space in this space
   *
   * @param {XRSpace} space
   * @return {XRRigidTransform}
   */
  _getSpaceRelativeTransform(space) {
    if (!this._inverseBaseMatrix || !space._baseMatrix) {
      return null;
    }
    let out = new Float32Array(16);
    multiply4(out, this._inverseBaseMatrix, space._baseMatrix);
    return new XRRigidTransform2(out);
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRReferenceSpace.js
var DEFAULT_EMULATION_HEIGHT = 1.6;
var PRIVATE4 = Symbol("@@webxr-polyfill/XRReferenceSpace");
var XRReferenceSpaceTypes = [
  "viewer",
  "local",
  "local-floor",
  "bounded-floor",
  "unbounded"
  // TODO: 'unbounded' is not supported by the polyfill.
];
function isFloor(type2) {
  return type2 === "bounded-floor" || type2 === "local-floor";
}
var XRReferenceSpace = class extends XRSpace {
  /**
   * Optionally takes a `transform` from a device's requestFrameOfReferenceMatrix
   * so device's can provide their own transforms for stage (or if they
   * wanted to override eye-level/head-model).
   *
   * @param {XRReferenceSpaceType} type
   * @param {Float32Array?} transform
   */
  constructor(type2, transform2 = null) {
    if (!XRReferenceSpaceTypes.includes(type2)) {
      throw new Error(`XRReferenceSpaceType must be one of ${XRReferenceSpaceTypes}`);
    }
    super(type2);
    if (type2 === "bounded-floor" && !transform2) {
      throw new Error(`XRReferenceSpace cannot use 'bounded-floor' type if the platform does not provide the floor level`);
    }
    if (isFloor(type2) && !transform2) {
      transform2 = identity3(new Float32Array(16));
      transform2[13] = DEFAULT_EMULATION_HEIGHT;
    }
    this._inverseBaseMatrix = transform2 || identity3(new Float32Array(16));
    this[PRIVATE4] = {
      type: type2,
      transform: transform2,
      originOffset: identity3(new Float32Array(16))
    };
  }
  /**
   * NON-STANDARD
   * Takes a base pose model matrix and transforms it by the
   * frame of reference.
   *
   * @param {Float32Array} out
   * @param {Float32Array} pose
   */
  _transformBasePoseMatrix(out, pose) {
    multiply4(out, this._inverseBaseMatrix, pose);
  }
  /**
   * NON-STANDARD
   * 
   * @return {Float32Array}
   */
  _originOffsetMatrix() {
    return this[PRIVATE4].originOffset;
  }
  /**
   * transformMatrix = Inv(OriginOffsetMatrix) * transformMatrix
   * @param {Float32Array} transformMatrix 
   */
  _adjustForOriginOffset(transformMatrix) {
    let inverseOriginOffsetMatrix = new Float32Array(16);
    invert2(inverseOriginOffsetMatrix, this[PRIVATE4].originOffset);
    multiply4(transformMatrix, inverseOriginOffsetMatrix, transformMatrix);
  }
  /**
   * Gets the transform of the given space in this space
   *
   * @param {XRSpace} space
   * @return {XRRigidTransform}
   */
  _getSpaceRelativeTransform(space) {
    let transform2 = super._getSpaceRelativeTransform(space);
    this._adjustForOriginOffset(transform2.matrix);
    return new XRRigidTransform(transform2.matrix);
  }
  /**
   * Doesn't update the bound geometry for bounded reference spaces.
   * @param {XRRigidTransform} additionalOffset
   * @return {XRReferenceSpace}
  */
  getOffsetReferenceSpace(additionalOffset) {
    let newSpace = new XRReferenceSpace(
      this[PRIVATE4].type,
      this[PRIVATE4].transform,
      this[PRIVATE4].bounds
    );
    multiply4(newSpace[PRIVATE4].originOffset, this[PRIVATE4].originOffset, additionalOffset.matrix);
    return newSpace;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRSystem.js
var PRIVATE5 = Symbol("@@webxr-polyfill/XR");
var XRSessionModes = ["inline", "immersive-vr", "immersive-ar"];
var DEFAULT_SESSION_OPTIONS = {
  "inline": {
    requiredFeatures: ["viewer"],
    optionalFeatures: []
  },
  "immersive-vr": {
    requiredFeatures: ["viewer", "local"],
    optionalFeatures: []
  },
  "immersive-ar": {
    requiredFeatures: ["viewer", "local"],
    optionalFeatures: []
  }
};
var POLYFILL_REQUEST_SESSION_ERROR = `Polyfill Error: Must call navigator.xr.isSessionSupported() with any XRSessionMode
or navigator.xr.requestSession('inline') prior to requesting an immersive
session. This is a limitation specific to the WebXR Polyfill and does not apply
to native implementations of the API.`;
var XRSystem = class extends EventTarget {
  /**
   * Receives a promise of an XRDevice, so that the polyfill
   * can pass in some initial checks to asynchronously provide XRDevices
   * if content immediately requests `requestDevice()`.
   *
   * @param {Promise<XRDevice>} devicePromise
   */
  constructor(devicePromise) {
    super();
    this[PRIVATE5] = {
      device: null,
      devicePromise,
      immersiveSession: null,
      inlineSessions: /* @__PURE__ */ new Set()
    };
    devicePromise.then((device) => {
      this[PRIVATE5].device = device;
    });
  }
  /**
   * @param {XRSessionMode} mode
   * @return {Promise<boolean>}
   */
  async isSessionSupported(mode) {
    if (!this[PRIVATE5].device) {
      await this[PRIVATE5].devicePromise;
    }
    if (mode != "inline") {
      return Promise.resolve(this[PRIVATE5].device.isSessionSupported(mode));
    }
    return Promise.resolve(true);
  }
  /**
   * @param {XRSessionMode} mode
   * @param {XRSessionInit} options
   * @return {Promise<XRSession>}
   */
  async requestSession(mode, options) {
    if (!this[PRIVATE5].device) {
      if (mode != "inline") {
        throw new Error(POLYFILL_REQUEST_SESSION_ERROR);
      } else {
        await this[PRIVATE5].devicePromise;
      }
    }
    if (!XRSessionModes.includes(mode)) {
      throw new TypeError(
        `The provided value '${mode}' is not a valid enum value of type XRSessionMode`
      );
    }
    const defaultOptions = DEFAULT_SESSION_OPTIONS[mode];
    const requiredFeatures = defaultOptions.requiredFeatures.concat(
      options && options.requiredFeatures ? options.requiredFeatures : []
    );
    const optionalFeatures = defaultOptions.optionalFeatures.concat(
      options && options.optionalFeatures ? options.optionalFeatures : []
    );
    const enabledFeatures = /* @__PURE__ */ new Set();
    let requirementsFailed = false;
    for (let feature of requiredFeatures) {
      if (!this[PRIVATE5].device.isFeatureSupported(feature)) {
        console.error(`The required feature '${feature}' is not supported`);
        requirementsFailed = true;
      } else {
        enabledFeatures.add(feature);
      }
    }
    if (requirementsFailed) {
      throw new DOMException("Session does not support some required features", "NotSupportedError");
    }
    for (let feature of optionalFeatures) {
      if (!this[PRIVATE5].device.isFeatureSupported(feature)) {
        console.log(`The optional feature '${feature}' is not supported`);
      } else {
        enabledFeatures.add(feature);
      }
    }
    const sessionId = await this[PRIVATE5].device.requestSession(mode, enabledFeatures);
    const session = new XRSession(this[PRIVATE5].device, mode, sessionId);
    if (mode == "inline") {
      this[PRIVATE5].inlineSessions.add(session);
    } else {
      this[PRIVATE5].immersiveSession = session;
    }
    const onSessionEnd = () => {
      if (mode == "inline") {
        this[PRIVATE5].inlineSessions.delete(session);
      } else {
        this[PRIVATE5].immersiveSession = null;
      }
      session.removeEventListener("end", onSessionEnd);
    };
    session.addEventListener("end", onSessionEnd);
    return session;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/lib/now.js
var now;
if ("performance" in global_default === false) {
  let startTime = Date.now();
  now = () => Date.now() - startTime;
} else {
  now = () => performance.now();
}
var now_default = now;

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRPose.js
var PRIVATE6 = Symbol("@@webxr-polyfill/XRPose");
var XRPose2 = class {
  /**
   * @param {XRRigidTransform} transform 
   * @param {boolean} emulatedPosition 
   */
  constructor(transform2, emulatedPosition) {
    this[PRIVATE6] = {
      transform: transform2,
      emulatedPosition
    };
  }
  /**
   * @return {XRRigidTransform}
   */
  get transform() {
    return this[PRIVATE6].transform;
  }
  /**
   * @return {bool}
   */
  get emulatedPosition() {
    return this[PRIVATE6].emulatedPosition;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRViewerPose.js
var PRIVATE7 = Symbol("@@webxr-polyfill/XRViewerPose");
var XRViewerPose = class extends XRPose2 {
  /**
   * @param {XRDevice} device
   */
  constructor(transform2, views, emulatedPosition = false) {
    super(transform2, emulatedPosition);
    this[PRIVATE7] = {
      views
    };
  }
  /**
   * @return {Array<XRView>}
   */
  get views() {
    return this[PRIVATE7].views;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRViewport.js
var PRIVATE8 = Symbol("@@webxr-polyfill/XRViewport");
var XRViewport = class {
  /**
   * Takes a proxy object that this viewport's XRView
   * updates and we serve here to match API.
   *
   * @param {Object} target
   */
  constructor(target) {
    this[PRIVATE8] = { target };
  }
  /**
   * @return {number}
   */
  get x() {
    return this[PRIVATE8].target.x;
  }
  /**
   * @return {number}
   */
  get y() {
    return this[PRIVATE8].target.y;
  }
  /**
   * @return {number}
   */
  get width() {
    return this[PRIVATE8].target.width;
  }
  /**
   * @return {number}
   */
  get height() {
    return this[PRIVATE8].target.height;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRView.js
var XREyes = ["left", "right", "none"];
var PRIVATE9 = Symbol("@@webxr-polyfill/XRView");
var XRView = class {
  /**
   * @param {XRDevice} device
   * @param {XREye} eye
   * @param {number} sessionId
   */
  constructor(device, transform2, eye, sessionId) {
    if (!XREyes.includes(eye)) {
      throw new Error(`XREye must be one of: ${XREyes}`);
    }
    const temp = /* @__PURE__ */ Object.create(null);
    const viewport = new XRViewport(temp);
    this[PRIVATE9] = {
      device,
      eye,
      viewport,
      temp,
      sessionId,
      transform: transform2
    };
  }
  /**
   * @return {XREye}
   */
  get eye() {
    return this[PRIVATE9].eye;
  }
  /**
   * @return {Float32Array}
   */
  get projectionMatrix() {
    return this[PRIVATE9].device.getProjectionMatrix(this.eye);
  }
  /**
   * @return {XRRigidTransform}
   */
  get transform() {
    return this[PRIVATE9].transform;
  }
  /**
   * NON-STANDARD
   *
   * `getViewport` is now exposed via XRWebGLLayer instead of XRView.
   * XRWebGLLayer delegates all the actual work to this function.
   *
   * @param {XRWebGLLayer} layer
   * @return {XRViewport?}
   */
  _getViewport(layer) {
    if (this[PRIVATE9].device.getViewport(
      this[PRIVATE9].sessionId,
      this.eye,
      layer,
      this[PRIVATE9].temp
    )) {
      return this[PRIVATE9].viewport;
    }
    return void 0;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRFrame.js
var PRIVATE11 = Symbol("@@webxr-polyfill/XRFrame");
var NON_ACTIVE_MSG = "XRFrame access outside the callback that produced it is invalid.";
var NON_ANIMFRAME_MSG = "getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.";
var NEXT_FRAME_ID = 0;
var XRFrame = class {
  /**
   * @param {XRDevice} device
   * @param {XRSession} session
   * @param {number} sessionId
   */
  constructor(device, session, sessionId) {
    this[PRIVATE11] = {
      id: ++NEXT_FRAME_ID,
      active: false,
      animationFrame: false,
      device,
      session,
      sessionId
    };
  }
  /**
   * @return {XRSession} session
   */
  get session() {
    return this[PRIVATE11].session;
  }
  /**
   * @param {XRReferenceSpace} referenceSpace
   * @return {XRViewerPose?}
   */
  getViewerPose(referenceSpace) {
    if (!this[PRIVATE11].animationFrame) {
      throw new DOMException(NON_ANIMFRAME_MSG, "InvalidStateError");
    }
    if (!this[PRIVATE11].active) {
      throw new DOMException(NON_ACTIVE_MSG, "InvalidStateError");
    }
    const device = this[PRIVATE11].device;
    const session = this[PRIVATE11].session;
    session[PRIVATE10].viewerSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
    referenceSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
    let viewerTransform = referenceSpace._getSpaceRelativeTransform(session[PRIVATE10].viewerSpace);
    const views = [];
    for (let viewSpace of session[PRIVATE10].viewSpaces) {
      viewSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
      let viewTransform = referenceSpace._getSpaceRelativeTransform(viewSpace);
      let view = new XRView(device, viewTransform, viewSpace.eye, this[PRIVATE11].sessionId);
      views.push(view);
    }
    let viewerPose = new XRViewerPose(
      viewerTransform,
      views,
      false
      /* TODO: emulatedPosition */
    );
    return viewerPose;
  }
  /**
   * @param {XRSpace} space
   * @param {XRSpace} baseSpace
   * @return {XRPose?} pose
   */
  getPose(space, baseSpace) {
    if (!this[PRIVATE11].active) {
      throw new DOMException(NON_ACTIVE_MSG, "InvalidStateError");
    }
    const device = this[PRIVATE11].device;
    if (space._specialType === "target-ray" || space._specialType === "grip") {
      return device.getInputPose(
        space._inputSource,
        baseSpace,
        space._specialType
      );
    } else {
      space._ensurePoseUpdated(device, this[PRIVATE11].id);
      baseSpace._ensurePoseUpdated(device, this[PRIVATE11].id);
      let transform2 = baseSpace._getSpaceRelativeTransform(space);
      if (!transform2) {
        return null;
      }
      return new XRPose(
        transform2,
        false
        /* TODO: emulatedPosition */
      );
    }
    return null;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRRenderState.js
var PRIVATE12 = Symbol("@@webxr-polyfill/XRRenderState");
var XRRenderStateInit = Object.freeze({
  depthNear: 0.1,
  depthFar: 1e3,
  inlineVerticalFieldOfView: null,
  baseLayer: null
});
var XRRenderState = class {
  /**
   * @param {Object?} stateInit
   */
  constructor(stateInit = {}) {
    const config = Object.assign({}, XRRenderStateInit, stateInit);
    this[PRIVATE12] = { config };
  }
  /**
   * @return {number}
   */
  get depthNear() {
    return this[PRIVATE12].config.depthNear;
  }
  /**
   * @return {number}
   */
  get depthFar() {
    return this[PRIVATE12].config.depthFar;
  }
  /**
   * @return {number?}
   */
  get inlineVerticalFieldOfView() {
    return this[PRIVATE12].config.inlineVerticalFieldOfView;
  }
  /**
   * @return {XRWebGLLayer}
   */
  get baseLayer() {
    return this[PRIVATE12].config.baseLayer;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/constants.js
var POLYFILLED_XR_COMPATIBLE = Symbol("@@webxr-polyfill/polyfilled-xr-compatible");
var XR_COMPATIBLE = Symbol("@@webxr-polyfill/xr-compatible");

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRWebGLLayer.js
var PRIVATE13 = Symbol("@@webxr-polyfill/XRWebGLLayer");
var XRWebGLLayerInit = Object.freeze({
  antialias: true,
  depth: false,
  stencil: false,
  alpha: true,
  multiview: false,
  ignoreDepthValues: false,
  framebufferScaleFactor: 1
});
var XRWebGLLayer2 = class {
  /**
   * @param {XRSession} session 
   * @param {XRWebGLRenderingContext} context 
   * @param {Object?} layerInit 
   */
  constructor(session, context, layerInit = {}) {
    const config = Object.assign({}, XRWebGLLayerInit, layerInit);
    if (!(session instanceof XRSession2)) {
      throw new Error("session must be a XRSession");
    }
    if (session.ended) {
      throw new Error(`InvalidStateError`);
    }
    if (context[POLYFILLED_XR_COMPATIBLE]) {
      if (context[XR_COMPATIBLE] !== true) {
        throw new Error(`InvalidStateError`);
      }
    }
    const framebuffer = context.getParameter(context.FRAMEBUFFER_BINDING);
    this[PRIVATE13] = {
      context,
      config,
      framebuffer,
      session
    };
  }
  /**
   * @return {WebGLRenderingContext}
   */
  get context() {
    return this[PRIVATE13].context;
  }
  /**
   * @return {boolean}
   */
  get antialias() {
    return this[PRIVATE13].config.antialias;
  }
  /**
   * The polyfill will always ignore depth values.
   *
   * @return {boolean}
   */
  get ignoreDepthValues() {
    return true;
  }
  /**
   * @return {WebGLFramebuffer}
   */
  get framebuffer() {
    return this[PRIVATE13].framebuffer;
  }
  /**
   * @return {number}
   */
  get framebufferWidth() {
    return this[PRIVATE13].context.drawingBufferWidth;
  }
  /**
   * @return {number}
   */
  get framebufferHeight() {
    return this[PRIVATE13].context.drawingBufferHeight;
  }
  /**
   * @return {XRSession}
   */
  get _session() {
    return this[PRIVATE13].session;
  }
  /**
   * @TODO No mention in spec on not reusing the XRViewport on every frame.
   * 
   * @TODO In the future maybe all this logic should be handled here instead of
   * delegated to the XRView?
   *
   * @param {XRView} view
   * @return {XRViewport?}
   */
  getViewport(view) {
    return view._getViewport(this);
  }
  /**
   * Gets the scale factor to be requested if you want to match the device
   * resolution at the center of the user's vision. The polyfill will always
   * report 1.0.
   * 
   * @param {XRSession} session 
   * @return {number}
   */
  static getNativeFramebufferScaleFactor(session) {
    if (!session) {
      throw new TypeError("getNativeFramebufferScaleFactor must be passed a session.");
    }
    if (session[PRIVATE10].ended) {
      return 0;
    }
    return 1;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRInputSourceEvent.js
var PRIVATE14 = Symbol("@@webxr-polyfill/XRInputSourceEvent");
var XRInputSourceEvent = class extends Event {
  /**
   * @param {string} type
   * @param {Object} eventInitDict
   */
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
    this[PRIVATE14] = {
      frame: eventInitDict.frame,
      inputSource: eventInitDict.inputSource
    };
    Object.setPrototypeOf(this, XRInputSourceEvent.prototype);
  }
  /**
   * @return {XRFrame}
   */
  get frame() {
    return this[PRIVATE14].frame;
  }
  /**
   * @return {XRInputSource}
   */
  get inputSource() {
    return this[PRIVATE14].inputSource;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRSessionEvent.js
var PRIVATE15 = Symbol("@@webxr-polyfill/XRSessionEvent");
var XRSessionEvent = class extends Event {
  /**
   * @param {string} type
   * @param {Object} eventInitDict
   */
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
    this[PRIVATE15] = {
      session: eventInitDict.session
    };
    Object.setPrototypeOf(this, XRSessionEvent.prototype);
  }
  /**
   * @return {XRSession}
   */
  get session() {
    return this[PRIVATE15].session;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRInputSourcesChangeEvent.js
var PRIVATE16 = Symbol("@@webxr-polyfill/XRInputSourcesChangeEvent");
var XRInputSourcesChangeEvent = class extends Event {
  /**
   * @param {string} type
   * @param {Object} eventInitDict
   */
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
    this[PRIVATE16] = {
      session: eventInitDict.session,
      added: eventInitDict.added,
      removed: eventInitDict.removed
    };
    Object.setPrototypeOf(this, XRInputSourcesChangeEvent.prototype);
  }
  /**
   * @return {XRSession}
   */
  get session() {
    return this[PRIVATE16].session;
  }
  /**
   * @return {Array<XRInputSource>}
   */
  get added() {
    return this[PRIVATE16].added;
  }
  /**
   * @return {Array<XRInputSource>}
   */
  get removed() {
    return this[PRIVATE16].removed;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRSession.js
var PRIVATE10 = Symbol("@@webxr-polyfill/XRSession");
var XRViewSpace = class extends XRSpace {
  constructor(eye) {
    super(eye);
  }
  get eye() {
    return this._specialType;
  }
  /**
   * Called when this space's base pose needs to be updated
   * @param {XRDevice} device
   */
  _onPoseUpdate(device) {
    this._inverseBaseMatrix = device.getBaseViewMatrix(this._specialType);
  }
};
var XRSession2 = class extends EventTarget {
  /**
   * @param {XRDevice} device
   * @param {XRSessionMode} mode
   * @param {number} id
   */
  constructor(device, mode, id2) {
    super();
    let immersive = mode != "inline";
    let initialRenderState = new XRRenderState({
      inlineVerticalFieldOfView: immersive ? null : Math.PI * 0.5
    });
    this[PRIVATE10] = {
      device,
      mode,
      immersive,
      ended: false,
      suspended: false,
      frameCallbacks: [],
      currentFrameCallbacks: null,
      frameHandle: 0,
      deviceFrameHandle: null,
      id: id2,
      activeRenderState: initialRenderState,
      pendingRenderState: null,
      viewerSpace: new XRReferenceSpace("viewer"),
      viewSpaces: [],
      currentInputSources: []
    };
    if (immersive) {
      this[PRIVATE10].viewSpaces.push(
        new XRViewSpace("left"),
        new XRViewSpace("right")
      );
    } else {
      this[PRIVATE10].viewSpaces.push(new XRViewSpace("none"));
    }
    this[PRIVATE10].onDeviceFrame = () => {
      if (this[PRIVATE10].ended || this[PRIVATE10].suspended) {
        return;
      }
      this[PRIVATE10].deviceFrameHandle = null;
      this[PRIVATE10].startDeviceFrameLoop();
      if (this[PRIVATE10].pendingRenderState !== null) {
        this[PRIVATE10].activeRenderState = new XRRenderState(this[PRIVATE10].pendingRenderState);
        this[PRIVATE10].pendingRenderState = null;
        if (this[PRIVATE10].activeRenderState.baseLayer) {
          this[PRIVATE10].device.onBaseLayerSet(
            this[PRIVATE10].id,
            this[PRIVATE10].activeRenderState.baseLayer
          );
        }
      }
      if (this[PRIVATE10].activeRenderState.baseLayer === null) {
        return;
      }
      const frame = new XRFrame(device, this, this[PRIVATE10].id);
      const callbacks = this[PRIVATE10].currentFrameCallbacks = this[PRIVATE10].frameCallbacks;
      this[PRIVATE10].frameCallbacks = [];
      frame[PRIVATE11].active = true;
      frame[PRIVATE11].animationFrame = true;
      this[PRIVATE10].device.onFrameStart(this[PRIVATE10].id, this[PRIVATE10].activeRenderState);
      this._checkInputSourcesChange();
      const rightNow = now_default();
      for (let i = 0; i < callbacks.length; i++) {
        try {
          if (!callbacks[i].cancelled && typeof callbacks[i].callback === "function") {
            callbacks[i].callback(rightNow, frame);
          }
        } catch (err) {
          console.error(err);
        }
      }
      this[PRIVATE10].currentFrameCallbacks = null;
      frame[PRIVATE11].active = false;
      this[PRIVATE10].device.onFrameEnd(this[PRIVATE10].id);
    };
    this[PRIVATE10].startDeviceFrameLoop = () => {
      if (this[PRIVATE10].deviceFrameHandle === null) {
        this[PRIVATE10].deviceFrameHandle = this[PRIVATE10].device.requestAnimationFrame(
          this[PRIVATE10].onDeviceFrame
        );
      }
    };
    this[PRIVATE10].stopDeviceFrameLoop = () => {
      const handle = this[PRIVATE10].deviceFrameHandle;
      if (handle !== null) {
        this[PRIVATE10].device.cancelAnimationFrame(handle);
        this[PRIVATE10].deviceFrameHandle = null;
      }
    };
    this[PRIVATE10].onPresentationEnd = (sessionId) => {
      if (sessionId !== this[PRIVATE10].id) {
        this[PRIVATE10].suspended = false;
        this[PRIVATE10].startDeviceFrameLoop();
        this.dispatchEvent("focus", { session: this });
        return;
      }
      this[PRIVATE10].ended = true;
      this[PRIVATE10].stopDeviceFrameLoop();
      device.removeEventListener("@@webxr-polyfill/vr-present-end", this[PRIVATE10].onPresentationEnd);
      device.removeEventListener("@@webxr-polyfill/vr-present-start", this[PRIVATE10].onPresentationStart);
      device.removeEventListener("@@webxr-polyfill/input-select-start", this[PRIVATE10].onSelectStart);
      device.removeEventListener("@@webxr-polyfill/input-select-end", this[PRIVATE10].onSelectEnd);
      this.dispatchEvent("end", new XRSessionEvent("end", { session: this }));
    };
    device.addEventListener("@@webxr-polyfill/vr-present-end", this[PRIVATE10].onPresentationEnd);
    this[PRIVATE10].onPresentationStart = (sessionId) => {
      if (sessionId === this[PRIVATE10].id) {
        return;
      }
      this[PRIVATE10].suspended = true;
      this[PRIVATE10].stopDeviceFrameLoop();
      this.dispatchEvent("blur", { session: this });
    };
    device.addEventListener("@@webxr-polyfill/vr-present-start", this[PRIVATE10].onPresentationStart);
    this[PRIVATE10].onSelectStart = (evt) => {
      if (evt.sessionId !== this[PRIVATE10].id) {
        return;
      }
      this[PRIVATE10].dispatchInputSourceEvent("selectstart", evt.inputSource);
    };
    device.addEventListener("@@webxr-polyfill/input-select-start", this[PRIVATE10].onSelectStart);
    this[PRIVATE10].onSelectEnd = (evt) => {
      if (evt.sessionId !== this[PRIVATE10].id) {
        return;
      }
      this[PRIVATE10].dispatchInputSourceEvent("selectend", evt.inputSource);
      this[PRIVATE10].dispatchInputSourceEvent("select", evt.inputSource);
    };
    device.addEventListener("@@webxr-polyfill/input-select-end", this[PRIVATE10].onSelectEnd);
    this[PRIVATE10].onSqueezeStart = (evt) => {
      if (evt.sessionId !== this[PRIVATE10].id) {
        return;
      }
      this[PRIVATE10].dispatchInputSourceEvent("squeezestart", evt.inputSource);
    };
    device.addEventListener("@@webxr-polyfill/input-squeeze-start", this[PRIVATE10].onSqueezeStart);
    this[PRIVATE10].onSqueezeEnd = (evt) => {
      if (evt.sessionId !== this[PRIVATE10].id) {
        return;
      }
      this[PRIVATE10].dispatchInputSourceEvent("squeezeend", evt.inputSource);
      this[PRIVATE10].dispatchInputSourceEvent("squeeze", evt.inputSource);
    };
    device.addEventListener("@@webxr-polyfill/input-squeeze-end", this[PRIVATE10].onSqueezeEnd);
    this[PRIVATE10].dispatchInputSourceEvent = (type2, inputSource) => {
      const frame = new XRFrame(device, this, this[PRIVATE10].id);
      const event = new XRInputSourceEvent(type2, { frame, inputSource });
      frame[PRIVATE11].active = true;
      this.dispatchEvent(type2, event);
      frame[PRIVATE11].active = false;
    };
    this[PRIVATE10].startDeviceFrameLoop();
    this.onblur = void 0;
    this.onfocus = void 0;
    this.onresetpose = void 0;
    this.onend = void 0;
    this.onselect = void 0;
    this.onselectstart = void 0;
    this.onselectend = void 0;
  }
  /**
   * @return {XRRenderState}
   */
  get renderState() {
    return this[PRIVATE10].activeRenderState;
  }
  /**
   * @return {XREnvironmentBlendMode}
   */
  get environmentBlendMode() {
    return this[PRIVATE10].device.environmentBlendMode || "opaque";
  }
  /**
   * @param {string} type
   * @return {XRReferenceSpace}
   */
  async requestReferenceSpace(type2) {
    if (this[PRIVATE10].ended) {
      return;
    }
    if (!XRReferenceSpaceTypes.includes(type2)) {
      throw new TypeError(`XRReferenceSpaceType must be one of ${XRReferenceSpaceTypes}`);
    }
    if (!this[PRIVATE10].device.doesSessionSupportReferenceSpace(this[PRIVATE10].id, type2)) {
      throw new DOMException(`The ${type2} reference space is not supported by this session.`, "NotSupportedError");
    }
    if (type2 === "viewer") {
      return this[PRIVATE10].viewerSpace;
    }
    let transform2 = await this[PRIVATE10].device.requestFrameOfReferenceTransform(type2);
    if (type2 === "bounded-floor") {
      if (!transform2) {
        throw new DOMException(`${type2} XRReferenceSpace not supported by this device.`, "NotSupportedError");
      }
      let bounds = this[PRIVATE10].device.requestStageBounds();
      if (!bounds) {
        throw new DOMException(`${type2} XRReferenceSpace not supported by this device.`, "NotSupportedError");
      }
      throw new DOMException(`The WebXR polyfill does not support the ${type2} reference space yet.`, "NotSupportedError");
    }
    return new XRReferenceSpace(type2, transform2);
  }
  /**
   * @param {Function} callback
   * @return {number}
   */
  requestAnimationFrame(callback) {
    if (this[PRIVATE10].ended) {
      return;
    }
    const handle = ++this[PRIVATE10].frameHandle;
    this[PRIVATE10].frameCallbacks.push({
      handle,
      callback,
      cancelled: false
    });
    return handle;
  }
  /**
   * @param {number} handle
   */
  cancelAnimationFrame(handle) {
    let callbacks = this[PRIVATE10].frameCallbacks;
    let index = callbacks.findIndex((d) => d && d.handle === handle);
    if (index > -1) {
      callbacks[index].cancelled = true;
      callbacks.splice(index, 1);
    }
    callbacks = this[PRIVATE10].currentFrameCallbacks;
    if (callbacks) {
      index = callbacks.findIndex((d) => d && d.handle === handle);
      if (index > -1) {
        callbacks[index].cancelled = true;
      }
    }
  }
  /**
   * @return {Array<XRInputSource>} input sources
   */
  get inputSources() {
    return this[PRIVATE10].device.getInputSources();
  }
  /**
   * @return {Promise<void>}
   */
  async end() {
    if (this[PRIVATE10].ended) {
      return;
    }
    if (this[PRIVATE10].immersive) {
      this[PRIVATE10].ended = true;
      this[PRIVATE10].device.removeEventListener(
        "@@webxr-polyfill/vr-present-start",
        this[PRIVATE10].onPresentationStart
      );
      this[PRIVATE10].device.removeEventListener(
        "@@webxr-polyfill/vr-present-end",
        this[PRIVATE10].onPresentationEnd
      );
      this[PRIVATE10].device.removeEventListener(
        "@@webxr-polyfill/input-select-start",
        this[PRIVATE10].onSelectStart
      );
      this[PRIVATE10].device.removeEventListener(
        "@@webxr-polyfill/input-select-end",
        this[PRIVATE10].onSelectEnd
      );
      this.dispatchEvent("end", new XRSessionEvent("end", { session: this }));
    }
    this[PRIVATE10].stopDeviceFrameLoop();
    return this[PRIVATE10].device.endSession(this[PRIVATE10].id);
  }
  /**
   * Queues an update to the active render state to be applied on the next
   * frame. Unset fields of newState will not be changed.
   * 
   * @param {XRRenderStateInit?} newState 
   */
  updateRenderState(newState) {
    if (this[PRIVATE10].ended) {
      const message2 = "Can't call updateRenderState on an XRSession that has already ended.";
      throw new Error(message2);
    }
    if (newState.baseLayer && newState.baseLayer._session !== this) {
      const message2 = "Called updateRenderState with a base layer that was created by a different session.";
      throw new Error(message2);
    }
    const fovSet = newState.inlineVerticalFieldOfView !== null && newState.inlineVerticalFieldOfView !== void 0;
    if (fovSet) {
      if (this[PRIVATE10].immersive) {
        const message2 = "inlineVerticalFieldOfView must not be set for an XRRenderState passed to updateRenderState for an immersive session.";
        throw new Error(message2);
      } else {
        newState.inlineVerticalFieldOfView = Math.min(
          3.13,
          Math.max(0.01, newState.inlineVerticalFieldOfView)
        );
      }
    }
    if (this[PRIVATE10].pendingRenderState === null) {
      const activeRenderState = this[PRIVATE10].activeRenderState;
      this[PRIVATE10].pendingRenderState = {
        depthNear: activeRenderState.depthNear,
        depthFar: activeRenderState.depthFar,
        inlineVerticalFieldOfView: activeRenderState.inlineVerticalFieldOfView,
        baseLayer: activeRenderState.baseLayer
      };
    }
    Object.assign(this[PRIVATE10].pendingRenderState, newState);
  }
  /**
   * Compares the inputSources with the ones in the previous frame.
   * Fires imputsourceschange event if any added or removed
   * inputSource is found.
   */
  _checkInputSourcesChange() {
    const added = [];
    const removed = [];
    const newInputSources = this.inputSources;
    const oldInputSources = this[PRIVATE10].currentInputSources;
    for (const newInputSource of newInputSources) {
      if (!oldInputSources.includes(newInputSource)) {
        added.push(newInputSource);
      }
    }
    for (const oldInputSource of oldInputSources) {
      if (!newInputSources.includes(oldInputSource)) {
        removed.push(oldInputSource);
      }
    }
    if (added.length > 0 || removed.length > 0) {
      this.dispatchEvent("inputsourceschange", new XRInputSourcesChangeEvent("inputsourceschange", {
        session: this,
        added,
        removed
      }));
    }
    this[PRIVATE10].currentInputSources.length = 0;
    for (const newInputSource of newInputSources) {
      this[PRIVATE10].currentInputSources.push(newInputSource);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRInputSource.js
var PRIVATE17 = Symbol("@@webxr-polyfill/XRInputSource");
var XRInputSource = class {
  /**
   * @param {GamepadXRInputSource} impl 
   */
  constructor(impl) {
    this[PRIVATE17] = {
      impl,
      gripSpace: new XRSpace("grip", this),
      targetRaySpace: new XRSpace("target-ray", this)
    };
  }
  /**
   * @return {XRHandedness}
   */
  get handedness() {
    return this[PRIVATE17].impl.handedness;
  }
  /**
   * @return {XRTargetRayMode}
   */
  get targetRayMode() {
    return this[PRIVATE17].impl.targetRayMode;
  }
  /**
   * @return {XRSpace}
   */
  get gripSpace() {
    let mode = this[PRIVATE17].impl.targetRayMode;
    if (mode === "gaze" || mode === "screen") {
      return null;
    }
    return this[PRIVATE17].gripSpace;
  }
  /**
   * @return {XRSpace}
   */
  get targetRaySpace() {
    return this[PRIVATE17].targetRaySpace;
  }
  /**
   * @return {Array<String>}
   */
  get profiles() {
    return this[PRIVATE17].impl.profiles;
  }
  /**
   * @return {Gamepad}
   */
  get gamepad() {
    return this[PRIVATE17].impl.gamepad;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/XRReferenceSpaceEvent.js
var PRIVATE18 = Symbol("@@webxr-polyfill/XRReferenceSpaceEvent");
var XRReferenceSpaceEvent = class extends Event {
  /**
   * @param {string} type
   * @param {Object} eventInitDict
   */
  constructor(type2, eventInitDict) {
    super(type2, eventInitDict);
    this[PRIVATE18] = {
      referenceSpace: eventInitDict.referenceSpace,
      transform: eventInitDict.transform || null
    };
    Object.setPrototypeOf(this, XRReferenceSpaceEvent.prototype);
  }
  /**
   * @return {XRFrame}
   */
  get referenceSpace() {
    return this[PRIVATE18].referenceSpace;
  }
  /**
   * @return {XRInputSource}
   */
  get transform() {
    return this[PRIVATE18].transform;
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/api/index.js
var api_default = {
  XRSystem,
  XRSession: XRSession2,
  XRSessionEvent,
  XRFrame,
  XRView,
  XRViewport,
  XRViewerPose,
  XRWebGLLayer: XRWebGLLayer2,
  XRSpace,
  XRReferenceSpace,
  XRReferenceSpaceEvent,
  XRInputSource,
  XRInputSourceEvent,
  XRInputSourcesChangeEvent,
  XRRenderState,
  XRRigidTransform: XRRigidTransform2,
  XRPose: XRPose2
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/polyfill-globals.js
var polyfillMakeXRCompatible = (Context) => {
  if (typeof Context.prototype.makeXRCompatible === "function") {
    return false;
  }
  Context.prototype.makeXRCompatible = function() {
    this[XR_COMPATIBLE] = true;
    return Promise.resolve();
  };
  return true;
};
var polyfillGetContext = (Canvas2) => {
  const getContext = Canvas2.prototype.getContext;
  Canvas2.prototype.getContext = function(contextType, glAttribs) {
    const ctx = getContext.call(this, contextType, glAttribs);
    if (ctx) {
      ctx[POLYFILLED_XR_COMPATIBLE] = true;
      if (glAttribs && "xrCompatible" in glAttribs) {
        ctx[XR_COMPATIBLE] = glAttribs.xrCompatible;
      }
    }
    return ctx;
  };
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/utils.js
var isImageBitmapSupported = (global2) => !!(global2.ImageBitmapRenderingContext && global2.createImageBitmap);
var isMobile2 = (global2) => {
  var check = false;
  (function(a) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
      check = true;
  })(global2.navigator.userAgent || global2.navigator.vendor || global2.opera);
  return check;
};
var applyCanvasStylesForMinimalRendering = (canvas) => {
  canvas.style.display = "block";
  canvas.style.position = "absolute";
  canvas.style.width = canvas.style.height = "1px";
  canvas.style.top = canvas.style.left = "0px";
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/CardboardXRDevice.js
var import_cardboard_vr_display = __toESM(require_cardboard_vr_display());

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/XRDevice.js
var XRDevice = class extends EventTarget {
  /**
   * Takes a VRDisplay object from the WebVR 1.1 spec.
   *
   * @param {Object} global
   */
  constructor(global2) {
    super();
    this.global = global2;
    this.onWindowResize = this.onWindowResize.bind(this);
    this.global.window.addEventListener("resize", this.onWindowResize);
    this.environmentBlendMode = "opaque";
  }
  /**
   * Called when a XRSession has a `baseLayer` property set.
   *
   * @param {number} sessionId
   * @param {XRWebGLLayer} layer
   */
  onBaseLayerSet(sessionId, layer) {
    throw new Error("Not implemented");
  }
  /**
   * @param {XRSessionMode} mode
   * @return {boolean}
   */
  isSessionSupported(mode) {
    throw new Error("Not implemented");
  }
  /**
   * @param {string} featureDescriptor
   * @return {boolean}
   */
  isFeatureSupported(featureDescriptor) {
    throw new Error("Not implemented");
  }
  /**
   * Returns a promise if creating a session is successful.
   * Usually used to set up presentation in the device.
   *
   * @param {XRSessionMode} mode
   * @param {Set<string>} enabledFeatures
   * @return {Promise<number>}
   */
  async requestSession(mode, enabledFeatures) {
    throw new Error("Not implemented");
  }
  /**
   * @return {Function}
   */
  requestAnimationFrame(callback) {
    throw new Error("Not implemented");
  }
  /**
   * @param {number} sessionId
   */
  onFrameStart(sessionId) {
    throw new Error("Not implemented");
  }
  /**
   * @param {number} sessionId
   */
  onFrameEnd(sessionId) {
    throw new Error("Not implemented");
  }
  /**
   * @param {number} sessionId
   * @param {XRReferenceSpaceType} type
   * @return {boolean}
   */
  doesSessionSupportReferenceSpace(sessionId, type2) {
    throw new Error("Not implemented");
  }
  /**
   * @return {Object?}
   */
  requestStageBounds() {
    throw new Error("Not implemented");
  }
  /**
   * Returns a promise resolving to a transform if XRDevice
   * can support frame of reference and provides its own values.
   * Can resolve to `undefined` if the polyfilled API can provide
   * a default. Rejects if this XRDevice cannot
   * support the frame of reference.
   *
   * @param {XRFrameOfReferenceType} type
   * @param {XRFrameOfReferenceOptions} options
   * @return {Promise<XRFrameOfReference>}
   */
  async requestFrameOfReferenceTransform(type2, options) {
    return void 0;
  }
  /**
   * @param {number} handle
   */
  cancelAnimationFrame(handle) {
    throw new Error("Not implemented");
  }
  /**
   * @param {number} sessionId
   */
  endSession(sessionId) {
    throw new Error("Not implemented");
  }
  /**
   * Takes a XREye and a target to apply properties of
   * `x`, `y`, `width` and `height` on. Returns a boolean
   * indicating if it successfully was able to populate
   * target's values.
   *
   * @param {number} sessionId
   * @param {XREye} eye
   * @param {XRWebGLLayer} layer
   * @param {Object?} target
   * @return {boolean}
   */
  getViewport(sessionId, eye, layer, target) {
    throw new Error("Not implemented");
  }
  /**
   * @param {XREye} eye
   * @return {Float32Array}
   */
  getProjectionMatrix(eye) {
    throw new Error("Not implemented");
  }
  /**
   * Get model matrix unaffected by frame of reference.
   *
   * @return {Float32Array}
   */
  getBasePoseMatrix() {
    throw new Error("Not implemented");
  }
  /**
   * Get view matrix unaffected by frame of reference.
   *
   * @param {XREye} eye
   * @return {Float32Array}
   */
  getBaseViewMatrix(eye) {
    throw new Error("Not implemented");
  }
  /**
   * Get a list of input sources.
   *
   * @return {Array<XRInputSource>}
   */
  getInputSources() {
    throw new Error("Not implemented");
  }
  /**
   * Get the current pose of an input source.
   *
   * @param {XRInputSource} inputSource
   * @param {XRCoordinateSystem} coordinateSystem
   * @param {String} poseType
   * @return {XRPose}
   */
  getInputPose(inputSource, coordinateSystem, poseType) {
    throw new Error("Not implemented");
  }
  /**
   * Called on window resize.
   */
  onWindowResize() {
    this.onWindowResize();
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/GamepadMappings.js
var daydream = {
  mapping: "",
  profiles: ["google-daydream", "generic-trigger-touchpad"],
  buttons: {
    length: 3,
    0: null,
    1: null,
    2: 0
  }
};
var viveFocus = {
  mapping: "xr-standard",
  profiles: ["htc-vive-focus", "generic-trigger-touchpad"],
  buttons: {
    length: 3,
    0: 1,
    1: null,
    2: 0
  }
};
var oculusGo = {
  mapping: "xr-standard",
  profiles: ["oculus-go", "generic-trigger-touchpad"],
  buttons: {
    length: 3,
    0: 1,
    1: null,
    2: 0
  },
  // Grip adjustments determined experimentally.
  gripTransform: {
    orientation: [Math.PI * 0.11, 0, 0, 1]
  }
};
var oculusTouch = {
  mapping: "xr-standard",
  displayProfiles: {
    "Oculus Quest": ["oculus-touch-v2", "oculus-touch", "generic-trigger-squeeze-thumbstick"]
  },
  profiles: ["oculus-touch", "generic-trigger-squeeze-thumbstick"],
  axes: {
    length: 4,
    0: null,
    1: null,
    2: 0,
    3: 1
  },
  buttons: {
    length: 7,
    0: 1,
    1: 2,
    2: null,
    3: 0,
    4: 3,
    5: 4,
    6: null
  },
  // Grip adjustments determined experimentally.
  gripTransform: {
    position: [0, -0.02, 0.04, 1],
    orientation: [Math.PI * 0.11, 0, 0, 1]
  }
};
var openVr = {
  mapping: "xr-standard",
  profiles: ["htc-vive", "generic-trigger-squeeze-touchpad"],
  displayProfiles: {
    "HTC Vive": ["htc-vive", "generic-trigger-squeeze-touchpad"],
    "HTC Vive DVT": ["htc-vive", "generic-trigger-squeeze-touchpad"],
    "Valve Index": ["valve-index", "generic-trigger-squeeze-touchpad-thumbstick"]
  },
  buttons: {
    length: 3,
    0: 1,
    1: 2,
    2: 0
  },
  // Transform adjustments determined experimentally.
  gripTransform: {
    position: [0, 0, 0.05, 1]
  },
  targetRayTransform: {
    orientation: [Math.PI * -0.08, 0, 0, 1]
  },
  userAgentOverrides: {
    "Firefox": {
      axes: {
        invert: [1, 3]
      }
    }
  }
};
var samsungGearVR = {
  mapping: "xr-standard",
  profiles: ["samsung-gearvr", "generic-trigger-touchpad"],
  buttons: {
    length: 3,
    0: 1,
    1: null,
    2: 0
  },
  gripTransform: {
    orientation: [Math.PI * 0.11, 0, 0, 1]
  }
};
var samsungOdyssey = {
  mapping: "xr-standard",
  profiles: ["samsung-odyssey", "microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
  buttons: {
    length: 4,
    0: 1,
    // index finger trigger
    1: 0,
    // pressable joystick
    2: 2,
    // grip trigger
    3: 4
    // pressable touchpad
  },
  // Grip adjustments determined experimentally.
  gripTransform: {
    position: [0, -0.02, 0.04, 1],
    orientation: [Math.PI * 0.11, 0, 0, 1]
  }
};
var windowsMixedReality = {
  mapping: "xr-standard",
  profiles: ["microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
  buttons: {
    length: 4,
    0: 1,
    // index finger trigger
    1: 0,
    // pressable joystick
    2: 2,
    // grip trigger
    3: 4
    // pressable touchpad
  },
  // Grip adjustments determined experimentally.
  gripTransform: {
    position: [0, -0.02, 0.04, 1],
    orientation: [Math.PI * 0.11, 0, 0, 1]
  }
};
var GamepadMappings = {
  "Daydream Controller": daydream,
  "Gear VR Controller": samsungGearVR,
  "HTC Vive Focus Controller": viveFocus,
  "Oculus Go Controller": oculusGo,
  "Oculus Touch (Right)": oculusTouch,
  "Oculus Touch (Left)": oculusTouch,
  "OpenVR Gamepad": openVr,
  "Spatial Controller (Spatial Interaction Source) 045E-065A": windowsMixedReality,
  "Spatial Controller (Spatial Interaction Source) 045E-065D": samsungOdyssey,
  "Windows Mixed Reality (Right)": windowsMixedReality,
  "Windows Mixed Reality (Left)": windowsMixedReality
};
var GamepadMappings_default = GamepadMappings;

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/lib/OrientationArmModel.js
var HEAD_ELBOW_OFFSET_RIGHTHANDED = fromValues5(0.155, -0.465, -0.15);
var HEAD_ELBOW_OFFSET_LEFTHANDED = fromValues5(-0.155, -0.465, -0.15);
var ELBOW_WRIST_OFFSET = fromValues5(0, 0, -0.25);
var WRIST_CONTROLLER_OFFSET = fromValues5(0, 0, 0.05);
var ARM_EXTENSION_OFFSET = fromValues5(-0.08, 0.14, 0.08);
var ELBOW_BEND_RATIO = 0.4;
var EXTENSION_RATIO_WEIGHT = 0.4;
var MIN_ANGULAR_SPEED = 0.61;
var MIN_ANGLE_DELTA = 0.175;
var MIN_EXTENSION_COS = 0.12;
var MAX_EXTENSION_COS = 0.87;
var RAD_TO_DEG = 180 / Math.PI;
function eulerFromQuaternion(out, q, order) {
  function clamp3(value2, min5, max5) {
    return value2 < min5 ? min5 : value2 > max5 ? max5 : value2;
  }
  var sqx = q[0] * q[0];
  var sqy = q[1] * q[1];
  var sqz = q[2] * q[2];
  var sqw = q[3] * q[3];
  if (order === "XYZ") {
    out[0] = Math.atan2(2 * (q[0] * q[3] - q[1] * q[2]), sqw - sqx - sqy + sqz);
    out[1] = Math.asin(clamp3(2 * (q[0] * q[2] + q[1] * q[3]), -1, 1));
    out[2] = Math.atan2(2 * (q[2] * q[3] - q[0] * q[1]), sqw + sqx - sqy - sqz);
  } else if (order === "YXZ") {
    out[0] = Math.asin(clamp3(2 * (q[0] * q[3] - q[1] * q[2]), -1, 1));
    out[1] = Math.atan2(2 * (q[0] * q[2] + q[1] * q[3]), sqw - sqx - sqy + sqz);
    out[2] = Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), sqw - sqx + sqy - sqz);
  } else if (order === "ZXY") {
    out[0] = Math.asin(clamp3(2 * (q[0] * q[3] + q[1] * q[2]), -1, 1));
    out[1] = Math.atan2(2 * (q[1] * q[3] - q[2] * q[0]), sqw - sqx - sqy + sqz);
    out[2] = Math.atan2(2 * (q[2] * q[3] - q[0] * q[1]), sqw - sqx + sqy - sqz);
  } else if (order === "ZYX") {
    out[0] = Math.atan2(2 * (q[0] * q[3] + q[2] * q[1]), sqw - sqx - sqy + sqz);
    out[1] = Math.asin(clamp3(2 * (q[1] * q[3] - q[0] * q[2]), -1, 1));
    out[2] = Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), sqw + sqx - sqy - sqz);
  } else if (order === "YZX") {
    out[0] = Math.atan2(2 * (q[0] * q[3] - q[2] * q[1]), sqw - sqx + sqy - sqz);
    out[1] = Math.atan2(2 * (q[1] * q[3] - q[0] * q[2]), sqw + sqx - sqy - sqz);
    out[2] = Math.asin(clamp3(2 * (q[0] * q[1] + q[2] * q[3]), -1, 1));
  } else if (order === "XZY") {
    out[0] = Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), sqw - sqx + sqy - sqz);
    out[1] = Math.atan2(2 * (q[0] * q[2] + q[1] * q[3]), sqw + sqx - sqy - sqz);
    out[2] = Math.asin(clamp3(2 * (q[2] * q[3] - q[0] * q[1]), -1, 1));
  } else {
    console.log("No order given for quaternion to euler conversion.");
    return;
  }
}
var OrientationArmModel = class {
  constructor() {
    this.hand = "right";
    this.headElbowOffset = HEAD_ELBOW_OFFSET_RIGHTHANDED;
    this.controllerQ = create11();
    this.lastControllerQ = create11();
    this.headQ = create11();
    this.headPos = create8();
    this.elbowPos = create8();
    this.wristPos = create8();
    this.time = null;
    this.lastTime = null;
    this.rootQ = create11();
    this.position = create8();
  }
  setHandedness(hand) {
    if (this.hand != hand) {
      this.hand = hand;
      if (this.hand == "left") {
        this.headElbowOffset = HEAD_ELBOW_OFFSET_LEFTHANDED;
      } else {
        this.headElbowOffset = HEAD_ELBOW_OFFSET_RIGHTHANDED;
      }
    }
  }
  /**
   * Called on a RAF.
   */
  update(controllerOrientation, headPoseMatrix) {
    this.time = now_default();
    if (controllerOrientation) {
      copy8(this.lastControllerQ, this.controllerQ);
      copy8(this.controllerQ, controllerOrientation);
    }
    if (headPoseMatrix) {
      getTranslation(this.headPos, headPoseMatrix);
      getRotation(this.headQ, headPoseMatrix);
    }
    let headYawQ = this.getHeadYawOrientation_();
    let angleDelta = this.quatAngle_(this.lastControllerQ, this.controllerQ);
    let timeDelta = (this.time - this.lastTime) / 1e3;
    let controllerAngularSpeed = angleDelta / timeDelta;
    if (controllerAngularSpeed > MIN_ANGULAR_SPEED) {
      slerp2(
        this.rootQ,
        this.rootQ,
        headYawQ,
        Math.min(angleDelta / MIN_ANGLE_DELTA, 1)
      );
    } else {
      copy8(this.rootQ, headYawQ);
    }
    let controllerForward = fromValues5(0, 0, -1);
    transformQuat2(controllerForward, controllerForward, this.controllerQ);
    let controllerDotY = dot5(controllerForward, [0, 1, 0]);
    let extensionRatio = this.clamp_(
      (controllerDotY - MIN_EXTENSION_COS) / MAX_EXTENSION_COS,
      0,
      1
    );
    let controllerCameraQ = clone7(this.rootQ);
    invert3(controllerCameraQ, controllerCameraQ);
    multiply5(controllerCameraQ, controllerCameraQ, this.controllerQ);
    let elbowPos = this.elbowPos;
    copy6(elbowPos, this.headPos);
    add5(elbowPos, elbowPos, this.headElbowOffset);
    let elbowOffset = clone5(ARM_EXTENSION_OFFSET);
    scale5(elbowOffset, elbowOffset, extensionRatio);
    add5(elbowPos, elbowPos, elbowOffset);
    let totalAngle = this.quatAngle_(controllerCameraQ, create11());
    let totalAngleDeg = totalAngle * RAD_TO_DEG;
    let lerpSuppression = 1 - Math.pow(totalAngleDeg / 180, 4);
    sssss;
    let elbowRatio = ELBOW_BEND_RATIO;
    let wristRatio = 1 - ELBOW_BEND_RATIO;
    let lerpValue = lerpSuppression * (elbowRatio + wristRatio * extensionRatio * EXTENSION_RATIO_WEIGHT);
    let wristQ = create11();
    slerp2(wristQ, wristQ, controllerCameraQ, lerpValue);
    let invWristQ = invert3(create11(), wristQ);
    let elbowQ = clone7(controllerCameraQ);
    multiply5(elbowQ, elbowQ, invWristQ);
    let wristPos = this.wristPos;
    copy6(wristPos, WRIST_CONTROLLER_OFFSET);
    transformQuat2(wristPos, wristPos, wristQ);
    add5(wristPos, wristPos, ELBOW_WRIST_OFFSET);
    transformQuat2(wristPos, wristPos, elbowQ);
    add5(wristPos, wristPos, elbowPos);
    let offset = clone5(ARM_EXTENSION_OFFSET);
    scale5(offset, offset, extensionRatio);
    add5(this.position, this.wristPos, offset);
    transformQuat2(this.position, this.position, this.rootQ);
    this.lastTime = this.time;
  }
  /**
   * Returns the position calculated by the model.
   */
  getPosition() {
    return this.position;
  }
  getHeadYawOrientation_() {
    let headEuler = create8();
    eulerFromQuaternion(headEuler, this.headQ, "YXZ");
    let destinationQ = fromEuler2(create11(), 0, headEuler[1] * RAD_TO_DEG, 0);
    return destinationQ;
  }
  clamp_(value2, min5, max5) {
    return Math.min(Math.max(value2, min5), max5);
  }
  quatAngle_(q1, q2) {
    let vec1 = [0, 0, -1];
    let vec2 = [0, 0, -1];
    transformQuat2(vec1, vec1, q1);
    transformQuat2(vec2, vec2, q2);
    return angle3(vec1, vec2);
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/GamepadXRInputSource.js
var PRIVATE19 = Symbol("@@webxr-polyfill/XRRemappedGamepad");
var PLACEHOLDER_BUTTON = { pressed: false, touched: false, value: 0 };
Object.freeze(PLACEHOLDER_BUTTON);
var XRRemappedGamepad = class {
  constructor(gamepad, display2, map) {
    if (!map) {
      map = {};
    }
    if (map.userAgentOverrides) {
      for (let agent in map.userAgentOverrides) {
        if (navigator.userAgent.includes(agent)) {
          let override = map.userAgentOverrides[agent];
          for (let key in override) {
            if (key in map) {
              Object.assign(map[key], override[key]);
            } else {
              map[key] = override[key];
            }
          }
          break;
        }
      }
    }
    let axes = new Array(map.axes && map.axes.length ? map.axes.length : gamepad.axes.length);
    let buttons = new Array(map.buttons && map.buttons.length ? map.buttons.length : gamepad.buttons.length);
    let gripTransform = null;
    if (map.gripTransform) {
      let orientation = map.gripTransform.orientation || [0, 0, 0, 1];
      gripTransform = create7();
      fromRotationTranslation(
        gripTransform,
        normalize7(orientation, orientation),
        map.gripTransform.position || [0, 0, 0]
      );
    }
    let targetRayTransform = null;
    if (map.targetRayTransform) {
      let orientation = map.targetRayTransform.orientation || [0, 0, 0, 1];
      targetRayTransform = create7();
      fromRotationTranslation(
        targetRayTransform,
        normalize7(orientation, orientation),
        map.targetRayTransform.position || [0, 0, 0]
      );
    }
    let profiles = map.profiles;
    if (map.displayProfiles) {
      if (display2.displayName in map.displayProfiles) {
        profiles = map.displayProfiles[display2.displayName];
      }
    }
    this[PRIVATE19] = {
      gamepad,
      map,
      profiles: profiles || [gamepad.id],
      mapping: map.mapping || gamepad.mapping,
      axes,
      buttons,
      gripTransform,
      targetRayTransform
    };
    this._update();
  }
  _update() {
    let gamepad = this[PRIVATE19].gamepad;
    let map = this[PRIVATE19].map;
    let axes = this[PRIVATE19].axes;
    for (let i = 0; i < axes.length; ++i) {
      if (map.axes && i in map.axes) {
        if (map.axes[i] === null) {
          axes[i] = 0;
        } else {
          axes[i] = gamepad.axes[map.axes[i]];
        }
      } else {
        axes[i] = gamepad.axes[i];
      }
    }
    if (map.axes && map.axes.invert) {
      for (let axis of map.axes.invert) {
        if (axis < axes.length) {
          axes[axis] *= -1;
        }
      }
    }
    let buttons = this[PRIVATE19].buttons;
    for (let i = 0; i < buttons.length; ++i) {
      if (map.buttons && i in map.buttons) {
        if (map.buttons[i] === null) {
          buttons[i] = PLACEHOLDER_BUTTON;
        } else {
          buttons[i] = gamepad.buttons[map.buttons[i]];
        }
      } else {
        buttons[i] = gamepad.buttons[i];
      }
    }
  }
  get id() {
    return "";
  }
  get _profiles() {
    return this[PRIVATE19].profiles;
  }
  get index() {
    return -1;
  }
  get connected() {
    return this[PRIVATE19].gamepad.connected;
  }
  get timestamp() {
    return this[PRIVATE19].gamepad.timestamp;
  }
  get mapping() {
    return this[PRIVATE19].mapping;
  }
  get axes() {
    return this[PRIVATE19].axes;
  }
  get buttons() {
    return this[PRIVATE19].buttons;
  }
  // Non-standard extension
  get hapticActuators() {
    return this[PRIVATE19].gamepad.hapticActuators;
  }
};
var GamepadXRInputSource = class {
  constructor(polyfill, display2, primaryButtonIndex = 0, primarySqueezeButtonIndex = -1) {
    this.polyfill = polyfill;
    this.display = display2;
    this.nativeGamepad = null;
    this.gamepad = null;
    this.inputSource = new XRInputSource(this);
    this.lastPosition = create8();
    this.emulatedPosition = false;
    this.basePoseMatrix = create7();
    this.outputMatrix = create7();
    this.primaryButtonIndex = primaryButtonIndex;
    this.primaryActionPressed = false;
    this.primarySqueezeButtonIndex = primarySqueezeButtonIndex;
    this.primarySqueezeActionPressed = false;
    this.handedness = "";
    this.targetRayMode = "gaze";
    this.armModel = null;
  }
  get profiles() {
    return this.gamepad ? this.gamepad._profiles : [];
  }
  updateFromGamepad(gamepad) {
    if (this.nativeGamepad !== gamepad) {
      this.nativeGamepad = gamepad;
      if (gamepad) {
        this.gamepad = new XRRemappedGamepad(gamepad, this.display, GamepadMappings_default[gamepad.id]);
      } else {
        this.gamepad = null;
      }
    }
    this.handedness = gamepad.hand === "" ? "none" : gamepad.hand;
    if (this.gamepad) {
      this.gamepad._update();
    }
    if (gamepad.pose) {
      this.targetRayMode = "tracked-pointer";
      this.emulatedPosition = !gamepad.pose.hasPosition;
    } else if (gamepad.hand === "") {
      this.targetRayMode = "gaze";
      this.emulatedPosition = false;
    }
  }
  updateBasePoseMatrix() {
    if (this.nativeGamepad && this.nativeGamepad.pose) {
      let pose = this.nativeGamepad.pose;
      let position = pose.position;
      let orientation = pose.orientation;
      if (!position && !orientation) {
        return;
      }
      if (!position) {
        if (!pose.hasPosition) {
          if (!this.armModel) {
            this.armModel = new OrientationArmModel();
          }
          this.armModel.setHandedness(this.nativeGamepad.hand);
          this.armModel.update(orientation, this.polyfill.getBasePoseMatrix());
          position = this.armModel.getPosition();
        } else {
          position = this.lastPosition;
        }
      } else {
        this.lastPosition[0] = position[0];
        this.lastPosition[1] = position[1];
        this.lastPosition[2] = position[2];
      }
      fromRotationTranslation(this.basePoseMatrix, orientation, position);
    } else {
      copy5(this.basePoseMatrix, this.polyfill.getBasePoseMatrix());
    }
    return this.basePoseMatrix;
  }
  /**
   * @param {XRReferenceSpace} coordinateSystem
   * @param {string} poseType
   * @return {XRPose?}
   */
  getXRPose(coordinateSystem, poseType) {
    this.updateBasePoseMatrix();
    switch (poseType) {
      case "target-ray":
        coordinateSystem._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
        if (this.gamepad && this.gamepad[PRIVATE19].targetRayTransform) {
          multiply4(this.outputMatrix, this.outputMatrix, this.gamepad[PRIVATE19].targetRayTransform);
        }
        break;
      case "grip":
        if (!this.nativeGamepad || !this.nativeGamepad.pose) {
          return null;
        }
        coordinateSystem._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
        if (this.gamepad && this.gamepad[PRIVATE19].gripTransform) {
          multiply4(this.outputMatrix, this.outputMatrix, this.gamepad[PRIVATE19].gripTransform);
        }
        break;
      default:
        return null;
    }
    coordinateSystem._adjustForOriginOffset(this.outputMatrix);
    return new XRPose(new XRRigidTransform(this.outputMatrix), this.emulatedPosition);
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/WebVRDevice.js
var PRIVATE20 = Symbol("@@webxr-polyfill/WebVRDevice");
var TEST_ENV = false;
var EXTRA_PRESENTATION_ATTRIBUTES = {
  // Non-standard attribute to enable running at the native device refresh rate
  // on the Oculus Go.
  highRefreshRate: true
};
var PRIMARY_BUTTON_MAP = {
  oculus: 1,
  openvr: 1,
  "spatial controller (spatial interaction source)": 1
};
var SESSION_ID = 0;
var Session = class {
  constructor(mode, enabledFeatures, polyfillOptions = {}) {
    this.mode = mode;
    this.enabledFeatures = enabledFeatures;
    this.outputContext = null;
    this.immersive = mode == "immersive-vr" || mode == "immersive-ar";
    this.ended = null;
    this.baseLayer = null;
    this.id = ++SESSION_ID;
    this.modifiedCanvasLayer = false;
    if (this.outputContext && !TEST_ENV) {
      const renderContextType = polyfillOptions.renderContextType || "2d";
      this.renderContext = this.outputContext.canvas.getContext(renderContextType);
    }
  }
};
var WebVRDevice = class extends XRDevice {
  /**
   * Takes a VRDisplay instance and a VRFrameData
   * constructor from the WebVR 1.1 spec.
   *
   * @param {VRDisplay} display
   * @param {VRFrameData} VRFrameData
   */
  constructor(global2, display2) {
    const { canPresent } = display2.capabilities;
    super(global2);
    this.display = display2;
    this.frame = new global2.VRFrameData();
    this.sessions = /* @__PURE__ */ new Map();
    this.immersiveSession = null;
    this.canPresent = canPresent;
    this.baseModelMatrix = create7();
    this.gamepadInputSources = {};
    this.tempVec3 = new Float32Array(3);
    this.onVRDisplayPresentChange = this.onVRDisplayPresentChange.bind(this);
    global2.window.addEventListener("vrdisplaypresentchange", this.onVRDisplayPresentChange);
    this.CAN_USE_GAMEPAD = global2.navigator && "getGamepads" in global2.navigator;
    this.HAS_BITMAP_SUPPORT = isImageBitmapSupported(global2);
  }
  /**
   * @return {number}
   */
  get depthNear() {
    return this.display.depthNear;
  }
  /**
   * @param {number}
   */
  set depthNear(val) {
    this.display.depthNear = val;
  }
  /**
   * @return {number}
   */
  get depthFar() {
    return this.display.depthFar;
  }
  /**
   * @param {number}
   */
  set depthFar(val) {
    this.display.depthFar = val;
  }
  /**
   * Called when a XRSession has a `baseLayer` property set.
   *
   * @param {number} sessionId
   * @param {XRWebGLLayer} layer
   */
  onBaseLayerSet(sessionId, layer) {
    const session = this.sessions.get(sessionId);
    const canvas = layer.context.canvas;
    if (session.immersive) {
      const left2 = this.display.getEyeParameters("left");
      const right = this.display.getEyeParameters("right");
      canvas.width = Math.max(left2.renderWidth, right.renderWidth) * 2;
      canvas.height = Math.max(left2.renderHeight, right.renderHeight);
      this.display.requestPresent([{
        source: canvas,
        attributes: EXTRA_PRESENTATION_ATTRIBUTES
      }]).then(() => {
        if (!TEST_ENV && !this.global.document.body.contains(canvas)) {
          session.modifiedCanvasLayer = true;
          this.global.document.body.appendChild(canvas);
          applyCanvasStylesForMinimalRendering(canvas);
        }
        session.baseLayer = layer;
      });
    } else {
      session.baseLayer = layer;
    }
  }
  /**
   * If a 1.1 VRDisplay cannot present, it could be a 6DOF device
   * that doesn't have its own way to present, but used in magic
   * window mode. So in WebXR lingo, this cannot support an
   * "immersive" session.
   *
   * @param {XRSessionMode} mode
   * @return {boolean}
   */
  isSessionSupported(mode) {
    if (mode == "immersive-ar") {
      return false;
    }
    if (mode == "immersive-vr" && this.canPresent === false) {
      return false;
    }
    return true;
  }
  /**
   * @param {string} featureDescriptor
   * @return {boolean}
   */
  isFeatureSupported(featureDescriptor) {
    switch (featureDescriptor) {
      case "viewer":
        return true;
      case "local":
        return true;
      case "local-floor":
        return true;
      case "bounded":
        return false;
      case "unbounded":
        return false;
      default:
        return false;
    }
  }
  /**
   * Returns a promise of a session ID if creating a session is successful.
   * Usually used to set up presentation in the device.
   * We can't start presenting in a 1.1 device until we have a canvas
   * layer, so use a dummy layer until `onBaseLayerSet` is called.
   * May reject if session is not supported, or if an error is thrown
   * when calling `requestPresent`.
   *
   * @param {XRSessionMode} mode
   * @param {Set<string>} enabledFeatures
   * @return {Promise<number>}
   */
  async requestSession(mode, enabledFeatures) {
    if (!this.isSessionSupported(mode)) {
      return Promise.reject();
    }
    let immersive = mode == "immersive-vr";
    if (immersive) {
      const canvas = this.global.document.createElement("canvas");
      if (!TEST_ENV) {
        const ctx = canvas.getContext("webgl");
      }
      await this.display.requestPresent([{
        source: canvas,
        attributes: EXTRA_PRESENTATION_ATTRIBUTES
      }]);
    }
    const session = new Session(mode, enabledFeatures, {
      renderContextType: this.HAS_BITMAP_SUPPORT ? "bitmaprenderer" : "2d"
    });
    this.sessions.set(session.id, session);
    if (immersive) {
      this.immersiveSession = session;
      this.dispatchEvent("@@webxr-polyfill/vr-present-start", session.id);
    }
    return Promise.resolve(session.id);
  }
  /**
   * @return {Function}
   */
  requestAnimationFrame(callback) {
    return this.display.requestAnimationFrame(callback);
  }
  getPrimaryButtonIndex(gamepad) {
    let primaryButton = 0;
    let name3 = gamepad.id.toLowerCase();
    for (let key in PRIMARY_BUTTON_MAP) {
      if (name3.includes(key)) {
        primaryButton = PRIMARY_BUTTON_MAP[key];
        break;
      }
    }
    return Math.min(primaryButton, gamepad.buttons.length - 1);
  }
  onFrameStart(sessionId, renderState) {
    this.display.depthNear = renderState.depthNear;
    this.display.depthFar = renderState.depthFar;
    this.display.getFrameData(this.frame);
    const session = this.sessions.get(sessionId);
    if (session.immersive && this.CAN_USE_GAMEPAD) {
      let prevInputSources = this.gamepadInputSources;
      this.gamepadInputSources = {};
      let gamepads = this.global.navigator.getGamepads();
      for (let i = 0; i < gamepads.length; ++i) {
        let gamepad = gamepads[i];
        if (gamepad && gamepad.displayId > 0) {
          let inputSourceImpl = prevInputSources[i];
          if (!inputSourceImpl) {
            inputSourceImpl = new GamepadXRInputSource(this, this.display, this.getPrimaryButtonIndex(gamepad));
          }
          inputSourceImpl.updateFromGamepad(gamepad);
          this.gamepadInputSources[i] = inputSourceImpl;
          if (inputSourceImpl.primaryButtonIndex != -1) {
            let primaryActionPressed = gamepad.buttons[inputSourceImpl.primaryButtonIndex].pressed;
            if (primaryActionPressed && !inputSourceImpl.primaryActionPressed) {
              this.dispatchEvent("@@webxr-polyfill/input-select-start", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
            } else if (!primaryActionPressed && inputSourceImpl.primaryActionPressed) {
              this.dispatchEvent("@@webxr-polyfill/input-select-end", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
            }
            inputSourceImpl.primaryActionPressed = primaryActionPressed;
          }
          if (inputSourceImpl.primarySqueezeButtonIndex != -1) {
            let primarySqueezeActionPressed = gamepad.buttons[inputSourceImpl.primarySqueezeButtonIndex].pressed;
            if (primarySqueezeActionPressed && !inputSourceImpl.primarySqueezeActionPressed) {
              this.dispatchEvent("@@webxr-polyfill/input-squeeze-start", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
            } else if (!primarySqueezeActionPressed && inputSourceImpl.primarySqueezeActionPressed) {
              this.dispatchEvent("@@webxr-polyfill/input-squeeze-end", { sessionId: session.id, inputSource: inputSourceImpl.inputSource });
            }
            inputSourceImpl.primarySqueezeActionPressed = primarySqueezeActionPressed;
          }
        }
      }
    }
    if (TEST_ENV) {
      return;
    }
    if (!session.immersive && session.baseLayer) {
      const canvas = session.baseLayer.context.canvas;
      perspective(
        this.frame.leftProjectionMatrix,
        renderState.inlineVerticalFieldOfView,
        canvas.width / canvas.height,
        renderState.depthNear,
        renderState.depthFar
      );
    }
  }
  onFrameEnd(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session.ended || !session.baseLayer) {
      return;
    }
    if (session.outputContext && !(session.immersive && !this.display.capabilities.hasExternalDisplay)) {
      const mirroring = session.immersive && this.display.capabilities.hasExternalDisplay;
      const iCanvas = session.baseLayer.context.canvas;
      const iWidth = mirroring ? iCanvas.width / 2 : iCanvas.width;
      const iHeight = iCanvas.height;
      if (!TEST_ENV) {
        const oCanvas = session.outputContext.canvas;
        const oWidth = oCanvas.width;
        const oHeight = oCanvas.height;
        const renderContext = session.renderContext;
        if (this.HAS_BITMAP_SUPPORT) {
          if (iCanvas.transferToImageBitmap) {
            renderContext.transferFromImageBitmap(iCanvas.transferToImageBitmap());
          } else {
            this.global.createImageBitmap(iCanvas, 0, 0, iWidth, iHeight, {
              resizeWidth: oWidth,
              resizeHeight: oHeight
            }).then((bitmap) => renderContext.transferFromImageBitmap(bitmap));
          }
        } else {
          renderContext.drawImage(
            iCanvas,
            0,
            0,
            iWidth,
            iHeight,
            0,
            0,
            oWidth,
            oHeight
          );
        }
      }
    }
    if (session.immersive && session.baseLayer) {
      this.display.submitFrame();
    }
  }
  /**
   * @param {number} handle
   */
  cancelAnimationFrame(handle) {
    this.display.cancelAnimationFrame(handle);
  }
  /**
   * @TODO Spec
   */
  async endSession(sessionId) {
    const session = this.sessions.get(sessionId);
    if (session.ended) {
      return;
    }
    if (session.immersive) {
      return this.display.exitPresent();
    } else {
      session.ended = true;
    }
  }
  /**
   * @param {number} sessionId
   * @param {XRReferenceSpaceType} type
   * @return {boolean}
   */
  doesSessionSupportReferenceSpace(sessionId, type2) {
    const session = this.sessions.get(sessionId);
    if (session.ended) {
      return false;
    }
    return session.enabledFeatures.has(type2);
  }
  /**
   * If the VRDisplay has stage parameters, convert them
   * to an array of X, Z pairings.
   *
   * @return {Object?}
   */
  requestStageBounds() {
    if (this.display.stageParameters) {
      const width2 = this.display.stageParameters.sizeX;
      const depth = this.display.stageParameters.sizeZ;
      const data = [];
      data.push(-width2 / 2);
      data.push(-depth / 2);
      data.push(width2 / 2);
      data.push(-depth / 2);
      data.push(width2 / 2);
      data.push(depth / 2);
      data.push(-width2 / 2);
      data.push(depth / 2);
      return data;
    }
    return null;
  }
  /**
   * Returns a promise resolving to a transform if XRDevice
   * can support frame of reference and provides its own values.
   * Can resolve to `undefined` if the polyfilled API can provide
   * a default. Rejects if this XRDevice cannot
   * support the frame of reference.
   *
   * @param {XRFrameOfReferenceType} type
   * @param {XRFrameOfReferenceOptions} options
   * @return {Promise<float32rray>}
   */
  async requestFrameOfReferenceTransform(type2, options) {
    if ((type2 === "local-floor" || type2 === "bounded-floor") && this.display.stageParameters && this.display.stageParameters.sittingToStandingTransform) {
      return this.display.stageParameters.sittingToStandingTransform;
    }
    return null;
  }
  /**
   * @param {XREye} eye
   * @return {Float32Array}
   */
  getProjectionMatrix(eye) {
    if (eye === "left") {
      return this.frame.leftProjectionMatrix;
    } else if (eye === "right") {
      return this.frame.rightProjectionMatrix;
    } else if (eye === "none") {
      return this.frame.leftProjectionMatrix;
    } else {
      throw new Error(`eye must be of type 'left' or 'right'`);
    }
  }
  /**
   * Takes a XREye and a target to apply properties of
   * `x`, `y`, `width` and `height` on. Returns a boolean
   * indicating if it successfully was able to populate
   * target's values.
   *
   * @param {number} sessionId
   * @param {XREye} eye
   * @param {XRWebGLLayer} layer
   * @param {Object?} target
   * @return {boolean}
   */
  getViewport(sessionId, eye, layer, target) {
    const session = this.sessions.get(sessionId);
    const { width: width2, height: height2 } = layer.context.canvas;
    if (!session.immersive) {
      target.x = target.y = 0;
      target.width = width2;
      target.height = height2;
      return true;
    }
    if (eye === "left" || eye === "none") {
      target.x = 0;
    } else if (eye === "right") {
      target.x = width2 / 2;
    } else {
      return false;
    }
    target.y = 0;
    target.width = width2 / 2;
    target.height = height2;
    return true;
  }
  /**
   * Get model matrix unaffected by frame of reference.
   *
   * @return {Float32Array}
   */
  getBasePoseMatrix() {
    let { position, orientation } = this.frame.pose;
    if (!position && !orientation) {
      return this.baseModelMatrix;
    }
    if (!position) {
      position = this.tempVec3;
      position[0] = position[1] = position[2] = 0;
    }
    fromRotationTranslation(this.baseModelMatrix, orientation, position);
    return this.baseModelMatrix;
  }
  /**
   * Get view matrix unaffected by frame of reference.
   *
   * @param {XREye} eye
   * @return {Float32Array}
   */
  getBaseViewMatrix(eye) {
    if (eye === "left" || eye === "none") {
      return this.frame.leftViewMatrix;
    } else if (eye === "right") {
      return this.frame.rightViewMatrix;
    } else {
      throw new Error(`eye must be of type 'left' or 'right'`);
    }
  }
  getInputSources() {
    let inputSources = [];
    for (let i in this.gamepadInputSources) {
      inputSources.push(this.gamepadInputSources[i].inputSource);
    }
    return inputSources;
  }
  getInputPose(inputSource, coordinateSystem, poseType) {
    if (!coordinateSystem) {
      return null;
    }
    for (let i in this.gamepadInputSources) {
      let inputSourceImpl = this.gamepadInputSources[i];
      if (inputSourceImpl.inputSource === inputSource) {
        return inputSourceImpl.getXRPose(coordinateSystem, poseType);
      }
    }
    return null;
  }
  /**
   * Triggered on window resize.
   *
   */
  onWindowResize() {
  }
  /**
   * Listens to the Native 1.1 `window.addEventListener('vrdisplaypresentchange')`
   * event.
   *
   * @param {Event} event
   */
  onVRDisplayPresentChange(e2) {
    if (!this.display.isPresenting) {
      this.sessions.forEach((session) => {
        if (session.immersive && !session.ended) {
          if (session.modifiedCanvasLayer) {
            const canvas = session.baseLayer.context.canvas;
            document.body.removeChild(canvas);
            canvas.setAttribute("style", "");
          }
          if (this.immersiveSession === session) {
            this.immersiveSession = null;
          }
          this.dispatchEvent("@@webxr-polyfill/vr-present-end", session.id);
        }
      });
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/CardboardXRDevice.js
var CardboardXRDevice = class extends WebVRDevice {
  /**
   * Takes a VRDisplay instance and a VRFrameData
   * constructor from the WebVR 1.1 spec.
   *
   * @param {VRDisplay} display
   * @param {Object?} cardboardConfig
   */
  constructor(global2, cardboardConfig) {
    const display2 = new import_cardboard_vr_display.default(cardboardConfig || {});
    super(global2, display2);
    this.display = display2;
    this.frame = {
      rightViewMatrix: new Float32Array(16),
      leftViewMatrix: new Float32Array(16),
      rightProjectionMatrix: new Float32Array(16),
      leftProjectionMatrix: new Float32Array(16),
      pose: null,
      timestamp: null
    };
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices/InlineDevice.js
var TEST_ENV2 = false;
var SESSION_ID2 = 0;
var Session2 = class {
  constructor(mode, enabledFeatures) {
    this.mode = mode;
    this.enabledFeatures = enabledFeatures;
    this.ended = null;
    this.baseLayer = null;
    this.id = ++SESSION_ID2;
  }
};
var InlineDevice = class extends XRDevice {
  /**
   * Constructs an inline-only XRDevice
   */
  constructor(global2) {
    super(global2);
    this.sessions = /* @__PURE__ */ new Map();
    this.projectionMatrix = create7();
    this.identityMatrix = create7();
  }
  /**
   * Called when a XRSession has a `baseLayer` property set.
   *
   * @param {number} sessionId
   * @param {XRWebGLLayer} layer
   */
  onBaseLayerSet(sessionId, layer) {
    const session = this.sessions.get(sessionId);
    session.baseLayer = layer;
  }
  /**
   * Returns true if the requested mode is inline
   *
   * @param {XRSessionMode} mode
   * @return {boolean}
   */
  isSessionSupported(mode) {
    return mode == "inline";
  }
  /**
   * @param {string} featureDescriptor
   * @return {boolean}
   */
  isFeatureSupported(featureDescriptor) {
    switch (featureDescriptor) {
      case "viewer":
        return true;
      default:
        return false;
    }
  }
  /**
   * Returns a promise of a session ID if creating a session is successful.
   *
   * @param {XRSessionMode} mode
   * @param {Set<string>} enabledFeatures
   * @return {Promise<number>}
   */
  async requestSession(mode, enabledFeatures) {
    if (!this.isSessionSupported(mode)) {
      return Promise.reject();
    }
    const session = new Session2(mode, enabledFeatures);
    this.sessions.set(session.id, session);
    return Promise.resolve(session.id);
  }
  /**
   * @return {Function}
   */
  requestAnimationFrame(callback) {
    return window.requestAnimationFrame(callback);
  }
  /**
   * @param {number} handle
   */
  cancelAnimationFrame(handle) {
    window.cancelAnimationFrame(handle);
  }
  onFrameStart(sessionId, renderState) {
    if (TEST_ENV2) {
      return;
    }
    const session = this.sessions.get(sessionId);
    if (session.baseLayer) {
      const canvas = session.baseLayer.context.canvas;
      perspective(
        this.projectionMatrix,
        renderState.inlineVerticalFieldOfView,
        canvas.width / canvas.height,
        renderState.depthNear,
        renderState.depthFar
      );
    }
  }
  onFrameEnd(sessionId) {
  }
  /**
   * @TODO Spec
   */
  async endSession(sessionId) {
    const session = this.sessions.get(sessionId);
    session.ended = true;
  }
  /**
   * @param {number} sessionId
   * @param {XRReferenceSpaceType} type
   * @return {boolean}
   */
  doesSessionSupportReferenceSpace(sessionId, type2) {
    const session = this.sessions.get(sessionId);
    if (session.ended) {
      return false;
    }
    return session.enabledFeatures.has(type2);
  }
  /**
   * Inline sessions don't have stage bounds
   *
   * @return {Object?}
   */
  requestStageBounds() {
    return null;
  }
  /**
   * Inline sessions don't have multiple frames of reference
   *
   * @param {XRFrameOfReferenceType} type
   * @param {XRFrameOfReferenceOptions} options
   * @return {Promise<Float32Array>}
   */
  async requestFrameOfReferenceTransform(type2, options) {
    return null;
  }
  /**
   * @param {XREye} eye
   * @return {Float32Array}
   */
  getProjectionMatrix(eye) {
    return this.projectionMatrix;
  }
  /**
   * Takes a XREye and a target to apply properties of
   * `x`, `y`, `width` and `height` on. Returns a boolean
   * indicating if it successfully was able to populate
   * target's values.
   *
   * @param {number} sessionId
   * @param {XREye} eye
   * @param {XRWebGLLayer} layer
   * @param {Object?} target
   * @return {boolean}
   */
  getViewport(sessionId, eye, layer, target) {
    const session = this.sessions.get(sessionId);
    const { width: width2, height: height2 } = layer.context.canvas;
    target.x = target.y = 0;
    target.width = width2;
    target.height = height2;
    return true;
  }
  /**
   * Get model matrix unaffected by frame of reference.
   *
   * @return {Float32Array}
   */
  getBasePoseMatrix() {
    return this.identityMatrix;
  }
  /**
   * Get view matrix unaffected by frame of reference.
   *
   * @param {XREye} eye
   * @return {Float32Array}
   */
  getBaseViewMatrix(eye) {
    return this.identityMatrix;
  }
  /**
   * No persistent input sources for the inline session
   */
  getInputSources() {
    return [];
  }
  getInputPose(inputSource, coordinateSystem, poseType) {
    return null;
  }
  /**
   * Triggered on window resize.
   */
  onWindowResize() {
  }
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/devices.js
var getWebVRDevice = async function(global2) {
  let device = null;
  if ("getVRDisplays" in global2.navigator) {
    try {
      const displays = await global2.navigator.getVRDisplays();
      if (displays && displays.length) {
        device = new WebVRDevice(global2, displays[0]);
      }
    } catch (e2) {
    }
  }
  return device;
};
var requestXRDevice = async function(global2, config) {
  if (config.webvr) {
    let xr = await getWebVRDevice(global2);
    if (xr) {
      return xr;
    }
  }
  let mobile = isMobile2(global2);
  if (mobile && config.cardboard || !mobile && config.allowCardboardOnDesktop) {
    if (!global2.VRFrameData) {
      global2.VRFrameData = function() {
        this.rightViewMatrix = new Float32Array(16);
        this.leftViewMatrix = new Float32Array(16);
        this.rightProjectionMatrix = new Float32Array(16);
        this.leftProjectionMatrix = new Float32Array(16);
        this.pose = null;
      };
    }
    return new CardboardXRDevice(global2, config.cardboardConfig);
  }
  return new InlineDevice(global2);
};

// ../Juniper/src/Juniper.TypeScript/node_modules/webxr-polyfill/src/WebXRPolyfill.js
var CONFIG_DEFAULTS = {
  // The default global to use for needed APIs.
  global: global_default,
  // Whether support for a browser implementing WebVR 1.1 is enabled.
  // If enabled, XR support is powered by native WebVR 1.1 VRDisplays,
  // exposed as XRDevices.
  webvr: true,
  // Whether a CardboardXRDevice should be discoverable if on
  // a mobile device, and no other native (1.1 VRDisplay if `webvr` on,
  // or XRDevice) found.
  cardboard: true,
  // The configuration to be used for CardboardVRDisplay when used.
  // Has no effect if `cardboard: false` or another XRDevice is used.
  // Configuration can be found: https://github.com/immersive-web/cardboard-vr-display/blob/master/src/options.js
  cardboardConfig: null,
  // Whether a CardboardXRDevice should be created if no WebXR API found
  // on desktop or not. Stereoscopic rendering with a gyro often does not make sense on desktop, and probably only useful for debugging.
  allowCardboardOnDesktop: false
};
var partials = ["navigator", "HTMLCanvasElement", "WebGLRenderingContext"];
var WebXRPolyfill = class {
  /**
   * @param {object?} config
   */
  constructor(config = {}) {
    this.config = Object.freeze(Object.assign({}, CONFIG_DEFAULTS, config));
    this.global = this.config.global;
    this.nativeWebXR = "xr" in this.global.navigator;
    this.injected = false;
    if (!this.nativeWebXR) {
      this._injectPolyfill(this.global);
    } else {
      this._injectCompatibilityShims(this.global);
    }
  }
  _injectPolyfill(global2) {
    if (!partials.every((iface) => !!global2[iface])) {
      throw new Error(`Global must have the following attributes : ${partials}`);
    }
    for (const className2 of Object.keys(api_default)) {
      if (global2[className2] !== void 0) {
        console.warn(`${className2} already defined on global.`);
      } else {
        global2[className2] = api_default[className2];
      }
    }
    if (true) {
      const polyfilledCtx = polyfillMakeXRCompatible(global2.WebGLRenderingContext);
      if (polyfilledCtx) {
        polyfillGetContext(global2.HTMLCanvasElement);
        if (global2.OffscreenCanvas) {
          polyfillGetContext(global2.OffscreenCanvas);
        }
        if (global2.WebGL2RenderingContext) {
          polyfillMakeXRCompatible(global2.WebGL2RenderingContext);
        }
        if (!window.isSecureContext) {
          console.warn(`WebXR Polyfill Warning:
This page is not running in a secure context (https:// or localhost)!
This means that although the page may be able to use the WebXR Polyfill it will
not be able to use native WebXR implementations, and as such will not be able to
access dedicated VR or AR hardware, and will not be able to take advantage of
any performance improvements a native WebXR implementation may offer. Please
host this content on a secure origin for the best user experience.
`);
        }
      }
    }
    this.injected = true;
    this._patchNavigatorXR();
  }
  _patchNavigatorXR() {
    let devicePromise = requestXRDevice(this.global, this.config);
    this.xr = new api_default.XRSystem(devicePromise);
    Object.defineProperty(this.global.navigator, "xr", {
      value: this.xr,
      configurable: true
    });
  }
  _injectCompatibilityShims(global2) {
    if (!partials.every((iface) => !!global2[iface])) {
      throw new Error(`Global must have the following attributes : ${partials}`);
    }
    if (global2.navigator.xr && "supportsSession" in global2.navigator.xr && !("isSessionSupported" in global2.navigator.xr)) {
      let originalSupportsSession = global2.navigator.xr.supportsSession;
      global2.navigator.xr.isSessionSupported = function(mode) {
        return originalSupportsSession.call(this, mode).then(() => {
          return true;
        }).catch(() => {
          return false;
        });
      };
      global2.navigator.xr.supportsSession = function(mode) {
        console.warn("navigator.xr.supportsSession() is deprecated. Please call navigator.xr.isSessionSupported() instead and check the boolean value returned when the promise resolves.");
        return originalSupportsSession.call(this, mode);
      };
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/ScreenControl.ts
if (!navigator.xr) {
  console.info("Polyfilling WebXR API");
  new WebXRPolyfill();
}
var XRSessionToggleEvent = class extends TypedEvent {
  constructor(type2, mode, session, referenceSpaceType, sessionMode) {
    super(type2);
    this.mode = mode;
    this.session = session;
    this.referenceSpaceType = referenceSpaceType;
    this.sessionMode = sessionMode;
  }
};
var XRSessionStartedEvent = class extends XRSessionToggleEvent {
  constructor(mode, session, referenceSpaceType, sessionMode) {
    super("sessionstarted", mode, session, referenceSpaceType, sessionMode);
  }
};
var XRSessionStoppedEvent = class extends XRSessionToggleEvent {
  constructor(mode, session, referenceSpaceType, sessionMode) {
    super("sessionstopped", mode, session, referenceSpaceType, sessionMode);
  }
};
var xrModes = /* @__PURE__ */ new Map([
  ["VR" /* VR */, {
    referenceSpaceType: "local-floor",
    sessionMode: "immersive-vr"
  }],
  ["AR" /* AR */, {
    referenceSpaceType: "local-floor",
    sessionMode: "immersive-ar"
  }]
]);
var ScreenControl = class extends TypedEventBase {
  constructor(renderer, camera, fullscreenElement, enableFullResolution2) {
    super();
    this.renderer = renderer;
    this.camera = camera;
    this.fullscreenElement = fullscreenElement;
    this.enableFullResolution = enableFullResolution2;
    this._currentMode = "None" /* None */;
    this.buttons = /* @__PURE__ */ new Map();
    this.currentSession = null;
    this.screenUI = null;
    this.wasVisible = /* @__PURE__ */ new Map();
    this.lastFOV = 50;
    this.addEventListener("sessionstarted", (evt) => {
      if (evt.sessionMode === "inline") {
        this.lastFOV = this.camera.fov;
        this.camera.fov = rad2deg(evt.session.renderState.inlineVerticalFieldOfView);
      }
    });
    this.addEventListener("sessionstopped", (evt) => {
      if (evt.sessionMode === "inline") {
        this.camera.fov = this.lastFOV;
      }
    });
    this.renderer.xr.addEventListener("sessionstart", () => this.onSessionStarted());
    this.renderer.xr.addEventListener("sessionend", () => this.onSessionEnded());
    this.refresh();
  }
  setUI(screenUI, fullscreenButton, vrButton, arButton) {
    this.screenUI = screenUI;
    this.buttons.set(fullscreenButton.mode, fullscreenButton);
    this.buttons.set(vrButton.mode, vrButton);
    this.buttons.set(arButton.mode, arButton);
    for (const button of this.buttons.values()) {
      this.wasVisible.set(button, button.visible);
      button.addEventListener("click", this.toggleMode.bind(this, button.mode));
    }
    fullscreenButton.available = !isMobileVR() && hasFullscreenAPI();
    vrButton.available = hasVR();
    arButton.available = hasWebXR();
    this.refresh();
  }
  get visible() {
    return elementIsDisplayed(this.renderer.domElement);
  }
  set visible(v) {
    elementSetDisplay(this.renderer.domElement, v);
    if (this.screenUI) {
      if (v) {
        this.screenUI.show();
      } else {
        this.screenUI.hide();
      }
    }
  }
  get currentMode() {
    return this._currentMode;
  }
  resize() {
    if (!this.renderer.xr.isPresenting) {
      const {
        clientWidth,
        clientHeight,
        width: width2,
        height: height2
      } = this.renderer.domElement;
      const nextWidth = Math.floor(clientWidth * devicePixelRatio);
      const nextHeight = Math.floor(clientHeight * devicePixelRatio);
      if (clientWidth > 0 && clientHeight > 0 && (width2 !== nextWidth || height2 !== nextHeight)) {
        this.renderer.setPixelRatio(devicePixelRatio);
        this.renderer.setSize(clientWidth, clientHeight, false);
        this.camera.aspect = clientWidth / clientHeight;
        this.camera.updateProjectionMatrix();
      }
    }
  }
  getMetrics() {
    const width2 = this.renderer.domElement.clientWidth;
    const height2 = this.renderer.domElement.clientHeight;
    const pixelRatio = this.renderer.getPixelRatio();
    const fov = this.camera.fov;
    return { width: width2, height: height2, pixelRatio, fov };
  }
  setMetrics(width2, height2, pixelRatio, fov) {
    this.renderer.setPixelRatio(pixelRatio);
    this.renderer.setSize(width2, height2, false);
    this.camera.aspect = width2 / height2;
    this.camera.fov = fov;
    this.camera.updateProjectionMatrix();
  }
  async refresh() {
    const toCheck = Array.from(this.buttons.values()).filter((btn) => btn.available && btn.mode !== "Fullscreen" /* Fullscreen */);
    await Promise.all(
      toCheck.map(async (btn) => {
        const xrMode = xrModes.get(btn.mode);
        btn.available = isDefined(xrMode);
        if (btn.available) {
          const typeSupported = navigator.xr && await navigator.xr.isSessionSupported(xrMode.sessionMode);
          const webVROverride = !hasWebXR() && hasWebVR() && xrMode.sessionMode === "immersive-vr" && xrMode.referenceSpaceType === "local-floor";
          btn.available = typeSupported || webVROverride;
        }
      })
    );
  }
  async toggleMode(mode) {
    if (mode === "Fullscreen" /* Fullscreen */) {
      await this.toggleFullscreen();
    } else if (mode !== "None" /* None */) {
      await this.toggleXR(mode);
    }
  }
  async start(mode) {
    if (mode !== this.currentMode) {
      await this.toggleMode(this.currentMode);
      await this.toggleMode(mode);
    }
  }
  async stop() {
    await this.toggleMode(this.currentMode);
  }
  get isFullscreen() {
    return document.fullscreen;
  }
  async startFullscreen() {
    if (!this.isFullscreen) {
      await this.fullscreenElement.requestFullscreen({
        navigationUI: "show"
      });
      this.setActive("Fullscreen" /* Fullscreen */);
      this.dispatchEvent(new XRSessionStartedEvent("Fullscreen" /* Fullscreen */, null, null, null));
    }
  }
  async stopFullscreen() {
    if (this.isFullscreen) {
      await document.exitFullscreen();
      this.setActive("None" /* None */);
      this.dispatchEvent(new XRSessionStoppedEvent("Fullscreen" /* Fullscreen */, null, null, null));
    }
  }
  async toggleFullscreen() {
    if (this.isFullscreen) {
      await this.stopFullscreen();
    } else {
      await this.startFullscreen();
    }
  }
  async toggleXR(mode) {
    const xrMode = xrModes.get(mode);
    if (isDefined(xrMode)) {
      if (this.currentSession) {
        this.currentSession.end();
      } else if (navigator.xr) {
        this.camera.position.setScalar(0);
        this.camera.quaternion.identity();
        try {
          const session = await navigator.xr.requestSession(xrMode.sessionMode, {
            optionalFeatures: [
              "local-floor",
              "bounded-floor",
              "high-refresh-rate",
              "hand-tracking",
              "layers"
            ]
          });
          this.setActive(mode);
          this.currentSession = session;
          this.renderer.xr.setReferenceSpaceType(xrMode.referenceSpaceType);
          if (this.enableFullResolution && "XRWebGLLayer" in window && "getNativeFramebufferScaleFactor" in XRWebGLLayer) {
            const size4 = XRWebGLLayer.getNativeFramebufferScaleFactor(session);
            this.renderer.xr.setFramebufferScaleFactor(size4);
          }
          this.renderer.xr.setSession(session);
        } catch (exp2) {
          console.error(`Couldn't start session type '${xrMode.sessionMode}'. Reason: ${exp2 && exp2.message || exp2 || "UNKNOWN"}`);
        }
      }
    }
  }
  onSessionStarted() {
    const mode = this.currentMode;
    const xrMode = xrModes.get(this.currentMode);
    const session = this.currentSession;
    if (session.supportedFrameRates) {
      const max5 = Math.max(...session.supportedFrameRates);
      console.log("Changing framerate to", max5);
      session.updateTargetFrameRate(max5);
    }
    this.dispatchEvent(new XRSessionStartedEvent(
      mode,
      session,
      xrMode.referenceSpaceType,
      xrMode.sessionMode
    ));
  }
  onSessionEnded() {
    const mode = this.currentMode;
    const xrMode = xrModes.get(this.currentMode);
    const session = this.currentSession;
    this.currentSession = null;
    this.renderer.xr.setSession(null);
    this.setActive("None" /* None */);
    this.dispatchEvent(new XRSessionStoppedEvent(
      mode,
      session,
      xrMode.referenceSpaceType,
      xrMode.sessionMode
    ));
  }
  setActive(mode) {
    for (const button of this.buttons.values()) {
      button.active = button.mode === mode;
      button.visible = this.wasVisible.get(button) && (mode === "None" /* None */ || mode === "Fullscreen" /* Fullscreen */ || button.mode === mode);
    }
    this._currentMode = mode;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/Skybox.ts
var U = new Vector3(0, 1, 0);
var FACE_SIZE = 2048;
var FACE_SIZE_HALF = FACE_SIZE / 2;
var FACES = [
  1,
  0,
  2,
  3,
  4,
  5
];
var CUBEMAP_PATTERN = {
  rows: 3,
  columns: 4,
  indices: [
    [-1 /* None */, 2 /* Up */, -1 /* None */, -1 /* None */],
    [0 /* Left */, 5 /* Front */, 1 /* Right */, 4 /* Back */],
    [-1 /* None */, 3 /* Down */, -1 /* None */, -1 /* None */]
  ],
  rotations: [
    [0, Pi, 0, 0],
    [0, 0, 0, 0],
    [0, Pi, 0, 0]
  ]
};
var black = new Color(0);
var Skybox = class {
  constructor(env) {
    this.env = env;
    this.rt = new WebGLCubeRenderTarget(FACE_SIZE);
    this.rtScene = new Scene();
    this.rtCamera = new CubeCamera(0.01, 10, this.rt);
    this._rotation = new Quaternion();
    this.layerRotation = new Quaternion().identity();
    this.stageRotation = new Quaternion().identity();
    this.canvases = new Array(6);
    this.contexts = new Array(6);
    this.layerOrientation = null;
    this.images = null;
    this.curImagePath = null;
    this.layer = null;
    this.wasVisible = false;
    this.stageHeading = 0;
    this.rotationNeedsUpdate = false;
    this.imageNeedsUpdate = false;
    this.useWebXRLayers = true;
    this.wasWebXRLayerAvailable = null;
    this.visible = true;
    this.onNeedsRedraw = () => this.imageNeedsUpdate = true;
    this.env.scene.background = black;
    for (let i = 0; i < this.canvases.length; ++i) {
      const f2 = this.canvases[i] = createUtilityCanvas(FACE_SIZE, FACE_SIZE);
      this.contexts[i] = f2.getContext("2d", { alpha: false });
    }
    for (let row = 0; row < CUBEMAP_PATTERN.rows; ++row) {
      const indices = CUBEMAP_PATTERN.indices[row];
      const rotations = CUBEMAP_PATTERN.rotations[row];
      for (let column = 0; column < CUBEMAP_PATTERN.columns; ++column) {
        const i = indices[column];
        if (i > -1) {
          const g = this.contexts[i];
          const rotation = rotations[column];
          if (rotation > 0) {
            if (rotation % 2 === 0) {
              g.translate(FACE_SIZE_HALF, FACE_SIZE_HALF);
            } else {
              g.translate(FACE_SIZE_HALF, FACE_SIZE_HALF);
            }
            g.rotate(rotation);
            g.translate(-FACE_SIZE_HALF, -FACE_SIZE_HALF);
          }
        }
      }
    }
    this.rt.texture.name = "SkyboxOutput";
    this.rtScene.add(this.rtCamera);
    this.flipped = createUtilityCanvas(FACE_SIZE, FACE_SIZE);
    this.flipper = this.flipped.getContext("2d", { alpha: false });
    this.flipper.fillStyle = black.getHexString();
    this.flipper.scale(-1, 1);
    this.flipper.translate(-FACE_SIZE, 0);
    this.setImages("", this.canvases);
    this.env.addScopedEventListener(this, "update", (evt) => this.checkWebXRLayer(evt.frame));
    Object.seal(this);
  }
  get envMap() {
    return this._cube;
  }
  clear() {
    this.setImage(null, null);
  }
  setImage(imageID, image2) {
    if (imageID !== this.curImagePath) {
      if (isDefined(image2)) {
        this.sliceImage(image2);
        return this.setImages(imageID, this.canvases);
      } else {
        return this.setImages(imageID, null);
      }
    }
    return null;
  }
  sliceImage(image2) {
    const width2 = image2.width / CUBEMAP_PATTERN.columns;
    const height2 = image2.height / CUBEMAP_PATTERN.rows;
    for (let row = 0; row < CUBEMAP_PATTERN.rows; ++row) {
      const indices = CUBEMAP_PATTERN.indices[row];
      for (let column = 0; column < CUBEMAP_PATTERN.columns; ++column) {
        const i = indices[column];
        if (i > -1) {
          const g = this.contexts[i];
          g.drawImage(
            image2,
            column * width2,
            row * height2,
            width2,
            height2,
            0,
            0,
            FACE_SIZE,
            FACE_SIZE
          );
        }
      }
    }
    return this.canvases;
  }
  setImages(imageID, images) {
    if (imageID !== this.curImagePath || images !== this.images) {
      this.curImagePath = imageID;
      if (images !== this.images) {
        if (isDefined(this._cube)) {
          cleanup(this._cube);
          this._cube = null;
        }
        if (isDefined(this.images)) {
          for (const img of this.images) {
            cleanup(img);
          }
        }
        this.images = images;
        if (isDefined(this.images)) {
          this.rtScene.background = this._cube = new CubeTexture(this.images);
          this._cube.name = "SkyboxInput";
        } else {
          this.rtScene.background = black;
        }
      }
    }
    this.updateImages();
    return this._cube;
  }
  updateImages() {
    this._cube.needsUpdate = true;
    this.imageNeedsUpdate = true;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(rotation) {
    const { x, y, z, w } = this._rotation;
    if (isQuaternion(rotation)) {
      this._rotation.copy(rotation);
    } else if (isEuler(rotation)) {
      this._rotation.setFromEuler(rotation);
    } else if (isArray(rotation)) {
      if (rotation.length === 4 && isNumber(rotation[0]) && isNumber(rotation[1]) && isNumber(rotation[2]) && isNumber(rotation[3])) {
        this._rotation.fromArray(rotation);
      } else {
        throw new Error("Skybox rotation was not a valid array format. Needs an array of 4 numbers.");
      }
    } else if (isGoodNumber(rotation)) {
      this._rotation.setFromAxisAngle(U, rotation);
    } else {
      if (isDefined(rotation)) {
        console.warn("Skybox rotation must be a THREE.Quaternion, THREE.Euler, number[] (representing a Quaternion), or a number (representing rotation about the Y-axis).");
      }
      this._rotation.identity();
    }
    this.rotationNeedsUpdate = this._rotation.x !== x || this._rotation.y !== y || this._rotation.z !== z || this._rotation.w !== w;
  }
  checkWebXRLayer(frame) {
    if (this._cube) {
      const isWebXRLayerAvailable = this.useWebXRLayers && this.env.hasXRCompositionLayers && isDefined(frame) && isDefined(this.env.xrBinding);
      const webXRLayerChanged = isWebXRLayerAvailable !== this.wasWebXRLayerAvailable;
      if (webXRLayerChanged) {
        if (isWebXRLayerAvailable) {
          const space = this.env.renderer.xr.getReferenceSpace();
          this.layer = this.env.xrBinding.createCubeLayer({
            space,
            layout: "mono",
            isStatic: false,
            viewPixelWidth: FACE_SIZE,
            viewPixelHeight: FACE_SIZE,
            orientation: this.layerOrientation
          });
          this.layer.addEventListener("redraw", this.onNeedsRedraw);
          this.env.addWebXRLayer(this.layer, Number.MAX_VALUE);
        } else if (this.layer) {
          this.env.removeWebXRLayer(this.layer);
          this.layer.removeEventListener("redraw", this.onNeedsRedraw);
          dispose2(this.layer);
          this.layer = null;
        }
        this.imageNeedsUpdate = true;
      }
      if (!this.layer || !webXRLayerChanged) {
        const visibleChanged = this.visible !== this.wasVisible;
        const headingChanged = this.env.avatar.headingRadians !== this.stageHeading;
        this.imageNeedsUpdate = this.imageNeedsUpdate || visibleChanged || this.layer && this.layer.needsRedraw;
        this.rotationNeedsUpdate = this.rotationNeedsUpdate || headingChanged;
        this.env.scene.background = this.layer ? null : this.visible ? this.rt.texture : black;
        if (this.rotationNeedsUpdate) {
          this.layerRotation.copy(this.rotation).invert();
          this.stageRotation.setFromAxisAngle(U, this.env.avatar.headingRadians).premultiply(this.layerRotation);
          this.layerOrientation = new DOMPointReadOnly(
            this.stageRotation.x,
            this.stageRotation.y,
            this.stageRotation.z,
            this.stageRotation.w
          );
          if (this.layer) {
            this.layer.orientation = this.layerOrientation;
          } else {
            this.rtCamera.quaternion.copy(this.layerRotation);
            this.imageNeedsUpdate = true;
          }
        }
        if (this.imageNeedsUpdate) {
          if (this.layer) {
            const gl = this.env.renderer.getContext();
            const gLayer = this.env.xrBinding.getSubImage(this.layer, frame);
            const imgs = this._cube.images;
            this.flipper.fillRect(0, 0, FACE_SIZE, FACE_SIZE);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, gLayer.colorTexture);
            for (let i = 0; i < imgs.length; ++i) {
              if (this.visible) {
                const img = imgs[FACES[i]];
                this.flipper.drawImage(
                  img,
                  0,
                  0,
                  img.width,
                  img.height,
                  0,
                  0,
                  FACE_SIZE,
                  FACE_SIZE
                );
              }
              gl.texSubImage2D(
                gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                0,
                0,
                0,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                this.flipped
              );
            }
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
          } else {
            this.rtCamera.update(this.env.renderer, this.rtScene);
          }
        }
        this.stageHeading = this.env.avatar.headingRadians;
        this.imageNeedsUpdate = false;
        this.rotationNeedsUpdate = false;
        this.wasVisible = this.visible;
      }
      this.wasWebXRLayerAvailable = isWebXRLayerAvailable;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/animation/BodyFollower.ts
var targetPos = new Vector3();
var targetHeadingRadians = 0;
var dPos = new Vector3();
var curPos = new Vector3();
var curDir = new Vector3();
var dQuat = new Quaternion();
var curHeadingRadians = 0;
var copyCounter2 = 0;
function minRotAngle(to, from) {
  const a = to - from;
  const b = a + Tau;
  const c = a - Tau;
  return minly(a, b, c);
}
var BodyFollower = class extends Object3D {
  constructor(name3, minDistance, minHeadingDegrees, heightOffset, speed = 1) {
    super();
    this.minDistance = minDistance;
    this.heightOffset = heightOffset;
    this.speed = speed;
    this.name = name3;
    this.lerp = this.minHeadingRadians > 0 || this.minDistance > 0;
    this.maxDistance = this.minDistance * 5;
    this.minHeadingRadians = deg2rad(minHeadingDegrees);
    this.maxHeadingRadians = Pi - this.minHeadingRadians;
    Object.seal(this);
  }
  copy(source, recursive = true) {
    super.copy(source, recursive);
    this.name = source.name + ++copyCounter2;
    this.lerp = source.lerp;
    this.maxDistance = source.maxDistance;
    this.minHeadingRadians = source.minHeadingRadians;
    this.maxHeadingRadians = source.maxHeadingRadians;
    return this;
  }
  update(height2, position, headingRadians, dt) {
    dt *= 1e-3;
    this.clampTo(this.lerp, height2, position, this.minDistance, this.maxDistance, headingRadians, this.minHeadingRadians, this.maxHeadingRadians, dt);
  }
  reset(height2, position, headingRadians) {
    this.clampTo(false, height2, position, 0, 0, headingRadians, 0, 0, 0);
  }
  clampTo(lerp8, height2, position, minDistance, maxDistance, headingRadians, minHeadingRadians, maxHeadingRadians, dt) {
    targetPos.copy(position);
    targetPos.y -= this.heightOffset * height2;
    targetHeadingRadians = headingRadians;
    this.getWorldPosition(curPos);
    this.getWorldDirection(curDir);
    curDir.negate();
    curHeadingRadians = getLookHeadingRadians(curDir);
    dQuat.identity();
    let setPos = !lerp8;
    let setRot = !lerp8;
    if (lerp8) {
      const dist4 = dPos.copy(targetPos).sub(curPos).length();
      if (minDistance < dist4) {
        if (dist4 < maxDistance) {
          targetPos.lerpVectors(curPos, targetPos, this.speed * dt);
        }
        setPos = true;
      }
      const dHeadingRadians = minRotAngle(targetHeadingRadians, curHeadingRadians);
      const mHeadingRadians = Math.abs(dHeadingRadians);
      if (minHeadingRadians < mHeadingRadians) {
        if (mHeadingRadians < maxHeadingRadians) {
          dQuat.setFromAxisAngle(this.up, dHeadingRadians * this.speed * dt);
        } else {
          dQuat.setFromAxisAngle(this.up, dHeadingRadians);
        }
        setRot = true;
      }
    }
    if (setPos || setRot) {
      if (setPos) {
        this.position.add(targetPos.sub(curPos));
      }
      if (setRot) {
        this.quaternion.multiply(dQuat);
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/EventedGamepad.ts
var GamepadButtonEvent = class extends TypedEvent {
  constructor(type2, button) {
    super(type2);
    this.button = button;
  }
};
var GamepadButtonUpEvent = class extends GamepadButtonEvent {
  constructor(button) {
    super("gamepadbuttonup", button);
  }
};
var GamepadButtonDownEvent = class extends GamepadButtonEvent {
  constructor(button) {
    super("gamepadbuttondown", button);
  }
};
var GamepadAxisEvent = class extends TypedEvent {
  constructor(type2, axis, value2) {
    super(type2);
    this.axis = axis;
    this.value = value2;
  }
};
var GamepadAxisMaxedEvent = class extends GamepadAxisEvent {
  constructor(axis, value2) {
    super("gamepadaxismaxed", axis, value2);
  }
};
var EventedGamepad = class extends TypedEventBase {
  constructor() {
    super();
    this.lastAxisValues = new Array();
    this.btnDownEvts = new Array();
    this.btnUpEvts = new Array();
    this.wasPressed = new Array();
    this.axisMaxEvts = new Array();
    this.wasAxisMaxed = new Array();
    this.sticks = new Array();
    this.axisThresholdMax = 0.9;
    this.axisThresholdMin = 0.1;
    this._pad = null;
    Object.seal(this);
  }
  get displayId() {
    if ("displayId" in this.pad) {
      return this.pad.displayId;
    }
    return void 0;
  }
  get pad() {
    return this._pad;
  }
  set pad(pad) {
    this._pad = pad;
    if (this.pad) {
      if (this.btnUpEvts.length === 0) {
        for (let b = 0; b < pad.buttons.length; ++b) {
          this.btnDownEvts[b] = new GamepadButtonDownEvent(b);
          this.btnUpEvts[b] = new GamepadButtonUpEvent(b);
          this.wasPressed[b] = false;
        }
        for (let a = 0; a < pad.axes.length; ++a) {
          this.axisMaxEvts[a] = new GamepadAxisMaxedEvent(a, 0);
          this.wasAxisMaxed[a] = false;
          if (a % 2 === 0 && a < pad.axes.length - 1) {
            this.sticks[a / 2] = { x: 0, y: 0 };
          }
          this.lastAxisValues[a] = pad.axes[a];
        }
      }
      for (let b = 0; b < this.pad.buttons.length; ++b) {
        const wasPressed = this.wasPressed[b];
        const pressed = this.pad.buttons[b].pressed;
        if (pressed !== wasPressed) {
          this.wasPressed[b] = pressed;
          this.dispatchEvent((pressed ? this.btnDownEvts : this.btnUpEvts)[b]);
        }
      }
      for (let a = 0; a < this.pad.axes.length; ++a) {
        const wasMaxed = this.wasAxisMaxed[a];
        const val = this.pad.axes[a];
        const dir = Math.sign(val);
        const mag = Math.abs(val);
        const maxed = mag >= this.axisThresholdMax;
        const mined = mag <= this.axisThresholdMin;
        const correctedVal = dir * (maxed ? 1 : mined ? 0 : mag);
        if (maxed && !wasMaxed) {
          this.axisMaxEvts[a].value = correctedVal;
          this.dispatchEvent(this.axisMaxEvts[a]);
        }
        this.wasAxisMaxed[a] = maxed;
        this.lastAxisValues[a] = correctedVal;
      }
      for (let a = 0; a < this.axes.length - 1; a += 2) {
        const stick = this.sticks[a / 2];
        stick.x = this.axes[a];
        stick.y = this.axes[a + 1];
      }
    }
  }
  get id() {
    if (!this.pad) {
      return null;
    }
    return this.pad.id;
  }
  get index() {
    if (!this.pad) {
      return null;
    }
    return this.pad.index;
  }
  get connected() {
    return this.pad && this.pad.connected;
  }
  get mapping() {
    if (!this.pad) {
      return null;
    }
    return this.pad.mapping;
  }
  get timestamp() {
    if (!this.pad) {
      return null;
    }
    return this.pad.timestamp;
  }
  get hand() {
    if (!this.pad) {
      return null;
    }
    return this.pad.hand;
  }
  get pose() {
    if (!this.pad) {
      return null;
    }
    return this.pad.pose;
  }
  get buttons() {
    if (!this.pad) {
      return null;
    }
    return this.pad.buttons;
  }
  get axes() {
    if (!this.pad) {
      return null;
    }
    return this.pad.axes;
  }
  get hapticActuators() {
    if (!this.pad) {
      return null;
    }
    return this.pad.hapticActuators;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/timers/SetIntervalTimer.ts
var SetIntervalTimer = class extends BaseTimer {
  constructor(targetFrameRate) {
    super(targetFrameRate);
  }
  start() {
    this.timer = setInterval(
      () => this.onTick(performance.now()),
      this.targetFrameTime
    );
  }
  stop() {
    if (this.timer) {
      clearInterval(this.timer);
      super.stop();
    }
  }
  get targetFPS() {
    return super.targetFPS;
  }
  set targetFPS(fps) {
    super.targetFPS = fps;
    if (this.isRunning) {
      this.restart();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/audio/ActivityDetector.ts
var ActivityEvent = class extends TypedEvent {
  constructor() {
    super("activity");
    this.level = 0;
  }
};
var ActivityDetector = class extends JuniperAnalyserNode {
  constructor(context) {
    super(context, {
      fftSize: 32,
      minDecibels: -70
    });
    this._level = 0;
    this.maxLevel = 0;
    this.activityEvt = new ActivityEvent();
    this.timer = new SetIntervalTimer(30);
    const buffer = new Uint8Array(this.frequencyBinCount);
    this.timer.addTickHandler(() => {
      this.getByteFrequencyData(buffer);
      this._level = Math.max(...buffer);
      if (isFinite(this._level)) {
        this.maxLevel = Math.max(this.maxLevel, this._level);
        if (this.maxLevel > 0) {
          this._level /= this.maxLevel;
        }
      }
      this.activityEvt.level = this.level;
      this.dispatchEvent(this.activityEvt);
    });
  }
  get level() {
    return this._level;
  }
  start() {
    this.timer.start();
  }
  stop() {
    this.timer.stop();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/setMatrixFromUpFwdPos.ts
var R = new Vector3();
function setMatrixFromUpFwdPos(U2, F, P2, matrix) {
  R.crossVectors(F, U2);
  U2.crossVectors(R, F);
  R.normalize();
  U2.normalize();
  F.normalize();
  matrix.set(
    R.x,
    U2.x,
    -F.x,
    P2.x,
    R.y,
    U2.y,
    -F.y,
    P2.y,
    R.z,
    U2.z,
    -F.z,
    P2.z,
    0,
    0,
    0,
    1
  );
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/cursors/BaseCursor.ts
var BaseCursor = class {
  constructor() {
    this._visible = true;
    this._style = "default";
  }
  get style() {
    return this._style;
  }
  set style(v) {
    this._style = v;
  }
  get visible() {
    return this._visible;
  }
  set visible(v) {
    this._visible = v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/cursors/BaseCursor3D.ts
var BaseCursor3D = class extends BaseCursor {
  constructor(env) {
    super();
    this.env = env;
    this._object = null;
    this.T = new Vector3();
    this.V = new Vector3();
    this.Q = new Quaternion();
    this._side = -1;
    this.f = new Vector3();
    this.up = new Vector3();
    this.right = new Vector3();
  }
  get side() {
    return this._side;
  }
  set side(v) {
    this._side = v;
  }
  get object() {
    return this._object;
  }
  set object(v) {
    this._object = v;
  }
  get position() {
    return this.object.position;
  }
  update(avatarHeadPos, comfortOffset, hit, target, defaultDistance, isLocal, canDragView, canTeleport, origin, direction, isPrimaryPressed) {
    if (hit && hit.face) {
      this.position.copy(hit.point);
      hit.object.getWorldQuaternion(this.Q);
      this.T.copy(hit.face.normal).applyQuaternion(this.Q);
      this.V.copy(this.T).multiplyScalar(0.02);
      this.position.add(this.V);
      this.V.copy(this.T).multiplyScalar(10).add(this.position);
    } else {
      if (isLocal) {
        this.position.copy(direction).multiplyScalar(2).add(origin).sub(this.env.avatar.worldPos).normalize().multiplyScalar(defaultDistance).add(this.env.avatar.worldPos);
      } else {
        this.V.copy(origin).add(comfortOffset).sub(avatarHeadPos).multiplyScalar(2);
        this.position.copy(direction).multiplyScalar(defaultDistance).add(this.V).add(this.env.avatar.worldPos);
      }
      this.V.copy(this.env.avatar.worldPos);
    }
    this.lookAt(this.position, this.V);
    this.style = !target || target.navigable && !canTeleport ? canDragView ? isPrimaryPressed ? "grabbing" : "grab" : "default" : !target.enabled ? "not-allowed" : target.draggable ? isPrimaryPressed ? "grabbing" : "move" : target.navigable ? "cell" : target.clickable ? "pointer" : "default";
  }
  lookAt(p, v) {
    this.f.copy(v).sub(p).normalize();
    this.up.set(0, 1, 0).applyQuaternion(this.env.avatar.worldQuat);
    this.right.crossVectors(this.up, this.f);
    this.up.crossVectors(this.f, this.right);
    setMatrixFromUpFwdPos(
      this.up,
      this.f,
      p,
      this.object.matrixWorld
    );
    this.object.matrix.copy(this.object.parent.matrixWorld).invert().multiply(this.object.matrixWorld);
    this.object.matrix.decompose(
      this.object.position,
      this.object.quaternion,
      this.object.scale
    );
    this.object.scale.x *= this.side;
    this.object.matrix.compose(
      this.object.position,
      this.object.quaternion,
      this.object.scale
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/cursors/CursorColor.ts
var CursorColor = class extends BaseCursor3D {
  constructor(env) {
    super(env);
    this.material = solid({
      name: "CursorMat",
      color: 16776960
    });
    this.object = new Cube(0.01, 0.01, 0.01, this.material);
  }
  get style() {
    return this._currentStyle;
  }
  set style(v) {
    this._currentStyle = v;
    if (isMesh(this.object) && !isArray(this.object.material)) {
      switch (this._currentStyle) {
        case "pointer":
          this.material.color = new Color(65280);
          this.material.needsUpdate = true;
          break;
        case "not-allowed":
          this.material.color = new Color(16711680);
          this.material.needsUpdate = true;
          break;
        case "move":
          this.material.color = new Color(255);
          this.material.needsUpdate = true;
          break;
        case "grab":
          this.material.color = new Color(16711935);
          this.material.needsUpdate = true;
          break;
        case "grabbing":
          this.material.color = new Color(65535);
          this.material.needsUpdate = true;
          break;
        default:
          this._currentStyle = "default";
          this.material.color = new Color(16776960);
          this.material.needsUpdate = true;
          break;
      }
    }
  }
  get visible() {
    return objectIsVisible(this);
  }
  set visible(v) {
    objectSetVisible(this, v);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector = new Vector3();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  constructor() {
    super();
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  applyMatrix4(matrix) {
    const start2 = this.attributes.instanceStart;
    const end2 = this.attributes.instanceEnd;
    if (start2 !== void 0) {
      start2.applyMatrix4(matrix);
      end2.applyMatrix4(matrix);
      start2.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  setPositions(array) {
    let lineSegments;
    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if (Array.isArray(array)) {
      lineSegments = new Float32Array(array);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  setColors(array) {
    let colors;
    if (array instanceof Float32Array) {
      colors = array;
    } else if (Array.isArray(array)) {
      colors = new Float32Array(array);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
    return this;
  }
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  fromMesh(mesh2) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh2.geometry));
    return this;
  }
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    if (geometry.isGeometry) {
      console.error("LineSegmentsGeometry no longer supports Geometry. Use BufferGeometry instead.");
      return;
    } else if (geometry.isBufferGeometry) {
      this.setPositions(geometry.attributes.position.array);
    }
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start2 = this.attributes.instanceStart;
    const end2 = this.attributes.instanceEnd;
    if (start2 !== void 0 && end2 !== void 0) {
      this.boundingBox.setFromBufferAttribute(start2);
      _box.setFromBufferAttribute(end2);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start2 = this.attributes.instanceStart;
    const end2 = this.attributes.instanceEnd;
    if (start2 !== void 0 && end2 !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = start2.count; i < il; i++) {
        _vector.fromBufferAttribute(start2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
        _vector.fromBufferAttribute(end2, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
  applyMatrix(matrix) {
    console.warn("LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().");
    return this.applyMatrix4(matrix);
  }
};
LineSegmentsGeometry.prototype.isLineSegmentsGeometry = true;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/lines/LineSegments2.js
var _start = new Vector3();
var _end = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint = new Vector3();
var _box2 = new Box3();
var _sphere = new Sphere();
var _clipToWorldVector = new Vector4();
function getWorldSpaceHalfWidth(camera, distance4, lineWidth, resolution) {
  _clipToWorldVector.set(0, 0, -distance4, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = lineWidth / resolution.width;
  _clipToWorldVector.y = lineWidth / resolution.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
var LineSegments2 = class extends Mesh {
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.type = "LineSegments2";
  }
  // for backwards-compatability, but could be a method of LineSegmentsGeometry...
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
      _start.fromBufferAttribute(instanceStart, i);
      _end.fromBufferAttribute(instanceEnd, i);
      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
  raycast(raycaster, intersects) {
    if (raycaster.camera === null) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
    }
    const threshold = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    const ray = raycaster.ray;
    const camera = raycaster.camera;
    const projectionMatrix = camera.projectionMatrix;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    const resolution = material.resolution;
    const lineWidth = material.linewidth + threshold;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const near = -camera.near;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(ray.origin));
    const sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, lineWidth, resolution);
    _sphere.radius += sphereMargin;
    if (raycaster.ray.intersectsSphere(_sphere) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(ray.origin));
    const boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, lineWidth, resolution);
    _box2.max.x += boxMargin;
    _box2.max.y += boxMargin;
    _box2.max.z += boxMargin;
    _box2.min.x -= boxMargin;
    _box2.min.y -= boxMargin;
    _box2.min.z -= boxMargin;
    if (raycaster.ray.intersectsBox(_box2) === false) {
      return;
    }
    ray.at(1, _ssOrigin);
    _ssOrigin.w = 1;
    _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
    _ssOrigin.applyMatrix4(projectionMatrix);
    _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
    _ssOrigin.x *= resolution.x / 2;
    _ssOrigin.y *= resolution.y / 2;
    _ssOrigin.z = 0;
    _ssOrigin3.copy(_ssOrigin);
    _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
    for (let i = 0, l = instanceStart.count; i < l; i++) {
      _start4.fromBufferAttribute(instanceStart, i);
      _end4.fromBufferAttribute(instanceEnd, i);
      _start4.w = 1;
      _end4.w = 1;
      _start4.applyMatrix4(_mvMatrix);
      _end4.applyMatrix4(_mvMatrix);
      var isBehindCameraNear = _start4.z > near && _end4.z > near;
      if (isBehindCameraNear) {
        continue;
      }
      if (_start4.z > near) {
        const deltaDist = _start4.z - _end4.z;
        const t2 = (_start4.z - near) / deltaDist;
        _start4.lerp(_end4, t2);
      } else if (_end4.z > near) {
        const deltaDist = _end4.z - _start4.z;
        const t2 = (_end4.z - near) / deltaDist;
        _end4.lerp(_start4, t2);
      }
      _start4.applyMatrix4(projectionMatrix);
      _end4.applyMatrix4(projectionMatrix);
      _start4.multiplyScalar(1 / _start4.w);
      _end4.multiplyScalar(1 / _end4.w);
      _start4.x *= resolution.x / 2;
      _start4.y *= resolution.y / 2;
      _end4.x *= resolution.x / 2;
      _end4.y *= resolution.y / 2;
      _line.start.copy(_start4);
      _line.start.z = 0;
      _line.end.copy(_end4);
      _line.end.z = 0;
      const param = _line.closestPointToPointParameter(_ssOrigin3, true);
      _line.at(param, _closestPoint);
      const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
      const isInClipSpace = zPos >= -1 && zPos <= 1;
      const isInside = _ssOrigin3.distanceTo(_closestPoint) < lineWidth * 0.5;
      if (isInClipSpace && isInside) {
        _line.start.fromBufferAttribute(instanceStart, i);
        _line.end.fromBufferAttribute(instanceEnd, i);
        _line.start.applyMatrix4(matrixWorld);
        _line.end.applyMatrix4(matrixWorld);
        const pointOnLine = new Vector3();
        const point = new Vector3();
        ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);
        intersects.push({
          point,
          pointOnLine,
          distance: ray.origin.distanceTo(point),
          object: this,
          face: null,
          faceIndex: i,
          uv: null,
          uv2: null
        });
      }
    }
  }
};
LineSegments2.prototype.isLineSegments2 = true;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  constructor() {
    super();
    this.type = "LineGeometry";
  }
  setPositions(array) {
    var length8 = array.length - 3;
    var points = new Float32Array(2 * length8);
    for (var i = 0; i < length8; i += 3) {
      points[2 * i] = array[i];
      points[2 * i + 1] = array[i + 1];
      points[2 * i + 2] = array[i + 2];
      points[2 * i + 3] = array[i + 3];
      points[2 * i + 4] = array[i + 4];
      points[2 * i + 5] = array[i + 5];
    }
    super.setPositions(points);
    return this;
  }
  setColors(array) {
    var length8 = array.length - 3;
    var colors = new Float32Array(2 * length8);
    for (var i = 0; i < length8; i += 3) {
      colors[2 * i] = array[i];
      colors[2 * i + 1] = array[i + 1];
      colors[2 * i + 2] = array[i + 2];
      colors[2 * i + 3] = array[i + 3];
      colors[2 * i + 4] = array[i + 4];
      colors[2 * i + 5] = array[i + 5];
    }
    super.setColors(colors);
    return this;
  }
  fromLine(line) {
    var geometry = line.geometry;
    if (geometry.isGeometry) {
      console.error("LineGeometry no longer supports Geometry. Use BufferGeometry instead.");
      return;
    } else if (geometry.isBufferGeometry) {
      this.setPositions(geometry.attributes.position.array);
    }
    return this;
  }
};
LineGeometry.prototype.isLineGeometry = true;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/lines/Line2.js
var Line2 = class extends LineSegments2 {
  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.type = "Line2";
  }
};
Line2.prototype.isLine2 = true;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/Laser.ts
var geom3 = new LineGeometry();
geom3.setPositions([
  0,
  0,
  0,
  0,
  0,
  -1
]);
var Laser = class extends Object3D {
  constructor(color2, opacity2, linewidth) {
    super();
    this._length = 1;
    this.line = new Line2(geom3, line2({
      color: color2,
      transparent: opacity2 < 1,
      opacity: opacity2,
      linewidth
    }));
    this.line.computeLineDistances();
    objGraph(this, this.line);
  }
  get length() {
    return this._length;
  }
  set length(v) {
    this._length = v;
    this.line.scale.set(1, 1, v);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/Pointers.ts
var PointerID = /* @__PURE__ */ ((PointerID2) => {
  PointerID2[PointerID2["LocalUser"] = 0] = "LocalUser";
  PointerID2[PointerID2["Mouse"] = 1] = "Mouse";
  PointerID2[PointerID2["Pen"] = 2] = "Pen";
  PointerID2[PointerID2["Touch"] = 3] = "Touch";
  PointerID2[PointerID2["Gamepad"] = 4] = "Gamepad";
  PointerID2[PointerID2["MotionController"] = 5] = "MotionController";
  PointerID2[PointerID2["MotionControllerLeft"] = 6] = "MotionControllerLeft";
  PointerID2[PointerID2["MotionControllerRight"] = 7] = "MotionControllerRight";
  PointerID2[PointerID2["Nose"] = 8] = "Nose";
  PointerID2[PointerID2["RemoteUser"] = 9] = "RemoteUser";
  return PointerID2;
})(PointerID || {});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/cursors/CursorSystem.ts
var CursorSystem = class extends BaseCursor {
  constructor(element) {
    super();
    this.element = element;
    this._hidden = false;
    this.visible = true;
    this.style = "default";
    document.addEventListener("pointerlockchange", () => {
      this._hidden = !!document.pointerLockElement;
      this.refresh();
    });
  }
  get style() {
    return super.style;
  }
  set style(v) {
    super.style = v;
    this.refresh();
  }
  get visible() {
    return super.visible && !this._hidden;
  }
  set visible(v) {
    super.visible = v;
    this.refresh();
  }
  refresh() {
    this.element.style.cursor = this.visible ? this.style : "none";
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/cursors/CursorXRMouse.ts
var CursorXRMouse = class extends BaseCursor3D {
  constructor(env) {
    super(env);
    this.xr = env.cursor3D && env.cursor3D.clone() || new CursorColor(this.env);
    this.system = new CursorSystem(this.env.renderer.domElement);
    this.xr.side = this.side;
    this.visible = false;
    Object.seal(this);
  }
  get object() {
    return this.xr.object;
  }
  get side() {
    return this.xr.side;
  }
  set side(v) {
    this.xr.side = v;
  }
  get cursor() {
    return this.xr;
  }
  set cursor(v) {
    this.xr = v;
    this._refresh();
  }
  get style() {
    return this.system.style;
  }
  get visible() {
    return super.visible;
  }
  set visible(v) {
    super.visible = v;
    this._refresh();
  }
  set style(v) {
    this.system.style = v;
    this.xr.style = v;
    this._refresh();
  }
  _refresh() {
    const isPointerLocked = this.env.eventSys && this.env.eventSys.mouse && this.env.eventSys.mouse.isPointerLocked;
    const showXR = this.env.renderer.xr.isPresenting || isPointerLocked;
    objectSetVisible(this.xr, this.visible && showXR);
    this.system.visible = this.visible && !showXR;
  }
  lookAt(p, v) {
    this.xr.lookAt(p, v);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/Pointer3DEvent.ts
var Pointer3DEvent = class extends TypedEvent {
  constructor(type2, pointer) {
    super(type2);
    this.pointer = pointer;
    this._hit = null;
    this._point = null;
    this._distance = Number.POSITIVE_INFINITY;
    this._rayTarget = null;
    Object.seal(this);
  }
  set(v, t2) {
    if (v !== this.hit) {
      this._hit = v;
      if (v) {
        this._point = v.point;
        this._distance = v.distance;
      } else {
        this._point = null;
        this._distance = Number.POSITIVE_INFINITY;
      }
    }
    this._rayTarget = t2;
  }
  get hit() {
    return this._hit;
  }
  get rayTarget() {
    return this._rayTarget;
  }
  get point() {
    return this._point;
  }
  get distance() {
    return this._distance;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/BasePointer.ts
var MAX_DRAG_DISTANCE = 5;
var ZERO = new Vector3();
var BasePointer = class extends TypedEventBase {
  constructor(type2, id2, env, cursor2) {
    super();
    this.type = type2;
    this.id = id2;
    this.env = env;
    this.origin = new Vector3();
    this.direction = new Vector3();
    this.up = new Vector3(0, 1, 0);
    this.canMoveView = false;
    this.mayTeleport = false;
    this.buttons = 0;
    this._isActive = false;
    this.moveDistance = 0;
    this.pointerEvents = /* @__PURE__ */ new Map();
    this.lastButtons = 0;
    this.canClick = false;
    this.dragDistance = 0;
    this._enabled = false;
    this._cursor = null;
    this._curHit = null;
    this._curTarget = null;
    this._hoveredHit = null;
    this._hoveredTarget = null;
    this._cursor = cursor2;
    if (this.cursor) {
      this.cursor.visible = false;
    }
  }
  get isActive() {
    return this._isActive;
  }
  get canSend() {
    return this.enabled && this.isActive;
  }
  get curHit() {
    return this._curHit;
  }
  get curTarget() {
    return this._curTarget;
  }
  get hoveredHit() {
    return this._hoveredHit;
  }
  set hoveredHit(v) {
    if (v !== this.hoveredHit) {
      const t2 = getRayTarget(v);
      this._hoveredHit = v;
      this._hoveredTarget = t2;
    }
  }
  get name() {
    return PointerID[this.id];
  }
  get rayTarget() {
    return this._hoveredTarget;
  }
  get cursor() {
    return this._cursor;
  }
  set cursor(newCursor) {
    if (newCursor !== this.cursor) {
      const oldCursor = this.cursor;
      const oldName = this.cursor && this.cursor.object && this.cursor.object.name || "cursor";
      const oldParent = oldCursor && oldCursor.object && oldCursor.object.parent;
      if (oldParent) {
        oldCursor.object.removeFromParent();
      }
      if (newCursor) {
        newCursor.object.name = oldName;
        if (oldCursor instanceof CursorXRMouse) {
          oldCursor.cursor = newCursor;
          if (oldParent) {
            objGraph(oldParent, oldCursor);
          }
        } else {
          this._cursor = newCursor;
          if (oldCursor) {
            if (oldParent) {
              objGraph(oldParent, newCursor);
            }
            newCursor.style = oldCursor.style;
            newCursor.visible = oldCursor.visible;
          }
        }
      }
    }
  }
  get needsUpdate() {
    return this.enabled && this._isActive;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(v) {
    this._enabled = v;
    if (this.cursor) {
      this.cursor.visible = v;
    }
  }
  setButton(button, pressed) {
    this.lastButtons = this.buttons;
    const mask = 1 << button;
    if (pressed) {
      this.buttons |= mask;
    } else {
      this.buttons &= ~mask;
    }
    if (pressed) {
      this.canClick = true;
      this.dragDistance = 0;
      this.env.avatar.setMode(this);
      this.setEventState("down");
    } else {
      if (this.canClick) {
        const curButtons = this.buttons;
        this.buttons = this.lastButtons;
        this.setEventState("click");
        this.buttons = curButtons;
      }
      this.setEventState("up");
    }
  }
  isPressed(button) {
    const mask = 1 << button;
    return (this.buttons & mask) !== 0;
  }
  wasPressed(button) {
    const mask = 1 << button;
    return (this.lastButtons & mask) !== 0;
  }
  fireRay(origin, direction) {
    const minHit = this.env.eventSys.fireRay(origin, direction);
    if (minHit !== this.curHit) {
      const t2 = getRayTarget(minHit);
      this._curHit = minHit;
      this._curTarget = t2;
    }
  }
  getEvent(type2) {
    if (!this.pointerEvents.has(type2)) {
      this.pointerEvents.set(type2, new Pointer3DEvent(type2, this));
    }
    const evt = this.pointerEvents.get(type2);
    if (this.hoveredHit) {
      evt.set(this.hoveredHit, this.rayTarget);
    } else if (this.curHit) {
      evt.set(this.curHit, this.curTarget);
    } else {
      evt.set(null, null);
    }
    if (evt.hit) {
      const lastHit = this.curHit || this.hoveredHit;
      if (lastHit && evt.hit !== lastHit) {
        evt.hit.uv = lastHit.uv;
      }
    }
    return evt;
  }
  update() {
    if (this.needsUpdate) {
      this.onUpdate();
    }
  }
  onUpdate() {
    this.updatePointerOrientation();
    const primaryPressed = this.isPressed(0 /* Primary */);
    if (this.moveDistance > 0 || primaryPressed) {
      if (primaryPressed) {
        this.dragDistance += this.moveDistance;
        if (this.dragDistance > MAX_DRAG_DISTANCE) {
          this.canClick = false;
        }
      }
      this.setEventState("move");
    }
    this.moveDistance = 0;
  }
  setEventState(eventType) {
    this.fireRay(this.origin, this.direction);
    if (this.curTarget === this.rayTarget) {
      this.hoveredHit = this.curHit;
    } else {
      const isPressed = this.isPressed(0 /* Primary */);
      const wasPressed = this.wasPressed(0 /* Primary */);
      const openMove = eventType === "move" && !isPressed;
      const primaryDown = eventType === "down" && isPressed && !wasPressed;
      const primaryUp = eventType === "up" && !isPressed && wasPressed;
      if (openMove || primaryDown || primaryUp) {
        if (this.rayTarget) {
          const upEvt = this.getEvent("up");
          this.rayTarget.dispatchEvent(upEvt);
          const exitEvt = this.getEvent("exit");
          this.dispatchEvent(exitEvt);
          this.rayTarget.dispatchEvent(exitEvt);
        }
        this.hoveredHit = this.curHit;
        if (this.rayTarget) {
          const enterEvt = this.getEvent("enter");
          this.dispatchEvent(enterEvt);
          this.rayTarget.dispatchEvent(enterEvt);
        }
      }
      if (this.hoveredHit) {
        this.hoveredHit.point.copy(this.direction).multiplyScalar(this.hoveredHit.distance).add(this.origin);
      }
    }
    const evt = this.getEvent(eventType);
    this.dispatchEvent(evt);
    if (evt.rayTarget && (eventType !== "click" || evt.rayTarget.clickable || evt.rayTarget.navigable)) {
      if (eventType === "click" && evt.rayTarget.clickable) {
        this.vibrate();
      }
      if (evt.rayTarget.enabled) {
        evt.rayTarget.dispatchEvent(evt);
      }
    }
    this.updateCursor(this.env.avatar.worldPos, ZERO, true, 2);
  }
  get canDragView() {
    return this.canMoveView;
  }
  get canTeleport() {
    return this.mayTeleport;
  }
  updateCursor(avatarHeadPos, comfortOffset, isLocal, defaultDistance) {
    if (this.cursor) {
      this.cursor.update(
        avatarHeadPos,
        comfortOffset,
        this.hoveredHit || this.curHit,
        this.rayTarget || this.curTarget,
        defaultDistance,
        isLocal,
        this.canDragView,
        this.canTeleport,
        this.origin,
        this.direction,
        this.isPressed(0 /* Primary */)
      );
    }
  }
  get bufferSize() {
    return 37;
  }
  writeState(buffer) {
    buffer.writeUint8(this.id);
    buffer.writeVector48(this.origin);
    buffer.writeVector48(this.direction);
    buffer.writeVector48(this.up);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/PointerRemote.ts
var ARM_LENGTH = 0.2;
var ARM_DIST = 0.5 * ARM_LENGTH - 0.025;

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/AvatarRemote.ts
var nameTagFont = {
  fontFamily: getMonospaceFonts(),
  fontSize: 20,
  fontWeight: "bold",
  textFillColor: "white",
  textStrokeColor: "black",
  textStrokeSize: 0.01,
  padding: {
    top: 0.025,
    right: 0.05,
    bottom: 0.025,
    left: 0.05
  },
  maxHeight: 0.2
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/BaseTele.ts
var HANDEDNESSES = [
  "none",
  "right",
  "left"
];

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/loaders/BufferGeometryUtils.js
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  load(url2, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      resourcePath = this.path;
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url2);
    }
    this.manager.itemStart(url2);
    const _onError = function(e2) {
      if (onError) {
        onError(e2);
      } else {
        console.error(e2);
      }
      scope.manager.itemError(url2);
      scope.manager.itemEnd(url2);
    };
    const loader2 = new FileLoader(this.manager);
    loader2.setPath(this.path);
    loader2.setResponseType("arraybuffer");
    loader2.setRequestHeader(this.requestHeader);
    loader2.setWithCredentials(this.withCredentials);
    loader2.load(url2, function(data) {
      try {
        scope.parse(data, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url2);
        }, _onError);
      } catch (e2) {
        _onError(e2);
      }
    }, onProgress, _onError);
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  parse(data, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data === "string") {
      json = JSON.parse(data);
    } else if (data instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError)
            onError(error);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data));
      }
    } else {
      json = data;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser);
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  parseAsync(data, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency)
      return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color2 = new Color(16777215);
    if (lightDef.color !== void 0)
      color2.fromArray(lightDef.color);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color2);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color2);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color2);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0)
      lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type2, index) {
    if (type2 !== "light")
      return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0)
      return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale8 = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale8, scale8);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color(colorArray[0], colorArray[1], colorArray[2]);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader2 = parser.options.ktx2Loader;
    if (!loader2) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader2);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name3 = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name3]) {
      return null;
    }
    const extension = textureDef.extensions[name3];
    const source = json.images[extension.source];
    let loader2 = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader2);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name3) >= 0) {
        throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image2 = new Image();
        image2.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
        image2.onload = image2.onerror = function() {
          resolve(image2.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
    this.isSupported = null;
  }
  loadTexture(textureIndex) {
    const name3 = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name3]) {
      return null;
    }
    const extension = textureDef.extensions[name3];
    const source = json.images[extension.source];
    let loader2 = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.detectSupport().then(function(isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader2);
      if (json.extensionsRequired && json.extensionsRequired.indexOf(name3) >= 0) {
        throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
      }
      return parser.loadTexture(textureIndex);
    });
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function(resolve) {
        const image2 = new Image();
        image2.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=";
        image2.onload = image2.onerror = function() {
          resolve(image2.height === 1);
        };
      });
    }
    return this.isSupported;
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh2 of meshes) {
        const m = new Matrix4();
        const p = new Vector3();
        const q = new Quaternion();
        const s = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh2.geometry, mesh2.material, count);
        for (let i = 0; i < count; i++) {
          if (attributes.TRANSLATION) {
            p.fromBufferAttribute(attributes.TRANSLATION, i);
          }
          if (attributes.ROTATION) {
            q.fromBufferAttribute(attributes.ROTATION, i);
          }
          if (attributes.SCALE) {
            s.fromBufferAttribute(attributes.SCALE, i);
          }
          instancedMesh.setMatrixAt(i, m.compose(p, q, s));
        }
        for (const attributeName in attributes) {
          if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh2.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh2);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0)
              attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform2) {
    if ((transform2.texCoord === void 0 || transform2.texCoord === texture.channel) && transform2.offset === void 0 && transform2.rotation === void 0 && transform2.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform2.texCoord !== void 0) {
      texture.channel = transform2.texCoord;
    }
    if (transform2.offset !== void 0) {
      texture.offset.fromArray(transform2.offset);
    }
    if (transform2.rotation !== void 0) {
      texture.rotation = transform2.rotation;
    }
    if (transform2.scale !== void 0) {
      texture.repeat.fromArray(transform2.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p = (t2 - t0) / td;
    const pp = p * p;
    const ppp = pp * p;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p;
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride];
      const m0 = values[offset0 + i + stride2] * td;
      const p1 = values[offset1 + i + stride];
      const m1 = values[offset1 + i] * td;
      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _q = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _q.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name3 in objectDef.extensions) {
    if (knownExtensions[name3] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name3] = objectDef.extensions[name3];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (target.POSITION !== void 0)
      hasMorphPosition = true;
    if (target.NORMAL !== void 0)
      hasMorphNormal = true;
    if (target.COLOR_0 !== void 0)
      hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor)
      break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition)
      geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal)
      geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor)
      geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh2, meshDef) {
  mesh2.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh2.morphTargetInfluences[i] = meshDef.weights[i];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh2.morphTargetInfluences.length === targetNames.length) {
      mesh2.morphTargetDictionary = {};
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh2.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ":" + attributes[keys[i]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0)
    return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return "image/webp";
  return "image/png";
}
var _identityMatrix = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari2 = false;
    let isFirefox2 = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true;
      isFirefox2 = navigator.userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox2 ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari2 || isFirefox2 && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   */
  _addNodeRef(cache, index) {
    if (index === void 0)
      return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /** Returns a reference to a shared resource, cloning it if necessary. */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1)
      return object;
    const ref = object.clone();
    const updateMappings = (original, clone9) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone9, mappings);
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone9.children[i]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i = 0; i < extensions.length; i++) {
      const result = func(extensions[i]);
      if (result)
        pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type2, index) {
    const cacheKey = type2 + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type2) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type2, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type2);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type2) {
    let dependencies = this.cache.get(type2);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type2 + (type2 === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type2, index);
      }));
      this.cache.add(type2, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader2 = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader2.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5)
            throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture|null>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader2 = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null)
        loader2 = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader2);
  }
  loadTextureImage(textureIndex, sourceIndex, loader2) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader2).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader2) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader2.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader2.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture)
        return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform2 = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform2) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform2);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh2) {
    const geometry = mesh2.geometry;
    let material = mesh2.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh2.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh2.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents)
        cacheKey += "derivative-tangents:";
      if (useVertexColors)
        cacheKey += "vertex-colors:";
      if (useFlatShading)
        cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors)
          cachedMaterial.vertexColors = true;
        if (useFlatShading)
          cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale)
            cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh2.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale8 = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale8, scale8);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name)
        material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /** When Object3D instances are targeted by animation, they need unique names. */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials2 = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i];
        const primitive = primitives[i];
        let mesh2;
        const material = materials2[i];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh2 = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh2.isSkinnedMesh === true) {
            mesh2.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh2.geometry = toTrianglesDrawMode(mesh2.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh2.geometry = toTrianglesDrawMode(mesh2.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh2 = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh2 = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh2 = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh2 = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh2.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh2, meshDef);
        }
        mesh2.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh2, meshDef);
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh2, primitive);
        parser.assignFinalMaterial(mesh2);
        meshes.push(mesh2);
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions)
          addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group2 = new Group();
      if (meshDef.extensions)
        addUnknownExtensionsToUserData(extensions, group2, meshDef);
      parser.associations.set(group2, { meshes: meshIndex });
      for (let i = 0, il = meshes.length; i < il; i++) {
        group2.add(meshes[i]);
      }
      return group2;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name)
      camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i = 0, il = skinDef.joints.length; i < il; i++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i = 0, il = jointNodes.length; i < il; i++) {
        const jointNode = jointNodes[i];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name3 = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0)
        continue;
      pendingNodes.push(this.getDependency("node", name3));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i];
        const inputAccessor = inputAccessors[i];
        const outputAccessor = outputAccessors[i];
        const sampler = samplers[i];
        const target = targets[i];
        if (node === void 0)
          continue;
        node.updateMatrix();
        let TypedKeyframeTrack;
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        const targetName = node.name ? node.name : node.uuid;
        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        const targetNames = [];
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function(object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }
        let outputArray = outputAccessor.array;
        if (outputAccessor.normalized) {
          const scale8 = getNormalizedComponentScale(outputArray.constructor);
          const scaled = new Float32Array(outputArray.length);
          for (let j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale8;
          }
          outputArray = scaled;
        }
        for (let j = 0, jl = targetNames.length; j < jl; j++) {
          const track = new TypedKeyframeTrack(
            targetNames[j] + "." + PATH_PROPERTIES[target.path],
            inputAccessor.array,
            outputArray,
            interpolation
          );
          if (sampler.interpolation === "CUBICSPLINE") {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
              return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
            };
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }
          tracks.push(track);
        }
      }
      return new AnimationClip(animationName, void 0, tracks);
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0)
      return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh2) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh2);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o) {
          if (!o.isMesh)
            return;
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i = 0, il = childrenDef.length; i < il; i++) {
      childPending.push(parser.getDependency("node", childrenDef[i]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh2) {
          if (!mesh2.isSkinnedMesh)
            return;
          mesh2.bind(skeleton, _identityMatrix);
        });
      }
      for (let i = 0, il = children.length; i < il; i++) {
        node.add(children[i]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name)
      scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(parser.getDependency("node", nodeIds[i]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i = 0, il = nodes.length; i < il; i++) {
        scene.add(nodes[i]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value2] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value2);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min5 = accessor.min;
    const max5 = accessor.max;
    if (min5 !== void 0 && max5 !== void 0) {
      box.set(
        new Vector3(min5[0], min5[1], min5[2]),
        new Vector3(max5[0], max5[1], max5[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min5 = accessor.min;
        const max5 = accessor.max;
        if (min5 !== void 0 && max5 !== void 0) {
          vector.setX(Math.max(Math.abs(min5[0]), Math.abs(max5[0])));
          vector.setY(Math.max(Math.abs(min5[1]), Math.abs(max5[1])));
          vector.setZ(Math.max(Math.abs(min5[2]), Math.abs(max5[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere2 = new Sphere();
  box.getCenter(sphere2.center);
  sphere2.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere2;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes)
      continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/webxr/motion-controllers.module.js
var Constants = {
  Handedness: Object.freeze({
    NONE: "none",
    LEFT: "left",
    RIGHT: "right"
  }),
  ComponentState: Object.freeze({
    DEFAULT: "default",
    TOUCHED: "touched",
    PRESSED: "pressed"
  }),
  ComponentProperty: Object.freeze({
    BUTTON: "button",
    X_AXIS: "xAxis",
    Y_AXIS: "yAxis",
    STATE: "state"
  }),
  ComponentType: Object.freeze({
    TRIGGER: "trigger",
    SQUEEZE: "squeeze",
    TOUCHPAD: "touchpad",
    THUMBSTICK: "thumbstick",
    BUTTON: "button"
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: "transform",
    VISIBILITY: "visibility"
  })
};
async function fetchJsonFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const profileListFileName = "profilesList.json";
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile = null, getAssetPath = true) {
  if (!xrInputSource) {
    throw new Error("No xrInputSource supplied");
  }
  if (!basePath) {
    throw new Error("No basePath supplied");
  }
  const supportedProfilesList = await fetchProfilesList(basePath);
  let match;
  xrInputSource.profiles.some((profileId) => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error("No matching profile name found");
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === "any") {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(
        `No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`
      );
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace("profile.json", layout.assetPath);
    }
  }
  return { profile, assetPath };
}
var defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};
function normalizeAxes(x = 0, y = 0) {
  let xAxis = x;
  let yAxis = y;
  const hypotenuse = Math.sqrt(x * x + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  }
  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}
var VisualResponse = class {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    }
    this.value = 0;
    this.updateFromComponent(defaultComponentValues);
  }
  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent({
    xAxis,
    yAxis,
    button,
    state
  }) {
    const { normalizedXAxis, normalizedYAxis } = normalizeAxes(xAxis, yAxis);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;
      case Constants.ComponentProperty.STATE:
        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1 : 0;
        }
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
};
var Component = class {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error("Invalid arguments supplied");
    }
    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName;
    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach((responseName) => {
      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    });
    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== void 0 ? 0 : void 0,
      xAxis: this.gamepadIndices.xAxis !== void 0 ? 0 : void 0,
      yAxis: this.gamepadIndices.yAxis !== void 0 ? 0 : void 0
    };
  }
  get data() {
    const data = { id: this.id, ...this.values };
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(gamepad) {
    this.values.state = Constants.ComponentState.DEFAULT;
    if (this.gamepadIndices.button !== void 0 && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button;
      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = Constants.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.xAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    if (this.gamepadIndices.yAxis !== void 0 && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    Object.values(this.visualResponses).forEach((visualResponse) => {
      visualResponse.updateFromComponent(this.values);
    });
  }
};
var MotionController = class {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error("No xrInputSource supplied");
    }
    if (!profile) {
      throw new Error("No profile supplied");
    }
    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId;
    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach((componentId) => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component(componentId, componentDescription);
    });
    this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }
  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const data = [];
    Object.values(this.components).forEach((component) => {
      data.push(component.data);
    });
    return data;
  }
  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach((component) => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/webxr/XRControllerModelFactory.ts
var DEFAULT_PROFILES_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles";
var DEFAULT_PROFILE = "generic-trigger";
var XRControllerModel = class extends Object3D {
  constructor() {
    super(...arguments);
    this.envMap = null;
    this.motionController = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    this.traverse((child) => {
      if (isMesh(child) && (isMeshStandardMaterial(child.material) || isMeshPhongMaterial(child.material) || isMeshPhysicalMaterial(child.material))) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }
  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController)
      return;
    this.motionController.updateFromGamepad();
    Object.values(this.motionController.components).forEach((component) => {
      Object.values(component.visualResponses).forEach((visualResponse) => {
        const { valueNode, minNode, maxNode } = visualResponse;
        if (!valueNode)
          return;
        if (isVisibility(visualResponse)) {
          valueNode.visible = visualResponse.value;
        } else if (isTransform(visualResponse)) {
          valueNode.quaternion.slerpQuaternions(
            minNode.quaternion,
            maxNode.quaternion,
            visualResponse.value
          );
          valueNode.position.lerpVectors(
            minNode.position,
            maxNode.position,
            visualResponse.value
          );
        }
      });
    });
  }
};
function isVisualResponse(visualResponse, type2) {
  return visualResponse && visualResponse.valueNodeProperty === type2;
}
function isVisibility(visualResponse) {
  return isVisualResponse(visualResponse, "visibility");
}
function isTransform(visualResponse) {
  return isVisualResponse(visualResponse, "transform");
}
function findNodes(motionController, scene) {
  Object.values(motionController.components).forEach((component) => {
    const { type: type2, touchPointNodeName, visualResponses } = component;
    if (type2 === Constants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        const sphereGeometry = new SphereGeometry(1e-3);
        const material = new MeshBasicMaterial({ color: 255 });
        const sphere2 = new Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere2);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    Object.values(visualResponses).forEach((visualResponse) => {
      const { valueNodeName, minNodeName, maxNodeName, valueNodeProperty } = visualResponse;
      if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  findNodes(controllerModel.motionController, scene);
  if (controllerModel.envMap) {
    scene.traverse((child) => {
      if (isMesh(child) && (isMeshStandardMaterial(child.material) || isMeshPhongMaterial(child.material) || isMeshPhysicalMaterial(child.material))) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  }
  controllerModel.add(scene);
}
var XRControllerModelFactory = class {
  constructor(gltfLoader = null) {
    this.gltfLoader = gltfLoader || new GLTFLoader();
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {};
  }
  createControllerModel(controller, profileName = null) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener("connected", async (event) => {
      const xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== "tracked-pointer" || !xrInputSource.gamepad)
        return;
      try {
        const { profile, assetPath } = await fetchProfile(xrInputSource, this.path, profileName || DEFAULT_PROFILE);
        controllerModel.motionController = new MotionController(
          xrInputSource,
          profile,
          assetPath
        );
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];
        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error("GLTFLoader not set.");
          }
          this.gltfLoader.setPath("");
          this.gltfLoader.load(
            controllerModel.motionController.assetUrl,
            (asset) => {
              this._assetCache[controllerModel.motionController.assetUrl] = asset;
              scene = asset.scene.clone();
              addAssetSceneToControllerModel(controllerModel, scene);
            },
            null,
            () => {
              throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
            }
          );
        }
      } catch (err) {
        console.warn(err);
      }
    });
    controller.addEventListener("disconnected", () => {
      cleanup(controllerModel.motionController);
      controllerModel.motionController = null;
      cleanup(scene);
      scene = null;
    });
    return controllerModel;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/PointerHand.ts
var mcModelFactory = new XRControllerModelFactory();
var riftSCorrection = new Matrix4().makeRotationX(-7 * Pi / 9);
var M2 = new Matrix4();
var pointerIDs = /* @__PURE__ */ new Map([
  ["none", 5 /* MotionController */],
  ["left", 6 /* MotionControllerLeft */],
  ["right", 7 /* MotionControllerRight */]
]);
var questToVirtualMap = /* @__PURE__ */ new Map([
  //[OculusQuestButton.Trigger, VirtualButton.Primary],
  //[OculusQuestButton.Grip, VirtualButton.Secondary],
  [5 /* Y_B */, 2 /* Menu */],
  [4 /* X_A */, 3 /* Info */]
]);
var PointerHand = class extends BasePointer {
  constructor(env, index) {
    super("hand", 5 /* MotionController */, env, new CursorColor(env));
    this.laser = new Laser(white, 0.75, 2e-3);
    this._isHand = false;
    this.inputSource = null;
    this._gamepad = new EventedGamepad();
    this.delta = new Vector3();
    this.newOrigin = new Vector3();
    this.quaternion = new Quaternion();
    this.newQuat = new Quaternion();
    this.useHaptics = true;
    this.mayTeleport = true;
    this.object = obj("PointerHand" + index);
    this.quaternion.identity();
    objGraph(
      this,
      objGraph(
        this.controller = this.env.renderer.xr.getController(index),
        this.laser
      ),
      objGraph(
        this.grip = this.env.renderer.xr.getControllerGrip(index),
        this.gripModel = mcModelFactory.createControllerModel(this.controller)
      ),
      objGraph(
        this.hand = this.env.renderer.xr.getHand(index),
        this.handModel = this.env.handModelFactory.createHandModel(this.hand)
      )
    );
    if (isDesktop() && isChrome() && !isOculusBrowser) {
      let maybeOculusRiftS = false;
      this.controller.traverse((child) => {
        const key = child.name.toLocaleLowerCase();
        if (key.indexOf("oculus") >= 0) {
          maybeOculusRiftS = true;
        }
      });
      if (maybeOculusRiftS) {
        this.laser.matrix.copy(riftSCorrection);
      }
    }
    this.gamepad.addEventListener("gamepadaxismaxed", (evt) => {
      if (evt.axis === 2) {
        this.env.avatar.snapTurn(evt.value);
      }
    });
    const setButton = (pressed) => {
      return (evt) => {
        if (questToVirtualMap.has(evt.button)) {
          this.setButton(questToVirtualMap.get(evt.button), pressed);
        }
      };
    };
    this.gamepad.addEventListener("gamepadbuttondown", setButton(true));
    this.gamepad.addEventListener("gamepadbuttonup", setButton(false));
    const setHandButton = (btn, pressed) => () => this.setButton(btn, pressed);
    this.controller.addEventListener("selectstart", setHandButton(0 /* Primary */, true));
    this.controller.addEventListener("selectend", setHandButton(0 /* Primary */, false));
    this.controller.addEventListener("squeezestart", setHandButton(1 /* Secondary */, true));
    this.controller.addEventListener("squeezeend", setHandButton(1 /* Secondary */, false));
    this.controller.addEventListener("connected", (evt) => {
      if (evt.target === this.controller) {
        this.inputSource = evt.data;
        this.gamepad.pad = this.inputSource.gamepad;
        this._isHand = isDefined(this.inputSource.hand);
        this.id = pointerIDs.get(this.handedness);
        this.grip.visible = !this.isHand;
        this.controller.visible = !this.isHand;
        this.hand.visible = this.isHand;
        this.enabled = true;
        this._isActive = true;
        this.env.eventSys.checkXRMouse();
        this.updateCursorSide();
      }
    });
    this.controller.addEventListener("disconnected", (evt) => {
      if (evt.target === this.controller) {
        this.inputSource = null;
        this.gamepad.pad = null;
        this._isHand = false;
        this.id = pointerIDs.get(this.handedness);
        this.grip.visible = false;
        this.controller.visible = false;
        this.hand.visible = false;
        this.enabled = false;
        this._isActive = false;
        this.env.eventSys.checkXRMouse();
        this.updateCursorSide();
      }
    });
    Object.seal(this);
  }
  vibrate() {
    this._vibrate();
  }
  async _vibrate() {
    if (this.useHaptics && this.gamepad.hapticActuators) {
      try {
        await Promise.all(this.gamepad.hapticActuators.map((actuator) => actuator.pulse(0.25, 125)));
      } catch {
        this.useHaptics = false;
      }
    }
  }
  get gamepad() {
    return this._gamepad;
  }
  get handedness() {
    if (isNullOrUndefined(this.inputSource)) {
      return null;
    }
    return this.inputSource.handedness;
  }
  get isHand() {
    return this._isHand;
  }
  get cursor() {
    return super.cursor;
  }
  set cursor(v) {
    super.cursor = v;
    this.updateCursorSide();
  }
  updateCursorSide() {
    this.cursor.side = this.handedness === "left" ? 1 : -1;
  }
  updatePointerOrientation() {
    this.laser.getWorldPosition(this.newOrigin);
    this.laser.getWorldQuaternion(this.newQuat);
    this.origin.lerp(this.newOrigin, 0.9);
    this.quaternion.slerp(this.newQuat, 0.9);
    this.delta.copy(this.origin).add(this.direction);
    this.direction.set(0, 0, -1).applyQuaternion(this.quaternion);
    this.up.set(0, 1, 0).applyQuaternion(this.quaternion);
    this.delta.sub(this.direction).sub(this.origin);
    this.moveDistance += 50 * this.delta.length();
  }
  onUpdate() {
    this.gamepad.pad = this.inputSource && this.inputSource.gamepad || null;
    super.onUpdate();
  }
  get bufferSize() {
    return super.bufferSize + 2 + this.handModel.count * 64;
  }
  writeState(buffer) {
    super.writeState(buffer);
    buffer.writeEnum8(this.handedness, HANDEDNESSES);
    buffer.writeUint8(this.handModel.count);
    if (this.handModel.isTracking) {
      for (let n2 = 0; n2 < this.handModel.count; ++n2) {
        this.handModel.getMatrixAt(n2, M2);
        buffer.writeMatrix512(M2);
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/BaseScreenPointer.ts
var BaseScreenPointer = class extends BasePointer {
  constructor(type2, id2, env, cursor2) {
    super(type2, id2, env, cursor2);
    this.position = new Vector2();
    this.motion = new Vector2();
    this.uv = new Vector2();
    this.duv = new Vector2();
    this.uvComp = new Vector2(1, -1);
    this.uvOff = new Vector2(-1, 1);
    this.canMoveView = true;
    const onPointerEvent = (evt) => {
      this._isActive = this.onCheckEvent(evt);
      if (this._isActive) {
        this.onReadEvent(evt);
      }
    };
    this.element = this.env.renderer.domElement;
    this.element.addEventListener("pointerdown", onPointerEvent);
    this.element.addEventListener("pointermove", onPointerEvent);
    this.element.addEventListener("pointerup", onPointerEvent);
    this.element.addEventListener("pointercancel", onPointerEvent);
  }
  onCheckEvent(evt) {
    return evt.pointerType === this.type;
  }
  onReadEvent(_evt) {
    this.updatePointerOrientation();
  }
  updatePointerOrientation() {
    if (this.element.clientWidth > 0 && this.element.clientHeight > 0) {
      this.uv.copy(this.position);
      this.uv.x /= this.element.clientWidth;
      this.uv.y /= this.element.clientHeight;
      this.uv.multiplyScalar(2).multiply(this.uvComp).add(this.uvOff);
      this.duv.copy(this.motion);
      this.duv.x /= this.element.clientWidth;
      this.duv.y /= this.element.clientHeight;
      this.duv.multiplyScalar(2).multiply(this.uvComp);
      this.moveDistance = 200 * this.duv.length();
    }
    const cam = resolveCamera(this.env.renderer, this.env.camera);
    this.origin.setFromMatrixPosition(cam.matrixWorld);
    this.direction.set(this.uv.x, this.uv.y, 0.5).unproject(cam).sub(this.origin).normalize();
    this.up.set(0, 1, 0).applyQuaternion(this.env.avatar.worldQuat);
  }
  onUpdate() {
    this.env.avatar.onMove(this, this.uv, this.duv);
    super.onUpdate();
    this.motion.setScalar(0);
    this.duv.setScalar(0);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/BaseScreenPointerSinglePoint.ts
var BaseScreenPointerSinglePoint = class extends BaseScreenPointer {
  constructor(type2, id2, env) {
    const onPrep = (evt) => {
      if (evt.pointerType === type2 && this.pointerID == null) {
        this.pointerID = evt.pointerId;
      }
    };
    const unPrep = (evt) => {
      if (evt.pointerType === type2 && this.pointerID != null) {
        this.pointerID = null;
      }
    };
    const element = env.renderer.domElement;
    element.addEventListener("pointerdown", onPrep);
    element.addEventListener("pointermove", onPrep);
    super(type2, id2, env, new CursorXRMouse(env));
    this.pointerID = null;
    this.lastX = null;
    this.lastY = null;
    element.addEventListener("pointerup", unPrep);
    element.addEventListener("pointercancel", unPrep);
  }
  onCheckEvent(evt) {
    return super.onCheckEvent(evt) && evt.pointerId === this.pointerID;
  }
  onReadEvent(evt) {
    this.position.set(evt.offsetX, evt.offsetY);
    if (evt.type === "pointerdown") {
      this.motion.setScalar(0);
    } else {
      this.motion.x += evt.offsetX - this.lastX;
      this.motion.y += evt.offsetY - this.lastY;
    }
    this.lastX = evt.offsetX;
    this.lastY = evt.offsetY;
    super.onReadEvent(evt);
    if (evt.type === "pointerdown" || evt.type === "pointerup" || evt.type === "pointercancel") {
      this.setButton(evt.button, evt.type === "pointerdown");
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/PointerMouse.ts
var PointerMouse = class extends BaseScreenPointerSinglePoint {
  constructor(env) {
    super("mouse", 1 /* Mouse */, env);
    this.allowPointerLock = false;
    this.dz = 0;
    this.keyMap = /* @__PURE__ */ new Map([
      ["`", 3 /* Info */],
      ["ContextMenu", 2 /* Menu */]
    ]);
    this.element.addEventListener("wheel", (evt) => {
      evt.preventDefault();
      this.dz += -evt.deltaY * 0.1;
    }, { passive: false });
    this.element.addEventListener("contextmenu", (evt) => {
      evt.preventDefault();
    });
    this.element.addEventListener("pointerdown", (evt) => {
      if (this.onCheckEvent(evt)) {
        if (this.allowPointerLock && !this.isPointerLocked) {
          this.lockPointer();
        } else if (!this.allowPointerLock && !this.isPointerCaptured) {
          this.capturePointer();
        }
      }
    });
    this.element.addEventListener("pointerup", (evt) => {
      if (this.onCheckEvent(evt)) {
        if (this.allowPointerLock && this.isPointerLocked) {
          this.unlockPointer();
        } else if (!this.allowPointerLock && this.isPointerCaptured) {
          this.releaseCapture();
        }
      }
    }, true);
    document.addEventListener("pointerlockchange", () => {
      this.cursor.visible = true;
    });
    window.addEventListener("keydown", (evt) => {
      if (this._isActive && this.keyMap.has(evt.key)) {
        this.setButton(this.keyMap.get(evt.key), isModifierless(evt));
      }
    });
    window.addEventListener("keyup", (evt) => {
      if (this.keyMap.has(evt.key)) {
        this.setButton(this.keyMap.get(evt.key), false);
      }
    });
    this.mayTeleport = true;
    Object.seal(this);
  }
  updatePointerOrientation() {
    if (this.isPointerLocked) {
      this.position.set(
        this.env.renderer.domElement.clientWidth,
        this.env.renderer.domElement.clientHeight
      ).multiplyScalar(0.5);
    }
    super.updatePointerOrientation();
  }
  onUpdate() {
    super.onUpdate();
    this.env.avatar.zoom(this.dz);
    this.dz = 0;
  }
  get isPointerLocked() {
    return document.pointerLockElement != null;
  }
  get isPointerCaptured() {
    return this.element.hasPointerCapture(this.pointerID);
  }
  get canDragView() {
    return super.canDragView && !this.isPointerLocked;
  }
  get canTeleport() {
    return super.canTeleport && this.isPointerLocked;
  }
  lockPointer() {
    this.element.requestPointerLock();
  }
  unlockPointer() {
    document.exitPointerLock();
  }
  capturePointer() {
    this.element.setPointerCapture(this.pointerID);
  }
  releaseCapture() {
    this.element.releasePointerCapture(this.pointerID);
  }
  vibrate() {
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/PointerNose.ts
var PointerNose = class extends BasePointer {
  constructor(env) {
    super("nose", 8 /* Nose */, env, null);
    this.point = new Vector3();
    this.lastPoint = new Vector3();
    this.mayTeleport = false;
    this.enabled = true;
    this._isActive = true;
    this.updatePointerOrientation();
    this.moveDistance = 0;
    Object.seal(this);
  }
  vibrate() {
  }
  get canSend() {
    return false;
  }
  updatePointerOrientation() {
    const camera = this.env.camera;
    camera.getWorldPosition(this.origin);
    camera.getWorldDirection(this.direction);
    this.up.copy(camera.up);
    this.point.copy(this.direction).add(this.origin);
    this.moveDistance = this.point.distanceTo(this.lastPoint);
    this.lastPoint.copy(this.point);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/PointerPen.ts
var PointerPen = class extends BaseScreenPointerSinglePoint {
  constructor(env) {
    super("pen", 2 /* Pen */, env);
    Object.seal(this);
  }
  vibrate() {
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/devices/PointerTouch.ts
function getPointerID(evt) {
  return evt.pointerId;
}
var PointerTouch = class extends BaseScreenPointer {
  constructor(env) {
    super("touch", 3 /* Touch */, env, null);
    this.dz = 0;
    this.lastZ = 0;
    this.points = new Array();
    this.lastXs = /* @__PURE__ */ new Map();
    this.lastYs = /* @__PURE__ */ new Map();
    this._canVibrate = null;
    Object.seal(this);
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(v) {
    super.enabled = v;
    arrayClear(this.points);
  }
  onReadEvent(evt) {
    arrayRemoveByKey(this.points, evt.pointerId, getPointerID);
    const isMove = evt.type === "pointerdown" || evt.type === "pointermove";
    if (isMove) {
      this.points.push(evt);
    }
    if (this.points.length === 2) {
      const a = this.points[0];
      const b = this.points[1];
      const dx = b.offsetX - a.offsetX;
      const dy = b.offsetY - a.offsetY;
      const z = 5 * Math.sqrt(dx * dx + dy * dy);
      const ddz = z - this.lastZ;
      if (evt.type === "pointermove") {
        this.dz += ddz;
      }
      this.lastZ = z;
    }
    const K = 1 / this.points.length;
    if (isMove) {
      this.position.setScalar(0);
      for (const point of this.points) {
        this.position.x += K * point.offsetX;
        this.position.y += K * point.offsetY;
        if (this.lastXs.has(point.pointerId)) {
          const lastX = this.lastXs.get(point.pointerId);
          const lastY = this.lastYs.get(point.pointerId);
          const dx = point.offsetX - lastX;
          const dy = point.offsetY - lastY;
          this.motion.x += K * dx;
          this.motion.y += K * dy;
        }
      }
    }
    if (isMove) {
      this.lastXs.set(evt.pointerId, evt.offsetX);
      this.lastYs.set(evt.pointerId, evt.offsetY);
    } else {
      this.lastXs.delete(evt.pointerId);
      this.lastYs.delete(evt.pointerId);
    }
    super.onReadEvent(evt);
    if (evt.type !== "pointermove") {
      let curButtons = 0;
      for (let button = 0; button < this.points.length; ++button) {
        const point = this.points[button];
        const mask = 1 << button;
        if (point.buttons !== 0) {
          curButtons |= mask;
        } else {
          curButtons &= ~mask;
        }
      }
      for (let button = 0; button < 10; ++button) {
        const wasPressed = this.isPressed(button);
        const mask = 1 << button;
        const isPressed = (curButtons & mask) !== 0;
        if (isPressed !== wasPressed) {
          this.setButton(button, isPressed);
        }
      }
      if (evt.type === "pointerup") {
        setTimeout(() => this._isActive = false, 10);
      }
    }
  }
  onUpdate() {
    this.env.avatar.zoom(this.dz);
    super.onUpdate();
    this.dz = 0;
  }
  get canVibrate() {
    if (this._canVibrate === null) {
      this._canVibrate = "vibrate" in navigator && isFunction(navigator.vibrate);
    }
    return this._canVibrate;
  }
  vibrate() {
    if (this.canVibrate) {
      navigator.vibrate(125);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/EventSystem.ts
var defaultSortFunction = (a, b) => a.distance - b.distance;
var EventSystem = class extends TypedEventBase {
  constructor(env) {
    super();
    this.env = env;
    this.raycaster = new Raycaster();
    this.hands = new Array();
    this.hits = new Array();
    this.queue = new Array();
    this.targetsFound = /* @__PURE__ */ new Set();
    this.targets = new Array();
    this.customSortFunction = null;
    this.raycaster.camera = this.env.camera;
    this.raycaster.layers.set(FOREGROUND);
    this.mouse = new PointerMouse(this.env);
    this.pen = new PointerPen(this.env);
    this.touches = new PointerTouch(this.env);
    this.nose = new PointerNose(this.env);
    for (let i = 0; i < 2; ++i) {
      this.hands[i] = new PointerHand(this.env, i);
    }
    this.pointers = [
      this.mouse,
      this.pen,
      this.touches,
      this.nose,
      ...this.hands
    ];
    for (const pointer of this.pointers) {
      pointer.addBubbler(this);
      if (pointer.cursor) {
        objGraph(this.env.stage, pointer.cursor);
      }
    }
    this.checkXRMouse();
    Object.seal(this);
  }
  set sortFunction(func) {
    this.customSortFunction = func;
  }
  get sortFunction() {
    return this.customSortFunction || defaultSortFunction;
  }
  checkXRMouse() {
    let count = 0;
    for (const hand of this.hands.values()) {
      if (hand.enabled) {
        ++count;
      }
    }
    const enableScreenPointers = count === 0;
    this.mouse.enabled = enableScreenPointers;
    this.pen.enabled = enableScreenPointers;
    this.touches.enabled = enableScreenPointers;
  }
  refreshCursors() {
    for (const pointer of this.pointers) {
      if (pointer.cursor) {
        pointer.cursor = this.env.cursor3D.clone();
      }
    }
  }
  fireRay(origin, direction) {
    arrayClear(this.hits);
    this.raycaster.ray.origin.copy(origin);
    this.raycaster.ray.direction.copy(direction);
    this.raycaster.intersectObjects(this.targets, false, this.hits);
    this.hits.sort(this.sortFunction);
    return this.hits[0] || null;
  }
  update() {
    this.targetsFound.clear();
    arrayClear(this.targets);
    this.queue.push(this.env.scene);
    while (this.queue.length > 0) {
      const here = this.queue.shift();
      if (here.children.length > 0) {
        this.queue.push(...here.children);
      }
      const target = getRayTarget(here);
      if (target && !this.targetsFound.has(target)) {
        this.targetsFound.add(target);
        this.targets.push(...target.meshes);
      }
    }
    for (const pointer of this.pointers) {
      pointer.update();
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/eventSystem/cursors/Cursor3D.ts
var Cursor3D = class extends BaseCursor3D {
  constructor(env, cursorSystem) {
    super(env);
    this.cursorSystem = null;
    this.object = obj("Cursor3D");
    this.cursorSystem = cursorSystem;
    this.object.matrixAutoUpdate = false;
  }
  add(name3, obj2) {
    objGraph(this, obj2);
    deepEnableLayer(obj2, PURGATORY);
    obj2.visible = name3 === "default";
  }
  get style() {
    for (const child of this.object.children) {
      if (child.visible) {
        return child.name;
      }
    }
    return null;
  }
  set style(v) {
    for (const child of this.object.children) {
      child.visible = child.name === v;
    }
    if (this.style == null && this.object.children.length > 0) {
      const defaultCursor = arrayScan(
        this.object.children,
        (child) => child.name === "default",
        (child) => child != null
      );
      if (defaultCursor != null) {
        defaultCursor.visible = true;
      }
    }
    if (this.cursorSystem) {
      this.cursorSystem.style = "none";
    }
  }
  get visible() {
    return objectIsVisible(this);
  }
  set visible(v) {
    objectSetVisible(this, v);
  }
  clone() {
    const obj2 = new Cursor3D(this.env);
    for (const child of this.object.children) {
      obj2.add(child.name, child.clone());
    }
    return obj2;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/webxr/XRHandMeshModel.ts
var _oculusBrowserV14CorrectionRight = new Quaternion().identity();
var _oculusBrowserV14CorrectionLeft = new Quaternion().identity();
if (/OculusBrowser\/14\./.test(navigator.userAgent)) {
  _oculusBrowserV14CorrectionRight.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
  _oculusBrowserV14CorrectionLeft.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI).premultiply(_oculusBrowserV14CorrectionRight);
}
var DEFAULT_HAND_PROFILE_PATH = "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles/generic-hand/";
var XRHandMeshModel = class extends Object3D {
  constructor(controller, handedness, color2) {
    super();
    this.controller = controller;
    this.handedness = handedness;
    this.bones = /* @__PURE__ */ new Map();
    this.root = null;
    this.instanceMatrix = { needsUpdate: false };
    this.oculusBrowserV14Correction = this.handedness === "left" ? _oculusBrowserV14CorrectionLeft : _oculusBrowserV14CorrectionRight;
    const loader2 = new GLTFLoader();
    loader2.setPath(DEFAULT_HAND_PROFILE_PATH);
    loader2.load(`${this.handedness}.glb`, (gltf) => {
      this.root = gltf.scene.children[0];
      this.add(this.root);
      const mesh2 = this.root.getObjectByProperty("type", "SkinnedMesh");
      mesh2.frustumCulled = false;
      mesh2.castShadow = true;
      mesh2.receiveShadow = true;
      if (isMeshPhysicalMaterial(mesh2.material)) {
        mesh2.material = materialPhysicalToPhong(mesh2.material);
      } else if (isMeshStandardMaterial(mesh2.material)) {
        mesh2.material = materialStandardToPhong(mesh2.material);
      }
      if (isMeshPhongMaterial(mesh2.material)) {
        mesh2.material.color = color2;
        mesh2.material.shininess = 0.1;
      }
      jointNames.forEach((jointName) => this.addBone(jointName));
    });
  }
  addBone(jointName) {
    if (this.root) {
      const bone = this.root.getObjectByName(jointName);
      if (bone) {
        this.bones.set(jointName, bone);
      }
    }
  }
  get count() {
    return this.bones.size;
  }
  set count(_v) {
  }
  getMatrixAt(n2, M3) {
    if (0 <= n2 && n2 < jointNames.length) {
      const jointName = jointNames[n2];
      if (this.bones.has(jointName)) {
        M3.copy(this.bones.get(jointName).matrix);
      }
    }
  }
  setMatrixAt(n2, M3) {
    if (0 <= n2 && n2 < jointNames.length) {
      const jointName = jointNames[n2];
      if (this.bones.has(jointName)) {
        const bone = this.bones.get(jointName);
        bone.matrix.copy(M3);
        bone.matrix.decompose(
          bone.position,
          bone.quaternion,
          bone.scale
        );
      }
    }
  }
  updateMesh() {
    if (this.controller) {
      for (const [jointName, bone] of this.bones) {
        const joint = this.controller.joints[jointName];
        if (joint && joint.visible) {
          bone.position.copy(joint.position);
          bone.quaternion.copy(joint.quaternion).multiply(this.oculusBrowserV14Correction);
        }
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/webxr/XRHandPrimitiveModel.ts
var defaultRadius = 8e-3;
var _matrix = new Matrix4();
var _vector2 = new Vector3();
var _oculusBrowserV14CorrectionRight2 = new Matrix4().identity();
var _oculusBrowserV14CorrectionLeft2 = new Matrix4().identity();
if (/OculusBrowser\/14\./.test(navigator.userAgent)) {
  _oculusBrowserV14CorrectionRight2.makeRotationY(Math.PI / 2);
  _oculusBrowserV14CorrectionLeft2.makeRotationY(-Math.PI / 2);
}
var XRHandPrimitiveModel = class extends InstancedMesh {
  constructor(controller, handedness, color2, primitive) {
    let geometry;
    if (primitive === "boxes") {
      geometry = new BoxGeometry(1, 1, 1);
    } else if (primitive === "bones") {
      geometry = new CylinderGeometry(0.5, 0.75, 2.25, 10, 1).rotateX(-Math.PI / 2);
    } else {
      geometry = new SphereGeometry(1, 10, 10);
    }
    const material = new MeshPhongMaterial({
      color: color2,
      shininess: 0.1
    });
    super(geometry, material, 30);
    this.controller = controller;
    this.instanceMatrix.setUsage(DynamicDrawUsage);
    this.castShadow = true;
    this.receiveShadow = true;
    this.oculusBrowserV14Correction = handedness === "left" ? _oculusBrowserV14CorrectionLeft2 : _oculusBrowserV14CorrectionRight2;
  }
  updateMesh() {
    if (this.controller) {
      let count = 0;
      for (const jointName of jointNames) {
        const joint = this.controller.joints[jointName];
        if (joint && joint.visible) {
          _vector2.setScalar(joint.jointRadius || defaultRadius);
          _matrix.compose(joint.position, joint.quaternion, _vector2);
          _matrix.multiply(this.oculusBrowserV14Correction);
          this.setMatrixAt(count, _matrix);
          count++;
        }
      }
      this.count = count;
    }
    this.instanceMatrix.needsUpdate = true;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/examples/webxr/XRHandModelFactory.ts
var jointNames = [
  "wrist",
  "thumb-metacarpal",
  "thumb-phalanx-proximal",
  "thumb-phalanx-distal",
  "thumb-tip",
  "index-finger-metacarpal",
  "index-finger-phalanx-proximal",
  "index-finger-phalanx-intermediate",
  "index-finger-phalanx-distal",
  "index-finger-tip",
  "middle-finger-metacarpal",
  "middle-finger-phalanx-proximal",
  "middle-finger-phalanx-intermediate",
  "middle-finger-phalanx-distal",
  "middle-finger-tip",
  "ring-finger-metacarpal",
  "ring-finger-phalanx-proximal",
  "ring-finger-phalanx-intermediate",
  "ring-finger-phalanx-distal",
  "ring-finger-tip",
  "pinky-finger-metacarpal",
  "pinky-finger-phalanx-proximal",
  "pinky-finger-phalanx-intermediate",
  "pinky-finger-phalanx-distal",
  "pinky-finger-tip"
];
var XRHandModel = class extends Object3D {
  constructor(controllerOrHandedness, color2, profile) {
    super();
    this.controllerOrHandedness = controllerOrHandedness;
    this.color = color2;
    this.profile = profile;
    this.impl = null;
    let controller = null;
    let handedness = null;
    if (isString(controllerOrHandedness)) {
      handedness = controllerOrHandedness;
    } else {
      controller = controllerOrHandedness;
    }
    const create13 = () => this.add(this.impl = this.createModel(controller, handedness));
    if (controller) {
      controller.addEventListener("connected", (event) => {
        const xrInputSource = event.data;
        if (xrInputSource.hand && !this.impl) {
          handedness = xrInputSource.handedness;
          create13();
        }
      });
      controller.addEventListener("disconnected", () => {
        const old = this.impl;
        this.impl = null;
        handedness = null;
        old.removeFromParent();
        cleanup(old);
      });
    } else if (handedness) {
      create13();
    }
  }
  get isTracking() {
    return !!this.impl;
  }
  createModel(controller, handedness) {
    if (this.profile === "mesh") {
      return new XRHandMeshModel(controller, handedness, this.color);
    } else {
      return new XRHandPrimitiveModel(controller, handedness, this.color, this.profile);
    }
  }
  get count() {
    if (this.impl) {
      return this.impl.count;
    }
    return 0;
  }
  set count(v) {
    if (this.impl) {
      this.impl.count = v;
    }
  }
  getMatrixAt(n2, M3) {
    if (this.impl) {
      this.impl.getMatrixAt(n2, M3);
    }
  }
  setMatrixAt(n2, M3) {
    if (this.impl) {
      this.impl.setMatrixAt(n2, M3);
    }
  }
  updateMesh() {
    if (this.impl) {
      this.impl.updateMesh();
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.impl) {
      this.impl.updateMesh();
    }
  }
};
var XRHandModelFactory = class {
  constructor(color2, profile) {
    this.color = color2;
    this.profile = profile;
  }
  createHandModel(controllerOrHandedness) {
    return new XRHandModel(controllerOrHandedness, this.color, this.profile);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/environment/XRTimer.ts
var XRTimerTickEvent = class extends BaseTimerTickEvent {
  constructor() {
    super();
    this.frame = null;
    Object.seal(this);
  }
  set(t2, dt, frame) {
    super.set(t2, dt);
    this.frame = frame;
  }
};
var XRTimer = class {
  constructor(renderer) {
    this.renderer = renderer;
    this.tickHandlers = new Array();
    this.lt = -1;
    this._isRunning = false;
    const tickEvt = new XRTimerTickEvent();
    let dt = 0;
    this._onTick = (t2, frame) => {
      if (this.lt >= 0) {
        dt = t2 - this.lt;
        tickEvt.set(t2, dt, frame);
        this.tick(tickEvt);
      }
      this.lt = t2;
    };
  }
  get isRunning() {
    return this._isRunning;
  }
  restart() {
    this.stop();
    this.start();
  }
  addTickHandler(onTick) {
    this.tickHandlers.push(onTick);
  }
  removeTickHandler(onTick) {
    arrayRemove(this.tickHandlers, onTick);
  }
  setAnimationLoop(loop2) {
    this.renderer.setAnimationLoop(loop2);
    this._isRunning = isDefined(loop2);
  }
  start() {
    if (!this.isRunning) {
      this.setAnimationLoop(this._onTick);
    }
  }
  stop() {
    if (this.isRunning) {
      this.setAnimationLoop(null);
      this.lt = -1;
    }
  }
  tick(evt) {
    for (const handler of this.tickHandlers) {
      handler(evt);
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/environment/BaseEnvironment/index.ts
var gridWidth = 15;
var gridSize = feet2Meters(gridWidth);
var BaseEnvironment = class extends TypedEventBase {
  constructor(canvas, styleSheetPath, fetcher2, enableFullResolution2, DEBUG2 = null, defaultAvatarHeight = null, defaultFOV = null) {
    super();
    this.styleSheetPath = styleSheetPath;
    this.fetcher = fetcher2;
    this.layers = new Array();
    this.layerSortOrder = /* @__PURE__ */ new Map();
    this.spectator = new PerspectiveCamera();
    this.lastViewport = new Vector4();
    this.curViewport = new Vector4();
    this.gltfLoader = new GLTFLoader();
    this.fadeDepth = 0;
    this.scene = new Scene();
    this.stage = obj("Stage");
    this.ambient = new AmbientLight(16777215, 0.5);
    this.sun = new DirectionalLight(16777215, 0.75);
    this.ground = new GridHelper(gridSize, gridWidth, 12632256, 8421504);
    this.foreground = obj("Foreground");
    this.loadingBar = new LoadingBar();
    this.handModelFactory = new XRHandModelFactory(new Color(12044521), "mesh");
    this.screenControl = null;
    this.enableSpectator = false;
    this._xrBinding = null;
    this._xrMediaBinding = null;
    this._hasXRMediaLayers = null;
    this._hasXRCompositionLayers = null;
    this.DEBUG = DEBUG2 || false;
    this.defaultAvatarHeight = defaultAvatarHeight || 1.75;
    defaultFOV = defaultFOV || 60;
    this.camera = new PerspectiveCamera(defaultFOV, 1, 0.01, 1e3);
    this.cursor3D = new Cursor3D(this);
    if (isHTMLCanvas(canvas)) {
      canvas.style.backgroundColor = "black";
      if (isNullOrUndefined(canvas.parentElement)) {
        throw new Error("The provided canvas must be included in a parent element before constructing the environment.");
      }
    }
    this.renderer = new WebGLRenderer({
      canvas,
      powerPreference: "high-performance",
      precision: "lowp",
      antialias: true,
      alpha: true,
      premultipliedAlpha: true,
      depth: true,
      logarithmicDepthBuffer: true,
      stencil: false,
      preserveDrawingBuffer: false
    });
    this.renderer.domElement.setAttribute("touch-action", "none");
    this.renderer.domElement.tabIndex = 1;
    this.useNewColorModel = false;
    if (isHTMLCanvas(canvas)) {
      this.screenControl = new ScreenControl(
        this.renderer,
        this.camera,
        this.renderer.domElement.parentElement,
        enableFullResolution2
      );
    }
    this.fader = new Fader("ViewFader");
    this.worldUISpace = new BodyFollower("WorldUISpace", 0.2, 20, 0.125);
    this.avatar = new AvatarLocal(this, this.fader);
    this.eventSys = new EventSystem(this);
    this.timer = new XRTimer(this.renderer);
    this.skybox = new Skybox(this);
    this.renderer.xr.enabled = true;
    this.sun.name = "Sun";
    this.sun.position.set(0, 1, 1);
    this.sun.lookAt(0, 0, 0);
    this.sun.layers.enableAll();
    const showGround = () => {
      this.ground.visible = this.renderer.xr.isPresenting;
    };
    this.screenControl.addEventListener("sessionstarted", showGround);
    this.screenControl.addEventListener("sessionstopped", showGround);
    showGround();
    this.ambient.name = "Fill";
    this.ambient.layers.enableAll();
    this.loadingBar.object.name = "MainLoadingBar";
    this.loadingBar.object.position.set(0, -0.25, -2);
    this.scene.layers.enableAll();
    this.avatar.addFollower(this.worldUISpace);
    objGraph(
      this.scene,
      this.sun,
      this.ambient,
      objGraph(
        this.stage,
        this.ground,
        this.camera,
        this.avatar,
        ...this.eventSys.hands
      ),
      this.foreground,
      objGraph(
        this.worldUISpace,
        this.loadingBar
      )
    );
    this.timer.addTickHandler((evt) => this.update(evt));
    this._start();
    globalThis.env = this;
  }
  get useNewColorModel() {
    return ColorManagement.enabled;
  }
  set useNewColorModel(enabled) {
    ColorManagement.enabled = enabled;
    this.renderer.outputEncoding = enabled ? sRGBEncoding : LinearEncoding;
  }
  async _start() {
    if (isDefined(this.styleSheetPath)) {
      await this.fetcher.get(this.styleSheetPath).style();
    }
    this.timer.start();
  }
  get gl() {
    return this.renderer.getContext();
  }
  get referenceSpace() {
    return this.renderer.xr.getReferenceSpace();
  }
  update(evt) {
    this.dispatchEvent(evt);
    if (this.screenControl.visible) {
      const session = this.xrSession;
      this._xrBinding = this.renderer.xr.getBinding();
      if (this.hasXRMediaLayers && this._xrMediaBinding === null === this.renderer.xr.isPresenting) {
        if (this._xrMediaBinding === null && isDefined(session)) {
          this._xrMediaBinding = new XRMediaBinding(session);
        } else {
          this._xrMediaBinding = null;
        }
      }
      const baseLayer = session && this.renderer.xr.getBaseLayer();
      if (baseLayer !== this.baseLayer) {
        if (isDefined(this.baseLayer)) {
          this.removeWebXRLayer(this.baseLayer);
          this.baseLayer = null;
        }
        if (isDefined(baseLayer)) {
          this.baseLayer = baseLayer;
          this.addWebXRLayer(baseLayer, 0);
        }
      }
      this.screenControl.resize();
      this.eventSys.update();
      this.avatar.update(evt.dt);
      this.worldUISpace.update(this.avatar.height, this.avatar.worldPos, this.avatar.worldHeadingRadians, evt.dt);
      this.fader.update(evt.dt);
      updateScalings(evt.dt);
      this.loadingBar.update(evt.sdt);
      this.preRender(evt);
      const cam = resolveCamera(this.renderer, this.camera);
      if (cam !== this.camera) {
        const vrCam = cam;
        vrCam.layers.mask = this.camera.layers.mask;
        for (let i = 0; i < vrCam.cameras.length; ++i) {
          const subCam = vrCam.cameras[i];
          subCam.layers.mask = this.camera.layers.mask;
          subCam.layers.enable(i + 1);
          vrCam.layers.enable(i + 1);
        }
      }
      this.renderer.clear();
      this.renderer.render(this.scene, this.camera);
      if (this.enableSpectator) {
        if (!this.renderer.xr.isPresenting) {
          this.lastViewport.copy(this.curViewport);
          this.renderer.getViewport(this.curViewport);
        } else if (isDesktop() && !isFirefox()) {
          this.drawSnapshot();
        }
      }
    }
  }
  drawSnapshot() {
    const isPresenting = this.renderer.xr.isPresenting;
    let curRT = null;
    if (isPresenting) {
      const cam = resolveCamera(this.renderer, this.camera);
      this.spectator.projectionMatrix.copy(this.camera.projectionMatrix);
      this.spectator.position.copy(cam.position);
      this.spectator.quaternion.copy(cam.quaternion);
      curRT = this.renderer.getRenderTarget();
      this.renderer.xr.isPresenting = false;
      this.renderer.setRenderTarget(null);
      this.renderer.setViewport(this.lastViewport);
    }
    this.renderer.clear();
    this.renderer.render(this.scene, isPresenting ? this.spectator : this.camera);
    if (isPresenting) {
      this.renderer.setViewport(this.curViewport);
      this.renderer.setRenderTarget(curRT);
      this.renderer.xr.isPresenting = true;
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
  preRender(_evt) {
  }
  async onQuitting() {
    this.dispatchEvent(new TypedEvent("quitting"));
    window.location.href = "/";
  }
  get hasAlpha() {
    return this.renderer.getContextAttributes().alpha;
  }
  get xrSession() {
    return this.renderer.xr.getSession();
  }
  get xrBinding() {
    return this._xrBinding;
  }
  get xrMediaBinding() {
    return this._xrMediaBinding;
  }
  get isReadyForLayers() {
    return this.hasAlpha && (!isOculusBrowser || oculusBrowserVersion.major >= 15);
  }
  get hasXRMediaLayers() {
    if (this._hasXRMediaLayers === null) {
      this._hasXRMediaLayers = this.isReadyForLayers && "XRMediaBinding" in globalThis && isFunction(XRMediaBinding.prototype.createQuadLayer);
    }
    return this._hasXRMediaLayers;
  }
  get hasXRCompositionLayers() {
    if (this._hasXRCompositionLayers === null) {
      this._hasXRCompositionLayers = this.isReadyForLayers && "XRWebGLBinding" in globalThis && isFunction(XRWebGLBinding.prototype.createCubeLayer);
    }
    return this._hasXRCompositionLayers;
  }
  addWebXRLayer(layer, sortOrder) {
    this.layers.push(layer);
    this.layerSortOrder.set(layer, sortOrder);
    arraySortByKeyInPlace(this.layers, (l) => -this.layerSortOrder.get(l));
    this.updateLayers();
  }
  removeWebXRLayer(layer) {
    this.layerSortOrder.delete(layer);
    arrayRemove(this.layers, layer);
    this.updateLayers();
  }
  updateLayers() {
    const session = this.xrSession;
    if (isDefined(session)) {
      session.updateRenderState({
        layers: this.layers
      });
    }
  }
  clearScene() {
    this.dispatchEvent(new TypedEvent("sceneclearing"));
    cleanup(this.foreground);
    this.dispatchEvent(new TypedEvent("scenecleared"));
  }
  async fadeOut() {
    ++this.fadeDepth;
    if (this.fadeDepth === 1) {
      await this.fader.fadeOut();
      this.skybox.visible = false;
      this.camera.layers.set(PURGATORY);
      this.loadingBar.start();
      await this.fader.fadeIn();
    }
  }
  async fadeIn() {
    if (this.fadeDepth === 1) {
      await this.fader.fadeOut();
      this.camera.layers.set(FOREGROUND);
      this.skybox.visible = true;
      await this.fader.fadeIn();
    }
    --this.fadeDepth;
  }
  async withFade(action) {
    try {
      await this.fadeOut();
      return await action();
    } finally {
      await this.fadeIn();
    }
  }
  get showWebXRLayers() {
    return this.fadeDepth === 0;
  }
  set3DCursor(model2) {
    const children = model2.children.slice(0);
    for (const child of children) {
      this.cursor3D.add(child.name, child);
    }
    this.eventSys.refreshCursors();
    this.dispatchEvent(new TypedEvent("newcursorloaded"));
  }
  async load(progOrAsset, ...assets) {
    let prog = null;
    if (isAsset(progOrAsset)) {
      assets.push(progOrAsset);
    } else {
      prog = progOrAsset;
    }
    const cursor3d = new AssetGltfModel(this, "/models/Cursors.glb", Model_Gltf_Binary, !this.DEBUG);
    assets.push(cursor3d);
    await this.fetcher.assets(prog, ...assets);
    convertMaterials(cursor3d.result.scene, materialStandardToBasic);
    this.set3DCursor(cursor3d.result.scene);
  }
  loadGltf(file) {
    return this.gltfLoader.loadAsync(file);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/InputRangeWithNumber/index.ts
var InputRangeWithNumber = class extends TypedEventBase {
  constructor(...rest) {
    super();
    this.element = Div(
      className("input-range-with-number"),
      this.rangeInput = InputRange(
        onInput(() => {
          this.numberInput.valueAsNumber = this.rangeInput.valueAsNumber;
          this.dispatchEvent(new TypedEvent("input"));
        }),
        ...rest
      ),
      this.numberInput = InputNumber(
        onInput(() => {
          this.rangeInput.valueAsNumber = this.numberInput.valueAsNumber;
          this.rangeInput.dispatchEvent(new Event("input"));
        })
      )
    );
    this.numberInput.min = this.rangeInput.min;
    this.numberInput.max = this.rangeInput.max;
    this.numberInput.step = this.rangeInput.step;
    this.numberInput.valueAsNumber = this.rangeInput.valueAsNumber;
    this.numberInput.disabled = this.rangeInput.disabled;
    this.numberInput.placeholder = this.rangeInput.placeholder;
  }
  get value() {
    return this.rangeInput.value;
  }
  set value(v) {
    this.rangeInput.value = this.numberInput.value = v;
  }
  get valueAsNumber() {
    return this.rangeInput.valueAsNumber;
  }
  set valueAsNumber(v) {
    this.rangeInput.valueAsNumber = this.numberInput.valueAsNumber = v;
  }
  get disabled() {
    return this.rangeInput.disabled;
  }
  set disabled(v) {
    this.rangeInput.disabled = this.numberInput.disabled = v;
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/PropertyList/index.ts
var PropertyGroup = class {
  constructor(name3, ...properties) {
    this.name = name3;
    this.properties = properties;
  }
};
function group(name3, ...properties) {
  return new PropertyGroup(name3, ...properties);
}
var DEFAULT_PROPERTY_GROUP = "DefaultPropertyGroup" + stringRandom(16);
var singleItem = className("single-item");
function createElements(rest) {
  return rest.flatMap((entry) => createRows(entry).flatMap(identity));
}
function createRows(entry) {
  let groupName = DEFAULT_PROPERTY_GROUP;
  const rows = new Array();
  if (entry instanceof PropertyGroup) {
    groupName = entry.name;
    rows.push(...entry.properties.map((e2) => createRow(groupName, e2)));
  } else {
    rows.push(createRow(groupName, entry));
  }
  return rows;
}
function createRow(groupName, entry) {
  const group2 = groupName === DEFAULT_PROPERTY_GROUP ? null : customData("groupname", groupName);
  if (isArray(entry)) {
    const [labelText, ...fields] = entry;
    const label = Label(labelText);
    for (const field of fields) {
      if (field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement || field instanceof HTMLSelectElement) {
        if (field.id.length === 0) {
          field.id = stringRandom(10);
        }
        label.htmlFor = field.id;
        break;
      }
    }
    return [
      DT(group2, label),
      DD(group2, ...fields)
    ];
  } else {
    if (isString(entry) || isNumber(entry) || isBoolean(entry) || isDate(entry)) {
      entry = H2(entry);
    }
    return [
      DD(group2, entry)
    ];
  }
}
function isPropertyDef(obj2) {
  return isDefined(obj2) && !isCssElementStyleProp(obj2) && !isAttr(obj2);
}
var PropertyList = class {
  constructor(element) {
    this.element = element;
    this.groups = new PriorityList();
    this.controls = new Array();
    this._disabled = false;
    const queue = [...element.children];
    while (queue.length > 0) {
      const child = queue.shift();
      if (isDisableable(child)) {
        this.controls.push(child);
      }
      if (child instanceof HTMLElement) {
        this.checkGroup(child);
        queue.push(...child.children);
      }
    }
  }
  static find() {
    return Array.from(PropertyList._find());
  }
  static *_find() {
    for (const elem of getElements(".properties")) {
      yield new PropertyList(elem);
    }
  }
  static create(...rest) {
    const props = rest.filter(isPropertyDef);
    const styles = rest.filter(isCssElementStyleProp);
    const attrs = rest.filter(isAttr);
    const classes = coallesceClassLists(attrs, "properties");
    const rows = createElements(props);
    return new PropertyList(DL(
      classList(...classes),
      ...styles,
      ...attrs,
      ...rows
    ));
  }
  append(...props) {
    const rows = createElements(props);
    elementApply(this.element, ...rows);
    for (const propDef of props) {
      const props2 = propDef instanceof PropertyGroup ? propDef.properties : [propDef];
      for (const prop of props2) {
        if (!isString(prop)) {
          const [_, ...elems] = isArray(prop) ? prop : [null, prop];
          for (const elem of elems) {
            if (isDisableable(elem)) {
              this.controls.push(elem);
            }
          }
        }
      }
    }
    for (const row of rows) {
      this.checkGroup(row);
    }
  }
  checkGroup(row) {
    const elem = resolveElement(row);
    const groupName = elem.dataset["groupname"];
    if (groupName !== DEFAULT_PROPERTY_GROUP) {
      this.groups.add(groupName, row);
    }
    if (elem.parentElement === this.element && elem.tagName === "DD" && (!elem.previousElementSibling || elem.previousElementSibling.tagName !== "DT")) {
      singleItem.applyToElement(elem);
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    if (v !== this.disabled) {
      this._disabled = v;
      elementSetClass(this, v, "disabled");
      for (const control of this.controls) {
        control.disabled = v;
      }
    }
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  setGroupVisible(id2, v) {
    const elems = this.groups.get(id2);
    if (elems) {
      for (const elem of elems) {
        elementSetDisplay(elem, v);
      }
    }
  }
  getGroupVisible(id2) {
    const elems = this.groups.get(id2);
    if (elems) {
      for (const elem of elems) {
        return elementIsDisplayed(elem);
      }
    }
    return false;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/environment/DeviceDialog.ts
var MIC_GROUP = "micFields" + stringRandom(8);
var CAM_GROUP = "camFields" + stringRandom(8);
function makeDeviceSelector(selector, devices, curDevice) {
  elementClearChildren(selector);
  elementApply(
    selector,
    Option(value(""), "NONE"),
    ...devices.map(
      (device) => Option(
        selected(curDevice && device.deviceId === curDevice.deviceId),
        value(device.deviceId),
        device.label
      )
    )
  );
}
var DeviceDialog = class extends DialogBox {
  constructor(fetcher2, devices, audio2, microphones, webcams, DEBUG2 = false) {
    super("Configure devices");
    this.devices = devices;
    this.audio = audio2;
    this.microphones = microphones;
    this.webcams = webcams;
    this.micLookup = null;
    this.camLookup = null;
    this.spkrLookup = null;
    this.spkrVolumeControl = null;
    this.speakers = null;
    this.cancelButton.style.display = "none";
    const clipAsset = new AssetFile("/audio/test-clip.mp3", Audio_Mpeg, !DEBUG2);
    const clipLoaded = fetcher2.assets(clipAsset).then(() => this.audio.createBasicClip("test-audio", clipAsset, 0.5));
    elementApply(
      this.contentArea,
      paddingRight("2em"),
      this.properties = PropertyList.create(
        group(
          CAM_GROUP,
          [
            "Webcams",
            this.webcamSelector = Select(
              onInput(async () => {
                const deviceId = this.webcamSelector.value;
                const device = this.camLookup.get(deviceId);
                await this.webcams.setDevice(device);
              })
            )
          ]
        ),
        group(
          MIC_GROUP,
          [
            "Microphones",
            this.microphoneSelector = Select(
              display("inline-block"),
              onInput(async () => {
                const deviceId = this.microphoneSelector.value;
                const device = this.micLookup.get(deviceId);
                await this.microphones.setDevice(device);
              })
            )
          ],
          [
            "Volume",
            this.micVolumeControl = new InputRangeWithNumber(
              min(0),
              max(100),
              step(1),
              value(0),
              onInput(() => {
                this.microphones.gain.setValueAtTime(this.micVolumeControl.valueAsNumber / 100, 0);
              })
            )
          ],
          [
            "Levels",
            this.micLevels = Meter(
              display("inline-block")
            )
          ]
        )
      )
    );
    if (canChangeAudioOutput) {
      this.properties.append(
        [
          "Speakers",
          this.speakers = Select(
            onInput(async () => {
              const deviceId = this.speakers.value;
              const device = this.spkrLookup.get(deviceId);
              await this.audio.speakers.setAudioOutputDevice(device);
            })
          )
        ]
      );
      this.audio.speakers.addEventListener("audiooutputchanged", (evt) => {
        this.speakers.value = evt.device && evt.device.deviceId || "";
      });
    }
    this.properties.append(
      [
        "Volume",
        this.spkrVolumeControl = new InputRangeWithNumber(
          min(0),
          max(100),
          step(1),
          value(0),
          onInput(() => this.audio.destination.volume = this.spkrVolumeControl.valueAsNumber / 100)
        )
      ],
      [
        "",
        this.testSpkrButton = ButtonSecondary(
          "Test",
          title("Test audio"),
          margin(em(0.5)),
          onClick(async () => {
            this.testSpkrButton.disabled = true;
            await clipLoaded;
            await this.audio.playClipThrough("test-audio");
            this.testSpkrButton.disabled = false;
          })
        )
      ],
      [
        "Using headphones",
        this.useHeadphones = InputCheckbox(
          checked(this.audio.useHeadphones),
          onInput(() => {
            this.audio.useHeadphones = this.useHeadphones.checked;
            elementSetDisplay(this.headphoneWarning, !this.audio.useHeadphones, "inline-block");
          })
        )
      ],
      this.headphoneWarning = Div(
        className("alert alert-warning"),
        "\u{1F3A7}\u{1F399}\uFE0F This site has a voice chat feature. Voice chat is best experienced using headphones."
      )
    );
    this.activity = new ActivityDetector(this.audio.context);
    this.activity.name = "device-settings-dialog-activity";
    this.activity.addEventListener("activity", (evt) => {
      if (this.isOpen) {
        this.micLevels.value = evt.level;
      }
    });
    this.microphones.connect(this.activity);
    this.activity.start();
    this.properties.setGroupVisible(MIC_GROUP, false);
    Object.seal(this);
  }
  get showWebcams() {
    return this.properties.getGroupVisible(CAM_GROUP);
  }
  set showWebcams(v) {
    this.properties.setGroupVisible(CAM_GROUP, v);
  }
  get showMicrophones() {
    return this.properties.getGroupVisible(MIC_GROUP);
  }
  set showMicrophones(v) {
    this.properties.setGroupVisible(MIC_GROUP, v);
  }
  async onShowing() {
    if (this.showWebcams || this.showMicrophones) {
      await this.devices.init();
      const devices = await this.devices.getDevices();
      if (this.showWebcams) {
        const cams = devices.filter((d) => d.kind === "videoinput");
        this.camLookup = makeLookup(cams, (m) => m.deviceId);
        makeDeviceSelector(this.webcamSelector, cams, this.webcams.device);
      }
      if (this.showMicrophones) {
        const mics = devices.filter((d) => d.kind === "audioinput");
        this.micLookup = makeLookup(mics, (m) => m.deviceId);
        makeDeviceSelector(this.microphoneSelector, mics, this.microphones.device);
        this.microphones.usingHeadphones = this.useHeadphones.checked;
        this.microphones.enabled = true;
        this.micVolumeControl.valueAsNumber = this.microphones.gain.value * 100;
      }
    }
    if (canChangeAudioOutput) {
      await this.audio.speakers.ready;
      const spkrs = await this.audio.speakers.getAudioOutputDevices();
      this.spkrLookup = makeLookup(spkrs, (device) => device.deviceId);
      elementClearChildren(this.speakers);
      elementApply(
        this.speakers,
        ...spkrs.map(
          (device) => Option(
            value(device.deviceId),
            device.label
          )
        )
      );
      let curSpker = await this.audio.speakers.getAudioOutputDevice();
      if (!curSpker) {
        curSpker = await this.audio.speakers.getPreferredAudioOutput();
        await this.audio.speakers.setAudioOutputDevice(curSpker);
      }
      this.speakers.value = curSpker && curSpker.deviceId || "";
    }
    this.spkrVolumeControl.valueAsNumber = this.audio.destination.volume * 100;
    this.useHeadphones.checked = this.audio.useHeadphones;
    elementSetDisplay(this.headphoneWarning, !this.audio.useHeadphones, "inline-block");
    await super.onShowing();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/environment/Environment/index.ts
var EnvironmentRoomJoinedEvent = class extends TypedEvent {
  constructor(roomName) {
    super("roomjoined");
    this.roomName = roomName;
  }
};
var DialogShowingEvent = class extends TypedEvent {
  constructor(showing) {
    super("dialogshowing");
    this.showing = showing;
  }
};
var Environment = class extends BaseEnvironment {
  constructor(options) {
    if (isNullOrUndefined(options)) {
      throw new Exception("Options are now required");
    }
    if (isNullOrUndefined(options.canvas)) {
      throw new Exception("options.canvas is required");
    }
    if (isNullOrUndefined(options.fetcher)) {
      throw new Exception("options.fetcher is required");
    }
    if (isNullOrUndefined(options.dialogFontFamily)) {
      throw new Exception("options.dialogFontFamily is required");
    }
    if (isNullOrUndefined(options.getAppUrl)) {
      throw new Exception("options.getAppUrl is required");
    }
    if (isNullOrUndefined(options.uiImagePaths)) {
      throw new Exception("options.uiImagePaths is required");
    }
    if (isNullOrUndefined(options.buttonFillColor)) {
      throw new Exception("options.buttonFillColor is required");
    }
    if (isNullOrUndefined(options.labelFillColor)) {
      throw new Exception("options.labelFillColor is required");
    }
    super(
      options.canvas,
      options.styleSheetPath,
      options.fetcher,
      options.enableFullResolution,
      options.DEBUG,
      options.defaultAvatarHeight,
      options.defaultFOV
    );
    this.envAudioToggleEvt = new TypedEvent("environmentaudiotoggled");
    this._currentRoom = null;
    this._testSpaceLayout = false;
    this.countTick = 0;
    this.fpses = new Array();
    this.avgFPS = 0;
    this.screenUISpace = new ScreenUI(options.buttonFillColor);
    this.compassImage = new ArtificialHorizon();
    this.clockImage = new CanvasImageMesh(this, "Clock", "none", new ClockImage());
    this.clockImage.sizeMode = "fixed-height";
    this.clockImage.mesh.renderOrder = 5;
    this.statsImage = new CanvasImageMesh(this, "Stats", "none", new StatsImage());
    this.statsImage.sizeMode = "fixed-height";
    this.statsImage.mesh.renderOrder = 5;
    this.infoLabel = new TextMesh(this, "InfoLabel", "none", {
      minHeight: 0.1,
      maxHeight: 0.1,
      padding: 0.02,
      scale: 1e3,
      bgFillColor: options.labelFillColor,
      textFillColor: "white"
    });
    this.apps = new ApplicationLoader(this, options.getAppUrl);
    this.apps.addEventListener("apploaded", (evt) => {
      evt.app.addEventListener("joinroom", (evt2) => {
        if (evt2.roomName !== this._currentRoom) {
          this._currentRoom = evt2.roomName;
          this.dispatchEvent(new EnvironmentRoomJoinedEvent(evt2.roomName));
        }
      });
    });
    this.audio = new AudioManager(options.fetcher, DEFAULT_LOCAL_USER_ID);
    this.graph = new AudioGraphDialog(this.audio.context);
    if (isHTMLCanvas(options.canvas)) {
      options.canvas.addEventListener("keypress", (evt) => {
        if (isModifierless(evt) && evt.key === "`") {
          this.graph.showDialog();
        }
      });
    }
    this.audioPlayer = new AudioPlayer(this.audio.context, this.audio.createSpatializer(false, false));
    this.videoPlayer = new VideoPlayer3D(this, this.audio.context, this.audio.createSpatializer(false, false));
    this.videoPlayer.object.visible = false;
    this.interactionAudio = new InteractionAudio(this.audio, this.eventSys);
    this.microphones = new LocalUserMicrophone(this.audio.context);
    this.webcams = new LocalUserWebcam();
    this.devices = new DeviceManager(this.microphones, this.webcams);
    this.confirmationDialog = new ConfirmationDialog(this, options.dialogFontFamily);
    this.devicesDialog = new DeviceDialog(this.fetcher, this.devices, this.audio, this.microphones, this.webcams, this.DEBUG);
    this.uiButtons = new ButtonFactory(options.uiImagePaths, 20, options.buttonFillColor, options.labelFillColor, this.DEBUG);
    this.menuButton = new ButtonImageWidget(this.uiButtons, "ui", "menu");
    this.settingsButton = new ButtonImageWidget(this.uiButtons, "ui", "settings");
    this.quitButton = new ButtonImageWidget(this.uiButtons, "ui", "quit");
    this.muteMicButton = new ToggleButton(this.uiButtons, "microphone", "mute", "unmute");
    this.muteCamButton = new ToggleButton(this.uiButtons, "media", "play", "pause");
    this.muteEnvAudioButton = new ToggleButton(this.uiButtons, "environment-audio", "mute", "unmute");
    this.muteEnvAudioButton.active = true;
    this.audio.ready.then(() => this.muteEnvAudioButton.active = false);
    this.vrButton = new ScreenModeToggleButton(this.uiButtons, "VR" /* VR */);
    this.fullscreenButton = new ScreenModeToggleButton(this.uiButtons, "Fullscreen" /* Fullscreen */);
    this.arButton = new ScreenModeToggleButton(this.uiButtons, "AR" /* AR */);
    if (BatteryImage.isAvailable && isMobile()) {
      this.batteryImage = new CanvasImageMesh(this, "Battery", "none", new BatteryImage());
      this.batteryImage.sizeMode = "fixed-height";
    }
    this.xrUI = new SpaceUI();
    this.subMenu = new Widget(
      Div(id("juniperSubMenu")),
      obj("sub-menu"),
      "flex"
    );
    this.createMenu();
    this.screenControl.setUI(this.screenUISpace, this.fullscreenButton, this.vrButton, this.arButton);
    if (isDefined(this.screenControl)) {
      this.screenControl.addEventListener("sessionstarted", (evt) => {
        if (evt.mode === "Fullscreen" /* Fullscreen */ && this.confirmationDialog.element.parentElement !== this.screenControl.fullscreenElement) {
          elementApply(this.screenControl.fullscreenElement, this.devicesDialog, this.confirmationDialog);
        }
      });
    }
    if (isDefined(options.watchModelPath)) {
      this.watch = new Watch(this, options.watchModelPath);
    }
    this.microphones.addEventListener("devicesettingschanged", () => {
      this.muteMicButton.active = this.microphones.enabled && !this.microphones.muted;
    });
    this.webcams.addEventListener("devicesettingschanged", () => {
      this.muteCamButton.active = this.webcams.enabled;
    });
    this.muteMicButton.addEventListener("click", () => {
      this.microphones.muted = this.microphones.enabled && !this.microphones.muted;
      this.muteMicButton.active = !this.microphones.muted;
    });
    this.muteCamButton.addEventListener("click", () => {
      this.webcams.enabled = !this.webcams.enabled;
      this.muteCamButton.active = this.webcams.enabled;
    });
    this.muteMicButton.active = this.microphones.enabled && !this.microphones.muted;
    this.muteCamButton.active = this.webcams.enabled;
    if (isFunction(options.createSpeechRecognizer)) {
      this.speech = options.createSpeechRecognizer(this.fetcher, this.devicesDialog.activity, this.microphones);
      this.speech.continuous = true;
    }
  }
  get currentRoom() {
    return this._currentRoom;
  }
  get testSpaceLayout() {
    return this._testSpaceLayout;
  }
  set testSpaceLayout(v) {
    if (v !== this.testSpaceLayout) {
      this._testSpaceLayout = v;
    }
  }
  createMenu() {
    if (isDefined(this.batteryImage)) {
      this.xrUI.addItem(this.batteryImage, { x: 0.75, y: -1, width: 0.2, height: 0.1 });
      elementApply(this.screenUISpace.topRight, this.batteryImage);
    }
    this.xrUI.addItem(this.clockImage, { x: -1, y: 1, height: 0.1 });
    this.xrUI.addItem(this.statsImage, { x: -1, y: 0.95, height: 0.1 });
    this.xrUI.addItem(this.confirmationDialog, { x: 0, y: 0, scale: 0.25 });
    this.xrUI.addItem(this.menuButton, { x: -1, y: -1, scale: 0.5 });
    this.xrUI.addItem(this.infoLabel, { x: 0, y: -1.125, scale: 0.5 });
    this.xrUI.addItem(this.vrButton, { x: 1, y: -1, scale: 0.5 });
    this.xrUI.addItem(this.arButton, { x: 1, y: -1, scale: 0.5 });
    objGraph(this.menuButton, this.subMenu);
    objGraph(this.worldUISpace, this.xrUI);
    elementApply(
      this.screenUISpace.topLeft,
      pointerEvents("none"),
      elementApply(
        this.webcams,
        display("inline-block"),
        width(perc(50)),
        transform("scaleX(-1)")
      )
    );
    elementApply(
      this.screenUISpace.topRight,
      this.compassImage,
      this.statsImage
    );
    elementApply(this.screenUISpace.bottomCenter, this.infoLabel);
    elementApply(this.screenUISpace.bottomRight, this.vrButton, this.arButton, this.fullscreenButton);
    elementApply(
      this.screenUISpace.bottomLeft,
      Div(
        this.menuButton,
        display("flex"),
        flexDirection("column-reverse"),
        gap(em(0.25)),
        this.subMenu
      )
    );
    widgetApply(
      this.subMenu,
      this.settingsButton,
      this.muteCamButton,
      this.muteMicButton,
      this.muteEnvAudioButton,
      this.quitButton
    );
    this.settingsButton.addEventListener("click", async () => {
      const mode = this.screenControl.currentMode;
      const wasPresenting = this.renderer.xr.isPresenting;
      if (wasPresenting) {
        await this.screenControl.stop();
      }
      await this.devicesDialog.showDialog();
      if (wasPresenting) {
        await this.screenControl.start(mode);
      }
    });
    this.muteEnvAudioButton.addEventListener("click", () => {
      this.muteEnvAudioButton.active = !this.muteEnvAudioButton.active;
      this.dispatchEvent(this.envAudioToggleEvt);
    });
    this.quitButton.addEventListener("click", () => this.withConfirmation(
      "Confirm quit",
      "Are you sure you want to quit?",
      async () => {
        if (this.renderer.xr.isPresenting) {
          this.screenControl.stop();
        }
        await this.onQuitting();
      }
    ));
    this.menuButton.addEventListener("click", () => this.subMenu.visible = !this.subMenu.visible);
    [
      this.settingsButton,
      this.muteCamButton,
      this.muteMicButton,
      this.muteEnvAudioButton,
      this.quitButton
    ].forEach((btn) => btn.addEventListener("click", () => this.subMenu.visible = false));
    this.subMenu.visible = false;
    this.vrButton.visible = isDesktop() && hasVR() || isMobileVR();
    this.arButton.visible = false;
    this.muteCamButton.visible = false;
    this.muteMicButton.visible = false;
  }
  layoutMenu() {
    let curCount = 0;
    for (const child of this.subMenu.object.children) {
      if (child.visible) {
        child.position.set(0, ++curCount * 0.25, 0);
      }
    }
  }
  preRender(evt) {
    super.preRender(evt);
    const { worldPos, worldQuat } = this.avatar;
    this.audio.setUserPose(
      this.audio.localUserID,
      worldPos.x,
      worldPos.y,
      worldPos.z,
      worldQuat.x,
      worldQuat.y,
      worldQuat.z,
      worldQuat.w
    );
    this.xrUI.visible = this.renderer.xr.isPresenting || this.testSpaceLayout;
    this.statsImage.isVisible = this.xrUI.visible && this.DEBUG;
    if (!this.renderer.xr.isPresenting) {
      this.compassImage.setPitchAndHeading(
        rad2deg(this.avatar.worldPitchRadians),
        rad2deg(this.avatar.worldHeadingRadians)
      );
    }
    this.layoutMenu();
    if (this.DEBUG) {
      const fps = Math.round(evt.fps);
      this.avgFPS += fps / 100;
      this.fpses.push(fps);
      if (this.fpses.length > 100) {
        const fps2 = this.fpses.shift();
        this.avgFPS -= fps2 / 100;
      }
      if (++this.countTick % 100 === 0) {
        this.statsImage.image.setStats(
          this.avgFPS,
          this.renderer.info.render.calls,
          this.renderer.info.render.triangles
        );
      }
    }
    this.confirmationDialog.update(evt.dt);
  }
  get environmentAudioMuted() {
    return this.muteEnvAudioButton.active;
  }
  async withConfirmation(title2, msg, act) {
    this.onConfirmationShowing(true);
    if (await this.confirmationDialog.prompt(title2, msg)) {
      act();
    }
    this.onConfirmationShowing(false);
  }
  onConfirmationShowing(showing) {
    widgetSetEnabled(this.quitButton, !showing);
    this.dispatchEvent(new DialogShowingEvent(showing));
  }
  async load(progOrAsset, ...assets) {
    let prog = null;
    if (isAsset(progOrAsset)) {
      assets.push(progOrAsset);
      prog = this.loadingBar;
    } else {
      prog = progOrAsset;
    }
    if (isHTMLCanvas(this.renderer.domElement)) {
      elementApply(
        this.renderer.domElement.parentElement,
        this.renderer.domElement,
        ...this.screenUISpace.elements
      );
    }
    const footsteps = new AssetFile("/audio/footsteps.mp3", Audio_Mpeg, !this.DEBUG);
    const enter = new AssetFile("/audio/basic_enter.mp3", Audio_Mpeg, !this.DEBUG);
    const exit = new AssetFile("/audio/basic_exit.mp3", Audio_Mpeg, !this.DEBUG);
    const error = new AssetFile("/audio/basic_error.mp3", Audio_Mpeg, !this.DEBUG);
    const click = new AssetFile("/audio/vintage_radio_button_pressed.mp3", Audio_Mpeg, !this.DEBUG);
    assets.push(...this.uiButtons.assets, footsteps, enter, exit, error, click);
    if (isDefined(this.watch)) {
      assets.push(this.watch.asset);
    }
    await super.load(prog, ...assets);
    await all(
      this.audio.createBasicClip("footsteps", footsteps, 0.5),
      this.interactionAudio.create("enter", enter, 0.25),
      this.interactionAudio.create("exit", exit, 0.25),
      this.interactionAudio.create("error", error, 0.25),
      this.interactionAudio.create("click", click, 1)
    );
    this.screenUISpace.show();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/ContextMenu/index.ts
var ContextMenu = class {
  constructor() {
    this.mouseX = 0;
    this.mouseY = 0;
    this.element = Div(
      className("context-menu")
    );
    elementSetDisplay(this.element, false);
    window.addEventListener("mousemove", (evt) => {
      this.mouseX = evt.clientX;
      this.mouseY = evt.clientY;
    });
  }
  async cancel() {
    if (isDefined(this.currentTask)) {
      this.currentTask.resolve("cancel");
      await this.currentTask;
      this.currentTask = null;
    }
  }
  async show(displayNamesOrFirstOption, ...options) {
    let displayNames;
    if (displayNamesOrFirstOption instanceof Map) {
      displayNames = displayNamesOrFirstOption;
    } else {
      displayNames = /* @__PURE__ */ new Map();
      options.unshift(displayNamesOrFirstOption);
    }
    if (isDefined(this.currentTask)) {
      await this.cancel();
    }
    const task = new Task();
    this.currentTask = task;
    elementClearChildren(this.element);
    elementApply(
      this.element,
      left(px(this.mouseX)),
      top(px(this.mouseY)),
      ...options.map((option) => {
        if (option instanceof HTMLHRElement) {
          option.style.width = perc(100);
          return option;
        } else {
          return Button(
            displayNames.has(option) ? displayNames.get(option) : option.toString(),
            onClick(this.currentTask.resolver(option), true)
          );
        }
      })
    );
    elementSetDisplay(this.element, true, "grid");
    this.mouseY = Math.min(this.mouseY, window.innerHeight - this.element.clientHeight - 50);
    this.element.style.top = px(this.mouseY);
    const onSideClick = this.currentTask.resolver("cancel");
    addEventListener("click", onSideClick);
    this.currentTask.finally(() => {
      elementSetDisplay(this.element, false);
      removeEventListener("click", onSideClick);
    });
    return await task;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/DockPanel/index.ts
var SIZE_KEY = "proportion";
var INDEX_KEY = "index";
function Dock(type2, ...rest) {
  return Div(
    classList("dock", type2),
    ...rest
  );
}
function isProportion(r) {
  return r instanceof Attr && r.key === SIZE_KEY;
}
var DockPanelAttr = class {
  constructor(type2, value2) {
    this.type = type2;
    this.value = value2;
  }
};
function resizable(v) {
  return new DockPanelAttr("resizable", v);
}
function rearrangeable(v) {
  return new DockPanelAttr("rearrangeable", v);
}
function isDockPanelAttr(type2, obj2) {
  return obj2 instanceof DockPanelAttr && obj2.type === type2;
}
function isResizableAttr(obj2) {
  return isDockPanelAttr("resizable", obj2);
}
function isRearrangeableAttr(obj2) {
  return isDockPanelAttr("rearrangeable", obj2);
}
function isRest(obj2) {
  return !(obj2 instanceof DockPanelAttr);
}
function DockPanel(name3, ...rest) {
  const resizable2 = arrayScanReverse(rest, isResizableAttr);
  const rearrangeable2 = arrayScanReverse(rest, isRearrangeableAttr);
  const isResizable = resizable2 && resizable2.value;
  const isRearrangeable = rearrangeable2 && rearrangeable2.value;
  const sub4 = rest.filter(isRest);
  const classes = [];
  if (isResizable) {
    classes.push("resizable");
  }
  if (isRearrangeable) {
    classes.push("rearrangeable");
  }
  let dragged = null;
  let draggedParent = null;
  let dragType = null;
  let target = null;
  const panel = Dock(
    "panel",
    id(name3),
    classList(...classes),
    onDragStart((evt) => {
      const obj2 = resolveDockObject(evt.target);
      if (isRearrangeable && isCell(obj2) || isResizable && isSep(obj2)) {
        setDraggedObject(obj2, evt.clientX, evt.clientY);
      }
    }),
    onDragOver((evt) => {
      if (isDefined(dragged)) {
        const obj2 = resolveDockObject(evt.target);
        if (isResizable && dragType === "sep") {
          evt.preventDefault();
          resizeGroup(draggedParent, dragged, evt.clientX, evt.clientY);
        } else if (isRearrangeable && dragType === "cell" && isSep(obj2)) {
          evt.preventDefault();
          setDropTarget(obj2);
        }
      }
    }),
    onDragEnd((evt) => {
      const obj2 = resolveDockObject(evt.target);
      if (obj2 === dragged && isCell(dragged) && isSep(target)) {
        moveGroup(draggedParent, target);
      }
      if (dragged) {
        dragged.classList.remove("dragging");
        dragged = null;
        draggedParent = null;
        dragType = null;
      }
      if (target) {
        target.classList.remove("targeting");
        target = null;
      }
    }),
    ...sub4
  );
  function resolveDockObject(e2) {
    let obj2 = e2;
    while (isDefined(obj2) && !obj2.classList.contains("dock")) {
      obj2 = obj2.parentElement;
    }
    return obj2;
  }
  const mouseStart = vec2_exports.create();
  const mouseEnd = vec2_exports.create();
  const mouseMove = vec2_exports.create();
  function setDraggedObject(obj2, startMouseX, startMouseY) {
    dragged = obj2;
    draggedParent = dragged.parentElement;
    dragType = getDockType(dragged);
    dragged.classList.add("dragging");
    if (isSep(dragged)) {
      vec2_exports.set(mouseStart, startMouseX, startMouseY);
    }
  }
  function setDropTarget(obj2) {
    if (target) {
      target.classList.remove("targeting");
      target = null;
    }
    target = obj2;
    target.classList.add("targeting");
  }
  function moveGroup(group2, sep) {
    let newParent = sep.parentElement;
    const insert = getDirection(newParent) === getDirection(sep);
    const index = getInsertionIndex(sep);
    if (!insert) {
      const dir = getDirectionAlt(newParent);
      newParent = elementSwap(newParent, (p) => DockGroup(dir, p));
    }
    const next = newParent.children[index];
    if (next !== dragged.nextElementSibling) {
      elementInsertBefore(newParent, group2, next);
      regrid(false);
    }
  }
  function resizeGroup(group2, sep, mouseX, mouseY) {
    vec2_exports.set(mouseEnd, mouseX, mouseY);
    vec2_exports.sub(mouseMove, mouseEnd, mouseStart);
    const r = isRow(group2);
    const dist4 = mouseMove[r ? 0 : 1];
    if (dist4 !== 0) {
      vec2_exports.copy(mouseStart, mouseEnd);
      const dim = r ? "clientWidth" : "clientHeight";
      let size4 = 0;
      let count = 0;
      group2.querySelectorAll(":scope > .dock.group").forEach((child) => {
        if (!isClosed(child)) {
          ++count;
          size4 += child[dim];
        }
      });
      const avg = size4 / count;
      const index = getInsertionIndex(sep);
      const left2 = findOpenGroup(group2, index, -1);
      const right = findOpenGroup(group2, index, 1);
      if (isDefined(left2) && isDefined(right)) {
        const leftSize = left2[dim] + dist4;
        const rightSize = right[dim] - dist4;
        const leftProp = leftSize / avg;
        const rightProp = rightSize / avg;
        setProportion(left2, leftProp);
        setProportion(right, rightProp);
        regrid(true);
      }
    }
  }
  function findOpenGroup(obj2, index, dir) {
    if (dir === -1) {
      --index;
    }
    let child = obj2.children[index];
    while (isDefined(child) && !isSep(child) && isClosed(child)) {
      index += dir;
      child = obj2.children[index];
    }
    if (isSep(child)) {
      child = null;
    }
    return child;
  }
  function getProportion(v) {
    if (!isSep(v)) {
      const str5 = localStorage.getItem(name3 + "." + v.id + ":" + SIZE_KEY) || elementGetCustomData(v, SIZE_KEY);
      return parseFloat(str5) || 1;
    }
    return null;
  }
  function setProportion(v, p) {
    if (!isSep(v)) {
      const str5 = p.toString();
      localStorage.setItem(name3 + "." + v.id + ":" + SIZE_KEY, str5);
      customData(SIZE_KEY, str5).applyToElement(v);
    }
  }
  function regrid(resize) {
    if (!resize) {
      panel.querySelectorAll(".dock.sep").forEach((sep) => sep.remove());
      panel.querySelectorAll(".dock.cell").forEach((cell) => {
        if (cell.parentElement.childElementCount > 1) {
          elementSwap(cell, (p) => DockGroupRow(p));
        }
      });
    }
    Array.from(panel.querySelectorAll(".dock.group")).reverse().forEach((group2) => {
      if (group2.childElementCount === 0) {
        group2.remove();
      } else if (group2.childElementCount === 1 && isGroup(group2.parentElement) && group2.parentElement.childElementCount === 1) {
        group2.replaceWith(...group2.children);
      } else {
        regridGroup(group2, resize);
      }
    });
  }
  function regridGroup(group2, resize) {
    if (group2.childElementCount === 1 && isColumn(group2)) {
      group2.classList.remove("column");
      group2.classList.add("row");
    }
    const gParentDir = getDirection(group2.parentElement);
    const parentDirection = getDirection(group2);
    const parentDirectionAlt = getDirectionAlt(group2);
    const r = isRow(group2);
    const gridCell = r ? gridColumn : gridRow;
    const gridCellAlt = r ? gridRow : gridColumn;
    const gridTemplate = r ? gridTemplateColumns : gridTemplateRows;
    const gridTemplateAlt = r ? gridTemplateRows : gridTemplateColumns;
    const offset = isRearrangeable ? 1 : 0;
    const center = gridCell(2, -2);
    const centerAlt = gridCellAlt(2, -2);
    const inAxis = [];
    group2.querySelectorAll(":scope > .dock:not(.sep)").forEach((e2, i) => {
      const child = e2;
      const start2 = 2 * i + offset + 1;
      gridCell(start2, start2 + 1).applyToElement(child);
      centerAlt.applyToElement(child);
      if (isClosed(child)) {
        inAxis.push("auto");
      } else {
        inAxis.push(`${getProportion(child)}fr`);
      }
    });
    for (let i = inAxis.length + offset - 1; i >= 1 - offset; --i) {
      arrayInsertAt(inAxis, "min-content", i);
    }
    const template = gridTemplate(...inAxis);
    const templateAlt = isRearrangeable ? gridTemplateAlt("min-content", fr(1), "min-content") : gridTemplateAlt("auto");
    elementApply(
      group2,
      template,
      templateAlt
    );
    if (!resize) {
      for (let l = group2.childElementCount, i = 0; i <= l; ++i) {
        const start2 = 2 * i + offset;
        const isEdge = i === 0 || i === l;
        if (!isEdge || isRearrangeable && parentDirection !== gParentDir) {
          elementApply(
            group2,
            DockSep(
              parentDirection,
              i,
              isEdge,
              gridCell(start2, start2 + 1),
              centerAlt
            )
          );
        }
      }
      if (isRearrangeable && parentDirectionAlt !== gParentDir) {
        for (let i = 0; i < 2; ++i) {
          const start2 = 2 * i + 1;
          elementApply(
            group2,
            DockSep(
              parentDirectionAlt,
              i,
              true,
              gridCellAlt(start2, start2 + 1),
              center
            )
          );
        }
      }
    }
  }
  let groupCounter = 0;
  panel.querySelectorAll(".dock.group").forEach((child) => {
    child.id = "G" + ++groupCounter;
    setProportion(child, getProportion(child));
  });
  regrid(false);
  panel.querySelectorAll(".dock.cell").forEach((child) => {
    child.querySelector(":scope > .header").draggable = isRearrangeable;
    child.addEventListener("regrid", () => regrid(false));
  });
  return panel;
}
function DockGroup(direction, ...rest) {
  return Dock(
    "group",
    classList(direction),
    ...rest
  );
}
function DockGroupColumn(...rest) {
  return DockGroup(
    "column",
    ...rest
  );
}
function DockGroupRow(...rest) {
  return DockGroup(
    "row",
    ...rest
  );
}
function getInsertionIndex(v) {
  if (isSep(v)) {
    const str5 = elementGetCustomData(v, INDEX_KEY);
    if (isNullOrUndefined(str5)) {
      return null;
    } else {
      return parseFloat(str5);
    }
  }
  return null;
}
function setInsertionIndex(v, index) {
  if (isSep(v)) {
    customData(INDEX_KEY, index.toFixed(0)).applyToElement(v);
  }
}
function DockSep(type2, index, isEdge, ...rest) {
  const classes = [type2];
  if (isEdge) {
    classes.push("edge");
  }
  const part = Dock(
    "sep",
    classList(...classes),
    draggable(!isEdge),
    ...rest
  );
  setInsertionIndex(part, index);
  return part;
}
function DockCell(header, ...rest) {
  if (isString(header) || isDate(header) || isNumber(header) || isBoolean(header)) {
    header = H3(header);
  }
  const proportion = rest.filter(isProportion);
  rest = rest.filter((e2) => !isProportion(e2));
  const content = Div(
    classList("content"),
    ...rest
  );
  const closer = ButtonSmall(
    classList("closer"),
    blackMediumDownPointingTriangleCentered.emojiStyle,
    onClick(() => {
      elementToggleDisplay(content, "grid");
      const isOpen = elementIsDisplayed(content);
      elementSetText(closer, isOpen ? blackMediumDownPointingTriangleCentered.emojiStyle : blackMediumRightPointingTriangleCentered.emojiStyle);
      cell.classList.toggle("closed", !isOpen);
      cell.dispatchEvent(new Event("regrid"));
    })
  );
  const cell = Dock(
    "cell",
    ...proportion,
    closer,
    elementApply(
      header,
      draggable(true),
      classList("header")
    ),
    content
  );
  return DockGroupRow(cell);
}
function isDockType(type2, v) {
  return isDefined(v) && v.classList.contains(type2);
}
function isPanel(v) {
  return isDockType("panel", v);
}
function isSep(v) {
  return isDockType("sep", v);
}
function isCell(v) {
  return isDockType("cell", v);
}
function isGroup(v) {
  return isDockType("group", v);
}
function getDockType(v) {
  if (isPanel(v)) {
    return "panel";
  } else if (isSep(v)) {
    return "sep";
  } else if (isCell(v)) {
    return "cell";
  } else if (isGroup(v)) {
    return "group";
  }
  return null;
}
function isClosed(v) {
  if (isCell(v)) {
    return v.classList.contains("closed");
  } else if (isGroup(v)) {
    for (let i = 0; i < v.childElementCount; ++i) {
      if (!isClosed(v.children[i])) {
        return false;
      }
    }
    return true;
  } else if (isSep(v)) {
    return true;
  } else {
    return false;
  }
}
function isDirection(type2, v) {
  return isDefined(v) && v.classList.contains(type2);
}
function isColumn(v) {
  return isDirection("column", v);
}
function isRow(v) {
  return isDirection("row", v);
}
function getDirection(v) {
  if (isRow(v)) {
    return "row";
  } else if (isColumn(v)) {
    return "column";
  } else {
    return null;
  }
}
function getDirectionAlt(v) {
  if (isRow(v)) {
    return "column";
  } else if (isColumn(v)) {
    return "row";
  } else {
    return null;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/TabPanel/index.ts
var TabPanelTabSelectedEvent = class extends TypedEvent {
  constructor(tabname) {
    super("tabselected");
    this.tabname = tabname;
  }
};
function isRule(obj2) {
  return obj2 instanceof CssElementStyleProp || obj2 instanceof Attr;
}
function isViewDef(obj2) {
  return !isRule(obj2);
}
var TabPanel = class extends TypedEventBase {
  constructor(element) {
    super();
    this.element = element;
    this.views = /* @__PURE__ */ new Map();
    this.curTab = null;
    this._disabled = false;
    let counter = 0;
    const btns = [...element.querySelectorAll(".tabs > button")].map((btn) => [btn.dataset.panelname || `tab${++counter}`, btn]);
    const buttons = new Map(btns);
    counter = 0;
    const panels = new Map(
      [...element.querySelectorAll(".panels > *")].map((panel) => [panel.id || `tab${++counter}`, panel])
    );
    for (const [name3, button] of buttons) {
      const panel = panels.get(name3);
      button.addEventListener("click", () => {
        this.select(name3);
        this.dispatchEvent(new TabPanelTabSelectedEvent(name3));
      });
      let displayType = panel.style.display;
      if (displayType = "none") {
        displayType = null;
      }
      this.views.set(name3, {
        button,
        displayType,
        panel
      });
    }
    if (btns.length > 0) {
      this.select(btns[0][0]);
    }
  }
  static find() {
    return Array.from(TabPanel._find());
  }
  static *_find() {
    for (const elem of getElements(".tab-panel")) {
      yield new TabPanel(elem);
    }
  }
  static create(...entries) {
    const rules = entries.filter(isRule);
    const viewDefs = entries.filter(isViewDef);
    const viewsByName = /* @__PURE__ */ new Map();
    let firstName = null;
    for (const viewDef of viewDefs) {
      const [name3, label, panel] = viewDef;
      const panelName = customData("panelname", name3);
      if (isNullOrUndefined(firstName)) {
        firstName = name3;
      }
      const elem = resolveElement(panel);
      const displayType = elem.style.display;
      elementApply(panel, id(name3));
      viewsByName.set(name3, {
        panel,
        displayType,
        button: ButtonSmall(
          label,
          panelName
        )
      });
    }
    const views = Array.from(viewsByName.values());
    return new TabPanel(Div(
      className("tab-panel"),
      ...rules,
      Div(
        className("tabs"),
        ...views.map((p) => p.button)
      ),
      Div(
        className("panels"),
        ...views.map((p) => p.panel)
      )
    ));
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    this._disabled = v;
    for (const [name3, view] of this.views) {
      view.button.disabled = v || name3 === this.curTab;
      elementSetClass(view.panel, v, "disabled");
      if (isDisableable(view.panel)) {
        view.panel.disabled = v;
      } else {
        const elem = resolveElement(view.panel);
        if (isDisableable(elem)) {
          elem.disabled = v;
        }
      }
    }
  }
  isSelected(name3) {
    return this.curTab === name3;
  }
  select(name3) {
    if (this.views.has(name3)) {
      this.curTab = name3;
      for (const [name4, view] of this.views) {
        const visible = name4 === this.curTab;
        view.button.disabled = visible || this.disabled;
        elementSetDisplay(view.panel, visible, view.displayType);
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/RefreshEvent.ts
var RefreshEvent = class extends TypedEvent {
  constructor() {
    super("refresh");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/BootstrapProgressBar.ts
var BootstrapProgressBarElement = class {
  constructor(outerClassName = "controls progress") {
    const inner = Div(
      className("progress-bar"),
      role("progressbar"),
      ariaValueNow(0),
      ariaValueMin(0),
      ariaValueMax(1),
      width(0)
    );
    this.element = Div(
      className(outerClassName),
      inner
    );
    this.progress = new BootstrapProgressBarCallback(inner);
  }
  clear() {
    this.progress.clear();
  }
  report(soFar, total, message2, est) {
    this.progress.report(soFar, total, message2, est);
  }
  attach(prog) {
    this.progress.attach(prog);
  }
  start(msg) {
    this.progress.start(msg);
  }
  end(msg) {
    this.progress.end(msg);
  }
};
var BootstrapProgressBarCallback = class extends BaseProgress {
  constructor(progressBar, showMessage = true) {
    super();
    this.progressBar = progressBar;
    this.showMessage = showMessage;
  }
  report(soFar, total, message2, estimate) {
    super.report(soFar, total, message2, estimate);
    if (soFar === 0) {
      this.progressBar.style.width = "0";
      this.progressBar.setAttribute("aria-valuenow", "0");
    } else {
      const percent = (100 * this.p).toFixed(1);
      this.progressBar.style.width = `${percent}%`;
      this.progressBar.setAttribute("aria-valuenow", percent);
    }
    if (this.showMessage) {
      elementSetText(this.progressBar, message2 || "");
    }
  }
};
function BootstrapProgressBar(outerClassName = "controls progress") {
  return new BootstrapProgressBarElement(outerClassName);
}

// src/dom-apps/editor/Throttler.ts
var Throttler = class {
  constructor(debounceSeconds = 0.25) {
    this.debounceSeconds = debounceSeconds;
    this.timer = null;
    this.curTask = null;
    this.nextTask = null;
  }
  throttle(callback) {
    if (isDefined(this.curTask)) {
      this.nextTask = callback;
    } else {
      if (isDefined(this.timer)) {
        clearTimeout(this.timer);
        this.timer = null;
      }
      this.timer = setTimeout(async () => {
        this.timer = null;
        this.run(callback);
      }, this.debounceSeconds * 1e3);
    }
  }
  async run(callback) {
    this.curTask = callback();
    await this.curTask;
    const next = this.nextTask;
    if (isDefined(next)) {
      this.nextTask = null;
      this.run(next);
    } else {
      this.curTask = null;
    }
  }
};

// src/vr-apps/yarrow/data.ts
function isGeographicData(obj2) {
  return isDefined(obj2) && isDefined(obj2.location);
}
function isScenarioFileAssetData(obj2) {
  return isDefined(obj2) && isDefined(obj2.transformID);
}
var Video_Vnd_DlsDc_YtDlp_Json = /* @__PURE__ */ specialize("video")("vnd.dlsdc.ytdlp+json", "ytdlp.json", "ytdlp", "json");
var Image_Vendor_Google_StreetView_Pano = (
  /*@__PURE_*/
  specialize("image")("vnd.google.streetview.pano")
);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/YouTubeProxy.ts
function isYouTube(url2) {
  return url2.hostname === "www.youtube.com" || url2.hostname === "youtube.com" || url2.hostname === "youtu.be";
}
var codecReplaces = /* @__PURE__ */ new Map([
  ["vp9", "vp09.00.10.08"]
]);
function classifyFormat(f2) {
  if (isNullOrUndefined(f2.vcodec) || f2.vcodec === "none") {
    return "audio";
  }
  return "video";
}
function combineContentTypeAndCodec(content_type, codec) {
  const parts = [content_type];
  if (isDefined(codec) && codec.length > 0 && codec !== "none") {
    codec = codecReplaces.get(codec) || codec;
  }
  if (isDefined(codec) && codec.length > 0 && codec !== "none") {
    const asterisk2 = encodeURI(codec) !== codec ? "*" : "";
    parts.push(`codecs${asterisk2}="${codec}"`);
  }
  return parts.join(";");
}
var YouTubeProxy = class {
  constructor(fetcher2, makeProxyURL2) {
    this.fetcher = fetcher2;
    this.makeProxyURL = makeProxyURL2;
  }
  makeVideoRecord(f2) {
    const { content_type, acodec, vcodec } = f2;
    const fullContentType = combineContentTypeAndCodec(content_type, vcodec);
    return {
      contentType: fullContentType,
      url: this.makeProxyURL(f2.url).href,
      acodec,
      abr: f2.abr * 1024,
      asr: f2.asr,
      vcodec,
      vbr: f2.vbr * 1024,
      fps: f2.fps,
      width: f2.width,
      height: f2.height,
      resolution: f2.width * f2.height
    };
  }
  makeAudioRecord(f2) {
    const { content_type, acodec } = f2;
    const fullContentType = combineContentTypeAndCodec(content_type, acodec);
    return {
      contentType: fullContentType,
      url: this.makeProxyURL(f2.url).href,
      acodec,
      abr: f2.abr * 1024,
      asr: f2.asr,
      resolution: f2.abr
    };
  }
  makeImageRecord(f2) {
    const { content_type, url: url2, width: width2, height: height2 } = f2;
    return {
      contentType: content_type,
      url: this.makeProxyURL(url2).href,
      width: width2,
      height: height2,
      resolution: width2 * height2
    };
  }
  async loadData(pageURLOrMetadata, prog) {
    if (isNullOrUndefined(pageURLOrMetadata)) {
      throw new Error("must provide a YouTube URL or a YTMetadata object");
    }
    if (isDefined(prog)) {
      prog.start();
    }
    let metadata = null;
    if (isString(pageURLOrMetadata)) {
      metadata = await this.fetcher.get(pageURLOrMetadata).progress(prog).object().then(unwrapResponse);
    } else {
      if (isDefined(prog)) {
        prog.end(pageURLOrMetadata.title);
      }
      metadata = pageURLOrMetadata;
    }
    let startTime = 0;
    if (isDefined(metadata.original_url)) {
      const url2 = new URL(metadata.original_url);
      if (isYouTube(url2) && url2.searchParams.has("t")) {
        startTime = parseFloat(url2.searchParams.get("t"));
      }
    }
    const formats = new PriorityList((await Promise.all(metadata.formats)).map((f2) => [classifyFormat(f2), f2]));
    const title2 = metadata.title;
    const thumbnails = metadata.thumbnails || [];
    const thumbnail = metadata.thumbnail && this.makeImageRecord(arrayScan(thumbnails, (t2) => t2.url === metadata.thumbnail));
    const videos = formats.get("video").map((f2) => this.makeVideoRecord(f2));
    const audios = formats.get("audio").map((f2) => this.makeAudioRecord(f2));
    const data = {
      title: title2,
      thumbnail,
      videos,
      audios,
      startTime
    };
    return data;
  }
};

// src/vr-apps/yarrow/proxy.ts
function resolveURL(url2) {
  if (isNullOrUndefined(url2)) {
    return null;
  }
  if (isString(url2)) {
    url2 = new URL(url2, location.href);
  }
  return url2;
}
function isProxyableDomain(url2) {
  if (isNullOrUndefined(url2)) {
    return false;
  }
  url2 = resolveURL(url2);
  return isYouTube(url2);
}
function stripParameters(url2) {
  if (isNullOrUndefined(url2)) {
    throw new Error("URL is undefined");
  }
  url2 = resolveURL(url2);
  if (isYouTube(url2)) {
    const toRemove = Array.from(url2.searchParams.keys()).filter((key) => key !== "v" && key !== "t");
    for (const key of toRemove) {
      url2.searchParams.delete(key);
    }
  }
  return url2;
}
function makeProxyURL(url2) {
  url2 = resolveURL(url2);
  if (isNullOrUndefined(url2)) {
    throw new Error("URL is undefined");
  }
  url2 = stripParameters(url2);
  return new URLBuilder("/vr/link", location.href).query("q", url2.href).toURL();
}

// src/file-picker/FilePickerEvents.ts
var SelectingEvent = class extends TypedEvent {
  constructor() {
    super("selecting");
  }
};
var URLSelectedEvent = class extends TypedEvent {
  constructor(file) {
    super("urlselected");
    this.file = file;
  }
};
var FileDataSelectedEvent = class extends TypedEvent {
  constructor(file) {
    super("filedataselected");
    this.file = file;
  }
};
var FileSelectedEvent = class extends TypedEvent {
  constructor(file, mediaType) {
    super("fileselected");
    this.file = file;
    this.mediaType = mediaType;
  }
};

// src/file-picker/TagPicker.ts
var TagPickerTagsChangedEvent = class extends TypedEvent {
  constructor(tags) {
    super("tagschanged");
    this.tags = tags;
  }
};
var fullWidth = width(perc(100));
var TagPicker = class extends TypedEventBase {
  constructor(newTagNameOrExistingTagsID, addTagButton, removeTagButton, tagsList) {
    super();
    this._tags = new Array();
    this.element = Div(
      display("grid"),
      gridAutoFlow("row"),
      width(em(10))
    );
    if (isString(newTagNameOrExistingTagsID)) {
      this.newTagName = InputText(
        id("newTagName"),
        list(newTagNameOrExistingTagsID),
        fullWidth
      );
      this.addTagButton = ButtonPrimary(
        id("addTagButton"),
        fullWidth,
        "Add"
      );
      this.removeTagButton = ButtonDanger(
        id("removeTagButton"),
        fullWidth,
        "Remove"
      );
      this.tagsList = Select(
        id("tagsList"),
        multiple(true),
        fullWidth
      );
    } else {
      this.newTagName = newTagNameOrExistingTagsID;
      this.addTagButton = addTagButton;
      this.removeTagButton = removeTagButton;
      this.tagsList = tagsList;
      this.newTagName.replaceWith(this.element);
    }
    elementApply(
      this.element,
      this.newTagName,
      this.addTagButton,
      this.tagsList,
      this.removeTagButton
    );
    this.addTagButton.disabled = true;
    this.removeTagButton.disabled = true;
    this.newTagName.addEventListener("input", () => {
      this.addTagButton.disabled = this.newTagName.value.length === 0;
    });
    const addTag = () => {
      if (this.newTagName.value.length > 0) {
        this.updateTags(this.newTagName.value.toLocaleLowerCase(), null);
      }
    };
    this.addTagButton.addEventListener("click", addTag);
    this.newTagName.addEventListener("keydown", makeEnterKeyEventHandler(addTag));
    this.tagsList.addEventListener("input", () => {
      this.removeTagButton.disabled = this.tagsList.selectedIndex === -1;
    });
    this.removeTagButton.addEventListener("click", () => {
      if (this.tagsList.selectedIndex > -1) {
        const tag2 = this.tagsList.selectedOptions[0].value;
        this.updateTags(null, tag2);
      }
    });
  }
  updateTags(newTag, oldTag) {
    const tags = new Array();
    if (newTag !== null) {
      newTag = newTag.trim().toLocaleLowerCase();
      if (newTag.length > 0) {
        arraySortedInsert(tags, newTag, false);
      }
    }
    for (let i = 0; i < this.tagsList.options.length; ++i) {
      const tag2 = this.tagsList.options[i].value;
      if (tag2 !== oldTag) {
        arraySortedInsert(tags, tag2, false);
      }
    }
    this.tags = tags;
    this.dispatchEvent(new TagPickerTagsChangedEvent(tags));
  }
  get tags() {
    return this._tags;
  }
  set tags(tags) {
    arrayReplace(this._tags, ...tags);
    this._tags.sort();
    elementClearChildren(this.tagsList);
    this.tagsList.append(...tags.map((t2) => Option(value(t2), t2)));
    this.newTagName.value = "";
    this.addTagButton.disabled = this.removeTagButton.disabled = true;
  }
};

// src/file-picker/FilePickerLinkTab.ts
function makeXUrlBlob(url2) {
  return new Blob([url2.href], { type: Application_X_Url.value });
}
var FilePickerLinkTab = class extends TypedEventBase {
  constructor(fetcher2, existingTagsID) {
    super();
    this.fetcher = fetcher2;
    this.selectedType = null;
    this.selectedURL = null;
    this.typeFilters = new Array();
    this.accept = null;
    this.selectedName = null;
    this.checkingURL = false;
    this.element = Div(
      PropertyList.create(
        [
          "File",
          this.urlInput = InputURL(
            placeHolder("Paste in URL to file"),
            required(true)
          ),
          this.loadingIndicator = Span(
            display("none"),
            clockwiseVerticalArrows.emojiStyle
          ),
          this.selectionMessage = Div()
        ],
        [
          "Copyright",
          this.copyrightInput = InputText(
            id("copyright"),
            name2("copyright"),
            required(true)
          )
        ],
        [
          "Copyright date",
          this.copyrightDateInput = InputDate(
            id("copyrightDate"),
            name2("copyrightDate"),
            required(true)
          )
        ],
        [
          "Tags",
          this.tagPicker = new TagPicker(existingTagsID)
        ]
      ),
      this.uploadProgress = BootstrapProgressBar("progress")
    );
    const refresh = () => this.refresh();
    this.urlInput.addEventListener("input", refresh);
    this.copyrightInput.addEventListener("input", refresh);
    this.copyrightDateInput.addEventListener("input", refresh);
    const checker = new Throttler(1);
    this.urlInput.addEventListener("input", () => {
      if (this.urlInput.value.length > 0 && !/^[a-z]+:\/\//.test(this.urlInput.value)) {
        const { selectionStart, selectionEnd, selectionDirection } = this.urlInput;
        const slug = "https://";
        this.urlInput.value = slug + this.urlInput.value;
        this.urlInput.setSelectionRange(
          selectionStart + slug.length,
          selectionEnd + slug.length,
          selectionDirection
        );
      }
      if (this.hasURL) {
        this.checkingURL = true;
        elementSetDisplay(this.loadingIndicator, true, "inline-block");
        checker.throttle(async () => {
          try {
            this.dispatchEvent(new SelectingEvent());
            this.selectedURL = new URL(this.urlInput.value);
            if (isProxyableDomain(this.selectedURL)) {
              this.selectedURL = stripParameters(this.selectedURL);
              this.urlInput.value = this.selectedURL.href;
              const mediaType = this.selectedType = Video_Vnd_DlsDc_YtDlp_Json.value;
              const fileURL = makeProxyURL(this.selectedURL);
              const metadata = await this.fetcher.get(fileURL).object().then(unwrapResponse);
              const name3 = this.selectedName = metadata.title;
              const copyright = this.copyrightInput.value = metadata.uploader;
              const year = metadata.upload_date.substring(0, 4);
              const month = metadata.upload_date.substring(4, 6);
              const day = metadata.upload_date.substring(6, 8);
              const copyrightDate = this.copyrightDateInput.valueAsDate = /* @__PURE__ */ new Date(`${year}/${month}/${day}`);
              ;
              const file = {
                filePath: fileURL.href,
                mediaType,
                name: name3,
                copyright,
                copyrightDate,
                size: null,
                sizeString: "--",
                id: null,
                tagsString: null,
                metadata
              };
              this.dispatchEvent(new FileDataSelectedEvent(file));
            } else {
              const response = await this.fetcher.head(makeProxyURL(this.selectedURL)).exec();
              const parts = this.selectedURL.pathname.split("/");
              this.copyrightInput.value = this.selectedURL.hostname;
              this.copyrightDateInput.valueAsDate = response.date;
              this.selectedName = response.fileName || parts[parts.length - 1];
              this.selectedType = response.contentType;
              this.dispatchEvent(new URLSelectedEvent(this.selectedURL));
            }
            this.checkingURL = false;
            this.refresh();
          } catch (exp2) {
            this.selectedType = null;
            this.checkingURL = false;
            this.refresh("Not a valid target");
          }
        });
      }
      this.refresh();
    });
  }
  clearFileSelection(tags) {
    this.uploadProgress.clear();
    this.selectedType = null;
    this.urlInput.value = null;
    this.copyrightInput.value = null;
    this.copyrightDateInput.value = null;
    this.tagPicker.tags = tags;
    this.refresh();
  }
  addMessage(msg) {
    elementApply(this.selectionMessage, Div(msg));
  }
  refresh(errMsg) {
    elementClearChildren(this.selectionMessage);
    if (isString(errMsg)) {
      this.addMessage(errMsg);
    } else if (this.hasURL && !this.checkingURL && !this.hasType) {
      this.addMessage("No file found at give location");
    } else if (this.hasType && !this.hasCorrectType) {
      this.addMessage(`Unexpected file type: ${this.selectedType}. Expected: ${this.accept}`);
    }
    if (!this.hasCopyright) {
      this.addMessage("Copyright holder is required");
    }
    if (!this.hasCopyrightDate) {
      this.addMessage("Copyright date is required");
    }
    elementSetDisplay(this.loadingIndicator, this.checkingURL);
    this.dispatchEvent(new RefreshEvent());
  }
  setTypeFilters(...types) {
    arrayReplace(this.typeFilters, ...types);
    this.accept = mediaTypesToAcceptValue(types);
  }
  isExpectedType(contentType) {
    if (isNullOrUndefined(contentType)) {
      return false;
    }
    if (this.typeFilters.length === 0) {
      return true;
    }
    return this.typeFilters.map((t2) => t2.matches(contentType)).reduce((a, b) => a || b, false);
  }
  get tagString() {
    return this.tagPicker.tags.join();
  }
  get hasURL() {
    return this.urlInput.validity.valid;
  }
  get hasFile() {
    return isDefined(this.selectedURL);
  }
  get hasType() {
    return isDefined(this.selectedType);
  }
  get hasCorrectType() {
    return this.isExpectedType(this.selectedType);
  }
  get hasCopyright() {
    return this.copyrightInput.value.length > 0;
  }
  get hasCopyrightDate() {
    return this.copyrightDateInput.validity.valid;
  }
  get requirementsMet() {
    return this.hasURL && this.hasFile && this.hasCorrectType && this.hasCopyright && this.hasCopyrightDate;
  }
  async upload() {
    try {
      const form = new FormData();
      const blob = makeXUrlBlob(this.selectedURL);
      form.set("FormFile", blob, this.selectedName);
      form.set("AltContentType", this.selectedType);
      form.set("Copyright", this.copyrightInput.value);
      form.set("CopyrightDate", this.copyrightDateInput.valueAsDate.toDateString());
      form.set("TagString", this.tagString);
      return await this.fetcher.post("/editor/files/create").body(form).progress(this.uploadProgress).object().then(unwrapResponse);
    } catch (exp2) {
      console.error(exp2);
      throw exp2;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/dom/getColumnIndex.ts
function getColumnIndex(element) {
  let column = element;
  while (column && column.tagName !== "TD" && column.tagName !== "TH") {
    column = column.parentElement;
  }
  if (column) {
    const columnRow = column.parentElement;
    let columnIndex = 0;
    for (const child of columnRow.children) {
      if (child === column) {
        return columnIndex;
      }
      if (child instanceof HTMLTableCellElement) {
        columnIndex += child.colSpan;
      }
    }
  }
  return -1;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/debounce.ts
function debounce(timeOrAction, action) {
  let time = 0;
  if (isNumber(timeOrAction)) {
    time = timeOrAction;
  } else {
    action = timeOrAction;
  }
  let ready = true;
  return (...args) => {
    if (ready) {
      ready = false;
      setTimeout(() => {
        ready = true;
        action(...args);
      }, time);
    }
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/FilterableTable/index.ts
function makeDate(value2) {
  if (/^\d{4}-\d\d?-\d\d?$/.test(value2)) {
    var parts = value2.split("-");
    var year = parts.shift();
    parts.push(year);
    value2 = parts.join("/");
  }
  return new Date(value2);
}
function isRangeStart(filterElement) {
  return filterElement.classList.contains("range-start");
}
function isRangeEnd(filterElement) {
  return filterElement.classList.contains("range-end");
}
function parseValue(input, value2) {
  if (input instanceof HTMLInputElement && (input.type.startsWith("date") || input.type.startsWith("time") || input.type.startsWith("month") || input.type.startsWith("week"))) {
    return value2 && makeDate(value2) || null;
  } else if (input instanceof HTMLInputElement && (input.type === "number" || input.type === "range")) {
    return value2 && parseFloat(value2) || null;
  } else {
    return value2 && value2.toLocaleLowerCase() || null;
  }
}
function getCellValue(cell, filterElement) {
  const inputs = Array.from(cell.querySelectorAll("input"));
  if (inputs.length === 0) {
    const text2 = cell.textContent.trim();
    return [parseValue(filterElement, text2)];
  } else {
    return inputs.map((input) => parseValue(input, input.value));
  }
}
var DEFAULT_PAGE_SIZES = [
  10,
  25,
  50,
  100
];
var FilterableTable = class {
  constructor(element) {
    this.element = element;
    this.ranges = /* @__PURE__ */ new Map();
    this.valueCache = /* @__PURE__ */ new Map();
    this.resetButton = null;
    this.cellMappers = /* @__PURE__ */ new Map();
    this.pageSizes = [0, ...DEFAULT_PAGE_SIZES];
    this.update = debounce(this._update.bind(this));
    this.resourceName = this.element.dataset.resourcename;
    this.pageIndexKey = `${this.resourceName}-page-index`;
    this.pageSizeKey = `${this.resourceName}-page-size`;
    this.rows = Array.from(this.element.querySelectorAll("tbody > tr"));
    this.ranges = /* @__PURE__ */ new Map();
    if (this.element.tHead) {
      this.filterElements = [
        ...this.element.tHead.querySelectorAll("input,select")
      ];
      this.resetButton = this.element.tHead.querySelector("button[type=reset]");
    } else {
      this.filterElements = [];
    }
    this.colCount = Math.max(
      ...Array.from(this.element.querySelectorAll("tr")).map((r) => r.children.length)
    );
    this.noContentMessageElement = TR(TD(colSpan(this.colCount), "No content"));
    this.paginator = TD(colSpan(this.colCount), classList("multi"));
    this.columnIndices = /* @__PURE__ */ new Map();
    if (this.resetButton) {
      this.resetButton.addEventListener("click", () => {
        this.valueCache.clear();
        for (const element2 of this.filterElements) {
          this.deleteValue(element2);
          element2.value = "";
        }
        this.update();
      });
    }
    if (!this.element.tFoot) {
      this.element.tFoot = TFoot();
    }
    elementApply(
      this.element.tFoot,
      this.noContentMessageElement,
      ...this.element.tFoot.children,
      TR(this.paginator)
    );
    for (const f2 of this.filterElements) {
      const idx = getColumnIndex(f2);
      this.columnIndices.set(f2, idx);
      f2.addEventListener("input", this.update.bind(null, f2));
      this.restoreValue(f2);
      if (isRangeStart(f2) || isRangeEnd(f2)) {
        if (!this.ranges.has(idx)) {
          this.ranges.set(idx, [null, null]);
        }
        const range = this.ranges.get(idx);
        const part = isRangeStart(f2) ? 0 : 1;
        range[part] = f2;
      }
    }
    for (const f2 of this.element.querySelectorAll("input")) {
      f2.classList.add("form-control", "form-control-sm");
    }
    for (const f2 of this.element.querySelectorAll("select")) {
      f2.classList.add("custom-select", "custom-select-sm");
    }
    this.pageIndex = parseFloat(localStorage.getItem(this.pageIndexKey) || "0");
    this.pageSize = parseFloat(localStorage.getItem(this.pageSizeKey) || "10");
    if (isDefined(this.element.dataset.pagesizes) && this.element.dataset.pagesizes.length > 0) {
      const sizes = this.element.dataset.pagesizes.split(",").map((v) => parseFloat(v.trim())).filter(identity);
      this.setPageSizes(sizes);
    } else {
      this.update();
    }
  }
  static create(options) {
    const headerRow = TR();
    const filterRow = TR();
    let burnHeader = 0;
    let burnFilter = 0;
    for (const column of options.columns) {
      let filterId = null;
      if (burnHeader > 0) {
        --burnHeader;
      } else {
        const header = Label(column.header);
        if (column.filter) {
          filterId = stringRandom(10);
          header.htmlFor = filterId;
        }
        const headerCell = TH(header);
        if (isDefined(column.headerColSpan)) {
          headerCell.colSpan = column.headerColSpan;
          burnHeader = column.headerColSpan - 1;
        }
        headerRow.appendChild(headerCell);
      }
      if (burnFilter > 0) {
        --burnFilter;
      } else if (column.filter) {
        const filter = column.filter;
        if (filterId) {
          filter.id = filterId;
        }
        if (column.header && filter instanceof HTMLInputElement) {
          filter.placeholder = "Filter by " + column.header;
        }
        const filterCell = TH(filter);
        if (isDefined(column.filterColSpan)) {
          filterCell.colSpan = column.filterColSpan;
          burnFilter = column.filterColSpan - 1;
        }
        filterRow.appendChild(filterCell);
      }
    }
    let lastColumn = getColumnIndex(headerRow.lastElementChild) - 1;
    while (getColumnIndex(filterRow.lastElementChild) < lastColumn) {
      filterRow.appendChild(TH());
    }
    filterRow.appendChild(TH(ButtonReset(classList("btn", "btn-secondary"), "Reset")));
    lastColumn = getColumnIndex(filterRow.lastElementChild);
    while (lastColumn > getColumnIndex(headerRow.lastElementChild)) {
      headerRow.appendChild(TH());
    }
    const table = new FilterableTable(Table(
      classList("table", "table-responsive", "table-hover", "table-striped", "summary"),
      customData("resourcename", options.resourceName),
      THead(
        headerRow,
        filterRow
      ),
      TBody()
    ));
    options.columns.forEach((c, i) => table.setCellMapper(i, c.getCellValue));
    table.setPageSizes(options.pageSizes || DEFAULT_PAGE_SIZES);
    return table;
  }
  get pageIndex() {
    return this._pageIndex;
  }
  set pageIndex(v) {
    this._pageIndex = v;
    localStorage.setItem(this.pageIndexKey, v.toString());
  }
  get pageSize() {
    return this._pageSize;
  }
  set pageSize(v) {
    this._pageSize = v;
    localStorage.setItem(this.pageSizeKey, v.toString());
  }
  setPageSizes(pageSizes) {
    if (isNullOrUndefined(pageSizes) || pageSizes.length === 0) {
      throw new Exception("Need at least one page size");
    }
    arrayReplace(this.pageSizes, 0, ...pageSizes);
    this.pageSize = this.pageSizes[1];
    this.update();
  }
  setCellMapper(columnIndex, mapper) {
    this.cellMappers.set(columnIndex, mapper);
  }
  clear() {
    arrayClear(this.rows);
    for (const body of this.element.tBodies) {
      elementClearChildren(body);
    }
    this._update();
  }
  setValues(...values) {
    const newRows = values.map((value2) => {
      const row = TR();
      for (let i = 0; i < this.colCount; ++i) {
        const cell = TD();
        if (this.cellMappers.has(i)) {
          elementApply(cell, this.cellMappers.get(i)(value2, row));
        }
        row.appendChild(cell);
      }
      this.rows.push(row);
      return row;
    });
    arrayReplace(this.rows, ...newRows);
    for (const body of this.element.tBodies) {
      elementClearChildren(body);
    }
    elementApply(
      this.contentRoot,
      ...this.rows
    );
    this._update();
  }
  select(sel) {
    let selectedIndex = null;
    for (let i = 0; i < this.rows.length; ++i) {
      const row = this.rows[i];
      const selected2 = row === sel;
      elementSetClass(row, selected2, "selected");
      if (selected2) {
        selectedIndex = i;
      }
    }
    if (selectedIndex !== null) {
      this.pageIndex = Math.floor(selectedIndex / this.pageSize) * this.pageSize;
      this.update();
    }
  }
  get noContentMessage() {
    return elementGetText(this.noContentMessageElement);
  }
  set noContentMessage(v) {
    elementSetText(this.noContentMessageElement, v);
  }
  get contentRoot() {
    return this.element.tBodies[0];
  }
  makeKey(filterElement) {
    return `yarrow:${this.resourceName}:${filterElement.id}`;
  }
  saveValue(filterElement, value2) {
    const key = this.makeKey(filterElement);
    if (value2) {
      localStorage.setItem(key, value2.toString());
    } else {
      localStorage.removeItem(key);
    }
  }
  deleteValue(filterElement) {
    const key = this.makeKey(filterElement);
    localStorage.removeItem(key);
  }
  restoreValue(input) {
    const key = this.makeKey(input);
    const value2 = localStorage.getItem(key);
    if (!isDefined(value2)) {
      input.value = "";
    } else if (input instanceof HTMLSelectElement) {
      input.value = value2;
      this.valueCache.set(input, input.value);
    } else if (input.type.startsWith("date")) {
      const date = makeDate(value2);
      input.valueAsDate = date;
      this.valueCache.set(input, date);
    } else if (input.type === "number" || input.type === "range") {
      const number = parseFloat(value2);
      input.valueAsNumber = number;
      this.valueCache.set(input, number);
    } else {
      input.value = value2;
      this.valueCache.set(input, input.value);
    }
  }
  isRange(filterElement) {
    const idx = getColumnIndex(filterElement);
    return this.ranges.has(idx);
  }
  _update(updatedElement = null) {
    if (isDefined(updatedElement)) {
      const value2 = parseValue(updatedElement, updatedElement.value);
      this.saveValue(updatedElement, value2);
      if (value2) {
        this.valueCache.set(updatedElement, value2);
      } else {
        this.valueCache.delete(updatedElement);
      }
    }
    if (this.resetButton) {
      buttonSetEnabled(this.resetButton, this.valueCache.size > 0, "Reset", "Clear out filters");
      elementSetClass(this.resetButton, this.valueCache.size > 0, "btn-secondary");
      elementSetClass(this.resetButton, this.valueCache.size === 0, "btn-outline-secondary");
    }
    let showCount = 0;
    for (let r = 0; r < this.rows.length; ++r) {
      const row = this.rows[r];
      let showCell = true;
      for (let f2 = 0; f2 < this.filterElements.length && showCell; ++f2) {
        const element = this.filterElements[f2];
        const columnIndex = this.columnIndices.get(element);
        if (this.isRange(element)) {
          const [minFilterElement, maxFilterElement] = this.ranges.get(columnIndex);
          const minFilterValue = this.valueCache.get(minFilterElement);
          const maxFilterValue = this.valueCache.get(maxFilterElement);
          const cell = row.children[columnIndex];
          const cellValues = getCellValue(cell, minFilterElement);
          let matches = null;
          if (isDefined(minFilterValue) && isDefined(maxFilterValue)) {
            matches = cellValues.map((cellValue) => minFilterValue <= cellValue && cellValue <= maxFilterValue);
          } else if (isDefined(minFilterValue)) {
            matches = cellValues.map((cellValue) => minFilterValue <= cellValue);
          } else if (isDefined(maxFilterValue)) {
            matches = cellValues.map((cellValue) => cellValue <= maxFilterValue);
          }
          if (matches) {
            const match = matches.reduce((a, b) => a || b, false);
            showCell &&= match;
          }
        } else {
          const filterValue = this.valueCache.get(element);
          if (filterValue) {
            const cell = row.children[columnIndex];
            const cellValues = getCellValue(cell, element);
            const matches = cellValues.map((cellValue) => isNullOrUndefined(cellValue) ? true : isDate(cellValue) ? filterValue.getTime() === cellValue.getTime() : isNumber(cellValue) ? cellValue === filterValue : filterValue === "XXX_NONE_XXX" ? cellValue.length === 0 || cellValue === "NONE" : element.classList.contains("exact") ? cellValue.toLocaleLowerCase() === filterValue : cellValue.toLocaleLowerCase().indexOf(filterValue) > -1);
            const match = matches.reduce((a, b) => a || b, false);
            showCell &&= match;
          }
        }
      }
      if (showCell) {
        ++showCount;
      }
      row.style.display = showCell ? "" : "none";
    }
    const numPages = Math.ceil(showCount / this.pageSize);
    const lastPage = Math.max(0, numPages - 1);
    const curPage = Math.min(lastPage, Math.floor(this.pageIndex / this.pageSize));
    this.pageIndex = curPage * this.pageSize;
    const nextPage = Math.min(lastPage, curPage + 1);
    const prevPage = Math.max(0, curPage - 1);
    const minIndex = curPage * this.pageSize;
    const maxIndex = minIndex + this.pageSize;
    const filteredRows = this.rows.filter((r) => r.style.display !== "none");
    for (let i = 0; i < filteredRows.length; ++i) {
      if (i < minIndex || maxIndex <= i) {
        filteredRows[i].style.display = "none";
      }
    }
    this.noContentMessageElement.style.display = showCount === 0 ? "" : "none";
    elementClearChildren(this.paginator);
    const pageNumbers = [];
    const addPage = (page) => arraySortedInsert(pageNumbers, page, false);
    addPage(0);
    addPage(curPage);
    addPage(prevPage);
    addPage(nextPage);
    addPage(lastPage);
    const lastIndex = lastPage * this.pageSize;
    const prevPageIndex = Math.max(0, this.pageIndex - this.pageSize);
    const makeChunk = (text2, enabled) => {
      let chunk;
      if (enabled) {
        chunk = ButtonSecondaryOutlineSmall(text2);
      } else {
        chunk = Span(padding(px(5), px(10)), text2);
      }
      this.paginator.append(chunk);
      return chunk;
    };
    const makePageIndexLink = (text2, index) => {
      const enabled = 0 <= index && index <= lastIndex && index !== this.pageIndex;
      const link = makeChunk(text2, enabled);
      if (enabled) {
        link.addEventListener("click", () => {
          this.pageIndex = index;
          this.update();
        });
      }
    };
    const makePageSizeLink = (size4) => {
      const enabled = size4 !== this.pageSize;
      const link = makeChunk(size4.toString(), enabled);
      if (enabled) {
        link.addEventListener("click", () => {
          this.pageSize = size4;
          this.update();
        });
      }
    };
    makePageIndexLink("<", prevPageIndex);
    let last = -1;
    for (const pageNumber of pageNumbers) {
      const delta3 = pageNumber - last;
      last = pageNumber;
      if (delta3 > 1) {
        makeChunk("...", false);
      }
      makePageIndexLink((pageNumber + 1).toFixed(0), pageNumber * this.pageSize);
    }
    makePageIndexLink(">", maxIndex);
    makeChunk("|", false);
    makeChunk(`${showCount} filtered items of ${this.rows.length} results`, false);
    if (this.pageSizes.length > 2) {
      makeChunk("|", false);
      makeChunk("Items per page:", false);
      for (let i = 1; i < this.pageSizes.length; ++i) {
        if (this.rows.length > this.pageSizes[i - 1]) {
          makePageSizeLink(this.pageSizes[i]);
        }
      }
    }
  }
};

// src/file-picker/FilePickerSelectTab.ts
var FilePickerSelectTabSearchingEvent = class extends TypedEvent {
  constructor() {
    super("searching");
  }
};
var FilePickerSelectTabSearchCompleteEvent = class extends TypedEvent {
  constructor() {
    super("searchcomplete");
  }
};
var FilePickerSelectTab = class extends TypedEventBase {
  constructor(fetcher2, existingTagsID) {
    super();
    this.fetcher = fetcher2;
    this.typeFilters = new Array();
    this.selectors = new Array();
    this.rows = /* @__PURE__ */ new Map();
    this._selectedFile = null;
    this.tagFilter = null;
    this.typeFilter = null;
    this.table = FilterableTable.create({
      resourceName: "file-picker",
      columns: [{
        header: "ID",
        filter: InputNumber(),
        getCellValue: (f2) => f2.id.toFixed(0)
      }, {
        header: "Name",
        filter: InputText(),
        getCellValue: (f2) => f2.name
      }, {
        header: "Type",
        filter: this.typeSelector = Select(),
        getCellValue: (f2) => f2.mediaType
      }, {
        header: "Tags",
        filter: InputText(list(existingTagsID)),
        getCellValue: (f2) => f2.tagsString
      }, {
        header: "Size",
        getCellValue: (f2) => f2.sizeString
      }, {
        getCellValue: (f2, row) => {
          const btn = ButtonPrimarySmall(
            "Select",
            onClick(() => this.selectFile(btn, f2))
          );
          this.selectors.push(btn);
          this.rows.set(btn, row);
          return btn;
        }
      }]
    });
  }
  get element() {
    return this.table.element;
  }
  get selectedFile() {
    return this._selectedFile;
  }
  get hasFile() {
    return isDefined(this._selectedFile);
  }
  upload() {
    return Promise.resolve(this.selectedFile);
  }
  get requirementsMet() {
    return this.hasFile;
  }
  setTypeFilters(...types) {
    arrayReplace(this.typeFilters, ...types);
    this.typeFilter = mediaTypesToAcceptValue(this.typeFilters);
    elementClearChildren(this.typeSelector);
    elementApply(
      this.typeSelector,
      Option(value(""), "--"),
      ...this.typeFilters.map((t2) => Option(
        value(t2.value),
        t2.value
      ))
    );
  }
  clearFileSelection(tags) {
    this.tagFilter = tags.join();
    this.selectFile(null, null);
  }
  search(tagFilter) {
    this.tagFilter = tagFilter;
    return this.update();
  }
  async update() {
    this.dispatchEvent(new FilePickerSelectTabSearchingEvent());
    arrayClear(this.selectors);
    this.rows.clear();
    const body = {
      typeFilter: this.typeFilter,
      tagFilter: this.tagFilter
    };
    this.table.noContentMessage = "Searching...";
    this.table.clear();
    const files = await this.fetcher.post("/Editor/Files/Search").body(body, Application_JsonUTF8).object().then(unwrapResponse);
    this.table.noContentMessage = "No content.";
    this.table.setValues(...files);
    this.dispatchEvent(new FilePickerSelectTabSearchCompleteEvent());
  }
  selectFile(btn, fileRecord) {
    this._selectedFile = fileRecord;
    for (const selector of this.selectors) {
      const row = this.rows.get(selector);
      const isSelected = btn === selector;
      elementSetClass(row, isSelected, "selected");
      selector.disabled = isSelected;
    }
    if (this._selectedFile) {
      this.dispatchEvent(new SelectingEvent());
      this.dispatchEvent(new FileDataSelectedEvent(this._selectedFile));
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/mediatypes/db.ts
var MediaTypeDB = /* @__PURE__ */ singleton("Juniper:TSLib:MediaTypeDB", () => {
  const byExtension = /* @__PURE__ */ new Map();
  function guessByFileName(fileName) {
    if (!fileName) {
      console.warn("Couldn't guess media type. Must provide a valid fileName.");
      return [];
    }
    const idx = fileName.lastIndexOf(".");
    if (idx === -1) {
      console.warn("Couldn't guess media type. FileName has no extension.");
      return [];
    }
    let ext = fileName.substring(idx);
    if (!ext) {
      ext = "unknown";
    } else if (ext[0] == ".") {
      ext = ext.substring(1);
    }
    if (byExtension.has(ext)) {
      return byExtension.get(ext);
    } else {
      return [new MediaType("unknown", ext, [ext])];
    }
  }
  function normalizeFileType(fileName, fileType) {
    if (!fileType && fileName.indexOf(".") > -1) {
      const guesses = guessByFileName(fileName);
      if (guesses.length > 0) {
        fileType = guesses[0].value;
      }
    }
    return fileType;
  }
  function register(type2) {
    let isNew = false;
    const value2 = type2.__getValueUnsafe();
    type2 = singleton("Juniper.MediaTypes:" + value2, () => {
      isNew = true;
      return type2;
    });
    if (isNew) {
      for (const ext of type2.__getExtensionsUnsafe()) {
        if (!byExtension.has(ext)) {
          byExtension.set(ext, new Array());
        }
        const byExts = byExtension.get(ext);
        if (byExts.indexOf(type2) < 0) {
          byExts.push(type2);
        }
      }
    }
    return type2;
  }
  const db = {
    normalizeFileType
  };
  function regAll(values) {
    Object.values(values).forEach(register);
  }
  regAll(application_exports);
  regAll(audio_exports);
  regAll(chemical_exports);
  regAll(font_exports);
  regAll(image_exports);
  regAll(message_exports);
  regAll(model_exports);
  regAll(multipart_exports);
  regAll(text_exports);
  regAll(video_exports);
  regAll(xConference_exports);
  regAll(xShader_exports);
  return db;
});

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/FileUploadInput.ts
var FileUploadInputEvent = class extends TypedEvent {
  constructor(files) {
    super("input");
    this.files = files;
  }
};
var FileUploadInput = class extends TypedEventBase {
  constructor(buttonText, buttonStyle, file, dragTarget = null) {
    super();
    this.file = file;
    this.typeFilters = new Array();
    this.element = null;
    this._dragTarget = null;
    const getMatchingFiles = (fileList) => Array.from(fileList).filter((f2) => this.typeFilters.length === 0 || this.typeFilters.filter((t2) => t2.matches(f2.type)).length > 0);
    const getMatchingItems = (itemList) => Array.from(itemList).filter((f2) => f2.kind == "file" && (this.typeFilters.length === 0 || this.typeFilters.filter((t2) => t2.matches(f2.type)).length > 0));
    this.onDragOver = (evt) => {
      if (this.enabled) {
        const items = getMatchingItems(evt.dataTransfer.items);
        if (items.length > 0) {
          elementSetText(this.element, "Drop file...");
        } else {
          elementSetText(this.element, "No files matching expected type(s)");
        }
      }
      evt.preventDefault();
    };
    this.onDragEnd = (evt) => {
      if (this.enabled) {
        elementSetText(this.element, buttonText);
      }
      evt.preventDefault();
    };
    this.onDrop = (evt) => {
      if (this.enabled) {
        select(evt.dataTransfer.files);
      }
      this.onDragEnd(evt);
    };
    const select = (fileList) => {
      const files = getMatchingFiles(fileList);
      if (files.length > 0) {
        this.dispatchEvent(new FileUploadInputEvent(files));
      }
    };
    this.file.style.display = "none";
    this.file.insertAdjacentElement(
      "afterend",
      this.element = Button(
        classList("btn", `btn-${buttonStyle}`),
        onClick(() => this.show()),
        buttonText
      )
    );
    this.dragTarget = dragTarget || this.element;
    this.file.addEventListener("input", () => select(this.file.files));
    this.setTypeFilters();
    this.enabled = true;
  }
  get dragTarget() {
    return this._dragTarget;
  }
  set dragTarget(v) {
    if (v !== this.dragTarget) {
      if (this.dragTarget) {
        this.dragTarget.removeEventListener("dragover", this.onDragOver);
        this.dragTarget.removeEventListener("dragend", this.onDragEnd);
        this.dragTarget.removeEventListener("dragleave", this.onDragEnd);
        this.dragTarget.removeEventListener("drop", this.onDrop);
      }
      this._dragTarget = v;
      if (this.dragTarget) {
        elementApply(
          this.dragTarget,
          onDragOver(this.onDragOver),
          onDragLeave(this.onDragEnd),
          onDragEnd(this.onDragEnd),
          onDrop(this.onDrop)
        );
      }
    }
  }
  show() {
    if (this.file.showPicker) {
      this.file.showPicker();
    } else {
      this.file.click();
    }
  }
  setTypeFilters(...types) {
    arrayReplace(this.typeFilters, ...types);
    this.file.accept = mediaTypesToAcceptValue(types);
  }
  isExpectedType(contentType) {
    if (isNullOrUndefined(contentType)) {
      return false;
    }
    if (this.typeFilters.length === 0) {
      return true;
    }
    return this.typeFilters.map((t2) => t2.matches(contentType)).reduce((a, b) => a || b, false);
  }
  get accept() {
    return this.file.accept;
  }
  get enabled() {
    return !this.file.disabled;
  }
  set enabled(v) {
    this.file.disabled = !v;
    this.element.disabled = !v;
  }
  get disabled() {
    return !this.enabled;
  }
  set disabled(v) {
    this.enabled = !v;
  }
  get files() {
    return this.file.files;
  }
  clear() {
    this.file.value = null;
  }
};

// src/file-picker/FilePickerUploadTab.ts
var FilePickerUploadTab = class extends TypedEventBase {
  constructor(fetcher2, existingTagsID) {
    super();
    this.fetcher = fetcher2;
    this.selectedFile = null;
    this.selectedType = null;
    this.element = Div(
      PropertyList.create(
        [
          "File",
          this.picker = new FileUploadInput(
            "Upload new file",
            "primary",
            InputFile(
              required(true)
            )
          ),
          this.selectionMessage = Div()
        ],
        [
          "Copyright",
          this.copyrightInput = InputText(
            id("copyright"),
            name2("copyright"),
            required(true)
          )
        ],
        [
          "Copyright date",
          this.copyrightDateInput = InputDate(
            id("copyrightDate"),
            name2("copyrightDate"),
            required(true)
          )
        ],
        [
          "Tags",
          this.tagPicker = new TagPicker(existingTagsID)
        ]
      ),
      this.uploadProgress = BootstrapProgressBar("progress")
    );
    this.picker.dragTarget = this.element;
    this.picker.addEventListener("input", async (evt) => {
      if (evt.files.length > 0) {
        this.selectedFile = evt.files[0];
        this.selectedType = this.selectedFile.type;
        if (isNullOrUndefined(this.selectedType) || this.selectedType.length === 0) {
          this.selectedType = MediaTypeDB.normalizeFileType(this.selectedFile.name, this.selectedType);
        }
        this.refresh();
        this.dispatchEvent(new FileSelectedEvent(this.selectedFile, this.selectedType));
      }
    });
    const refresh = this.refresh.bind(this);
    this.copyrightInput.addEventListener("input", refresh);
    this.copyrightDateInput.addEventListener("input", refresh);
  }
  setTypeFilters(...types) {
    this.picker.setTypeFilters(...types);
  }
  get accept() {
    return this.picker.accept;
  }
  addMessage(msg) {
    elementApply(this.selectionMessage, Div(msg));
  }
  refresh() {
    elementClearChildren(this.selectionMessage);
    if (this.hasType && !this.hasCorrectType) {
      this.addMessage(`Unexpected file type: ${this.selectedType}. Expected: ${this.picker.accept}`);
    }
    if (!this.hasCopyright) {
      this.addMessage("Copyright holder is required");
    }
    if (!this.hasCopyrightDate) {
      this.addMessage("Copyright date is required");
    }
    this.dispatchEvent(new RefreshEvent());
  }
  clearFileSelection(tags) {
    this.uploadProgress.clear();
    this.selectedType = null;
    this.picker.clear();
    this.copyrightInput.value = null;
    this.copyrightDateInput.value = null;
    this.tagPicker.tags = tags;
    this.refresh();
  }
  get tagString() {
    return this.tagPicker.tags.join(",");
  }
  get hasFile() {
    return isDefined(this.selectedFile);
  }
  get hasType() {
    return isDefined(this.selectedType);
  }
  get hasCorrectType() {
    return this.picker.isExpectedType(this.selectedType);
  }
  get hasCopyright() {
    return this.copyrightInput.value.length > 0;
  }
  get hasCopyrightDate() {
    return this.copyrightDateInput.validity.valid;
  }
  get requirementsMet() {
    return this.hasFile && this.hasCorrectType && this.hasCopyright && this.hasCopyrightDate;
  }
  upload() {
    const form = new FormData();
    form.set("FormFile", this.selectedFile, this.selectedFile.name);
    form.set("Copyright", this.copyrightInput.value);
    form.set("CopyrightDate", this.copyrightDateInput.valueAsDate.toDateString());
    form.set("TagString", this.tagString);
    return this.fetcher.post("/editor/files/create").body(form).progress(this.uploadProgress).object().then(unwrapResponse);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/PDFImage.ts
var import_pdfjs_dist = __toESM(require_pdf(), 1);

// ../Juniper/src/Juniper.TypeScript/node_modules/pdfjs-dist/package.json
var version4 = "2.16.105";

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/CancelToken.ts
var CancelSignalException = class extends Exception {
  constructor() {
    super("Cancellation!");
  }
};
var CancelToken = class {
  constructor() {
    this._cancelled = false;
  }
  get cancelled() {
    return this._cancelled;
  }
  check() {
    if (this.cancelled) {
      throw new CancelSignalException();
    }
  }
  cancel() {
    this._cancelled = true;
  }
  dispose() {
    throw new Error("Method not implemented.");
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/graphics2d/PDFImage.ts
var pdfReady = singleton("Juniper:PdfReady", () => new Task(false));
var PDFImage = class extends CanvasImage {
  constructor(filePath, viewportParams) {
    super(1, 1);
    this.viewportParams = viewportParams;
    this.pdf = null;
    this._curPageIndex = null;
    this.ready = this.load(filePath);
  }
  static async prepare(workerPath, fetcher2, debug, tokenOrProg, prog) {
    let token = null;
    if (tokenOrProg instanceof CancelToken) {
      token = tokenOrProg;
    } else {
      prog = tokenOrProg;
    }
    token = token || new CancelToken();
    if (!pdfReady.started) {
      pdfReady.start();
      console.info(`PDF.js v${version4}`);
      const uri = new URLBuilder(workerPath, location.href);
      uri.query("v", version4);
      workerPath = uri.toString();
      import_pdfjs_dist.default.GlobalWorkerOptions.workerSrc = await fetcher2.get(workerPath).useCache(!debug).progress(prog).file().then(unwrapResponse);
      token.check();
      pdfReady.resolve();
    }
    await pdfReady;
    token.check();
  }
  get curPageIndex() {
    return this._curPageIndex;
  }
  get curPageNumber() {
    return this.curPageIndex + 1;
  }
  get canGoBack() {
    return this._curPageIndex > 0;
  }
  get canGoForward() {
    return this._curPageIndex < this.numPages - 1;
  }
  async load(filePath) {
    await pdfReady;
    const pdfTask = import_pdfjs_dist.default.getDocument(filePath);
    this.pdf = await pdfTask.promise;
    if (this.pdf.numPages === 0) {
      throw new Error("No pages found in PDF");
    }
  }
  async getPage(pageIndex) {
    await this.ready;
    pageIndex = clamp(pageIndex, 0, this.pdf.numPages - 1);
    if (pageIndex !== this._curPageIndex) {
      this._curPageIndex = pageIndex;
      const page = await this.pdf.getPage(pageIndex + 1);
      const viewport = page.getViewport(this.viewportParams);
      setContextSize(this.g, viewport.width, viewport.height);
      const renderTask = page.render({
        canvasContext: this.g,
        viewport,
        intent: "print"
      });
      await renderTask.promise;
      this.dispatchEvent(this.redrawnEvt);
    }
  }
  get numPages() {
    if (this.pdf) {
      return this.pdf.numPages;
    }
    return null;
  }
  onRedraw() {
    return false;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/blobToObjectURL.ts
function blobToObjectURL(obj2) {
  return new URL(URL.createObjectURL(obj2));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/mapInvert.ts
function mapInvert(map) {
  const mapOut = /* @__PURE__ */ new Map();
  for (const [key, value2] of map) {
    mapOut.set(value2, key);
  }
  return mapOut;
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/units/fileSize.ts
function isBase2Units(label) {
  return label !== "B" && label[1] === "i";
}
function isBase10Units(label) {
  return label !== "B" && !isBase10Units(label);
}
var base2Labels = /* @__PURE__ */ new Map([
  [1, "KiB"],
  [2, "MiB"],
  [3, "GiB"],
  [4, "TiB"]
]);
var base10Labels = /* @__PURE__ */ new Map([
  [1, "KB"],
  [2, "MB"],
  [3, "GB"],
  [4, "TB"]
]);
var base2Sizes = /* @__PURE__ */ mapInvert(base2Labels);
var base10Sizes = /* @__PURE__ */ mapInvert(base10Labels);
var labels = /* @__PURE__ */ new Map([
  [2, base2Labels],
  [10, base10Labels]
]);
function formatBytes(value2, base = 10) {
  const isNegative = value2 < 0;
  value2 = Math.abs(value2);
  const systemBase = base === 2 ? 1024 : 1e3;
  let size4 = Math.min(4, Math.floor(Math.log(value2) / Math.log(systemBase)));
  let divisor = Math.pow(systemBase, size4);
  if (2 * value2 >= systemBase * divisor && size4 < 4) {
    size4++;
    divisor *= systemBase;
  }
  let label;
  if (size4 === 0) {
    label = "B";
  } else {
    const levels = labels.get(base);
    label = levels.get(size4);
    value2 /= divisor;
  }
  const isExact = value2 % 1 === 0;
  const str5 = `${isNegative ? "-" : ""}${value2.toFixed(isExact ? 0 : 2)} ${label}`;
  return str5;
}
function toBytes(value2, units) {
  if (units === "B") {
    return value2;
  } else {
    let systemBase;
    let size4;
    if (isBase2Units(units)) {
      systemBase = 1024;
      size4 = base2Sizes.get(units);
    } else if (isBase10Units(units)) {
      systemBase = 1e3;
      size4 = base10Sizes.get(units);
    } else {
      assertNever(units);
    }
    const multiplier = Math.pow(systemBase, size4);
    return value2 * multiplier;
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/video/VideoPlayer.ts
var loadingCursor = "wait";
var loadedCursor = "pointer";
var errorCursor = "not-allowed";
var VideoPlayer = class extends BaseVideoPlayer {
  constructor(context, spatializer) {
    super("video-player", context, spatializer);
    this.element = Div(
      display("inline-block"),
      this.thumbnail = Img(cursor(loadingCursor)),
      this.video,
      this.audio
    );
    this.thumbnail.addEventListener("click", () => {
      if (this.loaded) {
        this.play();
      }
    });
    this.addEventListener("played", () => this.showVideo(true));
    this.addEventListener("stopped", () => this.showVideo(false));
    this.showVideo(false);
  }
  onDisposing() {
    super.onDisposing();
    if (isDefined(this.element.parentElement)) {
      this.element.remove();
    }
  }
  showVideo(v) {
    elementSetDisplay(this.video, v, "inline-block");
    elementSetDisplay(this.thumbnail, !v, "inline-block");
  }
  async load(data, prog) {
    try {
      elementApply(
        this.thumbnail,
        opacity(0.5),
        cursor(loadingCursor)
      );
      const progs = progressSplitWeighted(prog, [1, 10]);
      await all(
        super.load(data, progs.shift()),
        this.loadThumbnail(data, progs.shift())
      );
      return this;
    } finally {
      elementApply(
        this.thumbnail,
        opacity(1),
        cursor(this.loaded ? loadedCursor : errorCursor)
      );
    }
  }
  clear() {
    super.clear();
    this.thumbnail.src = "";
  }
  setTitle(v) {
    super.setTitle(v);
    this.thumbnail.title = v;
  }
  async loadThumbnail(data, prog) {
    prog.start();
    if (isDefined(data)) {
      elementApply(
        this.thumbnail,
        src(data.thumbnail.url),
        opacity(0.5)
      );
      const loading = once(this.thumbnail, "load", "error");
      await success(loading);
    }
    prog.end();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/registerThumbnails.ts
function showThumbnail(elem, isPhotosphere) {
  elementSetDisplay(thumbnailView, true, "block");
  elementSetDisplay(thumbnailImage, !isPhotosphere, "block");
  elementSetDisplay(thumbnailIFrame, isPhotosphere, "block");
  const match = elem.src.match(/\/file\/(\d+)$/);
  if (isPhotosphere && match) {
    const id2 = parseInt(match[1], 10);
    thumbnailIFrame.src = `/Editor/PhotosphereViewer?FileID=${id2}`;
  } else {
    thumbnailImage.src = elem.src;
  }
}
function hideThumbnail() {
  thumbnailView.style.display = "none";
}
var existing = /* @__PURE__ */ new WeakSet();
function registerThumbnails() {
  const thumbnails = Array.from(document.querySelectorAll(".thumbnail"));
  for (const thumbnail of thumbnails) {
    if (!existing.has(thumbnail)) {
      thumbnail.addEventListener("click", () => showThumbnail(thumbnail, thumbnail.classList.contains("photosphere")));
      existing.add(thumbnail);
    }
  }
}
var thumbnailViewerID = "33D0371F-B096-473D-AEE3-B17F5392CCEC";
var thumbnailView = document.getElementById(thumbnailViewerID);
if (!thumbnailView) {
  thumbnailView = Div(
    id(thumbnailViewerID),
    className("thumbnail-view"),
    display("none"),
    Img(title("Thumbnail")),
    IFrame(title("Preview"))
  );
}
var thumbnailImage = thumbnailView.querySelector("img");
var thumbnailIFrame = thumbnailView.querySelector("iframe");
if (!thumbnailView.parentElement) {
  elementApply(document.body, thumbnailView);
  thumbnailView.addEventListener("pointerleave", hideThumbnail);
  thumbnailView.addEventListener("click", hideThumbnail);
}

// src/file-picker/FilePreviewer.ts
var anyAudio = create("audio", "*");
var anyImage = create("image", "*");
var anyText = create("text", "*");
var anyVideo = create("video", "*");
var FilePreviewer = class {
  constructor(element, fetcher2, audioSys) {
    this.element = element;
    this.fetcher = fetcher2;
    this.audioSys = audioSys;
    PDFImage.prepare(getScriptUrl("pdfjs"), fetcher2, true);
    this.yt = new YouTubeProxy(this.fetcher, makeProxyURL);
    let context = this.audioSys;
    if (context instanceof JuniperAudioContext) {
      const no = new NoSpatializer(context.destination);
      this.vid = new VideoPlayer(context, no);
      this.aud = new AudioPlayer(context, no);
    } else {
      this.vid = new VideoPlayer(context.audio.context, context.audio.noSpatializer);
      this.aud = context.audioPlayer;
      context = context.audio.context;
    }
    const json = this.element.dataset.json;
    if (isDefined(json)) {
      const fileData = JSON.parse(json);
      this.setFile(fileData, ...fileData.tagsString.split(",").map((v) => v.trim().toLowerCase()));
    }
  }
  get hasFile() {
    return this._hasFile;
  }
  showLoading() {
    this.setElement(Div("Loading"), "Loading", "Loading", null);
  }
  async setFile(file, ...classes) {
    this.showLoading();
    let path = null;
    let type2 = null;
    let name3 = null;
    let size4 = null;
    let metadata = null;
    if (file instanceof URL) {
      const response = await this.fetcher.get(makeProxyURL(file)).file();
      path = response.content;
      name3 = response.fileName ?? file.href;
      type2 = response.contentType;
      size4 = response.contentLength;
    } else if (file instanceof File) {
      path = URL.createObjectURL(file);
      name3 = file.name;
      type2 = file.type;
      size4 = file.size;
    } else {
      path = file.filePath;
      name3 = file.name;
      type2 = file.mediaType;
      size4 = file.size;
      metadata = file.metadata;
    }
    if (isNullOrUndefined(type2) || type2.length === 0) {
      type2 = MediaTypeDB.normalizeFileType(name3, type2);
    }
    let element = null;
    if (Video_Vnd_DlsDc_YtDlp_Json.matches(type2)) {
      const data = await this.yt.loadData(metadata || path);
      if (isNullOrUndefined(data.videos) || data.videos.length === 0) {
        element = await this.aud.load(data);
      } else {
        element = await this.vid.load(data);
      }
    } else if (Text_Html.matches(type2) || Application_X_Url.matches(type2)) {
      element = this.makeIFrame(path);
    } else if (Application_Pdf.matches(type2)) {
      element = await this.makePDF(path);
    } else if (anyAudio.matches(type2)) {
      element = this.makeAudio(path);
    } else if (anyVideo.matches(type2)) {
      element = this.makeVideo(path);
    } else if (anyImage.matches(type2)) {
      element = this.makeImage(path);
    } else if (anyText.matches(type2) || Application_Json.matches(type2) || Application_Javascript.matches(type2)) {
      element = await this.makeText(path);
    } else {
      element = await this.makeUnknown(path);
    }
    this.setElement(element, type2, name3, size4, ...classes);
  }
  clear() {
    elementClearChildren(this);
    this._hasFile = false;
  }
  makeAudio(path) {
    return Audio2(controls(true), src(path));
  }
  makeVideo(path) {
    return Video(controls(true), src(path));
  }
  async makeText(path) {
    const txt = await this.fetcher.get(path).text().then(unwrapResponse);
    return TextArea(txt);
  }
  async makePDF(path) {
    const pdf = new PDFImage(path, {
      scale: 72 / 50
    });
    await pdf.getPage(0);
    const canvBlob = await canvasToBlob(pdf.canvas, Image_Png);
    const canvURL = blobToObjectURL(canvBlob);
    return Img(
      classList(
        "thumbnail",
        "image"
      ),
      src(canvURL)
    );
  }
  makeImage(path) {
    return Img(
      classList(
        "thumbnail",
        "image"
      ),
      src(path)
    );
  }
  makeUnknown(path) {
    return Div(`Cannot preview file at path: ${path}`);
  }
  makeIFrame(path) {
    return IFrame(src(path));
  }
  setElement(element, type2, name3, size4, ...classes) {
    element = resolveElement(element);
    this._hasFile = element.tagName !== "DIV";
    elementClearChildren(this);
    elementApply(
      this,
      H2(name3),
      Div(size4 && `${type2}: ${formatBytes(size4)}` || ""),
      elementApply(
        element,
        classList(...classes)
      )
    );
    if (element.tagName === "IMG" || element.tagName === "CANVAS") {
      registerThumbnails();
    }
  }
};

// src/file-picker/FilePicker.ts
var EXISTING_TAGS_ID = "existingTags";
var FilePicker = class extends DialogBox {
  constructor(fetcher2, audioSys) {
    super("File Upload");
    this.fetcher = fetcher2;
    this.tags = new Array();
    this._selectedFile = null;
    this.element.classList.add("file-picker");
    this.preview = new FilePreviewer(
      Div(className("preview")),
      this.fetcher,
      audioSys
    );
    elementApply(
      this.contentArea,
      this.existingTags = DataList(id(EXISTING_TAGS_ID)),
      this.tabs = TabPanel.create(
        ["upload-file", "Upload new file", this.uploadTab = new FilePickerUploadTab(this.fetcher, EXISTING_TAGS_ID)],
        ["link-file", "Link to file", this.linkTab = new FilePickerLinkTab(this.fetcher, EXISTING_TAGS_ID)],
        ["pick-file", "Pick existing file", this.selectTab = new FilePickerSelectTab(this.fetcher, EXISTING_TAGS_ID)]
      ),
      this.preview
    );
    const refresh = () => this.refresh();
    const showLoading = () => this.preview.showLoading();
    const previewFile = (evt) => this.preview.setFile(evt.file, ...this.tags);
    this.uploadTab.addEventListener("refresh", refresh);
    this.linkTab.addEventListener("refresh", refresh);
    this.linkTab.addEventListener("selecting", showLoading);
    this.selectTab.addEventListener("selecting", showLoading);
    this.uploadTab.addEventListener("fileselected", previewFile);
    this.linkTab.addEventListener("filedataselected", previewFile);
    this.linkTab.addEventListener("urlselected", previewFile);
    this.selectTab.addEventListener("filedataselected", (evt) => {
      refresh();
      previewFile(evt);
    });
    this.selectTab.addEventListener("searching", () => {
      this.confirmButton.disabled = true;
      this.cancelButton.disabled = true;
    });
    this.selectTab.addEventListener("searchcomplete", () => {
      this.confirmButton.disabled = !this.canConfirm;
      this.cancelButton.disabled = false;
    });
    this.tabs.addEventListener(
      "tabselected",
      this.clearFileSelection.bind(this)
    );
    this.getTags();
  }
  get selectedFile() {
    return this._selectedFile;
  }
  setTags(...tags) {
    arrayReplace(this.tags, ...tags);
    this.tags.sort();
  }
  setTypeFilters(...types) {
    this.uploadTab.setTypeFilters(...types);
    this.linkTab.setTypeFilters(...types);
    this.selectTab.setTypeFilters(...types);
  }
  async getTags() {
    const tags = await this.fetcher.get("/editor/files/tags").object().then(unwrapResponse);
    elementClearChildren(this.existingTags);
    this.existingTags.append(
      ...tags.map(
        (tag2) => Option(
          value(tag2),
          tag2
        )
      )
    );
  }
  clearFileSelection() {
    this.preview.clear();
    this.uploadTab.clearFileSelection(this.tags);
    this.linkTab.clearFileSelection(this.tags);
    this.selectTab.clearFileSelection(this.tags);
  }
  onShown() {
    super.onShown();
    this.clearFileSelection();
    this.tabs.select("upload-file");
    this.selectTab.search(this.tags.join());
  }
  async onConfirm() {
    this.confirmButton.disabled = true;
    this._selectedFile = await this.currentTab.upload();
    super.onConfirm();
  }
  onClosed() {
    this.clearFileSelection();
    this.preview.clear();
    this.getTags();
    super.onClosed();
  }
  get isUploading() {
    return this.tabs.isSelected("upload-file");
  }
  get isLinking() {
    return this.tabs.isSelected("link-file");
  }
  get isSelecting() {
    return this.tabs.isSelected("pick-file");
  }
  get currentTab() {
    return this.isUploading && this.uploadTab || this.isLinking && this.linkTab || this.isSelecting && this.selectTab;
  }
  get canConfirm() {
    return this.currentTab.requirementsMet;
  }
  refresh() {
    const msg = this.canConfirm ? "Confirm" : this.isUploading ? "Upload requirements not met" : this.isLinking ? "Link requirements not met" : "No file choice made";
    buttonSetEnabled(
      this.confirmButton,
      this.canConfirm,
      msg,
      msg
    );
  }
};

// src/vr-apps/yarrow/Transform.ts
var Transform = class extends Object3D {
  constructor(data) {
    super();
    this.M = new Matrix4();
    this.data = data;
    this.name = data.name;
    this.M.fromArray(data.matrix);
    this.M.decompose(this.position, this.quaternion, this.scale);
  }
  get transformID() {
    return this.data.id;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/LRUCache.ts
var LRUCacheItemEvicted = class extends TypedEvent {
  constructor(key, value2) {
    super("itemevicted");
    this.key = key;
    this.value = value2;
  }
};
var LRUCache = class extends TypedEventBase {
  constructor(size4) {
    super();
    this.size = size4;
    this.map = /* @__PURE__ */ new Map();
    this.usage = new Array();
    this.removed = /* @__PURE__ */ new Map();
  }
  set(key, value2) {
    this.usage.push(key);
    while (this.usage.length > this.size) {
      const toDelete = this.usage.shift();
      if (isDefined(toDelete)) {
        this.removed.set(toDelete, this.map.get(toDelete));
        this.map.delete(toDelete);
      }
    }
    this.removed.delete(key);
    for (const [key2, value3] of this.removed) {
      this.dispatchEvent(new LRUCacheItemEvicted(key2, value3));
    }
    this.removed.clear();
    return this.map.set(key, value2);
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    return this.map.get(key);
  }
  delete(key) {
    if (!this.map.has(key)) {
      return false;
    }
    arrayRemove(this.usage, key);
    return this.map.delete(key);
  }
  clear() {
    arrayClear(this.usage);
    this.map.clear();
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/progress/progressOfArray.ts
function progressOfArray(prog, items, callback) {
  const weights = items.map(() => 1);
  const progs = progressSplitWeighted(prog, weights);
  return Promise.all(items.map(async (item, i) => {
    const prog2 = progs[i];
    prog2.start();
    const value2 = await callback(item, prog2, i);
    prog2.end();
    return value2;
  }));
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/PhotosphereRig.ts
var QUAD_SIZE = 2;
var FACE_SIZE2 = 1 << 11;
var E = new Euler();
var FOVOffsetsDegrees = /* @__PURE__ */ new Map([
  [90 /* Low */, 4],
  [60 /* Medium */, 8],
  [45 /* High */, 3],
  [30 /* Fine */, 2]
]);
var captureParamsRadians = [
  [HalfPi, 0, 0, 1],
  [-HalfPi, 0, 2, 1],
  [0, HalfPi, 1, 0],
  [0, -HalfPi, 1, 2],
  [Pi, 0, 3, 1],
  [0, 0, 1, 1]
];
var PhotosphereRig = class {
  constructor(fetcher2, fixWatermarks) {
    this.fetcher = fetcher2;
    this.fixWatermarks = fixWatermarks;
    this.baseURL = null;
    this.isDebug = false;
    this.disposed = false;
    this.canvas = createUtilityCanvas(FACE_SIZE2, FACE_SIZE2);
    this.renderer = new WebGLRenderer({
      canvas: this.canvas,
      alpha: false,
      antialias: false,
      depth: true,
      logarithmicDepthBuffer: false,
      powerPreference: "low-power",
      precision: "lowp",
      stencil: false,
      premultipliedAlpha: false,
      preserveDrawingBuffer: false
    });
    this.camera = new PerspectiveCamera(90);
    this.photosphere = new Group();
    this.scene = objGraph(
      new Scene(),
      new AmbientLight(16777215, 1),
      this.camera,
      this.photosphere
    );
    this.geometry = new PlaneGeometry(1, 1, 1, 1);
  }
  init(baseURL, isDebug2) {
    this.baseURL = baseURL;
    this.isDebug = isDebug2;
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.onDisposing();
    }
  }
  onDisposing() {
    for (const child of this.scene.children) {
      cleanup(child);
    }
    dispose(this.renderer);
  }
  async renderFaces(getImagePath, level, progress) {
    this.clear();
    await this.loadFrames(level, progress, getImagePath);
    const files = await Promise.all(captureParamsRadians.map(async ([headingRadians, pitchRadians, dx, dy]) => {
      const rollRadians = CUBEMAP_PATTERN.rotations[dy][dx];
      E.set(pitchRadians, headingRadians, rollRadians, "YXZ");
      this.camera.setRotationFromEuler(E);
      this.renderer.render(this.scene, this.camera);
      const blob = await canvasToBlob(this.renderer.domElement, Image_Jpeg.value, 1);
      return URL.createObjectURL(blob);
    }));
    this.clear();
    return files;
  }
  async renderCubeMap(getImagePath, level, progress) {
    this.clear();
    const canv = createUtilityCanvas(FACE_SIZE2 * 4, FACE_SIZE2 * 3);
    const g = canv.getContext("2d", { alpha: false });
    await this.loadFrames(level, progress, getImagePath);
    for (const [headingRadians, pitchRadians, dx, dy] of captureParamsRadians) {
      E.set(pitchRadians, headingRadians, 0, "YXZ");
      this.camera.setRotationFromEuler(E);
      this.renderer.render(this.scene, this.camera);
      g.drawImage(this.renderer.domElement, dx * FACE_SIZE2, dy * FACE_SIZE2);
    }
    const blob = await canvasToBlob(canv, Image_Jpeg.value, 1);
    const file = URL.createObjectURL(blob);
    ;
    this.clear();
    return file;
  }
  getImageAngles(level) {
    const anglesDegrees = new Array();
    const FOVDegrees = level;
    const dFOVDegrees = this.fixWatermarks ? FOVOffsetsDegrees.get(FOVDegrees) : 0;
    for (let pitchDegrees = -90 + FOVDegrees; pitchDegrees < 90; pitchDegrees += FOVDegrees) {
      for (let headingDegrees = -180; headingDegrees < 180; headingDegrees += FOVDegrees) {
        anglesDegrees.push([headingDegrees, pitchDegrees, FOVDegrees + dFOVDegrees, QUAD_SIZE]);
      }
    }
    anglesDegrees.push([0, -90, FOVDegrees + dFOVDegrees, QUAD_SIZE]);
    anglesDegrees.push([0, 90, FOVDegrees + dFOVDegrees, QUAD_SIZE]);
    if (this.fixWatermarks) {
      anglesDegrees.push([0, -90, FOVDegrees, 0.5 * QUAD_SIZE]);
      anglesDegrees.push([0, 90, FOVDegrees, 0.5 * QUAD_SIZE]);
    }
    return anglesDegrees;
  }
  async loadFrames(level, progress, getImagePath) {
    const angles = this.getImageAngles(level);
    await progressOfArray(progress, angles, (set7, prog) => this.loadFrame(getImagePath, ...set7, prog));
  }
  async loadFrame(getImagePath, headingDegrees, pitchDegrees, fovDegrees, size4, prog) {
    const halfFOV = 0.5 * deg2rad(fovDegrees);
    const k = Math.tan(halfFOV);
    const dist4 = 0.5 * size4 / k;
    const path = getImagePath(fovDegrees, headingDegrees, pitchDegrees);
    const canvas = await this.fetcher.get(path, this.baseURL).progress(prog).useCache(!this.isDebug).canvas().then(unwrapResponse);
    const texture = new Texture(canvas);
    const material = new MeshBasicMaterial({
      map: texture,
      side: DoubleSide
    });
    const frame = mesh(`frame-${fovDegrees}-${headingDegrees}-${pitchDegrees}`, this.geometry, material);
    texture.needsUpdate = true;
    material.needsUpdate = true;
    E.set(deg2rad(pitchDegrees), -deg2rad(headingDegrees), 0, "YXZ");
    frame.scale.setScalar(size4);
    frame.quaternion.setFromEuler(E);
    frame.position.set(0, 0, -dist4).applyQuaternion(frame.quaternion);
    objGraph(this.photosphere, frame);
  }
  clear() {
    for (const child of this.photosphere.children) {
      cleanup(child);
    }
    this.photosphere.clear();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/WindowQuitEventer.ts
var WindowQuitEventer = class extends TypedEventBase {
  constructor() {
    super();
    this.event = new TypedEvent("quitting");
    const onWindowClosed = () => this.dispatchEvent(this.event);
    window.addEventListener("beforeunload", onWindowClosed);
    window.addEventListener("unload", onWindowClosed);
    window.addEventListener("pagehide", onWindowClosed);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/gis/Datum.ts
var FalseNorthing = 1e7;
var invF = 298.257223563;
var equatorialRadius = 6378137;
var pointScaleFactor = 0.9996;
var E0 = 5e5;
var flattening = 1 / invF;
var flatteningComp = 1 - flattening;
var n = flattening / (2 - flattening);
var A2 = equatorialRadius / (1 + n) * (1 + n * n / 4 + n * n * n * n / 64);
var e = Math.sqrt(1 - flatteningComp * flatteningComp);
var esq = 1 - flatteningComp * flatteningComp;
var e0sq = e * e / (1 - e * e);
var alpha1 = 1 - esq * (0.25 + esq * (3 / 64 + 5 * esq / 256));
var alpha2 = esq * (3 / 8 + esq * (3 / 32 + 45 * esq / 1024));
var alpha3 = esq * esq * (15 / 256 + esq * 45 / 1024);
var alpha4 = esq * esq * esq * (35 / 3072);
var beta = [
  n / 2 - 2 * n * n / 3 + 37 * n * n * n / 96,
  n * n / 48 + n * n * n / 15,
  17 * n * n * n / 480
];
var delta2 = [
  2 * n - 2 * n * n / 3,
  7 * n * n / 3 - 8 * n * n * n / 5,
  56 * n * n * n / 15
];
var DatumWGS_84 = {
  FalseNorthing,
  equatorialRadius,
  pointScaleFactor,
  E0,
  A: A2,
  flattening,
  e,
  esq,
  e0sq,
  alpha1,
  alpha2,
  alpha3,
  alpha4,
  beta,
  delta: delta2
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/gis/UTMPoint.ts
var UTMPoint = class {
  static centroid(points) {
    const zoneCounts = /* @__PURE__ */ new Map();
    points.forEach((p) => zoneCounts.set(p.zone, (zoneCounts.get(p.zone) || 0) + 1));
    let maxZone = 0;
    let maxZoneCount = 0;
    for (const [zone, count] of zoneCounts) {
      if (count > maxZoneCount) {
        maxZone = zone;
        maxZoneCount = count;
      }
    }
    const scale8 = 1 / points.length;
    const vec = points.map((p) => p.rezone(maxZone).toVec3()).reduce((a, b) => vec3_exports.scaleAndAdd(a, a, b, scale8), vec3_exports.create());
    return new UTMPoint().fromVec3(vec, maxZone).toLatLng().toUTM();
  }
  /**
   * The east/west component of the coordinate.
   **/
  get easting() {
    return this._easting;
  }
  /**
   * The north/south component of the coordinate.
   **/
  get northing() {
    return this._northing;
  }
  /**
   * An altitude component.
   **/
  get altitude() {
    return this._altitude;
  }
  /**
   * The UTM Zone for which this coordinate represents.
   **/
  get zone() {
    return this._zone;
  }
  /**
   * The hemisphere in which the UTM point sits.
   **/
  get hemisphere() {
    return this.northing >= 0 ? "northern" : "southern";
  }
  constructor(eastingOrCopy, northing, altitude, zone) {
    if (isObject(eastingOrCopy)) {
      this._easting = eastingOrCopy.easting;
      this._northing = eastingOrCopy.northing;
      this._altitude = eastingOrCopy.altitude;
      this._zone = eastingOrCopy.zone;
    } else {
      this._easting = eastingOrCopy || 0;
      this._northing = northing || 0;
      this._altitude = altitude || 0;
      this._zone = zone || 0;
    }
  }
  toJSON() {
    return JSON.stringify({
      easting: this.easting,
      northing: this.northing,
      altitude: this.altitude,
      zone: this.zone,
      hemisphere: this.hemisphere
    });
  }
  toString() {
    return `(${this.easting}, ${this.northing}, ${this.altitude}) zone ${this.zone}`;
  }
  equals(other) {
    return isDefined(other) && this.hemisphere == other.hemisphere && this.easting == other.easting && this.northing == other.northing && this.altitude == other.altitude && this.zone == other.zone;
  }
  static A(cosPhi, lng, utmz) {
    const zcm = 3 + 6 * (utmz - 1) - 180;
    return deg2rad(lng - zcm) * cosPhi;
  }
  static getZoneWidthAtLatitude(lat) {
    const phi = deg2rad(lat);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    const tanPhi = sinPhi / cosPhi;
    const ePhi = DatumWGS_84.e * sinPhi;
    const N = DatumWGS_84.equatorialRadius / Math.sqrt(1 - ePhi * ePhi);
    const T = tanPhi * tanPhi;
    const C2 = DatumWGS_84.e0sq * cosPhi * cosPhi;
    const Tsqr = T * T;
    const A3 = deg2rad(3) * cosPhi;
    const Asqr = A3 * A3;
    const x0 = 1 - T + C2;
    const x1 = 5 - 18 * T + Tsqr + 72 * C2 - 58 * DatumWGS_84.e0sq;
    const x2 = x0 / 6 + Asqr * x1 / 120;
    const x3 = 1 + Asqr * x2;
    const width2 = 2 * DatumWGS_84.pointScaleFactor * N * A3 * x3;
    return width2;
  }
  /**
   * Converts this UTMPoint to a Latitude/Longitude point using the WGS-84 datum. The
   * coordinate pair's units will be in meters, and should be usable to make distance
   * calculations over short distances.
   * reference: http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  fromLatLng(latLng) {
    const phi = deg2rad(latLng.lat);
    const sinPhi = Math.sin(phi);
    const cosPhi = Math.cos(phi);
    const cosPhi2 = 2 * cosPhi;
    const sin2Phi = cosPhi2 * sinPhi;
    const cos2Phi = cosPhi2 * cosPhi - 1;
    const cos2Phi2 = 2 * cos2Phi;
    const sin4Phi = cos2Phi2 * sin2Phi;
    const cos4Phi = cos2Phi2 * cos2Phi - 1;
    const sin6Phi = sin4Phi * cos2Phi + cos4Phi * sin2Phi;
    const tanPhi = sinPhi / cosPhi;
    const ePhi = DatumWGS_84.e * sinPhi;
    const N = DatumWGS_84.equatorialRadius / Math.sqrt(1 - ePhi * ePhi);
    const M3 = DatumWGS_84.equatorialRadius * (phi * DatumWGS_84.alpha1 - sin2Phi * DatumWGS_84.alpha2 + sin4Phi * DatumWGS_84.alpha3 - sin6Phi * DatumWGS_84.alpha4);
    const utmz = 1 + (latLng.lng + 180) / 6 | 0;
    const A3 = UTMPoint.A(cosPhi, latLng.lng, utmz);
    const Asqr = A3 * A3;
    const T = tanPhi * tanPhi;
    const C2 = DatumWGS_84.e0sq * cosPhi * cosPhi;
    const Tsqr = T * T;
    const x0 = 1 - T + C2;
    const x1 = 5 - 18 * T + Tsqr + 72 * C2 - 58 * DatumWGS_84.e0sq;
    const x2 = Asqr * x1 / 120;
    const x3 = x0 / 6 + x2;
    const x4 = 1 + Asqr * x3;
    const easting = DatumWGS_84.pointScaleFactor * N * A3 * x4 + DatumWGS_84.E0;
    const y0 = 5 - T + 9 * C2 + 4 * C2 * C2;
    const y1 = 61 - 58 * T + Tsqr + 600 * C2 - 330 * DatumWGS_84.e0sq;
    const y2 = y0 / 24 + Asqr * y1 / 720;
    const y3 = 0.5 + Asqr * y2;
    const y4 = M3 + N * tanPhi * Asqr * y3;
    const northing = DatumWGS_84.pointScaleFactor * y4;
    this._easting = easting;
    this._northing = northing;
    this._altitude = latLng.alt;
    this._zone = utmz;
    return this;
  }
  rezone(newZone) {
    if (!(1 <= newZone && newZone <= 60)) {
      throw new Error(`Zones must be on the range [1, 60]. Given: ${newZone}`);
    }
    if (newZone !== this.zone) {
      const deltaZone = newZone - this.zone;
      const ll = this.toLatLng();
      const width2 = UTMPoint.getZoneWidthAtLatitude(ll.lat);
      return new UTMPoint(
        this.easting - width2 * deltaZone,
        this.northing,
        this.altitude,
        newZone
      );
    } else {
      return this;
    }
  }
  /**
   * Converts this UTMPoint to a Latitude/Longitude point using the WGS-84 datum. The
   * coordinate pair's units will be in meters, and should be usable to make distance
   * calculations over short distances.
   * reference: http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  toLatLng() {
    return new LatLngPoint().fromUTM(this);
  }
  toVec2() {
    const v = vec2_exports.create();
    vec2_exports.set(v, this.easting, -this.northing);
    return v;
  }
  fromVec2(arr, zone) {
    this._easting = arr[0];
    this._northing = -arr[1];
    this._altitude = 0;
    this._zone = zone;
    return this;
  }
  toVec3() {
    const v = vec3_exports.create();
    vec3_exports.set(v, this.easting, this.altitude, -this.northing);
    return v;
  }
  fromVec3(arr, zone) {
    this._easting = arr[0];
    this._altitude = arr[1];
    this._northing = -arr[2];
    this._zone = zone;
    return this;
  }
  copy(other) {
    this._easting = other.easting;
    this._northing = other.northing;
    this._altitude = other.altitude;
    this._zone = other.zone;
    return this;
  }
  clone() {
    return new UTMPoint(this);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/gis/LatLngPoint.ts
var LatLngPoint = class {
  static centroid(points) {
    const scale8 = 1 / points.length;
    const vec = points.map((p) => p.toVec3()).reduce((a, b) => vec3_exports.scaleAndAdd(a, a, b, scale8), vec3_exports.create());
    return new LatLngPoint().fromVec3(vec);
  }
  /**
   * An altitude value thrown in just for kicks. It makes some calculations and conversions
   * easier if we keep the Altitude value.
   **/
  get alt() {
    return this._alt;
  }
  /**
   * Lines of latitude run east/west around the globe, parallel to the equator, never
   * intersecting. They measure angular distance north/south.
   **/
  get lat() {
    return this._lat;
  }
  /**
   * Lines of longitude run north/south around the globe, intersecting at the poles. They
   * measure angular distance east/west.
   **/
  get lng() {
    return this._lng;
  }
  constructor(lat, lng, alt) {
    if (isObject(lat)) {
      this._lat = lat.lat;
      this._lng = lat.lng;
      this._alt = lat.alt;
    } else {
      this._lat = lat || 0;
      this._lng = lng || 0;
      this._alt = alt;
    }
  }
  toJSON() {
    return JSON.stringify({
      lat: this.lat,
      lng: this.lng,
      alt: this.alt
    });
  }
  static parseDMS(value2) {
    const parts = value2.split(" ");
    if (parts.length == 3) {
      const hemisphere = parts[0];
      const degrees = parseInt(parts[1], 10);
      const minutes = parseFloat(parts[2]);
      if ((hemisphere == "N" || hemisphere == "S" || hemisphere == "E" || hemisphere == "W") && Number.isInteger(degrees) && Number.isFinite(minutes)) {
        let dec = degrees + minutes / 60;
        if (hemisphere == "S" || hemisphere == "W") {
          dec *= -1;
        }
        return dec;
      }
    }
    return Number.NaN;
  }
  static parseDMSPair(value2) {
    const parts = value2.split(",");
    if (parts.length == 2) {
      const lat = LatLngPoint.parseDMS(parts[0]);
      const lng = LatLngPoint.parseDMS(parts[1]);
      if (!Number.isNaN(lat) && !Number.isNaN(lng)) {
        return new LatLngPoint(lat, lng);
      }
    }
    return null;
  }
  static parseDecimal(value2) {
    const parts = value2.split(",");
    if (parts.length == 2) {
      const lat = parseFloat(parts[0].trim());
      const lng = parseFloat(parts[1].trim());
      if (Number.isFinite(lat) && Number.isFinite(lng)) {
        return new LatLngPoint(lat, lng);
      }
    }
    return null;
  }
  /**
   * Try to parse a string as a Latitude/Longitude.
   **/
  static parse(value2) {
    const asDecimal = LatLngPoint.parseDecimal(value2);
    const asDMS = LatLngPoint.parseDMSPair(value2);
    return asDecimal || asDMS;
  }
  /**
   * Pretty-print the Degrees/Minutes/Second version of the Latitude/Longitude angles.
   * @param sigfigs
   */
  toDMS(sigfigs, withAltitude = true) {
    const latStr = LatLngPoint.toDMS(this.lat, "S", "N", sigfigs);
    const lngStr = LatLngPoint.toDMS(this.lng, "W", "E", sigfigs);
    if (this.alt && withAltitude) {
      const altStr = `${this.alt.toFixed(sigfigs)}m`;
      return `<${latStr}, ${lngStr}> alt ${altStr}`;
    } else {
      return `<${latStr}, ${lngStr}>`;
    }
  }
  toDMSArray(sigfigs, withAltitude = false) {
    const parts = [
      LatLngPoint.toDMS(this.lat, "S", "N", sigfigs),
      LatLngPoint.toDMS(this.lng, "W", "E", sigfigs)
    ];
    if (this.alt && withAltitude) {
      parts.push(`${this.alt.toFixed(sigfigs)}m`);
    }
    return parts;
  }
  /**
   * Pretty-print the Degrees/Minutes/Second version of the Latitude/Longitude angles.
   * @param value The decimal degree value to format
   * @param negative The string prefix to use when the value is negative
   * @param positive The string prefix to use when the value is positive
   * @param sigfigs The number of significant figures to which to print the value
   */
  static toDMS(value2, negative, positive, sigfigs) {
    const hemisphere = value2 < 0 ? negative : positive;
    value2 = Math.abs(value2);
    const degrees = Math.floor(value2);
    const minutes = (value2 - degrees) * 60;
    const intMinutes = Math.floor(minutes);
    const seconds = (minutes - intMinutes) * 60;
    let secondsStr = seconds.toFixed(sigfigs);
    while (secondsStr.indexOf(".") <= 1) {
      secondsStr = `0${secondsStr}`;
    }
    return `${hemisphere} ${degrees.toFixed(0)}\xB0 ${intMinutes.toFixed(0)}' ${secondsStr}"`;
  }
  /**
   * Pretty-print the LatLngPoint for easier debugging.
   * @param sigfigs
   */
  toString(sigfigs) {
    sigfigs = sigfigs || 6;
    return `(${this.lat.toFixed(sigfigs)}\xB0, ${this.lng.toFixed(sigfigs)}\xB0)`;
  }
  /**
   * Check two LatLngPoints to see if they overlap.
   * @param other
   */
  equals(other) {
    return isObject(other) && this.lat == other.lat && this.lng == other.lng && this.alt == other.alt;
  }
  compareTo(other) {
    if (isNullOrUndefined(other)) {
      return -1;
    } else {
      const byLat = this.lat - other.lat;
      const byLng = this.lng - other.lng;
      const byAlt = (this.alt || 0) - (other.alt || 0);
      if (byLat == 0 && byLng == 0) {
        return byAlt;
      } else if (byLat == 0) {
        return byLng;
      } else {
        return byLat;
      }
    }
  }
  /**
   * Calculate a rough distance, in meters, between two LatLngPoints.
   * @param other
   */
  distance(other) {
    const a = this.toUTM();
    const b = other.toUTM().rezone(a.zone);
    const dx = b.easting - a.easting;
    const dy = b.northing - a.northing;
    return Math.sqrt(dx * dx + dy * dy);
  }
  /**
   * Converts this UTMPoint to a Latitude/Longitude point using the WGS-84 datum. The
   * coordinate pair's units will be in meters, and should be usable to make distance
   * calculations over short distances.
   * reference: http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  fromUTM(utm) {
    const N0 = utm.hemisphere === "southern" && utm.northing >= 0 ? DatumWGS_84.FalseNorthing : 0;
    const xi = (utm.northing - N0) / (DatumWGS_84.pointScaleFactor * DatumWGS_84.A);
    const eta = (utm.easting - DatumWGS_84.E0) / (DatumWGS_84.pointScaleFactor * DatumWGS_84.A);
    let xiPrime = xi;
    let etaPrime = eta;
    for (let j = 1; j <= 3; ++j) {
      const beta2 = DatumWGS_84.beta[j - 1];
      const je2 = 2 * j * xi;
      const jn2 = 2 * j * eta;
      const sinje2 = Math.sin(je2);
      const coshjn2 = Math.cosh(jn2);
      const cosje2 = Math.cos(je2);
      const sinhjn2 = Math.sinh(jn2);
      xiPrime -= beta2 * sinje2 * coshjn2;
      etaPrime -= beta2 * cosje2 * sinhjn2;
    }
    const chi = Math.asin(Math.sin(xiPrime) / Math.cosh(etaPrime));
    let lat = chi;
    for (let j = 1; j <= 3; ++j) {
      lat += DatumWGS_84.delta[j - 1] * Math.sin(2 * j * chi);
    }
    const long0 = utm.zone * 6 - 183;
    const lng = Math.atan(Math.sinh(etaPrime) / Math.cos(xiPrime));
    this._lat = rad2deg(lat);
    this._lng = long0 + rad2deg(lng);
    while (this._lng < -180) {
      this._lng += 360;
    }
    while (this._lng > 180) {
      this._lng -= 360;
    }
    this._alt = utm.altitude;
    return this;
  }
  /**
   * Converts this LatLngPoint to a Universal Transverse Mercator point using the WGS-84
   * datum. The coordinate pair's units will be in meters, and should be usable to make
   * distance calculations over short distances.
   *
   * @see http://www.uwgb.edu/dutchs/usefuldata/utmformulas.htm
   **/
  toUTM() {
    return new UTMPoint().fromLatLng(this);
  }
  toVec2() {
    const v = vec2_exports.create();
    vec2_exports.set(v, this.lng, this.lat);
    return v;
  }
  fromVec2(v) {
    this._lng = v[0];
    this._lat = v[1];
    this._alt = void 0;
    return this;
  }
  toVec3() {
    const v = vec3_exports.create();
    vec3_exports.set(v, this.lng, this.alt, this.lat);
    return v;
  }
  fromVec3(v) {
    this._lng = v[0];
    this._alt = v[1];
    this._lat = v[2];
    return this;
  }
  toArray() {
    return [this._lng, this._alt, this._lat];
  }
  fromArray(arr) {
    return this.fromVec3(arr);
  }
  copy(other) {
    this._lat = other.lat;
    this._lng = other.lng;
    this._alt = other.alt;
    return this;
  }
  clone() {
    return new LatLngPoint(this);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/EmojiGroup.ts
var EmojiGroup = class extends Emoji {
  /**
   * Groupings of Unicode-standardized pictograms.
   * @param value - a Unicode sequence.
   * @param desc - an English text description of the pictogram.
   * @param ...rest - Emojis in this group.
   */
  constructor(value2, desc, ...alts) {
    super(value2, desc);
    this.width = null;
    this.alts = alts;
  }
  /**
   * Selects a random emoji out of the collection.
   **/
  random() {
    const idx = Math.floor(Math.random() * this.alts.length);
    if (idx < 0) {
      return null;
    }
    const selection = this.alts[idx];
    if (selection instanceof EmojiGroup) {
      return selection.random();
    } else {
      return selection;
    }
  }
  contains(e2) {
    if (super.contains(e2)) {
      return true;
    } else {
      for (const alt of this.alts) {
        if (alt.contains(e2)) {
          return true;
        }
      }
      return false;
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/emoji/numbers.ts
var keycapDigits = /* @__PURE__ */ new EmojiGroup(
  "Keycap Digits",
  "Keycap Digits",
  keycapDigitZero,
  keycapDigitOne,
  keycapDigitTwo,
  keycapDigitThree,
  keycapDigitFour,
  keycapDigitFive,
  keycapDigitSix,
  keycapDigitSeven,
  keycapDigitEight,
  keycapDigitNine,
  keycap10
);

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/threejs/widgets/PlaybackButton.ts
var playEvt = new TypedEvent("play");
var stopEvt = new TypedEvent("stop");
var size3 = 0.1;
var translations = new Map(
  keycapDigits.alts.map((m, i) => [m.value, i.toString()])
);
var PlaybackButton = class extends BaseProgress {
  constructor(env, buttonFactory, data, name3, label, volume, player) {
    super();
    this.data = data;
    this.volume = volume;
    this.player = player;
    this.playButton = null;
    this.pauseButton = null;
    this.stopButton = null;
    this.replayButton = null;
    this.clickPlay = null;
    this.disposed = false;
    label = translations.get(label) || label || "";
    this.object = obj(`playback-${name3}`);
    this.textLabel = new TextMesh(env, `playback-${name3}-label`, "none", {
      minHeight: size3,
      minWidth: 4 * size3,
      maxWidth: 4 * size3,
      padding: 0.02,
      scale: 1e3,
      bgFillColor: buttonFactory.labelFillColor,
      textFillColor: "white"
    });
    this.textLabel.image.value = label;
    this.textLabel.image.addEventListener("redrawn", () => this.repositionLabel());
    this.progressBar = new Cube(4 * size3, 0.025, 0.01, solidWhite);
    this.progressBar.visible = false;
    this.clickPlay = async () => {
      if (this.player.data !== this.data) {
        await this.player.load(this.data, this);
      }
      this.player.volume = this.volume;
      await this.player.play();
    };
    this.load(buttonFactory, player);
  }
  dispose() {
    if (!this.disposed) {
      if (this.data === this.player.data) {
        this.player.clear();
      }
      cleanup(this.object);
      this.disposed = true;
    }
  }
  repositionLabel() {
    this.textLabel.position.y = -(size3 + this.textLabel.objectHeight) / 2;
  }
  async load(buttonFactory, player) {
    const [
      play,
      pause,
      stop,
      replay
    ] = await all(
      buttonFactory.getMeshButton("media", "play", size3),
      buttonFactory.getMeshButton("media", "pause", size3),
      buttonFactory.getMeshButton("media", "stop", size3),
      buttonFactory.getMeshButton("media", "replay", size3)
    );
    objGraph(
      this,
      this.playButton = play,
      this.pauseButton = pause,
      this.stopButton = stop,
      this.replayButton = replay,
      this.progressBar,
      this.textLabel
    );
    this.playButton.object.position.x = -1.5 * size3;
    this.pauseButton.object.position.x = -0.5 * size3;
    this.stopButton.object.position.x = 0.5 * size3;
    this.replayButton.object.position.x = 1.5 * size3;
    this.progressBar.position.y = -size3 / 2;
    this.progressBar.position.z = 0.01;
    this.repositionLabel();
    const refresh = () => {
      const hasMyData = player.data === this.data;
      this.playButton.disabled = hasMyData && (player.playbackState === "loading" || player.playbackState === "playing" || player.playbackState === "errored") || !hasMyData && player.playbackState === "loading";
      this.pauseButton.disabled = !hasMyData || player.playbackState === "loading" || player.playbackState !== "playing";
      this.replayButton.disabled = this.stopButton.disabled = !hasMyData || player.playbackState === "loading" || player.playbackState === "stopped" || player.playbackState === "errored";
      if (!hasMyData || player.playbackState === "loading" || player.playbackState === "stopped") {
        this.progressBar.visible = false;
      }
    };
    refresh();
    const local = (callback) => (evt) => {
      if (evt.source.data === this.data) {
        callback(evt);
      }
    };
    const localRefresh = local(refresh);
    player.addEventListener("loading", refresh);
    player.addEventListener("loaded", localRefresh);
    player.addEventListener("played", localRefresh);
    player.addEventListener("paused", localRefresh);
    player.addEventListener("stopped", refresh);
    player.addEventListener("progress", local((evt) => this.report(evt.value, evt.total)));
    player.addEventListener("played", local(() => this.dispatchEvent(playEvt)));
    player.addEventListener("stopped", local(() => this.dispatchEvent(stopEvt)));
    const onClick2 = (btn, callback) => {
      btn.addEventListener("click", callback);
    };
    onClick2(this.playButton, this.clickPlay);
    onClick2(this.pauseButton, () => player.pause());
    onClick2(this.stopButton, () => player.stop());
    onClick2(this.replayButton, () => player.restart());
  }
  get label() {
    if (isDefined(this.textLabel.image)) {
      return this.textLabel.image.value;
    }
    return null;
  }
  set label(v) {
    v = translations.get(v) || v;
    this.textLabel.image.value = v;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    const width2 = this.p * 4 * size3;
    this.progressBar.position.x = 0.5 * (width2 - 4 * size3);
    this.progressBar.scale.x = width2;
    this.progressBar.visible = soFar > 0;
  }
};

// src/vr-apps/yarrow/Audio.ts
var P = new Vector3();
var Audio4 = class {
  constructor(scenario, parent, player, data) {
    this.scenario = scenario;
    this.parent = parent;
    this.player = player;
    this.clip = null;
    this.controls = null;
    this.error = null;
    this.disposed = false;
    this.zone = data.zone;
    this.minDistance = data.minDistance;
    this.maxDistance = data.maxDistance;
    this.spatialize = data.spatialize;
    this.effect = data.effect;
    this.label = data.label;
    this.volume = data.volume;
    this.enabled = data.enabled;
    this.transformID = data.transformID;
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
  }
  get effects() {
    if (isNullOrUndefined(this.effect)) {
      return [];
    } else {
      return this.effect.split(",").map((f2) => f2.trim()).filter((f2) => f2.length > 0);
    }
  }
  async load(prog) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    try {
      if (this.spatialize) {
        this.clip = await this.scenario.env.audio.createClip(
          this.transformID.toString(),
          this.filePath,
          this.spatialize,
          this.spatialize,
          this.spatialize,
          this.spatialize,
          this.volume,
          this.effects,
          prog
        );
        this.clip.spatializer.setAudioProperties(this.minDistance, this.maxDistance, this.scenario.env.audio.algorithm);
        this.updateAudioPosition();
      } else {
        objGraph(
          this.parent,
          this.controls = new PlaybackButton(
            this.scenario.env,
            this.scenario.env.uiButtons,
            this.filePath,
            `${this.fileName}(${this.transformID})`,
            this.label,
            this.volume,
            this.player
          )
        );
        this.controls.addScopedEventListener(this, "play", () => {
          this.scenario.log("play audio", { id: this.transformID });
        });
        this.controls.addScopedEventListener(this, "stop", () => {
          this.scenario.log("stop audio", { id: this.transformID });
        });
      }
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    const isPlaying = this.clip && this.clip.playbackState === "playing";
    this.dispose();
    this.player.cacheBust(this.filePath);
    await this.load(prog);
    if (isPlaying) {
      this.clip.play();
    }
  }
  updateAudioPosition() {
    this.parent.getWorldPosition(P);
    this.scenario.env.audio.setClipPosition(this.transformID.toString(), P.x, P.y, P.z);
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    if (isDefined(this.clip)) {
      this.scenario.env.audio.removeClip(this.transformID.toString());
      this.clip = null;
    }
    if (isDefined(this.controls)) {
      this.controls.removeScope(this);
      this.controls.object.removeFromParent();
      this.controls.dispose();
      this.controls = null;
    }
  }
  play() {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    if (isDefined(this.clip)) {
      return this.clip.play();
    }
    return this.controls.clickPlay();
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    if (isDefined(this.clip)) {
      this.clip.stop();
    } else {
      this.player.stop();
    }
  }
};

// src/vr-apps/yarrow/Connection.ts
var DEFAULT_NAV_ICON = ` ${upArrowText.textStyle} `;
var TEST_OBJECT = new Object3D();
var Connection = class extends BaseProgress {
  constructor(env, transform2, from, to, label) {
    super();
    this.env = env;
    this.transform = transform2;
    this.from = from;
    this.to = to;
    label = label || DEFAULT_NAV_ICON;
    this.icon = new TextMeshButton(this.env, "navButton", label, textButtonStyle);
    this.icon.addEventListener("click", (evt) => {
      if (this.enabled) {
        this.dispatchEvent(evt);
      }
    });
    this.transform.scale.setScalar(0.5);
    this.progressBar = new Cube(this.icon.image.width, 0.025, 0.01, solidWhite);
    this.progressBar.position.y = -this.icon.image.height / 2;
    this.progressBar.position.z = 0.01;
    objGraph(
      this.transform,
      objGraph(
        this.icon,
        this.progressBar
      )
    );
  }
  get object() {
    return this.transform;
  }
  get fromStationID() {
    return this.from.transformID;
  }
  get toStationID() {
    return this.to.transformID;
  }
  get transformID() {
    return this.transform && this.transform.transformID;
  }
  report(soFar, total, msg, est) {
    super.report(soFar, total, msg, est);
    const width2 = this.icon.image.width * this.p;
    this.progressBar.position.x = 0.5 * (width2 - this.icon.image.width);
    this.progressBar.scale.x = width2;
  }
  get label() {
    return this.icon.image.value;
  }
  set label(v) {
    this.icon.image.value = this.icon.image.value = v || DEFAULT_NAV_ICON;
  }
  get enabled() {
    return !this.icon.disabled;
  }
  set enabled(v) {
    this.icon.disabled = !v;
    this.progressBar.visible = !v;
  }
  static calcMatrix(from, to, defaultAvatarHeight, object = null) {
    object = object || TEST_OBJECT;
    const parent = object.parent;
    if (parent) {
      parent.remove(object);
    }
    object.position.copy(to.position);
    object.position.sub(from.position);
    object.position.y = 0;
    object.position.normalize();
    object.position.multiplyScalar(1.5);
    object.position.y += 1;
    object.lookAt(0, defaultAvatarHeight, 0);
    object.updateMatrix();
    if (parent) {
      objGraph(parent, object);
    }
    return object.matrix;
  }
  resetPosition() {
    Connection.calcMatrix(this.from, this.to, this.env.defaultAvatarHeight, this.object);
  }
};

// src/vr-apps/yarrow/StreetViewPhotosphereRig.ts
function getStreetViewImagePath(pano, fovDegrees, headingDegrees, pitchDegrees) {
  return `/Editor/Google/StreetView/Image/${pano}/${fovDegrees}/${headingDegrees}/${pitchDegrees}/`;
}
var StreetViewPhotosphereRig = class extends PhotosphereRig {
  constructor(fetcher2) {
    super(fetcher2, true);
  }
  loadFiles(pano, level, progress) {
    return this.renderFaces(
      getStreetViewImagePath.bind(null, pano),
      level,
      progress
    );
  }
  loadFile(pano, level, progress) {
    return this.renderCubeMap(
      getStreetViewImagePath.bind(null, pano),
      level,
      progress
    );
  }
  async loadImages(pano, level, progress) {
    const files = await this.loadFiles(pano, level, progress);
    return await Promise.all(files.map(createImageFromFile));
  }
  async loadCanvas(pano, level, progress) {
    const file = await this.loadFile(pano, level, progress);
    const img = await createImageFromFile(file);
    return createCanvasFromImage(img);
  }
};

// src/vr-apps/yarrow/StreetViewPhotosphereServiceClient.ts
var StreetViewPhotosphereServiceClient = class extends WorkerClient {
  init(baseURL, isDebug2) {
    this.callMethod("init", [baseURL, isDebug2]);
  }
  propogateEvent(msg) {
    assertNever(msg.eventName);
  }
  loadFiles(pano, level, progress) {
    return this.callMethod("loadFiles", [pano, level], progress);
  }
  loadFile(pano, level, progress) {
    return this.callMethod("loadFile", [pano, level], progress);
  }
  async loadImages(pano, level, progress) {
    const files = await this.loadFiles(pano, level, progress);
    return await Promise.all(files.map(createImageFromFile));
  }
  async loadCanvas(pano, level, progress) {
    const file = await this.loadFile(pano, level, progress);
    const img = await createImageFromFile(file);
    return createCanvasFromImage(img);
  }
};

// src/vr-apps/yarrow/StreetViewPhotosphereServicePool.ts
var StreetViewPhotosphereServicePool = class extends WorkerPool {
  constructor(options, WorkerClientClass) {
    if (options.workers !== 1) {
      options.workers = 1;
    }
    super(options, WorkerClientClass);
  }
  get canvases() {
    return this.peekWorker().canvases;
  }
  init(baseURL, isDebug2) {
    for (const worker2 of this.workers) {
      worker2.init(baseURL, isDebug2);
    }
  }
  loadImages(pano, level, progress) {
    return this.nextWorker().loadImages(pano, level, progress);
  }
  loadCanvas(pano, level, progress) {
    return this.nextWorker().loadCanvas(pano, level, progress);
  }
};

// src/vr-apps/yarrow/createPhotosphereCaptureRig.ts
async function createPhotosphereCaptureRig(fetcher2, tokenOrEnableWorkers, enableWorkers) {
  let token = null;
  if (isBoolean(tokenOrEnableWorkers)) {
    enableWorkers = tokenOrEnableWorkers;
  } else {
    token = tokenOrEnableWorkers;
  }
  token = token || new CancelToken();
  if (false) {
    throw new Exception2("Cannot create a Photosphere Capture Rig in a worker. Use StreetViewPhotosphereRig directly.");
  }
  if (!isFirefox() && enableWorkers) {
    const threejs = await fetcher2.get(getLibScriptUrl("three")).text().then(unwrapResponse);
    token.check();
    const worker2 = await fetcher2.get(getWorkerUrl("photosphere-capture")).text().then(unwrapResponse);
    token.check();
    const script = threejs + worker2;
    const blob = new Blob([script], {
      type: Application_Javascript.value
    });
    const scriptPath = URL.createObjectURL(blob);
    return new StreetViewPhotosphereServicePool(
      { scriptPath },
      StreetViewPhotosphereServiceClient
    );
  } else {
    fetcher2 = fetcher2 || createFetcher(false);
    return new StreetViewPhotosphereRig(fetcher2);
  }
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/DwellEventer.ts
var DwellEvent = class extends TypedEvent {
  constructor(dwellTimeSeconds) {
    super("dwell");
    this.dwellTimeSeconds = dwellTimeSeconds;
  }
};
var DwellEventer = class extends TypedEventBase {
  constructor(minTimeSeconds = 1, graceTimeSeconds = 0.25) {
    super();
    this.minTimeSeconds = minTimeSeconds;
    this.graceTimeSeconds = graceTimeSeconds;
    this.startTime = null;
    this.graceTimer = null;
    Object.seal(this);
  }
  start() {
    this.stopGrace();
    if (this.startTime === null) {
      this.startTime = performance.now();
    }
  }
  stopGrace() {
    if (this.graceTimer !== null) {
      clearTimeout(this.graceTimer);
      this.graceTimer = null;
    }
  }
  stop() {
    if (this.startTime !== null) {
      this.graceTimer = setTimeout(() => {
        this.graceTimer = null;
        const delta3 = (performance.now() - this.startTime) / 1e3;
        this.startTime = null;
        if (delta3 > this.minTimeSeconds) {
          this.dispatchEvent(new DwellEvent(delta3));
        }
      }, this.graceTimeSeconds * 1e3);
    }
  }
};

// src/vr-apps/yarrow/Model.ts
var modelTemplateTasks = singleton("Yarrow:Model:modelTemplateTasks", () => /* @__PURE__ */ new Map());
var Model = class extends Object3D {
  constructor(scenario, model2, parent) {
    super();
    this.scenario = scenario;
    this.model = null;
    this.error = null;
    this.disposed = false;
    this.name = `model-${model2.fileName}`;
    this.key = model2.key;
    this.scenarioID = model2.scenarioID;
    this.fileID = model2.fileID;
    this.fileName = model2.fileName;
    this.filePath = model2.filePath;
    this.fileTagString = model2.fileTagString;
    this.transformID = model2.transformID;
    this.mediaType = model2.mediaType;
    this.trueMediaType = model2.trueMediaType;
    this.copyright = model2.copyright;
    this.copyrightDate = model2.copyrightDate;
    this.target = new RayTarget(this);
    objGraph(parent, this);
    Object.seal(this);
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    if (isDefined(this.model)) {
      this.model.removeFromParent();
      cleanup(this.model);
      this.model = null;
    }
  }
  async load(prog) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    let templateTask = modelTemplateTasks.get(this.filePath);
    if (!templateTask) {
      const asset = new AssetGltfModel(this.scenario.env, this.filePath, this.mediaType, !this.scenario.env.DEBUG);
      templateTask = asset.then((template2) => {
        try {
          convertMaterials(template2.scene, materialStandardToPhong);
        } catch (err) {
          this.error = err;
        }
        return template2;
      });
      modelTemplateTasks.set(this.filePath, templateTask);
      this.scenario.env.fetcher.assets(prog, asset);
    }
    const template = await templateTask;
    const dweller = new DwellEventer();
    dweller.addEventListener("dwell", (evt) => {
      this.scenario.log("model viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
    });
    this.model = template.scene.clone(true);
    this.model.traverse((obj2) => {
      if (isMesh(obj2)) {
        this.target.addMesh(obj2);
      }
    });
    this.target.addEventListener("enter", (evt) => {
      if (evt.pointer.type === "nose") {
        dweller.start();
      }
    });
    this.target.addEventListener("exit", (evt) => {
      if (evt.pointer.type === "nose") {
        dweller.stop();
      }
    });
    objGraph(this, this.model);
  }
  async reload(prog) {
    this.dispose();
    this.error = null;
    await this.load(prog);
  }
  get size() {
    return this.parent.scale.x;
  }
  set size(v) {
    this.parent.scale.setScalar(v);
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};

// src/vr-apps/yarrow/Sign.ts
var TRANSITION_TIME = 1e3;
var SPEED = 1e3 / TRANSITION_TIME;
var Q2 = new Vector3();
var iconSize = 0.15;
var textSize = 0.1;
var signLabelStyle = {
  minHeight: textSize,
  maxHeight: textSize,
  minWidth: textSize,
  padding: 0.02,
  scale: 1e3,
  bgFillColor: DLSBlue,
  textFillColor: "white"
};
var _Sign = class extends Object3D {
  constructor(scenario, data, parent) {
    super();
    this.scenario = scenario;
    this.originPoint = new Vector3();
    this.originRotation = new Quaternion();
    this._isCallout = false;
    this.wasCallout = null;
    this._alwaysVisible = false;
    this.wasAlwaysVisible = null;
    this.opacity = 1;
    this.lastOpacity = null;
    this.file = null;
    this.pdf = null;
    this.zoomInButton = null;
    this.zoomOutButton = null;
    this.prevButton = null;
    this.pageLabel = null;
    this.nextButton = null;
    this.error = null;
    this.disposed = false;
    this.invMatrix = new Matrix4();
    this.dumpScale = new Vector3();
    this.followObj = this.scenario.env.worldUISpace;
    this.onClick = () => this.toggle();
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.transformID = data.transformID;
    this.name = `sign-${data.fileName}`;
    this.originPoint.copy(this.position);
    this.originRotation.copy(this.quaternion);
    objGraph(parent, this);
    this._alwaysVisible = data.alwaysVisible;
    this._isCallout = data.isCallout;
    this.start = -1;
    this.end = 0;
    this.t = 1;
    this.direction = -1;
    this.target = new RayTarget(this);
    this.scenario.addScopedEventListener(this, "present", (evt) => {
      if (this.direction !== -1 && evt.source !== this) {
        this.toggle();
      }
    });
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    this.scenario.removeScope(this);
    if (isDefined(this.image)) {
      this.image.dispose();
      this.image = null;
    }
    this.removeButton(this.zoomInButton);
    this.zoomInButton = null;
    this.removeButton(this.zoomOutButton);
    this.zoomOutButton = null;
    this.removeButton(this.prevButton);
    this.prevButton = null;
    this.removeButton(this.nextButton);
    this.nextButton = null;
    this.removeButton(this.pageLabel);
    this.pageLabel = null;
    this.pdf = null;
  }
  removeButton(obj2) {
    if (isDefined(obj2)) {
      if (obj2 instanceof TypedEventBase) {
        obj2.removeScope(this);
      }
      if (isErsatzObject(obj2)) {
        obj2.object.removeFromParent();
        cleanup(obj2);
      }
    }
  }
  async load(progress) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    try {
      const [file, zoomInButton, zoomOutButton] = await all(
        this.scenario.env.fetcher.get(this.filePath).progress(progress).file(),
        this.scenario.env.uiButtons.getMeshButton("zoom", "in", iconSize),
        this.scenario.env.uiButtons.getMeshButton("zoom", "out", iconSize)
      );
      this.file = file;
      this.zoomInButton = zoomInButton;
      this.zoomInButton.addScopedEventListener(this, "click", this.onClick);
      this.zoomInButton.object.visible = this.isCallout;
      this.zoomOutButton = zoomOutButton;
      this.zoomOutButton.addScopedEventListener(this, "click", this.onClick);
      this.zoomOutButton.object.visible = false;
      objGraph(this, this.zoomInButton, this.zoomOutButton);
      if (Application_Pdf.matches(this.file.contentType)) {
        this.pdf = new PDFImage(this.file.content, { scale: 2 });
        const [prevButton, nextButton] = await all(
          this.scenario.env.uiButtons.getMeshButton("arrow", "left", 0.1),
          this.scenario.env.uiButtons.getMeshButton("arrow", "right", 0.1)
        );
        objGraph(
          this,
          this.prevButton = prevButton,
          this.pageLabel = new TextMesh(this.scenario.env, "label-" + this.transformID, "none", signLabelStyle, { side: FrontSide }),
          this.nextButton = nextButton
        );
        this.prevButton.addScopedEventListener(this, "click", () => this.loadImage(this.pdf.curPageIndex - 1));
        this.nextButton.addScopedEventListener(this, "click", () => this.loadImage(this.pdf.curPageIndex + 1));
      }
      objGraph(
        this,
        this.image = new Image2D(this.scenario.env, `Sign(${this.key}) ${file.fileName}`, "dynamic")
      );
      const dweller = new DwellEventer();
      dweller.addEventListener("dwell", (evt) => {
        this.scenario.log("sign viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
      });
      this.target.clickable = true;
      this.target.addEventListener("click", this.onClick);
      this.target.addEventListener("enter", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.start();
        }
      });
      this.target.addEventListener("exit", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.stop();
        }
      });
      await this.loadImage(0);
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    this.dispose();
    this.error = null;
    await this.load(prog);
  }
  async loadImage(pageIndex) {
    if (this.pdf) {
      this.prevButton.disabled = true;
      this.nextButton.disabled = true;
    }
    const image2 = await this.getFrame(pageIndex);
    this.image.setTextureMap(image2);
    this.image.objectWidth = 1;
    if (this.pdf) {
      const y = this.image.objectHeight / 2;
      this.prevButton.object.visible = this.pageLabel.object.visible = this.nextButton.object.visible = this.hasPages;
      if (this.hasPages) {
        this.prevButton.object.position.set(-0.5, -y, 0.1);
        this.pageLabel.position.set(0, -y, 0.1);
        this.nextButton.object.position.set(0.5, -y, 0.1);
        this.prevButton.disabled = !this.pdf.canGoBack;
        this.pageLabel.image.value = `${this.pdf.curPageNumber} of ${this.pdf.numPages}`;
        this.nextButton.disabled = !this.pdf.canGoForward;
      }
    }
  }
  async getFrame(pageIndex) {
    if (this.pdf) {
      this.scenario.log("view sign page", { id: this.transformID, page: pageIndex });
      await this.pdf.getPage(pageIndex);
      return this.pdf.canvas;
    } else {
      return await this.scenario.env.fetcher.get(this.file.content).image().then(unwrapResponse);
    }
  }
  get isCallout() {
    return this._isCallout;
  }
  set isCallout(v) {
    this._isCallout = v;
    this.update(0);
  }
  get hasPages() {
    return this.pdf && this.pdf.numPages > 1;
  }
  get alwaysVisible() {
    return this._alwaysVisible;
  }
  set alwaysVisible(v) {
    this._alwaysVisible = v;
    this.update(0);
  }
  get isClickable() {
    return this.isCallout || !this.alwaysVisible;
  }
  get showZoomIn() {
    return this.isClickable && this.direction === -1 && this.t >= this.end;
  }
  get showZoomOut() {
    return this.isClickable && this.direction === 1 && this.t >= this.end;
  }
  toggle() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      if (this.direction !== 1) {
        this.scenario.log("expand sign", { id: this.transformID });
        this.target.addMesh(this.image.mesh);
        this.direction = 1;
        const evt = new PresentEvent(this);
        this.scenario.dispatchEvent(evt);
      } else {
        this.target.removeMesh(this.image.mesh);
        this.direction = -1;
      }
      const left2 = Math.max(0, this.end - this.t);
      this.start = performance.now();
      this.end = this.start + TRANSITION_TIME;
      this.t = this.start + left2;
    }
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      this.start = -1;
      this.t = 0;
      this.end = 0;
      this.direction = -1;
    }
    if (isDefined(this.image)) {
      this.image.removeWebXRLayer();
    }
  }
  update(dt) {
    if (isDefined(this.error) || !isDefined(this.parent)) {
      return;
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.visible = this.showZoomIn;
      this.zoomOutButton.object.visible = this.showZoomOut;
      if (this.isCallout !== this.wasCallout || this.alwaysVisible !== this.wasAlwaysVisible) {
        const x = this.image.objectWidth / 2;
        const y = this.image.objectHeight / 2;
        this.zoomInButton.object.visible = this.isClickable;
        this.zoomOutButton.object.visible = false;
        if (this.alwaysVisible) {
          this.zoomInButton.object.position.set(x, y, 0.1);
        } else {
          this.zoomInButton.object.position.set(0, 0, 0);
        }
        this.zoomOutButton.object.position.set(x, y, 0.1);
        this.wasCallout = this.isCallout;
        this.wasAlwaysVisible = this.alwaysVisible;
      }
    }
    this.t += SPEED * dt;
    const p = project(this.t, this.start, this.end);
    const q = clamp(p, 0, 1);
    const r = this.direction === 1 ? 1 - q : q;
    if (this.isCallout) {
      this.invMatrix.copy(this.parent.matrixWorld).invert().multiply(this.followObj.matrixWorld).multiply(_Sign.offsetMatrix).decompose(this.position, this.quaternion, this.dumpScale);
      this.position.lerp(this.originPoint, r);
      this.quaternion.slerp(this.originRotation, r);
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.lookAt(this.scenario.env.avatar.worldPos);
      this.zoomInButton.object.getWorldPosition(Q2);
      this.zoomInButton.size = this.zoomOutButton.size = iconSize * Q2.sub(this.scenario.env.avatar.worldPos).length() / (3 * this.size);
      this.zoomOutButton.object.matrix.copy(this.zoomInButton.object.matrix);
    }
    if (this.alwaysVisible) {
      this.opacity = 1;
    } else {
      this.opacity = this.alwaysVisible ? 1 : 1 - r;
    }
    if (this.opacity !== this.lastOpacity) {
      this.image.mesh.material.opacity = this.opacity;
      this.image.mesh.material.transparent = this.opacity < 1;
      this.image.mesh.material.needsUpdate = true;
      this.image.mesh.visible = 0 < this.opacity && this.opacity < 1 || !(this.scenario.env.showWebXRLayers && this.scenario.env.hasXRCompositionLayers);
      this.image.webXRLayerType = this.opacity === 1 ? "dynamic" : "none";
      if (isDefined(this.pdf)) {
        this.prevButton.object.visible = this.pageLabel.object.visible = this.nextButton.object.visible = this.hasPages && this.opacity === 1;
      }
      this.lastOpacity = this.opacity;
    }
  }
  get size() {
    return this.parent.scale.x;
  }
  set size(v) {
    this.parent.scale.setScalar(v);
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};
var Sign = _Sign;
Sign.offsetMatrix = new Matrix4().makeTranslation(0, 0, -1.5);

// src/vr-apps/yarrow/Station.ts
var Station = class {
  constructor(scenario, data) {
    this.scenario = scenario;
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.transformID = data.transformID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.location = data.location;
    this.zone = data.zone;
    this.label = data.label;
    this.rotation = data.rotation;
  }
  async reload(prog) {
    this.scenario.evict(this);
    if (this.scenario.curStation === this) {
      await this.scenario.env.withFade(async () => {
        this.scenario.env.skybox.clear();
        await this.scenario.showStation(this, false, prog);
      });
    }
  }
};

// src/vr-apps/yarrow/Text.ts
var TRANSITION_TIME2 = 1e3;
var SPEED2 = 1e3 / TRANSITION_TIME2;
var Q3 = new Vector3();
var iconSize2 = 0.15;
var textSize2 = 0.2;
var textLabelStyle3 = {
  minHeight: textSize2,
  maxHeight: textSize2,
  minWidth: textSize2,
  padding: 0.04,
  scale: 1e3,
  bgFillColor: "white",
  textFillColor: "black",
  bgStrokeColor: DLSBlue,
  bgStrokeSize: 0.01
};
var _Text = class extends Object3D {
  constructor(scenario, data, parent) {
    super();
    this.scenario = scenario;
    this.originPoint = new Vector3();
    this.originRotation = new Quaternion();
    this._isCallout = false;
    this.wasCallout = null;
    this._alwaysVisible = false;
    this.wasAlwaysVisible = null;
    this.opacity = 1;
    this.lastOpacity = null;
    this.zoomInButton = null;
    this.error = null;
    this.disposed = false;
    this.invMatrix = new Matrix4();
    this.dumpScale = new Vector3();
    this.followObj = this.scenario.env.worldUISpace;
    this.onClick = () => this.toggle();
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.transformID = data.transformID;
    this.name = `text-${data.fileName}`;
    this.originPoint.copy(this.position);
    this.originRotation.copy(this.quaternion);
    objGraph(parent, this);
    this._alwaysVisible = data.alwaysVisible;
    this._isCallout = data.isCallout;
    this.start = -1;
    this.end = 0;
    this.t = 1;
    this.direction = -1;
    this.target = new RayTarget(this);
    this.scenario.addScopedEventListener(this, "present", (evt) => {
      if (this.direction !== -1 && evt.source !== this) {
        this.toggle();
      }
    });
  }
  get text() {
    return this.image.image.value;
  }
  set text(v) {
    this.image.image.value = v;
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    this.scenario.removeScope(this);
    if (isDefined(this.image)) {
      this.image.dispose();
      this.image = null;
    }
    this.removeButton(this.zoomInButton);
    this.zoomInButton = null;
  }
  removeButton(obj2) {
    if (isDefined(obj2)) {
      if (obj2 instanceof TypedEventBase) {
        obj2.removeScope(this);
      }
      if (isErsatzObject(obj2)) {
        obj2.object.removeFromParent();
        cleanup(obj2);
      }
    }
  }
  async load(progress) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    this.disposed = false;
    try {
      const [text2, zoomInButton] = await all(
        this.scenario.env.fetcher.get(this.filePath).progress(progress).text(),
        this.scenario.env.uiButtons.getMeshButton("zoom", "info", iconSize2)
      );
      this.zoomInButton = zoomInButton;
      this.zoomInButton.addScopedEventListener(this, "click", this.onClick);
      this.zoomInButton.object.visible = this.isCallout;
      objGraph(this, this.zoomInButton);
      objGraph(
        this,
        this.image = new TextMesh(this.scenario.env, `Text(${this.key}) ${text2.fileName}`, "dynamic", textLabelStyle3)
      );
      const dweller = new DwellEventer();
      dweller.addEventListener("dwell", (evt) => {
        this.scenario.log("text viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
      });
      this.target.clickable = true;
      this.target.addEventListener("click", this.onClick);
      this.target.addEventListener("enter", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.start();
        }
      });
      this.target.addEventListener("exit", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.stop();
        }
      });
      this.image.image.value = text2.content;
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    this.dispose();
    this.error = null;
    await this.load(prog);
  }
  get isCallout() {
    return this._isCallout;
  }
  set isCallout(v) {
    this._isCallout = v;
    this.update(0);
  }
  get alwaysVisible() {
    return this._alwaysVisible;
  }
  set alwaysVisible(v) {
    this._alwaysVisible = v;
    this.update(0);
  }
  get isClickable() {
    return this.isCallout || !this.alwaysVisible;
  }
  get showZoomIn() {
    return this.isClickable && this.direction === -1 && this.t >= this.end;
  }
  toggle() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      if (this.direction !== 1) {
        this.scenario.log("expand text", { id: this.transformID });
        this.target.addMesh(this.image.mesh);
        this.direction = 1;
        const evt = new PresentEvent(this);
        this.scenario.dispatchEvent(evt);
      } else {
        this.target.removeMesh(this.image.mesh);
        this.direction = -1;
      }
      const left2 = Math.max(0, this.end - this.t);
      this.start = performance.now();
      this.end = this.start + TRANSITION_TIME2;
      this.t = this.start + left2;
    }
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    if (this.isClickable) {
      this.start = -1;
      this.t = 0;
      this.end = 0;
      this.direction = -1;
    }
    if (isDefined(this.image)) {
      this.image.removeWebXRLayer();
    }
  }
  update(dt) {
    if (isDefined(this.error) || !isDefined(this.parent)) {
      return;
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.visible = this.showZoomIn;
      if (this.isCallout !== this.wasCallout || this.alwaysVisible !== this.wasAlwaysVisible) {
        const x = this.image.objectWidth / 2;
        const y = this.image.objectHeight / 2;
        this.zoomInButton.object.visible = this.isClickable;
        if (this.alwaysVisible) {
          this.zoomInButton.object.position.set(x, y, 0.1);
        } else {
          this.zoomInButton.object.position.set(0, 0, 0);
        }
        this.wasCallout = this.isCallout;
        this.wasAlwaysVisible = this.alwaysVisible;
      }
    }
    this.t += SPEED2 * dt;
    const p = project(this.t, this.start, this.end);
    const q = clamp(p, 0, 1);
    const r = this.direction === 1 ? 1 - q : q;
    if (this.isCallout) {
      this.invMatrix.copy(this.parent.matrixWorld).invert().multiply(this.followObj.matrixWorld).multiply(_Text.offsetMatrix).decompose(this.position, this.quaternion, this.dumpScale);
      this.position.lerp(this.originPoint, r);
      this.quaternion.slerp(this.originRotation, r);
    }
    if (isDefined(this.zoomInButton)) {
      this.zoomInButton.object.lookAt(this.scenario.env.avatar.worldPos);
      this.zoomInButton.object.getWorldPosition(Q3);
      this.zoomInButton.size = iconSize2 * Q3.sub(this.scenario.env.avatar.worldPos).length() / (3 * this.size);
    }
    if (this.alwaysVisible) {
      this.opacity = 1;
    } else {
      this.opacity = this.alwaysVisible ? 1 : 1 - r;
    }
    if (this.opacity !== this.lastOpacity) {
      this.image.mesh.material.opacity = this.opacity;
      this.image.mesh.material.transparent = this.opacity < 1;
      this.image.mesh.material.needsUpdate = true;
      this.image.mesh.visible = 0 < this.opacity && this.opacity < 1 || !(this.scenario.env.showWebXRLayers && this.scenario.env.hasXRCompositionLayers);
      this.image.webXRLayerType = this.opacity === 1 ? "dynamic" : "none";
      this.lastOpacity = this.opacity;
    }
  }
  get size() {
    return this.parent.scale.x;
  }
  set size(v) {
    this.parent.scale.setScalar(v);
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};
var Text = _Text;
Text.offsetMatrix = new Matrix4().makeTranslation(0, 0, -1.5);

// src/vr-apps/yarrow/Video.ts
var Video2 = class extends Object3D {
  constructor(scenario, proxy, parent, player, data) {
    super();
    this.scenario = scenario;
    this.proxy = proxy;
    this.player = player;
    this.controls = null;
    this.data = null;
    this.error = null;
    this.disposed = false;
    this.label = data.label;
    this.volume = data.volume;
    this.enabled = data.enabled;
    this.transformID = data.transformID;
    this.key = data.key;
    this.scenarioID = data.scenarioID;
    this.fileID = data.fileID;
    this.fileName = data.fileName;
    this.filePath = data.filePath;
    this.fileTagString = data.fileTagString;
    this.mediaType = data.mediaType;
    this.trueMediaType = data.trueMediaType;
    this.copyright = data.copyright;
    this.copyrightDate = data.copyrightDate;
    this.sphereEncodingName = data.sphereEncodingName;
    this.stereoLayoutName = data.stereoLayoutName;
    this.name = "video-" + data.fileName;
    objGraph(
      parent,
      objGraph(
        this,
        this.thumbnail = new Image2D(this.scenario.env, "thumbnail-" + data.fileName, "static")
      )
    );
    this.size = parent.scale.x;
    parent.scale.setScalar(1);
    this.target = new RayTarget(this);
    Object.seal(this);
  }
  dispose() {
    if (!this.disposed) {
      this.onDisposing();
      this.disposed = true;
    }
  }
  onDisposing() {
    if (isDefined(this.thumbnail)) {
      this.thumbnail.dispose();
    }
    if (isDefined(this.controls)) {
      this.controls.removeScope(this);
      this.controls.dispose();
    }
  }
  async load(prog) {
    if (isDefined(this.error)) {
      return Promise.resolve();
    }
    try {
      const progs = progressSplitWeighted(prog, [10, 1]);
      if (Video_Vnd_DlsDc_YtDlp_Json.matches(this.mediaType)) {
        this.data = await this.proxy.loadData(this.filePath, progs.shift());
        const thumbnailImage2 = await this.scenario.env.fetcher.get(this.data.thumbnail.url).image(this.data.thumbnail.contentType).then(unwrapResponse);
        this.thumbnail.setTextureMap(thumbnailImage2);
        this.thumbnail.objectWidth = 1;
        this.thumbnail.mesh.renderOrder = 4;
      }
      const title2 = this.label || this.data && this.data.title && this.data.title.substring(0, 25) || this.fileName;
      objGraph(
        this,
        objGraph(this.controls = new PlaybackButton(
          this.scenario.env,
          this.scenario.env.uiButtons,
          this.data || this.filePath,
          this.filePath,
          title2,
          this.volume,
          this.player
        ))
      );
      this.controls.object.renderOrder = 5;
      this.controls.object.position.y = -this.thumbnail.objectHeight / 2;
      this.controls.object.position.z = 0.01;
      const showHideVideo = (v) => () => {
        this.thumbnail.visible = !v;
        this.player.object.visible = v;
        if (v) {
          this.scenario.log("play video", { id: this.transformID });
          objGraph(this, this.player);
          this.player.setStereoParameters(this.sphereEncodingName, this.stereoLayoutName);
          this.player.object.position.set(0, 0, 0);
          this.player.object.quaternion.identity();
          this.target.addMeshes(...this.player.meshes);
        } else {
          this.scenario.log("stop video", { id: this.transformID });
          this.target.removeMeshes(...this.player.meshes);
        }
      };
      this.controls.addScopedEventListener(this, "play", showHideVideo(true));
      this.controls.addScopedEventListener(this, "stop", showHideVideo(false));
      const dweller = new DwellEventer();
      dweller.addEventListener("dwell", (evt) => {
        this.scenario.log("video viewed", { id: this.transformID, time: evt.dwellTimeSeconds });
      });
      this.target.addEventListener("enter", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.start();
        }
      });
      this.target.addEventListener("exit", (evt) => {
        if (evt.pointer.type === "nose") {
          dweller.stop();
        }
      });
      this.disposed = false;
    } catch (error) {
      this.error = error;
      this.dispose();
    }
  }
  async reload(prog) {
    this.dispose();
    await this.load(prog);
  }
  reset() {
    if (isDefined(this.error)) {
      return;
    }
    this.player.stop();
    if (isDefined(this.thumbnail)) {
      this.thumbnail.removeWebXRLayer();
    }
  }
  get size() {
    return this.scale.x;
  }
  set size(v) {
    this.scale.x = this.scale.y = v;
  }
  get rotationX() {
    return rad2deg(this.parent.rotation.x);
  }
  get rotationY() {
    return rad2deg(this.parent.rotation.y);
  }
  get rotationZ() {
    return rad2deg(this.parent.rotation.z);
  }
};

// src/vr-apps/yarrow/BaseScenario.ts
var ScenarioNavigateEvent = class extends TypedEvent {
  constructor(station) {
    super("navigate");
    this.station = station;
  }
};
var PresentEvent = class extends Event {
  constructor(source) {
    super("present");
    this.source = source;
    Object.seal(this);
  }
};
var BaseScenario3 = class extends TypedEventBase {
  constructor(env, dataLogger, data) {
    super();
    this.env = env;
    this.dataLogger = dataLogger;
    this.data = data;
    this.stations = new Array();
    this.signs = new Array();
    this.videos = new Array();
    this.texts = new Array();
    this.audios = new Array();
    this.models = new Array();
    this.signsByStation = new PriorityList();
    this.videosByStation = new PriorityList();
    this.textsByStation = new PriorityList();
    this.audiosByStation = new PriorityList();
    this.modelsByStation = new PriorityList();
    this.curConnections = new PriorityMap();
    this.transformsByTransformID = /* @__PURE__ */ new Map();
    this.zonedClips = new PriorityList();
    this.playbackButtons = /* @__PURE__ */ new Map();
    this.videosReady = null;
    this.cancellationToken = null;
    this.curStationID = null;
    this.curZone = null;
    this.rootTransformID = null;
    this.__originLL = null;
    this._originUTM = null;
    this.windowQuitter = new WindowQuitEventer();
    this.disposed = false;
    this._muteEnvAudio = false;
    this.imgCache = new LRUCache(10);
    this.imgTasks = /* @__PURE__ */ new Map();
    this.imgCache.addEventListener("itemevicted", (evt) => {
      if (isImageBitmap(evt.value)) {
        evt.value.close();
      }
    });
    this.yt = new YouTubeProxy(this.env.fetcher, makeProxyURL);
    if (isDefined(data.origin)) {
      this._originLL = new LatLngPoint(data.origin);
    }
    this.startStationID = data.startStationID;
    this.startRotation = data.startRotation;
    this.transforms = data.transforms;
    this.connections = data.connections;
    this.env.addScopedEventListener(this, "environmentaudiotoggled", () => {
      this.environmentAudioMuted = env.environmentAudioMuted;
    });
    let quit = false;
    const onQuit = () => {
      if (!quit) {
        quit = true;
        this.logLeaveStation();
        this.log("leave scenario", { id: this.id });
      }
    };
    this.env.addScopedEventListener(this, "quitting", onQuit);
    this.windowQuitter.addScopedEventListener(this, "quitting", onQuit);
    this.env.addScopedEventListener(this, "sceneclearing", () => {
      this.pauseCurrentAudioZone();
      this.curZone = null;
    });
    this.env.avatar.addScopedEventListener(this, "avatarreset", () => {
      this.moveToStation(this.curStation);
    });
  }
  get isEmpty() {
    return this.stations.length === 0 && this.connections.length === 0 && this.signs.length === 0 && this.videos.length === 0 && this.texts.length === 0 && this.audios.length === 0 && this.models.length === 0;
  }
  get rootTransform() {
    return this.transformsByTransformID.get(this.rootTransformID);
  }
  get _originLL() {
    return this.__originLL;
  }
  set _originLL(v) {
    this.__originLL = v;
    if (isDefined(v)) {
      this._originUTM = this.originLL.toUTM();
    } else {
      this._originUTM = null;
    }
  }
  get originLL() {
    return this._originLL;
  }
  get originUTM() {
    return this._originUTM;
  }
  get id() {
    return this.data.id;
  }
  get name() {
    return this.data.name;
  }
  get version() {
    return this.data.version;
  }
  get published() {
    return this.data.published;
  }
  get roomName() {
    return this.data.roomName;
  }
  async loadAssets(prog) {
    this.cancellationToken = new CancelToken();
    this.clearCache();
    this.rig = await createPhotosphereCaptureRig(this.env.fetcher, this.cancellationToken);
    this.rig.init(location.href, this.env.DEBUG);
    prog = prog || this.env.loadingBar;
    const [pdfJSProg, assetProg] = progressSplitWeighted(prog, [1, 100]);
    await PDFImage.prepare(getScriptUrl("pdfjs"), this.env.fetcher, this.env.DEBUG, pdfJSProg);
    for (const transformData of this.data.transforms) {
      this.addTransformData(transformData);
    }
    for (const transformData of this.data.transforms) {
      if (transformData.parentTransformID === 0) {
        this.rootTransformID = transformData.id;
      } else {
        const parent = this.getTransform(transformData.parentTransformID);
        const child = this.getTransform(transformData.id);
        parent.attach(child);
      }
    }
    const [otherAssetProg, videoAssetProg] = progressSplitWeighted(assetProg, [10, 1]);
    this.videosReady = progressOfArray(videoAssetProg, this.data.videoClips, (videoClip, prog2) => this.createVideo(videoClip, prog2).catch((exp2) => {
      if (exp2 instanceof CancelSignalException) {
        console.warn("Late load cancellation occured");
      } else {
        throw exp2;
      }
    })).then(() => null);
    await progressTasksWeighted(otherAssetProg, [
      /////////// BUILD STATIONS ///////////
      [this.data.stations.length, (prog2) => progressOfArray(prog2, this.data.stations, (station, prog3) => this.createStation(station, prog3))],
      /////////// BUILD SIGNS ///////////
      [this.data.signs.length, (prog2) => progressOfArray(prog2, this.data.signs, (sign, prog3) => this.createSign(sign, prog3))],
      /////////// BUILD MODELS ///////////
      [this.data.models.length, (prog2) => progressOfArray(prog2, this.data.models, (model2, prog3) => this.createModel(model2, prog3))],
      /////////// BUILD AUDIO TRACKS ///////////
      [this.data.audioTracks.length, (prog2) => progressOfArray(prog2, this.data.audioTracks, (audioTrack, prog3) => this.createAudio(audioTrack, prog3))],
      /////////// BUILD TEXTS ///////////
      [this.data.texts.length, (prog2) => progressOfArray(prog2, this.data.texts, (text2, prog3) => this.createText(text2, prog3))]
    ]);
    for (const connection of this.data.connections) {
      this.createConnection(connection);
    }
    this.env.addScopedEventListener(this, "update", (evt) => this.update(evt));
  }
  dispose() {
    if (!this.disposed) {
      if (this.cancellationToken) {
        this.cancellationToken.cancel();
      }
      this.env.infoLabel.image.clear();
      this.pauseCurrentAudioZone();
      this.env.removeScope(this);
      this.env.avatar.removeScope(this);
      for (const audio2 of this.audios) {
        audio2.dispose();
      }
      for (const sign of this.signs) {
        sign.dispose();
      }
      for (const model2 of this.models) {
        model2.dispose();
      }
      for (const video2 of this.videos) {
        video2.dispose();
      }
      for (const text2 of this.texts) {
        text2.dispose();
      }
      const root = this.transformsByTransformID.get(this.rootTransformID);
      root.removeFromParent();
      cleanup(root);
      this.transformsByTransformID.clear();
      this.signsByStation.clear();
      this.audiosByStation.clear();
      this.videosByStation.clear();
      this.textsByStation.clear();
      this.modelsByStation.clear();
      this.zonedClips.clear();
      arrayClear(this.audios);
      arrayClear(this.videos);
      arrayClear(this.texts);
      arrayClear(this.signs);
      arrayClear(this.models);
      this.windowQuitter.removeScope(this);
      this.disposed = true;
    }
  }
  get avatarHeightOffset() {
    return this.env.avatar.height - this.env.defaultAvatarHeight;
  }
  update(evt) {
    const signs = this.signsByStation.get(this.curStation);
    for (const sign of signs) {
      sign.update(evt.dt);
    }
    const texts = this.textsByStation.get(this.curStation);
    for (const text2 of texts) {
      text2.update(evt.dt);
    }
  }
  get environmentAudioMuted() {
    return this._muteEnvAudio;
  }
  set environmentAudioMuted(v) {
    if (v !== this.environmentAudioMuted) {
      this._muteEnvAudio = v;
      if (this.environmentAudioMuted) {
        this.pauseCurrentAudioZone();
      } else {
        this.playCurrentAudioZone();
      }
    }
  }
  addTransformData(transformData) {
    const transform2 = new Transform(transformData);
    this.transformsByTransformID.set(transform2.transformID, transform2);
    return transform2;
  }
  getTransform(transformID) {
    return this.transformsByTransformID.get(transformID);
  }
  getStation(stationID) {
    return arrayScan(this.stations, (s) => s.transformID === stationID);
  }
  get curStation() {
    return this.getStation(this.curStationID);
  }
  get startStation() {
    return this.getStation(this.startStationID);
  }
  async createStation(data, prog) {
    if (prog) {
      prog.end();
    }
    const station = new Station(this, data);
    this.stations.push(station);
    return station;
  }
  async createConnection(data) {
    try {
      const fromStation = this.getStation(data.fromStationID);
      const toStation = this.getStation(data.toStationID);
      const fromTransform = this.getTransform(fromStation.transformID);
      const toTransform = this.getTransform(toStation.transformID);
      let transform2 = this.getTransform(data.transformID);
      if (isNullOrUndefined(transform2)) {
        data.transformID = -this.transforms.length;
        const transformData = {
          id: data.transformID,
          name: `nav-icon-from-${fromTransform.name}-to-${toTransform.name}`,
          matrix: Connection.calcMatrix(fromTransform, toTransform, this.env.defaultAvatarHeight).toArray(),
          parentTransformID: fromStation.transformID
        };
        this.transforms.push(transformData);
        transform2 = this.addTransformData(transformData);
        objGraph(fromTransform, transform2);
      }
      const icon = new Connection(this.env, transform2, fromTransform, toTransform, data.label);
      icon.addEventListener("click", () => {
        this.dispatchEvent(new ScenarioNavigateEvent(toStation));
        this.showStation(toStation, true, this.env.loadingBar);
      });
      this.curConnections.add(fromStation, toStation, icon);
      return icon;
    } catch (err) {
      console.error({ task: "createConnection", err, data });
      return null;
    }
  }
  async createSign(data, prog) {
    const transform2 = this.getTransform(data.transformID);
    const sign = new Sign(this, data, transform2);
    this.signs.push(sign);
    await sign.load(prog);
    this.cancellationToken.check();
    const station = this.findStation(sign);
    this.signsByStation.add(station, sign);
    return sign;
  }
  async createModel(data, prog) {
    const transform2 = this.getTransform(data.transformID);
    const obj2 = new Model(this, data, transform2);
    this.models.push(obj2);
    await obj2.load(prog);
    this.cancellationToken.check();
    const station = this.findStation(obj2);
    this.modelsByStation.add(station, obj2);
    return obj2;
  }
  async createAudio(data, prog) {
    const transform2 = this.getTransform(data.transformID);
    const audio2 = new Audio4(this, transform2, this.env.audioPlayer, data);
    this.audios.push(audio2);
    const station = this.findStation(audio2.parent);
    this.audiosByStation.add(station, audio2);
    await audio2.load(prog);
    this.cancellationToken.check();
    if (isDefined(audio2.controls)) {
      this.playbackButtons.set(audio2.parent, audio2.controls);
      if (isNullOrUndefined(audio2.error)) {
        audio2.controls.addEventListener("play", () => this.pauseCurrentAudioZone());
        audio2.controls.addEventListener("stop", () => this.playCurrentAudioZone());
      }
    }
    if (isDefined(audio2.clip)) {
      this.zonedClips.add(audio2.zone, audio2.clip);
    }
    return audio2;
  }
  async createVideo(data, prog) {
    const transform2 = this.getTransform(data.transformID);
    const video2 = new Video2(this, this.yt, transform2, this.env.videoPlayer, data);
    this.videos.push(video2);
    await video2.load(prog);
    this.cancellationToken.check();
    this.playbackButtons.set(video2.parent, video2.controls);
    const station = this.findStation(video2.parent);
    this.videosByStation.add(station, video2);
    if (isNullOrUndefined(video2.error)) {
      video2.controls.addEventListener("play", () => this.pauseCurrentAudioZone());
      video2.controls.addEventListener("stop", () => this.playCurrentAudioZone());
    }
    return video2;
  }
  async createText(data, prog) {
    const transform2 = this.getTransform(data.transformID);
    const text2 = new Text(this, data, transform2);
    this.texts.push(text2);
    await text2.load(prog);
    this.cancellationToken.check();
    const station = this.findStation(text2);
    this.textsByStation.add(station, text2);
    return text2;
  }
  getConnectionLabel(fromStation, toStation) {
    if (isNullOrUndefined(fromStation) || isNullOrUndefined(toStation)) {
      return null;
    }
    for (const connection of this.connections) {
      if (connection.fromStationID === fromStation.transformID && connection.toStationID === toStation.transformID) {
        return connection.label;
      }
    }
    return null;
  }
  getStationByObject(obj2) {
    if (obj2 instanceof Transform) {
      return this.getStation(obj2.transformID);
    }
    return null;
  }
  findStation(obj2) {
    let station = this.getStationByObject(obj2);
    while (!station && obj2 != null) {
      obj2 = obj2.parent;
      station = this.getStationByObject(obj2);
    }
    return station;
  }
  getStationCenter(station) {
    const v = new Vector3();
    const stTransform = this.getTransform(station.transformID);
    if (stTransform) {
      stTransform.getWorldPosition(v);
    }
    v.y += this.env.defaultAvatarHeight;
    return v;
  }
  get visible() {
    return isDefined(this.rootTransform.parent);
  }
  set visible(v) {
    if (v !== this.visible) {
      if (v) {
        this.curStationID = null;
        if (this.rootTransform == null) {
          throw new Error("No root transform");
        }
        objGraph(this.env.foreground, this.rootTransform);
        for (const station of this.stations) {
          const here = this.getTransform(station.transformID);
          here.visible = false;
        }
      } else {
        this.env.foreground.remove(this.rootTransform);
      }
    }
  }
  async showStart(stationProg) {
    this.visible = true;
    if (this.startStationID == null) {
      throw new Error("Scenario has no starting point");
    }
    this.log("start scenario", { id: this.id });
    await this.showStation(this.startStation, false, stationProg);
    this.env.avatar.setHeadingImmediate(this.startRotation);
  }
  async showStation(station, playTransitionSound, prog) {
    this.logLeaveStation();
    this.log("show station", { id: station.transformID });
    if (this.curStationID) {
      const station2 = this.getStation(this.curStationID);
      this.resetStationAssets(station2);
    }
    prog = prog || this.env.loadingBar;
    this.curStationID = station.transformID;
    const stepoutTask = playTransitionSound ? this.env.audio.playClipThrough("footsteps") : Promise.resolve();
    const isCached = await this.isCached(station.filePath);
    this.env.loadingBar.enabled = !isCached;
    await this.env.withFade(async () => {
      this.env.skybox.rotation = station.rotation;
      const images = await this.getImage(station.filePath, prog);
      if (images.length === 6) {
        await this.env.skybox.setImages(station.filePath, images);
      } else {
        await this.env.skybox.setImage(station.filePath, images[0]);
      }
      this.moveToStation(station);
      for (const otherStation of this.stations) {
        const there = this.getTransform(otherStation.transformID);
        there.visible = otherStation.transformID === station.transformID;
      }
      const connections = this.curConnections.get(station);
      const toStations = this.getConnectedStations(station);
      for (const toStation of toStations) {
        this.prefetchConnectedStation(connections, toStation);
      }
      this.resetStationAssets(station);
      this.env.infoLabel.image.value = station.label || station.fileName;
      await all(
        this.playAudioZone(station.zone),
        stepoutTask
      );
    });
    this.env.loadingBar.enabled = false;
  }
  logLeaveStation() {
    if (this.curStationID) {
      this.log("leave station", { id: this.curStationID });
    }
  }
  moveToStation(station) {
    if (isDefined(station)) {
      const here = this.getTransform(station.transformID);
      here.getWorldPosition(this.env.stage.position);
      this.env.stage.position.y -= this.avatarHeightOffset;
    }
  }
  resetStationAssets(station) {
    const signs = this.signsByStation.get(station);
    for (const sign of signs) {
      sign.reset();
    }
    const audios = this.audiosByStation.get(station);
    for (const audio2 of audios) {
      audio2.reset();
    }
    const videos = this.videosByStation.get(station);
    for (const video2 of videos) {
      video2.reset();
    }
    const texts = this.textsByStation.get(station);
    for (const text2 of texts) {
      text2.reset();
    }
  }
  evict(station) {
    this.imgCache.delete(station.filePath);
    this.imgTasks.delete(station.filePath);
  }
  async prefetchConnectedStation(connections, toStation) {
    const connection = connections.get(toStation);
    connection.enabled = false;
    if (!this.imgCache.has(toStation.filePath)) {
      await this.getImage(toStation.filePath, connection);
    }
    connection.enabled = true;
  }
  getImage(path, prog) {
    if (this.imgCache.has(path)) {
      return Promise.resolve(this.imgCache.get(path));
    }
    if (this.imgTasks.has(path)) {
      return this.imgTasks.get(path);
    }
    const task = this.getImages(path, prog).then((images) => {
      this.imgCache.set(path, images);
      this.imgTasks.delete(path);
      return images;
    });
    this.imgTasks.set(path, task);
    return task;
  }
  async getImages(path, prog) {
    const { contentType } = await this.env.fetcher.head(path).exec();
    if (contentType === Image_Vendor_Google_StreetView_Pano.value) {
      const pano = await this.env.fetcher.get(path).text().then(unwrapResponse);
      const images = await this.rig.loadImages(pano, 45 /* High */, prog);
      return images;
    } else {
      const image2 = await this.env.fetcher.get(path).useCache(!this.env.DEBUG).image().then(unwrapResponse);
      return [image2];
    }
  }
  async isCached(path) {
    return await this.imgCache.has(path);
  }
  clearCache() {
    this.imgCache.clear();
  }
  getConnectedStations(fromStation) {
    return fromStation && this.connections.filter((c) => c.fromStationID === fromStation.transformID).map((c) => this.getStation(c.toStationID));
  }
  async playAudioZone(zone) {
    if (zone !== this.curZone) {
      const toPause = /* @__PURE__ */ new Map();
      const toPlay = /* @__PURE__ */ new Map();
      for (const clip of this.zonedClips.get(this.curZone)) {
        toPause.set(clip.audio, clip);
        clip.disable();
      }
      for (const clip of this.zonedClips.get(zone)) {
        if (toPause.has(clip.audio)) {
          toPause.delete(clip.audio);
        } else {
          toPlay.set(clip.audio, clip);
        }
        clip.enable();
      }
      for (const clip of toPause.values()) {
        clip.pause();
      }
      await Promise.all(Array.from(toPlay.values()).map((clip) => clip.play()));
      this.curZone = zone;
    }
  }
  pauseCurrentAudioZone() {
    const clips = this.zonedClips.get(this.curZone);
    const toPause = /* @__PURE__ */ new Map();
    for (const clip of clips) {
      toPause.set(clip.audio, clip);
      clip.disable();
    }
    for (const clip of toPause.values()) {
      clip.pause();
    }
  }
  async playCurrentAudioZone() {
    if (!this.environmentAudioMuted) {
      const clips = this.zonedClips.get(this.curZone);
      const toPlay = /* @__PURE__ */ new Map();
      for (const clip of clips) {
        clip.enable();
        toPlay.set(clip.audio, clip);
      }
      await Promise.all(Array.from(toPlay.values()).map((clip) => clip.play()));
    }
  }
  log(key, value2) {
    this.dataLogger.log(key, value2);
  }
  error(page, operation, exception) {
    this.dataLogger.error(page, operation, exception);
  }
};

// src/vr-apps/yarrow/AssetScenario.ts
var BaseAssetScenario = class extends BaseAsset {
  constructor(path) {
    super(path, Application_JsonUTF8);
  }
  async getResult(fetcher2, prog) {
    const [metaLoad, assetLoad] = progressSplitWeighted(prog, [1, 89]);
    return await fetcher2.get(this.path).progress(metaLoad).object().then(unwrapResponse).then(async (data) => {
      const scenario = this.createScenario(data);
      await scenario.loadAssets(assetLoad);
      return scenario;
    });
  }
};

// node_modules/gl-matrix/esm/common.js
var EPSILON3 = 1e-6;
var ARRAY_TYPE3 = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM3 = Math.random;
var degree3 = Math.PI / 180;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports3 = {};
__export(vec3_exports3, {
  add: () => add7,
  angle: () => angle4,
  bezier: () => bezier2,
  ceil: () => ceil3,
  clone: () => clone8,
  copy: () => copy9,
  create: () => create12,
  cross: () => cross4,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot7,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach6,
  fromValues: () => fromValues8,
  hermite: () => hermite2,
  inverse: () => inverse3,
  len: () => len5,
  length: () => length7,
  lerp: () => lerp7,
  max: () => max4,
  min: () => min4,
  mul: () => mul4,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize8,
  random: () => random4,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  round: () => round3,
  scale: () => scale7,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set6,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength6,
  str: () => str4,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat33,
  transformMat4: () => transformMat43,
  transformQuat: () => transformQuat3,
  zero: () => zero3
});
function create12() {
  var out = new ARRAY_TYPE3(3);
  if (ARRAY_TYPE3 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone8(a) {
  var out = new ARRAY_TYPE3(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length7(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues8(x, y, z) {
  var out = new ARRAY_TYPE3(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy9(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set6(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add7(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply6(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide3(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil3(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor3(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min4(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max4(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale7(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd3(out, a, b, scale8) {
  out[0] = a[0] + b[0] * scale8;
  out[1] = a[1] + b[1] * scale8;
  out[2] = a[2] + b[2] * scale8;
  return out;
}
function distance3(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance3(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength6(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate3(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse3(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize8(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len6 = x * x + y * y + z * z;
  if (len6 > 0) {
    len6 = 1 / Math.sqrt(len6);
  }
  out[0] = a[0] * len6;
  out[1] = a[1] * len6;
  out[2] = a[2] * len6;
  return out;
}
function dot7(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross4(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp7(out, a, b, t2) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t2 * (b[0] - ax);
  out[1] = ay + t2 * (b[1] - ay);
  out[2] = az + t2 * (b[2] - az);
  return out;
}
function hermite2(out, a, b, c, d, t2) {
  var factorTimes2 = t2 * t2;
  var factor1 = factorTimes2 * (2 * t2 - 3) + 1;
  var factor2 = factorTimes2 * (t2 - 2) + t2;
  var factor3 = factorTimes2 * (t2 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t2);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier2(out, a, b, c, d, t2) {
  var inverseFactor = 1 - t2;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t2 * t2;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t2 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t2;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random4(out, scale8) {
  scale8 = scale8 || 1;
  var r = RANDOM3() * 2 * Math.PI;
  var z = RANDOM3() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale8;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale8;
  return out;
}
function transformMat43(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat33(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat3(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX3(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY3(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ3(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle4(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot7(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str4(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals6(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals6(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON3 * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON3 * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON3 * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract3;
var mul4 = multiply6;
var div3 = divide3;
var dist3 = distance3;
var sqrDist3 = squaredDistance3;
var len5 = length7;
var sqrLen4 = squaredLength6;
var forEach6 = function() {
  var vec = create12();
  return function(a, stride, offset, count, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/coallesce.ts
function coallesce(overwrite, to, from, ...fieldNames) {
  for (const fieldName of fieldNames) {
    if (!(fieldName in to) || overwrite) {
      to[fieldName] = from[fieldName];
    }
  }
}

// src/dom-apps/editor/models.ts
function isModel(obj2) {
  return obj2 instanceof Model;
}
function isSign(obj2) {
  return obj2 instanceof Sign;
}
function isVideo(obj2) {
  return obj2 instanceof Video2;
}
function isText(obj2) {
  return obj2 instanceof Text;
}
function isAudio(obj2) {
  return obj2 instanceof Audio4;
}
function isAmbientAudio(obj2) {
  return isAudio(obj2) && obj2.spatialize;
}
function isVoiceOver(obj2) {
  return isAudio(obj2) && !obj2.spatialize;
}
function isZone(obj2) {
  return isString(obj2);
}
function isScenario(obj2) {
  return obj2 instanceof EditableScenario;
}
function isStation(obj2) {
  return isDefined(obj2) && obj2 instanceof Station;
}
function isConnection(obj2) {
  return isDefined(obj2) && !isModel(obj2) && !isSign(obj2) && !isVideo(obj2) && !isText(obj2) && !isAudio(obj2) && !isStation(obj2) && !isZone(obj2) && !isScenario(obj2) && isDefined(obj2.fromStationID) && isDefined(obj2.toStationID);
}
function getAssetKind(obj2) {
  if (isNullOrUndefined(obj2)) {
    return null;
  } else if (isZone(obj2)) {
    return "zone";
  } else if (isStation(obj2)) {
    return "station";
  } else if (isAudio(obj2)) {
    return obj2.spatialize ? "ambientAudio" : "audio";
  } else if (isVideo(obj2)) {
    return "video";
  } else if (isText(obj2)) {
    return "text";
  } else if (isSign(obj2)) {
    return "sign";
  } else if (isModel(obj2)) {
    return "model";
  } else if (isConnection(obj2)) {
    return "connection";
  } else if (isScenario(obj2)) {
    return "scenario";
  } else {
    assertNever(obj2);
  }
}
var AssetEvent = class extends TypedEvent {
  constructor(type2, asset) {
    super(type2);
    this.asset = asset;
  }
};
var AssetSelectedEvent = class extends AssetEvent {
  constructor(asset, isContextMenu) {
    super("assetselected", asset);
    this.isContextMenu = isContextMenu;
  }
};
var AssetUpdatedEvent = class extends AssetEvent {
  constructor(asset) {
    super("assetupdated", asset);
  }
};
var AssetRenameEvent = class extends AssetEvent {
  constructor(asset, newName) {
    super("assetrename", asset);
    this.newName = newName;
  }
};
var AssetDeleteEvent = class extends AssetEvent {
  constructor(asset) {
    super("assetdelete", asset);
  }
};
var AssetResetEvent = class extends AssetEvent {
  constructor(asset) {
    super("assetreset", asset);
  }
};
var AssetViewFileEvent = class extends AssetEvent {
  constructor(asset) {
    super("assetviewfile", asset);
  }
};
var assetIcons = /* @__PURE__ */ new Map([
  ["scenario", scroll.emojiStyle],
  ["zone", worldMap.emojiStyle],
  ["station", globeShowingAmericas.emojiStyle],
  ["ambientAudio", megaphone.emojiStyle],
  ["connection", upArrow.emojiStyle],
  ["sign", framedPicture.emojiStyle],
  ["audio", speakerHighVolume.emojiStyle],
  ["video", videoCamera.emojiStyle],
  ["text", memo.emojiStyle],
  ["model", joystick.emojiStyle]
]);
var assetNames = /* @__PURE__ */ new Map([
  ["zone", "Zone"],
  ["station", "Station"],
  ["ambientAudio", "Environment Audio"],
  ["sign", "Sign"],
  ["audio", "Voice Over"],
  ["video", "Video Clip"],
  ["text", "Text"],
  ["model", "3D Model"],
  ["connection", "Station Connection"]
]);
var assetDisplayNames = /* @__PURE__ */ new Map([
  ["delete", wastebasket.emojiStyle + " Delete"],
  ["readonly", cancelTag.emojiStyle + " Cannot edit published scenario"]
]);
for (const [key, value2] of assetNames) {
  assetDisplayNames.set(key, assetIcons.get(key) + " " + value2);
}
var AssetKindValues = Array.from(assetIcons.keys());
var DeletableAssetKindValues = Array.from(assetNames.keys());

// src/dom-apps/editor/makeSphereName.ts
function makeMarkerPath(name3) {
  return `/images/markers/${name3}.png`;
}

// src/dom-apps/editor/adapters/BaseScenarioFileAssetAdapter.ts
var ScenarioAdapterTransformMovedEvent = class extends TypedEvent {
  constructor(object, transform2) {
    super("transformmoved");
    this.object = object;
    this.transform = transform2;
  }
};
var BaseScenarioFileAssetAdapter = class extends TypedEventBase {
  constructor(scenario, assets, assetsByStation, assetName) {
    super();
    this.scenario = scenario;
    this.assets = assets;
    this.assetsByStation = assetsByStation;
    this.assetName = assetName;
  }
  saveTransformThrottled(obj2, transform2) {
    this.scenario.transformAdapter.saveMatrixThrottled(transform2);
    this.dispatchEvent(new ScenarioAdapterTransformMovedEvent(obj2, transform2));
  }
  async saveTransform(obj2, transform2) {
    await this.scenario.transformAdapter.saveMatrix(transform2);
    this.dispatchEvent(new ScenarioAdapterTransformMovedEvent(obj2, transform2));
  }
  async createTransformAndSaveAsset(input, upload, download) {
    const output = await this.scenario.postFor("Create", this.assetName, input, upload).then(unwrapResponse);
    const transform2 = this.scenario.addTransformData(output.transform);
    const parentTransform = this.scenario.getTransform(output.transform.parentTransformID);
    parentTransform.attach(transform2);
    const obj2 = await this.createAsset(output, download);
    download.end();
    return obj2;
  }
  async createEditorAssets(obj2) {
    if (!this.scenario.fileMarkers.has(obj2.transformID)) {
      const transform2 = this.scenario.getTransform(obj2.transformID);
      const prefix = isDefined(obj2.error) ? "error-" : "";
      const marker = await this.scenario.createMarker(
        obj2,
        obj2.transformID,
        obj2.fileName,
        makeMarkerPath(prefix + this.getMarkerImagePath(obj2))
      );
      if (isDefined(marker)) {
        marker.addListener("click", () => this.onMarkerSelected(obj2, false));
        marker.addListener("contextmenu", () => this.onMarkerSelected(obj2, true));
        if (!this.scenario.published) {
          marker.setDraggable(true);
          marker.setCursor("move");
          marker.addListener("dragend", (evt) => {
            const curLL = this.scenario.getTransformPosition(obj2.transformID);
            this.moveTransformThrottled(
              obj2,
              transform2,
              evt.latLng.lat(),
              evt.latLng.lng(),
              curLL.alt
            );
            this.scenario.dispatchEvent(new AssetUpdatedEvent(obj2));
          });
        }
      }
    }
  }
  onTransformMoved(obj2, transform2) {
    this.scenario.transformAdapter.updateMarker(transform2, obj2);
    this.scenario.dispatchEvent(new AssetUpdatedEvent(obj2));
    this.dispatchEvent(new ScenarioAdapterTransformMovedEvent(obj2, transform2));
  }
  moveTransformThrottled(obj2, transform2, latitude, longitude, altitude) {
    this.scenario.moveTransformByGeoThrottled(transform2, latitude, longitude, altitude);
    this.onTransformMoved(obj2, transform2);
  }
  async moveTransform(obj2, transform2, latitude, longitude, altitude) {
    await this.scenario.moveTransformByGeo(transform2, latitude, longitude, altitude);
    this.onTransformMoved(obj2, transform2);
  }
  resetThrottled(obj2, defaultAvatarHeight) {
    const transform2 = this.scenario.getTransform(obj2.transformID);
    transform2.position.set(0, defaultAvatarHeight, -2);
    transform2.quaternion.identity();
    this.saveTransformThrottled(obj2, transform2);
    this.scenario.transformAdapter.updateMarker(transform2, obj2);
  }
  async reset(obj2, defaultAvatarHeight) {
    const transform2 = this.scenario.getTransform(obj2.transformID);
    transform2.position.set(0, defaultAvatarHeight, -2);
    transform2.quaternion.identity();
    await this.saveTransform(obj2, transform2);
    this.scenario.transformAdapter.updateMarker(transform2, obj2);
  }
  async delete(obj2) {
    const marker = this.scenario.fileMarkers.get(obj2.transformID);
    const transform2 = this.scenario.getTransform(obj2.transformID);
    const station = transform2 && this.scenario.findStation(transform2);
    await this.scenario.post("Delete", this.assetName, obj2.key);
    arrayRemove(this.assets, obj2);
    this.assetsByStation.remove(station, obj2);
    if (isDefined(transform2)) {
      await this.scenario.removeTransform(transform2);
    }
    if (isDefined(marker)) {
      marker.setMap(null);
      this.scenario.fileMarkers.delete(obj2.transformID);
    }
    obj2.dispose();
  }
};

// src/dom-apps/editor/adapters/StationAdapter.ts
function getMarkerLabelString(oldMarker) {
  let text2 = null;
  const label = oldMarker.getLabel();
  if (isString(label)) {
    text2 = label;
  } else {
    text2 = label.text;
  }
  return text2;
}
var StationAdapter = class {
  constructor(scenario) {
    this.scenario = scenario;
  }
  async create(fileID, fileName, latitude, longitude, altitude, prog) {
    const stationLatLng = new LatLngPoint(latitude, longitude, altitude);
    await this.scenario.resolveOrigin(stationLatLng);
    const stationVector = this.scenario.latLngToVector(stationLatLng);
    const stationTranslation = new Matrix4().makeTranslation(stationVector.x, stationVector.y, stationVector.z);
    const transformData = await this.scenario.transformAdapter.create(this.scenario.rootTransform.transformID, fileName, stationTranslation.toArray());
    const transform2 = this.scenario.addTransformData(transformData);
    this.scenario.rootTransform.attach(transform2);
    const input = {
      transformID: transform2.transformID,
      fileID,
      rotation: [0, 0, 0, 1],
      latitude,
      longitude,
      altitude
    };
    const [upload, download] = progressSplit(prog, 2);
    const data = await this.scenario.postFor("Add", "Stations", input, upload).then(unwrapResponse);
    const station = await this.scenario.createStation(data, download);
    if (isNullOrUndefined(this.scenario.startStationID)) {
      this.scenario.startStationID = station.transformID;
    }
    this.scenario.stations.push(station);
    return station;
  }
  async markStart(station) {
    let startStation = this.scenario.startStation;
    const oldMarker = startStation && this.scenario.fileMarkers.get(startStation.transformID);
    await this.scenario.post("MarkStart", "Stations", station.transformID);
    this.scenario.startStationID = station.transformID;
    startStation = this.scenario.startStation;
    const newMarker = startStation && this.scenario.fileMarkers.get(this.scenario.startStation.transformID);
    if (isDefined(oldMarker)) {
      let newLabel = getMarkerLabelString(oldMarker);
      newLabel = newLabel.substring(star.emojiStyle.length);
      oldMarker.setLabel(newLabel);
    }
    if (isDefined(newMarker)) {
      let newLabel = getMarkerLabelString(newMarker);
      newLabel = star.emojiStyle + newLabel;
      newMarker.setLabel(newLabel);
    }
  }
  setStartRotation(station, rotation) {
    if (this.scenario.startStation === station) {
      this.scenario.startRotation = rotation;
      this.scenario.throttle(`updateScenarioStartRotation::${this.scenario.id}`, () => this.scenario.post("SetStartRotation", "Stations", rotation));
    }
  }
  async createEditorAssets(station) {
    await this.createMarker(station);
  }
  async createMarker(station) {
    let marker = this.scenario.fileMarkers.get(station.transformID);
    if (marker) {
      marker.setMap(null);
    }
    let label = station.fileName;
    if (station.transformID === this.scenario.startStationID) {
      label = star.emojiStyle + label;
    }
    marker = await this.scenario.createMarker(station, station.transformID, label, makeMarkerPath(stationIcon));
    if (isDefined(marker)) {
      marker.addListener("click", () => this.onMarkerSelected(station, false));
      marker.addListener("contextmenu", () => this.onMarkerSelected(station, true));
      if (!this.scenario.published) {
        marker.setDraggable(true);
        marker.setCursor("move");
        marker.addListener("drag", (evt) => {
          for (const [fromStationID, toStationID, line] of this.scenario.lines.entries()) {
            if (fromStationID === station.transformID || toStationID === station.transformID) {
              const path = line.getPath();
              const idx = fromStationID === station.transformID ? 0 : 1;
              path.setAt(idx, evt.latLng);
            }
          }
        });
        marker.addListener("dragend", async (evt) => {
          this.scenario.dispatchEvent(new EditableScenarioStationMarkerMovedEvent(station, g2y(evt.latLng)));
          this.scenario.dispatchEvent(new AssetUpdatedEvent(station));
        });
      }
    }
  }
  onMarkerSelected(station, isContextMenu) {
    this.scenario.dispatchEvent(new EditableScenarioStationSelectedEvent(station));
    this.scenario.dispatchEvent(new AssetSelectedEvent(station, isContextMenu));
  }
  moveThrottled(station, latitude, longitude, altitude, resetRotation) {
    const transform2 = this.setMoveData(resetRotation, station, latitude, longitude, altitude);
    this.scenario.moveTransformByGeoThrottled(transform2, latitude, longitude, altitude);
    this.getMoveData(station, transform2);
  }
  async move(station, latitude, longitude, altitude, resetRotation) {
    const transform2 = this.setMoveData(resetRotation, station, latitude, longitude, altitude);
    await this.scenario.moveTransformByGeo(transform2, latitude, longitude, altitude);
    this.getMoveData(station, transform2);
  }
  getMoveData(station, transform2) {
    if (station.transformID === this.scenario.curStationID) {
      transform2.getWorldPosition(this.scenario.env.stage.position);
    }
  }
  setMoveData(resetRotation, station, latitude, longitude, altitude) {
    if (resetRotation) {
      this.updateThrottled(station, {
        latitude,
        longitude,
        altitude,
        rotation: [0, 0, 0, 1]
      });
    } else {
      this.updateThrottled(station, {
        latitude,
        longitude,
        altitude
      });
    }
    const transform2 = this.scenario.getTransform(station.transformID);
    return transform2;
  }
  updateThrottled(station, newData) {
    this.setUpdateData(newData, station);
    this.scenario.throttle(`updateStation::${station.transformID}`, () => this.scenario.post("Update", "Stations", newData));
    this.getUpdateData(station, newData);
  }
  async update(station, newData) {
    this.setUpdateData(newData, station);
    await this.scenario.post("Update", "Stations", newData);
    this.getUpdateData(station, newData);
  }
  copy(overwrite, to, from) {
    coallesce(
      overwrite,
      to,
      from,
      "fileName",
      "zone",
      "rotation",
      "label"
    );
  }
  setUpdateData(newData, station) {
    newData.stationID = station.key;
    this.copy(false, newData, station);
    if (!("latitude" in newData)) {
      newData.latitude = station.location.lat;
    }
    if (!("longitude" in newData)) {
      newData.longitude = station.location.lng;
    }
    if (!("altitude" in newData)) {
      newData.altitude = station.location.alt;
    }
  }
  getUpdateData(station, newData) {
    this.copy(true, station, newData);
    station.location.lat = newData.latitude;
    station.location.lng = newData.longitude;
    station.location.alt = newData.altitude;
    const marker = this.scenario.fileMarkers.get(station.transformID);
    marker.setLabel(newData.fileName);
    this.scenario.refreshZones();
    this.scenario.env.skybox.rotation = station.rotation;
    if (this.scenario.curStation === station) {
      this.scenario.env.infoLabel.image.value = station.label || station.fileName;
    }
  }
  async delete(station) {
    const transform2 = this.scenario.getTransform(station.transformID);
    const marker = this.scenario.fileMarkers.get(station.transformID);
    const connections = this.scenario.connections.filter((c) => c.fromStationID === station.transformID || c.toStationID === station.transformID);
    const oldStartID = this.scenario.startStationID;
    this.scenario.startStationID = await this.scenario.postFor("Delete", "Stations", station.transformID).then(unwrapResponse);
    if (this.scenario.startStationID !== oldStartID && this.scenario.startStationID) {
      const startStation = this.scenario.startStation;
      const startMarker = this.scenario.fileMarkers.get(startStation.transformID);
      if (isDefined(startMarker)) {
        startMarker.setLabel(star.emojiStyle + startStation.fileName);
      }
    }
    if (station.transformID === this.scenario.curStationID) {
      this.scenario.curStationID = null;
    }
    for (const connection of connections) {
      const fromStation = this.scenario.getStation(connection.fromStationID);
      const toStation = this.scenario.getStation(connection.toStationID);
      await this.scenario.connectionAdapter.disconnect(fromStation, toStation);
    }
    marker.setMap(null);
    this.scenario.fileMarkers.delete(station.transformID);
    arrayRemove(this.scenario.stations, station);
    await this.scenario.removeTransform(transform2);
  }
};
var stationIcon = "globe";
var EditableScenarioStationSelectedEvent = class extends TypedEvent {
  constructor(station) {
    super("stationselected");
    this.station = station;
  }
};
var EditableScenarioStationMarkerMovedEvent = class extends TypedEvent {
  constructor(station, latLng) {
    super("stationmarkermoved");
    this.station = station;
    this.latLng = latLng;
  }
};
var EditableScenarioMarkerSelectedEvent = class extends TypedEvent {
  constructor(subType, object) {
    super(`${subType}selected`);
    this.subType = subType;
    this.object = object;
  }
};

// src/dom-apps/editor/adapters/AudiosAdapter.ts
var audioIcon = "sound";
var environmentAudioIcon = "disc";
var EditableScenarioAudioSelectedEvent = class extends EditableScenarioMarkerSelectedEvent {
  constructor(audio2) {
    super("audio", audio2);
    this.audio = audio2;
  }
};
var AudiosAdapter = class extends BaseScenarioFileAssetAdapter {
  constructor(scenario) {
    super(scenario, scenario.audios, scenario.audiosByStation, "AudioTracks");
    this.addEventListener("transformmoved", (evt) => {
      if (evt.object.spatialize) {
        evt.object.updateAudioPosition();
      }
    });
  }
  createAsset(output, download) {
    return this.scenario.createAudio(output.audioTrack, download);
  }
  create(station, file, prog) {
    const [upload, download] = progressSplitWeighted(prog, [2, 1]);
    const parent = station || this.scenario.rootTransform;
    const input = {
      fileID: file.id,
      spatialize: parent !== station,
      parentTransformID: parent.transformID
    };
    return this.createTransformAndSaveAsset(input, upload, download);
  }
  getMarkerImagePath(obj2) {
    return obj2.spatialize ? environmentAudioIcon : audioIcon;
  }
  onMarkerSelected(obj2, isContenxtMenu) {
    this.scenario.dispatchEvent(new EditableScenarioAudioSelectedEvent(obj2));
    this.scenario.dispatchEvent(new AssetSelectedEvent(obj2, isContenxtMenu));
  }
  changeElevationThrottled(audio2, elevation) {
    const { transform: transform2, latLng } = this.setChangeElevationData(audio2);
    this.moveTransformThrottled(audio2, transform2, latLng.lat(), latLng.lng(), elevation);
  }
  async changeElevation(audio2, elevation) {
    const { transform: transform2, latLng } = this.setChangeElevationData(audio2);
    await this.moveTransform(audio2, transform2, latLng.lat(), latLng.lng(), elevation);
  }
  setChangeElevationData(audio2) {
    const marker = this.scenario.fileMarkers.get(audio2.transformID);
    const latLng = marker.getPosition();
    const transform2 = this.scenario.getTransform(audio2.transformID);
    return { transform: transform2, latLng };
  }
  async createEditorAssets(audio2) {
    await super.createEditorAssets(audio2);
    if (audio2.spatialize && audio2.zone === this.scenario.curZone) {
      audio2.play();
    }
  }
  resetThrottled(audio2, defaultAvatarHeight) {
    const y = audio2.spatialize ? 0 : defaultAvatarHeight;
    super.resetThrottled(audio2, y);
  }
  async reset(audio2, defaultAvatarHeight) {
    const y = audio2.spatialize ? 0 : defaultAvatarHeight;
    await super.reset(audio2, y);
  }
  updateThrottled(audio2, newData) {
    this.setUpdateData(newData, audio2);
    this.scenario.throttle(`updateAudioTrack::${newData.id}`, () => this.scenario.post("Update", "AudioTracks", newData));
    this.getUpdateData(audio2, newData);
  }
  async update(audio2, newData) {
    this.setUpdateData(newData, audio2);
    await this.scenario.post("Update", "AudioTracks", newData);
    this.getUpdateData(audio2, newData);
  }
  copy(overwrite, to, from) {
    coallesce(
      overwrite,
      to,
      from,
      "fileName",
      "enabled",
      "label",
      "minDistance",
      "maxDistance",
      "volume",
      "zone",
      "effect"
    );
  }
  setUpdateData(newData, audio2) {
    newData.id = audio2.key;
    this.copy(false, newData, audio2);
  }
  getUpdateData(audio2, newData) {
    this.copy(true, audio2, newData);
    if (isDefined(audio2.controls)) {
      audio2.controls.volume = newData.volume;
      audio2.controls.label = newData.label;
    }
    const clip = this.scenario.env.audio.getClip(audio2.transformID.toString());
    if (isDefined(clip)) {
      clip.volume = newData.volume;
      clip.spatializer.setAudioProperties(
        newData.minDistance,
        newData.maxDistance,
        this.scenario.env.audio.algorithm
      );
      clip.setEffects(newData.effect);
      if (newData.enabled && newData.zone === this.scenario.curZone) {
        if (clip.playbackState !== "playing") {
          clip.play();
        }
      } else {
        if (clip.playbackState !== "stopped") {
          clip.stop();
        }
      }
    }
  }
  getStation(audio2) {
    const transform2 = audio2 && this.scenario.getTransform(audio2.transformID);
    return transform2 && this.scenario.findStation(transform2);
  }
  async delete(audio2) {
    const { zone, clip } = audio2;
    await super.delete(audio2);
    if (audio2.spatialize) {
      this.scenario.zonedClips.remove(zone, clip);
    }
  }
};

// src/dom-apps/editor/adapters/ConnectionAdapter.ts
var ConnectionAdapter = class {
  constructor(scenario) {
    this.scenario = scenario;
  }
  async createEditorAssets(connection) {
    if (connection.transformID < 0) {
      const transform2 = this.scenario.getTransform(connection.transformID);
      const oldData = transform2.data;
      const newData = await this.scenario.transformAdapter.create(oldData.parentTransformID, oldData.name, oldData.matrix);
      this.scenario.transformsByTransformID.delete(oldData.id);
      this.scenario.transformsByTransformID.set(newData.id, transform2);
      connection.transformID = newData.id;
      transform2.data.id = newData.id;
      await this.update(connection, connection.label);
      await this.reset(connection);
    }
    const fromStation = this.scenario.getStation(connection.fromStationID);
    const toStation = this.scenario.getStation(connection.toStationID);
    const path = [fromStation, toStation].map((s) => s.location);
    const line = this.scenario.createLine(path);
    this.scenario.lines.add(fromStation.transformID, toStation.transformID, line);
  }
  getConnectableStations(fromStation) {
    const connectedTo = fromStation && this.scenario.connections.filter((c) => c.fromStationID === fromStation.transformID).map((c) => c.toStationID);
    return fromStation && this.scenario.stations.filter((s) => s.transformID !== fromStation.transformID && connectedTo.indexOf(s.transformID) === -1);
  }
  findConnection(fromStation, toStation) {
    for (const connection of this.scenario.connections) {
      if (connection.fromStationID == fromStation.transformID && connection.toStationID == toStation.transformID) {
        return connection;
      }
    }
    return null;
  }
  async create(fromStation, toStation) {
    const forward = {
      fromStationID: fromStation.transformID,
      toStationID: toStation.transformID
    };
    const back = {
      fromStationID: toStation.transformID,
      toStationID: fromStation.transformID
    };
    await all(
      this.createConnectionHalf(forward),
      this.createConnectionHalf(back)
    );
  }
  async createConnectionHalf(connection) {
    await this.scenario.post("Create", "Connections", connection);
    const icon = await this.scenario.createConnection(connection);
    this.scenario.connections.push(connection);
    await this.scenario.transformAdapter.saveMatrix(icon.transform);
  }
  async reset(connection) {
    const fromStation = this.scenario.getStation(connection.fromStationID);
    const toStation = this.scenario.getStation(connection.toStationID);
    const connections = this.scenario.curConnections.get(fromStation);
    const icon = connections.get(toStation);
    icon.resetPosition();
    await this.scenario.transformAdapter.saveMatrix(icon.transform);
  }
  updateThrottled(connection, label) {
    const newData = this.setConnectionUpdateData(connection, label);
    this.scenario.throttle(`updateConnectionLabel::${connection.fromStationID} -> ${connection.toStationID}`, () => this.scenario.post("Update", "Connections", newData));
  }
  async update(connection, label) {
    const newData = this.setConnectionUpdateData(connection, label);
    await this.scenario.post("Update", "Connections", newData);
  }
  setConnectionUpdateData(connection, label) {
    connection.label = label;
    const fromStation = this.scenario.getStation(connection.fromStationID);
    const connections = this.scenario.curConnections.get(fromStation);
    if (connections) {
      const toStation = this.scenario.getStation(connection.toStationID);
      const icon = connections.get(toStation);
      icon.label = label;
    }
    return {
      transformID: connection.transformID,
      fromStationID: connection.fromStationID,
      toStationID: connection.toStationID,
      label
    };
  }
  async disconnect(fromStation, toStation) {
    await all(
      this.scenario.post("Delete", "Connections", {
        fromStationID: fromStation.transformID,
        toStationID: toStation.transformID
      }),
      this.removeConnection(fromStation, toStation),
      this.removeConnection(toStation, fromStation)
    );
  }
  async removeConnection(fromStation, toStation) {
    const connection = this.findConnection(fromStation, toStation);
    arrayRemove(this.scenario.connections, connection);
    const line = this.scenario.lines.get(fromStation.transformID, toStation.transformID);
    if (line) {
      line.setMap(null);
      this.scenario.lines.delete(toStation.transformID, toStation.transformID);
    }
    const icon = this.scenario.curConnections.get(fromStation, toStation);
    if (icon) {
      await this.scenario.removeTransform(icon.transform);
      this.scenario.curConnections.delete(fromStation, toStation);
      cleanup(icon);
    }
  }
};

// src/dom-apps/editor/adapters/ModelsAdapter.ts
var modelIcon = "joy";
var EditableScenarioModelSelectedEvent = class extends EditableScenarioMarkerSelectedEvent {
  constructor(model2) {
    super("model", model2);
  }
};
var ModelsAdapter = class extends BaseScenarioFileAssetAdapter {
  constructor(scenario) {
    super(scenario, scenario.models, scenario.modelsByStation, "Models");
  }
  createAsset(output, download) {
    return this.scenario.createModel(output.model, download);
  }
  create(station, file, prog) {
    const [upload, download] = progressSplitWeighted(prog, [2, 1]);
    const parent = station || this.scenario.rootTransform;
    const input = {
      fileID: file.id,
      parentTransformID: parent.transformID
    };
    return this.createTransformAndSaveAsset(input, upload, download);
  }
  getMarkerImagePath() {
    return modelIcon;
  }
  onMarkerSelected(obj2, isContenxtMenu) {
    this.scenario.dispatchEvent(new EditableScenarioModelSelectedEvent(obj2));
    this.scenario.dispatchEvent(new AssetSelectedEvent(obj2, isContenxtMenu));
  }
  setSize(model2, size4) {
    const transform2 = this.scenario.getTransform(model2.transformID);
    model2.size = size4;
    this.saveTransformThrottled(model2, transform2);
  }
  setRotation(model2, pitchDegrees, yawDegrees, rollDegrees) {
    const transform2 = this.scenario.getTransform(model2.transformID);
    transform2.rotation.set(
      deg2rad(pitchDegrees),
      deg2rad(yawDegrees),
      deg2rad(rollDegrees),
      "XYZ"
    );
    this.saveTransformThrottled(model2, transform2);
  }
  getStation(model2) {
    const transform2 = model2 && this.scenario.getTransform(model2.transformID);
    return transform2 && this.scenario.findStation(transform2);
  }
  async update(model2, newData) {
    this.setUpdateData(newData, model2);
    await this.scenario.post("Update", "Models", newData);
    this.getUpdateData(model2, newData);
  }
  updateThrottled(model2, newData) {
    this.setUpdateData(newData, model2);
    this.scenario.throttle(`updateModel::${newData.id}`, () => this.scenario.post("Update", "Models", newData));
    this.getUpdateData(model2, newData);
  }
  copy(overwrite, to, from) {
    coallesce(overwrite, to, from, "fileName");
  }
  getUpdateData(model2, newData) {
    this.copy(true, model2, newData);
  }
  setUpdateData(newData, model2) {
    newData.id = model2.key;
    this.copy(false, newData, model2);
  }
};

// src/dom-apps/editor/adapters/SignsAdapter.ts
var signIcon = "painting";
var EditableScenarioSignSelectedEvent = class extends EditableScenarioMarkerSelectedEvent {
  constructor(sign) {
    super("sign", sign);
  }
};
var SignsAdapter = class extends BaseScenarioFileAssetAdapter {
  constructor(scenario) {
    super(scenario, scenario.signs, scenario.signsByStation, "Signs");
  }
  async loadSignImage(fileInfo, progress) {
    const response = await this.scenario.env.fetcher.get(fileInfo.filePath).progress(progress).file();
    if (Application_Pdf.matches(response.contentType)) {
      const pdf = new PDFImage(response.content, { scale: 2 });
      await pdf.getPage(0);
      return pdf.canvas;
    } else {
      return await this.scenario.env.fetcher.get(response.content).image().then(unwrapResponse);
    }
  }
  createAsset(output, download) {
    return this.scenario.createSign(output.sign, download);
  }
  async create(station, file, prog) {
    const [info, upload, download] = progressSplitWeighted(prog, [1, 2, 1]);
    const img = await this.loadSignImage(file, info);
    const input = {
      parentTransformID: (station || this.scenario.rootTransform).transformID,
      fileID: file.id,
      imageWidth: img.width,
      imageHeight: img.height
    };
    return await this.createTransformAndSaveAsset(input, upload, download);
  }
  getMarkerImagePath() {
    return signIcon;
  }
  onMarkerSelected(obj2, isContenxtMenu) {
    this.scenario.dispatchEvent(new EditableScenarioSignSelectedEvent(obj2));
    this.scenario.dispatchEvent(new AssetSelectedEvent(obj2, isContenxtMenu));
  }
  resetThrottled(sign, defaultAvatarHeight) {
    const inches = sign.image.imageWidth / DEMO_PPI;
    const meters = inches2Meters(inches);
    sign.size = meters;
    super.resetThrottled(sign, defaultAvatarHeight);
  }
  async reset(sign, defaultAvatarHeight) {
    const inches = sign.image.imageWidth / DEMO_PPI;
    const meters = inches2Meters(inches);
    sign.size = meters;
    await super.resetThrottled(sign, defaultAvatarHeight);
  }
  async update(sign, newData) {
    this.setUpdateData(newData, sign);
    await this.scenario.post("Update", "Signs", newData);
    this.getUpdateData(sign, newData);
  }
  updateThrottled(sign, newData) {
    this.setUpdateData(newData, sign);
    this.scenario.throttle(`updateSign::${newData.id}`, () => this.scenario.post("Update", "Signs", newData));
    this.getUpdateData(sign, newData);
  }
  copy(overwrite, to, from) {
    coallesce(
      overwrite,
      to,
      from,
      "fileName",
      "isCallout",
      "alwaysVisible"
    );
  }
  setUpdateData(newData, sign) {
    newData.id = sign.key;
    this.copy(false, newData, sign);
  }
  getUpdateData(sign, newData) {
    this.copy(true, sign, newData);
  }
  setSize(sign, size4) {
    sign.size = size4;
    const transform2 = this.scenario.getTransform(sign.transformID);
    this.saveTransformThrottled(sign, transform2);
  }
  setRotation(sign, pitchDegrees, yawDegrees, rollDegrees) {
    const transform2 = this.scenario.getTransform(sign.transformID);
    transform2.rotation.set(
      deg2rad(pitchDegrees),
      deg2rad(yawDegrees),
      deg2rad(rollDegrees),
      "XYZ"
    );
    this.saveTransformThrottled(sign, transform2);
  }
  getStation(sign) {
    const transform2 = sign && this.scenario.getTransform(sign.transformID);
    return transform2 && this.scenario.findStation(transform2);
  }
};

// src/dom-apps/editor/adapters/TextsAdapter.ts
var textIcon = "pad";
var EditableScenarioTextSelectedEvent = class extends EditableScenarioMarkerSelectedEvent {
  constructor(text2) {
    super("text", text2);
  }
};
var TextsAdapter = class extends BaseScenarioFileAssetAdapter {
  constructor(scenario) {
    super(scenario, scenario.texts, scenario.textsByStation, "Texts");
  }
  createAsset(output, download) {
    return this.scenario.createText(output.text, download);
  }
  async create(station, file, prog) {
    const [upload, download] = progressSplitWeighted(prog, [1, 1]);
    const input = {
      parentTransformID: (station || this.scenario.rootTransform).transformID,
      fileID: file.id
    };
    return await this.createTransformAndSaveAsset(input, upload, download);
  }
  getMarkerImagePath() {
    return textIcon;
  }
  onMarkerSelected(obj2, isContenxtMenu) {
    this.scenario.dispatchEvent(new EditableScenarioTextSelectedEvent(obj2));
    this.scenario.dispatchEvent(new AssetSelectedEvent(obj2, isContenxtMenu));
  }
  resetThrottled(text2, defaultAvatarHeight) {
    const inches = text2.image.imageWidth / DEMO_PPI;
    const meters = inches2Meters(inches);
    text2.size = meters;
    super.resetThrottled(text2, defaultAvatarHeight);
  }
  async reset(text2, defaultAvatarHeight) {
    const inches = text2.image.imageWidth / DEMO_PPI;
    const meters = inches2Meters(inches);
    text2.size = meters;
    await super.resetThrottled(text2, defaultAvatarHeight);
  }
  async update(text2, newData) {
    this.setUpdateData(newData, text2);
    await this.scenario.post("Update", "Texts", newData);
    this.getUpdateData(text2, newData);
  }
  updateThrottled(text2, newData) {
    this.setUpdateData(newData, text2);
    this.scenario.throttle(`updateText::${newData.id}`, () => this.scenario.post("Update", "Texts", newData));
    this.getUpdateData(text2, newData);
  }
  copy(overwrite, to, from) {
    coallesce(
      overwrite,
      to,
      from,
      "text",
      "fileName",
      "isCallout",
      "alwaysVisible"
    );
  }
  setUpdateData(newData, text2) {
    newData.id = text2.key;
    this.copy(false, newData, text2);
  }
  getUpdateData(text2, newData) {
    this.copy(true, text2, newData);
  }
  setSize(text2, size4) {
    text2.size = size4;
    const transform2 = this.scenario.getTransform(text2.transformID);
    this.saveTransformThrottled(text2, transform2);
  }
  setRotation(text2, pitchDegrees, yawDegrees, rollDegrees) {
    const transform2 = this.scenario.getTransform(text2.transformID);
    transform2.rotation.set(
      deg2rad(pitchDegrees),
      deg2rad(yawDegrees),
      deg2rad(rollDegrees),
      "XYZ"
    );
    this.saveTransformThrottled(text2, transform2);
  }
  getStation(text2) {
    const transform2 = text2 && this.scenario.getTransform(text2.transformID);
    return transform2 && this.scenario.findStation(transform2);
  }
};

// src/dom-apps/editor/EditableScenarioObjectMovedEvent.ts
var EditableScenarioObjectMovedEvent = class extends TypedEvent {
  constructor(object) {
    super("objectmoved");
    this.object = object;
  }
};

// src/dom-apps/editor/adapters/TransformAdapter.ts
var TransformAdapter = class {
  constructor(scenario) {
    this.scenario = scenario;
  }
  async create(parentTransformID, name3, matrix) {
    const data = {
      parentTransformID,
      name: name3,
      matrix
    };
    return await this.scenario.postFor("Create", "Transforms", data).then(unwrapResponse);
  }
  getChangedMatrices(transform2) {
    const transforms = [transform2];
    transform2.traverse((c) => {
      if (c instanceof Transform) {
        c.updateMatrixWorld();
        transforms.push(c);
      }
    });
    return transforms.map((transform3) => {
      return {
        transformID: transform3.transformID,
        matrix: transform3.matrixWorld.toArray()
      };
    });
  }
  saveMatrixThrottled(transform2) {
    const changes = this.getChangedMatrices(transform2);
    for (const newData of changes) {
      this.scenario.throttle(`saveTransformPosition::${newData.transformID}`, () => this.scenario.post("Move", "Transforms", newData));
    }
  }
  async saveMatrix(transform2) {
    const changes = this.getChangedMatrices(transform2);
    await Promise.all(changes.map((newData) => this.scenario.post("Move", "Transforms", newData)));
  }
  updateMarker(transform2, markerFileAsset) {
    if (isDefined(markerFileAsset)) {
      const latLng = this.scenario.getTransformPosition(transform2.transformID);
      const marker = this.scenario.fileMarkers.get(transform2.transformID);
      marker.setPosition(y2g(latLng));
      this.scenario.dispatchEvent(new EditableScenarioObjectMovedEvent(markerFileAsset));
    }
  }
};

// src/dom-apps/editor/adapters/VideosAdapter.ts
var videoIcon = "clapper";
var EditableScenarioVideoSelectedEvent = class extends EditableScenarioMarkerSelectedEvent {
  constructor(video2) {
    super("video", video2);
  }
};
var VideosAdapter = class extends BaseScenarioFileAssetAdapter {
  constructor(scenario) {
    super(scenario, scenario.videos, scenario.videosByStation, "VideoClips");
  }
  createAsset(output, download) {
    return this.scenario.createVideo(output.videoClip, download);
  }
  create(station, file, prog) {
    const [upload, download] = progressSplitWeighted(prog, [2, 1]);
    const input = {
      fileID: file.id,
      parentTransformID: station.transformID
    };
    return this.createTransformAndSaveAsset(input, upload, download);
  }
  getMarkerImagePath() {
    return videoIcon;
  }
  onMarkerSelected(obj2, isContenxtMenu) {
    this.scenario.dispatchEvent(new EditableScenarioVideoSelectedEvent(obj2));
    this.scenario.dispatchEvent(new AssetSelectedEvent(obj2, isContenxtMenu));
  }
  saveTransformThrottled(obj2, transform2) {
    transform2.scale.setScalar(obj2.size);
    super.saveTransformThrottled(obj2, transform2);
    transform2.scale.setScalar(1);
  }
  setSphereEncodingAndLayout(video2, sphereEncodingName, stereoLayoutName) {
    if (!this.scenario.env.videoPlayer.isSupported(sphereEncodingName, stereoLayoutName)) {
      return false;
    }
    this.updateThrottled(video2, {
      sphereEncodingName,
      stereoLayoutName
    });
    return true;
  }
  setSize(video2, size4) {
    video2.size = size4;
    const transform2 = this.scenario.getTransform(video2.transformID);
    this.saveTransformThrottled(video2, transform2);
  }
  setRotation(video2, pitchDegrees, yawDegrees, rollDegrees) {
    const transform2 = this.scenario.getTransform(video2.transformID);
    transform2.rotation.set(
      deg2rad(pitchDegrees),
      deg2rad(yawDegrees),
      deg2rad(rollDegrees),
      "XYZ"
    );
    this.saveTransformThrottled(video2, transform2);
  }
  updateThrottled(video2, newData) {
    this.setUpdateData(newData, video2);
    this.scenario.throttle(`updateVideo::${newData.id}`, () => this.scenario.post("Update", "VideoClips", newData));
    this.getUpdateData(video2, newData);
  }
  async update(video2, newData) {
    this.setUpdateData(newData, video2);
    await this.scenario.post("Update", "VideoClips", newData);
    this.getUpdateData(video2, newData);
  }
  copy(overwrite, to, from) {
    coallesce(
      overwrite,
      to,
      from,
      "fileName",
      "sphereEncodingName",
      "stereoLayoutName",
      "enabled",
      "label",
      "volume"
    );
  }
  setUpdateData(newData, video2) {
    newData.id = video2.key;
    this.copy(false, newData, video2);
  }
  getUpdateData(video2, newData) {
    this.copy(true, video2, newData);
    if (isDefined(video2.controls)) {
      video2.controls.volume = newData.volume;
      video2.controls.label = newData.label;
    }
    const clip = this.scenario.env.audio.getClip(video2.transformID.toString());
    if (isDefined(clip)) {
      clip.volume = newData.volume;
    }
  }
  getStation(video2) {
    const transform2 = video2 && this.scenario.getTransform(video2.transformID);
    return transform2 && this.scenario.findStation(transform2);
  }
};

// src/dom-apps/editor/EditableScenario.ts
var EditableScenario = class extends BaseScenario3 {
  constructor(env, data, dataLogger, map) {
    super(env, dataLogger, data);
    this.map = map;
    this.throttlers = /* @__PURE__ */ new Map();
    this.fileMarkers = /* @__PURE__ */ new Map();
    this.lines = new PriorityMap();
    this.zones = new Array();
    this.transformAdapter = new TransformAdapter(this);
    this.stationAdapter = new StationAdapter(this);
    this.connectionAdapter = new ConnectionAdapter(this);
    this.signAdapter = new SignsAdapter(this);
    this.audioAdapter = new AudiosAdapter(this);
    this.videoAdapter = new VideosAdapter(this);
    this.textAdapter = new TextsAdapter(this);
    this.modelAdapter = new ModelsAdapter(this);
    this.versions = data.versions;
  }
  dispose() {
    for (const marker of this.fileMarkers.values()) {
      marker.setMap(null);
    }
    this.fileMarkers.clear();
    for (const line of this.lines.values()) {
      line.setMap(null);
    }
    this.lines.clear();
    super.dispose();
  }
  throttle(key, callback) {
    if (!this.throttlers.has(key)) {
      this.throttlers.set(key, new Throttler());
    }
    const throttler = this.throttlers.get(key);
    throttler.throttle(callback);
  }
  refreshZones() {
    const newZones = new Array();
    for (const station of this.stations) {
      if (isDefined(station.zone)) {
        arraySortedInsert(newZones, station.zone, false);
      }
    }
    for (const audio2 of this.audios) {
      if (isDefined(audio2.zone)) {
        arraySortedInsert(newZones, audio2.zone, false);
      }
    }
    const changed = newZones.length !== this.zones.length || !newZones.every((zone, idx) => zone === this.zones[idx]);
    arrayReplace(this.zones, ...newZones);
    if (changed) {
      this.dispatchEvent(new TypedEvent("zonesupdated"));
    }
  }
  async loadAssets(assetProg) {
    await super.loadAssets(assetProg);
    this.refreshZones();
  }
  toggleMarkers() {
    for (const marker of this.fileMarkers.values()) {
      marker.setVisible(!marker.getVisible());
    }
  }
  makeOnlyStationsSelectable(stations) {
    const keys = stations.map((s) => s.key);
    for (const [key, marker] of this.fileMarkers.entries()) {
      const enabled = keys.indexOf(key) > -1;
      marker.setOpacity(enabled ? 1 : 0.5);
      marker.setClickable(enabled);
    }
  }
  makeAllMarkersSelectable() {
    for (const marker of this.fileMarkers.values()) {
      marker.setOpacity(1);
      marker.setClickable(true);
    }
  }
  async createStation(station, prog) {
    const stat = await super.createStation(station, prog);
    this.cancellationToken.check();
    if (isDefined(stat)) {
      await this.stationAdapter.createEditorAssets(stat);
      this.cancellationToken.check();
    }
    return stat;
  }
  async createConnection(connection) {
    const icon = super.createConnection(connection);
    if (isDefined(icon)) {
      await this.connectionAdapter.createEditorAssets(connection);
      this.cancellationToken.check();
    }
    return icon;
  }
  async createAudio(audioTrack, prog) {
    const audio2 = await super.createAudio(audioTrack, prog);
    this.cancellationToken.check();
    if (isDefined(audio2)) {
      await this.audioAdapter.createEditorAssets(audio2);
      this.cancellationToken.check();
    }
    return audio2;
  }
  async createSign(sign, prog) {
    const img = await super.createSign(sign, prog);
    this.cancellationToken.check();
    if (isDefined(img)) {
      await this.signAdapter.createEditorAssets(img);
      this.cancellationToken.check();
    }
    return img;
  }
  async createVideo(videoClip, prog) {
    const video2 = await super.createVideo(videoClip, prog);
    this.cancellationToken.check();
    if (isDefined(video2)) {
      await this.videoAdapter.createEditorAssets(video2);
      this.cancellationToken.check();
    }
    return video2;
  }
  async createText(text2, prog) {
    const txt = await super.createText(text2, prog);
    this.cancellationToken.check();
    if (isDefined(txt)) {
      await this.textAdapter.createEditorAssets(txt);
      this.cancellationToken.check();
    }
    return txt;
  }
  async createModel(model2, prog) {
    const mod = await super.createModel(model2, prog);
    this.cancellationToken.check();
    if (isDefined(mod)) {
      await this.modelAdapter.createEditorAssets(mod);
      this.cancellationToken.check();
    }
    return mod;
  }
  makePost(command, resource, object, prog) {
    return this.env.fetcher.post(`/Editor/Scenarios/${resource}/${this.id}`).query("handler", command).body(object, Application_JsonUTF8).progress(prog);
  }
  postFor(command, resource, object, prog) {
    return this.makePost(command, resource, object, prog).object();
  }
  post(command, resource, object, prog) {
    return this.makePost(command, resource, object, prog).exec();
  }
  async publish() {
    await this.post("Publish", "Layout");
    this.data.published = true;
  }
  fork() {
    return this.postFor("Fork", "Layout");
  }
  async resolveOrigin(point) {
    if (isNullOrUndefined(this._originLL)) {
      await this.setOrigin(point);
    }
  }
  async setOrigin(point) {
    if (isNullOrUndefined(point)) {
      this._originLL = null;
      await this.post("SetOrigin", "Layout", null);
    } else {
      this._originLL = new LatLngPoint(point);
      await this.post("SetOrigin", "Layout", {
        lat: this._originLL.lat,
        lng: this._originLL.lng,
        alt: this._originLL.alt
      });
    }
  }
  vectorToLatLng(objVector) {
    const rootUTMVec = this.originUTM.toVec3();
    const objVec = vec3_exports3.fromValues(objVector.x, objVector.y, objVector.z);
    const objUTMVec = vec3_exports3.add(vec3_exports3.create(), rootUTMVec, objVec);
    const objUTM = new UTMPoint().fromVec3(objUTMVec, this.originUTM.zone);
    const objLL = objUTM.toLatLng();
    return objLL;
  }
  latLngToVector(objLL) {
    const rootUTMVec = this.originUTM.toVec3();
    const objUTM = objLL.toUTM().rezone(this.originUTM.zone);
    const objUTMVec = objUTM.toVec3();
    const objVec = vec3_exports3.sub(vec3_exports3.create(), objUTMVec, rootUTMVec);
    const objVector = new Vector3().fromArray(objVec);
    return objVector;
  }
  moveTransformByGeoThrottled(transform2, latitude, longitude, altitude) {
    this.setMoveTransforByGeoData(latitude, longitude, altitude, transform2);
    this.transformAdapter.saveMatrixThrottled(transform2);
  }
  async moveTransformByGeo(transform2, latitude, longitude, altitude) {
    this.setMoveTransforByGeoData(latitude, longitude, altitude, transform2);
    await this.transformAdapter.saveMatrix(transform2);
  }
  setMoveTransforByGeoData(latitude, longitude, altitude, transform2) {
    const nextLL = new LatLngPoint(latitude, longitude, altitude);
    const nextVector = this.latLngToVector(nextLL);
    objectSetWorldPosition(transform2, nextVector);
  }
  async createMarker(data, key, label, icon) {
    if (isNullOrUndefined(this.map)) {
      return null;
    }
    let location2 = null;
    if (isGeographicData(data)) {
      location2 = data.location;
    } else if (isScenarioFileAssetData(data)) {
      location2 = this.getTransformPosition(data.transformID);
    }
    const marker = await this.map.createMarker(location2, label, icon);
    marker.addListener("click", () => this.map.setTarget(g2y(marker.getPosition())));
    this.fileMarkers.set(key, marker);
    return marker;
  }
  createLine(path) {
    if (isNullOrUndefined(this.map)) {
      return null;
    }
    return this.map.createLine(path);
  }
  getTransformPosition(transformID) {
    const transform2 = this.getTransform(transformID);
    if (isNullOrUndefined(transform2)) {
      throw new Error("Couldn't find transform");
    }
    const objVector = transform2.getWorldPosition(new Vector3());
    const objLatLng = this.vectorToLatLng(objVector);
    return objLatLng;
  }
  findAssetForTransform(transformID, arr) {
    for (const asset of arr) {
      if (asset.transformID === transformID) {
        return asset;
      }
    }
    return null;
  }
  getAssetForTransform(transform2) {
    return this.findAssetForTransform(transform2.transformID, this.stations) || this.findAssetForTransform(transform2.transformID, this.audios) || this.findAssetForTransform(transform2.transformID, this.videos) || this.findAssetForTransform(transform2.transformID, this.texts) || this.findAssetForTransform(transform2.transformID, this.signs) || this.findAssetForTransform(transform2.transformID, this.models) || this.findAssetForTransform(transform2.transformID, this.connections);
  }
  async removeTransform(transform2) {
    transform2.parent.remove(transform2);
    cleanup(transform2);
    const toDelete = new Array(transform2);
    transform2.traverse((child) => {
      if (child instanceof Transform) {
        toDelete.push(child);
      }
    });
    for (const t2 of toDelete) {
      const id2 = t2.transformID;
      this.transformsByTransformID.delete(id2);
      const station = this.getStation(id2);
      if (station) {
        this.signsByStation.delete(station);
        this.modelsByStation.delete(station);
        this.audiosByStation.delete(station);
        this.videosByStation.delete(station);
        this.textsByStation.delete(station);
        this.curConnections.delete(station);
        const moreToDelete = new Array();
        for (const [fromStation, toStation] of this.curConnections.entries()) {
          if (toStation === station) {
            moreToDelete.push(fromStation);
          }
        }
        for (const fromStation of moreToDelete) {
          this.curConnections.delete(fromStation, station);
        }
      }
    }
    if (isDefined(this.originLL) && this.isEmpty) {
      await this.setOrigin(null);
    }
  }
  async showStation(station, playTransitionSound, prog) {
    await super.showStation(station, playTransitionSound, prog);
    this.dispatchEvent(new AssetSelectedEvent(station, false));
  }
  async showStationNow(station) {
    this.visible = true;
    if (this.curStation !== station) {
      await this.showStation(station, false);
      this.dispatchEvent(new EditableScenarioStationSelectedEvent(station));
    }
  }
  log() {
  }
};

// src/dom-apps/editor/AssetEditableScenario.ts
var AssetEditableScenario = class extends BaseAssetScenario {
  constructor(env, dataLogger, map, scenarioID) {
    super(`/editor/scenarios/layout/${scenarioID}`);
    this.env = env;
    this.dataLogger = dataLogger;
    this.map = map;
  }
  createScenario(data) {
    return new EditableScenario(this.env, data, this.dataLogger, this.map);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/collections/TreeNode.ts
function buildTree(items, getParent, _getOrder) {
  const getOrder = (v) => isDefined(v) && isDefined(_getOrder) && _getOrder(v);
  const rootNode = new TreeNode(null);
  const nodes = /* @__PURE__ */ new Map();
  for (const item of items) {
    const node = new TreeNode(item);
    nodes.set(item, node);
  }
  for (const node of nodes.values()) {
    const parent = getParent(node.value);
    const hasParentNode = parent != null && nodes.has(parent);
    const parentNode = hasParentNode ? nodes.get(parent) : rootNode;
    parentNode.connectSorted(node, getOrder);
  }
  return rootNode;
}
var TreeNode = class extends BaseGraphNode {
  get depth() {
    let counter = 0;
    let here = this.parent;
    while (isDefined(here)) {
      ++counter;
      here = here.parent;
    }
    return counter;
  }
  removeFromParent() {
    while (this.parent) {
      this.parent.disconnectFrom(this);
    }
  }
  connectTo(child) {
    child.removeFromParent();
    super.connectTo(child);
  }
  connectAt(child, index) {
    child.removeFromParent();
    super.connectAt(child, index);
  }
  connectSorted(child, sortKey) {
    child.removeFromParent();
    super.connectSorted(child, sortKey);
  }
  get parent() {
    if (this._reverse.length === 0) {
      return null;
    }
    return this._reverse[0];
  }
  get children() {
    return this._forward;
  }
  get isRoot() {
    return this._isEntryPoint;
  }
  get isChild() {
    return !this._isEntryPoint;
  }
  get isLeaf() {
    return this._isExitPoint;
  }
  get hasChildren() {
    return !this._isExitPoint;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/TreeView/TreeViewNode.ts
var TreeViewNodeClickedEvent = class extends TypedEvent {
  constructor(node) {
    super("click");
    this.node = node;
  }
};
var TreeViewNodeSelectedEvent = class extends TypedEvent {
  constructor(node) {
    super("select");
    this.node = node;
  }
};
var TreeViewNodeEvent = class extends TypedEvent {
  constructor(type2, parent) {
    super(type2);
    this.parent = parent;
    this._finished = new Task();
  }
  get finished() {
    return this._finished;
  }
  complete() {
    this._finished.resolve();
  }
};
var TreeViewNodeAddEvent = class extends TreeViewNodeEvent {
  constructor(parent) {
    super("add", parent);
  }
};
var TreeViewNodeContextMenuEvent = class extends TreeViewNodeEvent {
  constructor(parent) {
    super("contextmenu", parent);
  }
};
var TreeViewNode = class extends TypedEventBase {
  constructor(node, defaultLabel, _getLabel, _getDescription, _canChangeOrder, _getChildDescription, _canHaveChildren, createElement) {
    super();
    this.node = node;
    this.defaultLabel = defaultLabel;
    this._getLabel = _getLabel;
    this._getDescription = _getDescription;
    this._canChangeOrder = _canChangeOrder;
    this._getChildDescription = _getChildDescription;
    this._canHaveChildren = _canHaveChildren;
    this.createElement = createElement;
    this.refresh = debounce(() => this.onRefresh());
    const onEnabledClick = (act) => onClick((evt) => {
      if (this.enabled) {
        evt.preventDefault();
        evt.cancelBubble = true;
        act(evt);
      }
    });
    this.element = Div(
      className("tree-view-node"),
      this.upper = Div(className("drag-buffer top")),
      this.infoView = Div(
        className("tree-view-node-label"),
        draggable(this.canChangeOrder),
        onEnabledClick(() => {
          if (!this.selected) {
            this._select(true);
          }
        }),
        onDblClick((evt) => {
          if (this.enabled && this.canHaveChildren) {
            evt.preventDefault();
            evt.cancelBubble = true;
            this.isOpen = !this.isOpen;
          }
        }),
        this.collapser = ButtonSmall(
          className("tree-view-node-collapser"),
          onClick((evt) => {
            if (this.canHaveChildren) {
              evt.preventDefault();
              evt.cancelBubble = true;
              this.isOpen = !this.isOpen;
            } else {
              this._select(true);
            }
          })
        ),
        this.labeler = Span(
          this.label,
          onContextMenu(async (evt) => {
            if (this.enabled) {
              await this._launchMenu(evt, new TreeViewNodeContextMenuEvent(this));
            }
          })
        )
      ),
      this.subView = Div(
        className("tree-view-node-children"),
        this.children = Div(),
        this.adder = ButtonSmall(
          className("tree-view-node-adder"),
          title(this.adderTitle),
          onEnabledClick(async (evt) => {
            if (this.canHaveChildren) {
              await this._launchMenu(evt, new TreeViewNodeAddEvent(this));
            }
          }),
          plus.emojiStyle
        )
      ),
      this.lower = Div(className("drag-buffer bottom"))
    );
    this.refresh();
    this.isOpen = node.isRoot;
  }
  async _launchMenu(parentEvt, evt) {
    parentEvt.preventDefault();
    parentEvt.cancelBubble = true;
    this.adder.disabled = true;
    try {
      this.dispatchEvent(evt);
      await evt.finished;
    } catch {
      evt.complete();
    } finally {
      this.adder.disabled = false;
    }
  }
  onRefresh() {
    if (this.node.isRoot !== (this.adder.parentElement === this.subView)) {
      if (this.node.isRoot) {
        this.subView.append(this.adder);
      } else {
        this.infoView.append(this.adder);
      }
    }
    const canOpenClose = this.canHaveChildren && this.node.hasChildren && this.node.isChild;
    elementSetTitle(this.collapser, this.collapserTitle);
    elementSetText(
      this.collapser,
      canOpenClose ? this.isOpen ? blackMediumDownPointingTriangleCentered.emojiStyle : blackMediumRightPointingTriangleCentered.emojiStyle : blackDiamondCentered.emojiStyle
    );
    this.collapser.style.opacity = canOpenClose ? "1" : "0";
    elementSetText(this.labeler, this.label);
    elementSetTitle(this.adder, this.adderTitle);
    elementSetDisplay(this.adder, this.canHaveChildren, "inline-block");
    elementSetDisplay(this.upper, this.node.isChild && this.canChangeOrder && isNullOrUndefined(this.element.previousSibling));
    elementSetDisplay(this.lower, this.node.isChild && this.canChangeOrder);
    this.collapser.disabled = this.disabled && !this.specialSelectMode || this.node.isRoot;
    this.adder.disabled = this.disabled || this.specialSelectMode;
  }
  get specialSelectMode() {
    return this.adder.classList.contains("disabled");
  }
  set specialSelectMode(v) {
    if (v !== this.specialSelectMode) {
      this.adder.classList.toggle("disabled");
      this.refresh();
    }
  }
  get canHaveChildren() {
    return this._canHaveChildren(this.node);
  }
  get label() {
    return isDefined(this.node.value) ? this._getLabel(this.node.value) : this.defaultLabel;
  }
  get description() {
    return isDefined(this.node.value) ? this._getDescription(this.node.value) : null;
  }
  get childDescription() {
    return isDefined(this.node.value) ? this._getChildDescription(this.node.value) : null;
  }
  get canChangeOrder() {
    return isDefined(this.node.value) && this._canChangeOrder(this.node.value);
  }
  get collapserTitle() {
    if (!this.canHaveChildren) {
      return "Select " + this.description;
    } else if (this.isOpen) {
      return "Collapse " + this.description;
    } else {
      return "Expand " + this.description;
    }
  }
  get adderTitle() {
    return "Add " + this.childDescription;
  }
  get disabled() {
    return this.element.classList.contains("disabled");
  }
  set disabled(v) {
    if (v !== this.disabled) {
      this.element.classList.toggle("disabled");
      this.refresh();
    }
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  get filtered() {
    return this.element.classList.contains("filtered");
  }
  set _filtered(v) {
    if (v !== this.filtered) {
      this.element.classList.toggle("filtered");
    }
  }
  get selected() {
    return this.element.classList.contains("selected");
  }
  set _selected(v) {
    if (v !== this.selected) {
      this.element.classList.toggle("selected");
    }
  }
  get highlighted() {
    if (this.element.classList.contains("highlighted")) {
      return 0;
    } else if (this.upper.classList.contains("highlighted")) {
      return -1;
    } else if (this.lower.classList.contains("highlighted")) {
      return 1;
    } else {
      return null;
    }
  }
  set highlighted(v) {
    if (v !== this.highlighted) {
      this.element.classList.remove("highlighted");
      this.upper.classList.remove("highlighted");
      this.lower.classList.remove("highlighted");
      if (v === 0) {
        this.element.classList.add("highlighted");
      } else if (v === -1) {
        this.upper.classList.add("highlighted");
      } else if (v === 1) {
        this.lower.classList.add("highlighted");
      }
    }
  }
  get isOpen() {
    return elementIsDisplayed(this.subView);
  }
  set isOpen(v) {
    if (v !== this.isOpen) {
      elementSetDisplay(this.subView, v);
      this.refresh();
    }
  }
  add(value2) {
    this.isOpen = true;
    const node = new TreeNode(value2);
    this.node.connectTo(node);
    this.createElement(node);
    this.refresh();
  }
  _select(bubbles) {
    this.dispatchEvent(new TreeViewNodeClickedEvent(this.node));
    if (!this.selected) {
      const selectEvt = new TreeViewNodeSelectedEvent(this.node);
      selectEvt.cancelBubble = !bubbles;
      this.dispatchEvent(selectEvt);
    }
  }
  scrollIntoView() {
    this.element.scrollIntoView({
      behavior: "smooth",
      block: "center",
      inline: "nearest"
    });
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/SelectBox/index.ts
function withDefault(callback, defaultValue = null) {
  return (value2) => {
    try {
      return callback(value2);
    } catch {
      return defaultValue;
    }
  };
}

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/SelectList.ts
var SelectListItemSelectedEvent = class extends TypedEvent {
  constructor(item) {
    super("itemselected");
    this.item = item;
  }
};
var SelectList = class extends TypedEventBase {
  constructor(makeID, makeLabel, getSortKey, noSelectionText) {
    super();
    this.element = Select(classList("custom-select"));
    this.itemToOption = /* @__PURE__ */ new Map();
    this.optionToItem = /* @__PURE__ */ new Map();
    this._emptySelectionEnabled = false;
    this._values = null;
    this.makeID = withDefault(makeID);
    this.makeLabel = withDefault(makeLabel, "None");
    this.getSortKey = withDefault(getSortKey);
    this.noSelection = Option(noSelectionText);
    this.emptySelectionEnabled = !isNullOrUndefined(noSelectionText);
    this.element.addEventListener("input", () => this.dispatchEvent(new SelectListItemSelectedEvent(this.selectedValue)));
    Object.seal(this);
  }
  get disabled() {
    return this.element.disabled;
  }
  set disabled(v) {
    this.element.disabled = v;
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  get count() {
    return this._values && this._values.length || 0;
  }
  /**
   * Gets whether or not the select box will have a vestigial entry for "no selection" or "null" in the select box.
   **/
  get emptySelectionEnabled() {
    return this._emptySelectionEnabled;
  }
  /**
   * Sets whether or not the select box will have a vestigial entry for "no selection" or "null" in the select box.
   **/
  set emptySelectionEnabled(value2) {
    if (value2 !== this.emptySelectionEnabled) {
      this._emptySelectionEnabled = value2;
      this.render();
    }
  }
  /**
   * Gets the collection to which the select box was databound
   **/
  get values() {
    return this._values || [];
  }
  /**
   * Sets the collection to which the select box will be databound
   **/
  set values(newItems) {
    newItems = newItems || null;
    if (newItems !== this._values) {
      const curValue = this.selectedValue;
      this._values = newItems;
      this.render();
      this.selectedValue = curValue;
    }
  }
  get selectedOption() {
    return this.element.selectedOptions.item(0);
  }
  set selectedOption(option) {
    for (let i = 0; i < this.element.options.length; ++i) {
      const here = this.element.options[i];
      here.selected = here === option;
    }
  }
  /**
   * Gets the item at `selectedIndex` in the collection to which the select box was databound
   */
  get selectedValue() {
    return this.optionToItem.get(this.selectedOption);
  }
  /**
   * Gets the index of the given item in the select box's databound collection, then
   * sets that index as the `selectedIndex`.
   */
  set selectedValue(value2) {
    this.selectedOption = this.itemToOption.get(this.makeID(value2));
  }
  refresh() {
    this.render();
  }
  render() {
    elementClearChildren(this);
    this.itemToOption.clear();
    this.optionToItem.clear();
    if (this.count === 0 || this.emptySelectionEnabled) {
      this.append(null, this.noSelection);
    }
    if (this.count > 0) {
      const sortedItems = arraySortByKey(this.values, this.getSortKey);
      for (let item of sortedItems) {
        const option = this.makeOption(item);
        this.append(item, option);
      }
    }
  }
  makeOption(item) {
    const option = Option(
      value(this.makeID(item)),
      this.makeLabel(item)
    );
    this.itemToOption.set(this.makeID(item), option);
    this.optionToItem.set(option, item);
    return option;
  }
  append(value2, option) {
    this.element.append(option);
    this.itemToOption.set(this.makeID(value2), option);
    this.optionToItem.set(option, value2);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/TreeView/index.ts
var TreeViewNodeEvent2 = class extends TypedEvent {
  constructor(type2, node) {
    super(type2);
    this.node = node;
  }
};
var TreeViewNodeDeleteEvent = class extends TreeViewNodeEvent2 {
  constructor(node) {
    super("delete", node);
  }
};
var TreeViewNodeMovedEvent = class extends TreeViewNodeEvent2 {
  constructor(node, newIndex) {
    super("moved", node);
    this.newIndex = newIndex;
  }
};
var TreeViewNodeReparentedEvent = class extends TreeViewNodeEvent2 {
  constructor(node, newParent) {
    super("reparented", node);
    this.newParent = newParent;
  }
};
var TreeView = class extends TypedEventBase {
  constructor(options, ...styleProps) {
    super();
    this.filterTypeInput = null;
    this.elements = new Array();
    this.nodes2Elements = /* @__PURE__ */ new Map();
    this.htmlElements2Nodes = /* @__PURE__ */ new Map();
    this.htmlElements2Elements = /* @__PURE__ */ new Map();
    this._rootNode = null;
    this.locked = false;
    this._disabled = false;
    this.typeFilter = null;
    this.nameFilter = null;
    this.readonly = false;
    this.createElement = this.createElement.bind(this);
    this.options = Object.assign({
      defaultLabel: null,
      getOrder: null,
      replaceElement: null,
      canReorder: alwaysFalse,
      additionalProperties: []
    }, options);
    const canReorder = this.options.canReorder;
    if (isDefined(canReorder)) {
      this.options.canReorder = (value2) => !this.readonly && canReorder(value2);
    }
    if (isNullOrUndefined(this.options.canParent)) {
      this.options.canParent = this.options.canHaveChildren;
    }
    this._canChangeOrder = isFunction(this.options.getOrder);
    this.element = Div(
      className("tree-view"),
      ...styleProps,
      this.filters = PropertyList.create(
        className("tree-view-controls"),
        ...this.options.additionalProperties
      ),
      Div(
        className("tree-view-controls"),
        this.collapseButton = ButtonPrimarySmall(
          onClick(() => this.collapseAll()),
          "Collapse all"
        ),
        this.expandButton = ButtonPrimarySmall(
          onClick(() => this.expandAll()),
          "Expand all"
        )
      ),
      Div(
        className("tree-view-inner"),
        tabIndex(0),
        onContextMenu(async (evt) => {
          if (!this.disabled) {
            const rootElement = this.nodes2Elements.get(this.rootNode);
            await rootElement._launchMenu(evt, new TreeViewNodeContextMenuEvent(rootElement));
          }
        }),
        onClick((evt) => {
          if (!this.disabled && !evt.defaultPrevented) {
            for (const element of this.elements) {
              if (element.selected) {
                this.selectedNode = null;
                this.dispatchEvent(new TreeViewNodeSelectedEvent(null));
                return;
              }
            }
          }
        }),
        onKeyDown((evt) => {
          if (isModifierless(evt)) {
            const sel = this.selectedElement;
            if (sel) {
              if (evt.key === "Delete") {
                this.dispatchEvent(new TreeViewNodeDeleteEvent(sel.node));
              } else if (evt.key === "ArrowUp") {
                const index = elementGetIndexInParent(sel);
                if (index > 0) {
                  const nextHTMLElement = sel.element.parentElement.children[index - 1];
                  const nextElement = this.htmlElements2Elements.get(nextHTMLElement);
                  nextElement._select(true);
                } else if (sel.node.isChild && sel.node.parent.isChild) {
                  const nextNode = sel.node.parent;
                  const nextElement = this.nodes2Elements.get(nextNode);
                  nextElement._select(true);
                }
              } else if (evt.key === "ArrowDown") {
                const index = elementGetIndexInParent(sel);
                if (index < sel.element.parentElement.childElementCount - 1) {
                  const nextHTMLElement = sel.element.parentElement.children[index + 1];
                  const nextElement = this.htmlElements2Elements.get(nextHTMLElement);
                  nextElement._select(true);
                } else if (sel.node.isChild) {
                  const parentNode = sel.node.parent;
                  const parentElement = this.nodes2Elements.get(parentNode);
                  const parentIndex = elementGetIndexInParent(parentElement);
                  const nextHTMLElement = parentElement.element.parentElement.children[parentIndex + 1];
                  if (nextHTMLElement) {
                    const nextElement = this.htmlElements2Elements.get(nextHTMLElement);
                    nextElement._select(true);
                  }
                }
              } else if (evt.key === "ArrowRight") {
                if (sel.node.hasChildren) {
                  if (sel.isOpen) {
                    const nextHTMLElem = sel.children.children[0];
                    if (nextHTMLElem) {
                      const elem = this.htmlElements2Elements.get(nextHTMLElem);
                      elem._select(true);
                    }
                  } else {
                    sel.isOpen = true;
                  }
                }
              } else if (evt.key === "ArrowLeft") {
                const sel2 = this.selectedElement;
                if (sel2.isOpen) {
                  sel2.isOpen = false;
                } else if (sel2.node.isChild && sel2.node.parent.isChild) {
                  const parentElem = this.nodes2Elements.get(sel2.node.parent);
                  parentElem._select(true);
                }
              }
            } else if (this.children.children.length > 0) {
              const rootElem = this.nodes2Elements.get(this.rootNode);
              let htmlElem = null;
              if (evt.key === "ArrowUp") {
                htmlElem = rootElem.children.children[rootElem.children.children.length - 1];
              } else if (evt.key === "ArrowDown") {
                htmlElem = rootElem.children.children[0];
              }
              if (htmlElem) {
                const elem = this.htmlElements2Elements.get(htmlElem);
                elem._select(true);
              }
            }
          }
        }),
        this.children = Div(
          className("tree-view-children")
        )
      )
    );
    if (this.options.showNameFilter || isDefined(this.options.typeFilters)) {
      if (this.options.showNameFilter) {
        this.filters.append(
          ["Name", this.filterNameInput = InputText(
            classList("form-control"),
            placeHolder("Filter by name"),
            autoComplete(false),
            onInput(() => {
              this.nameFilter = this.filterNameInput.value.toLocaleLowerCase();
              if (this.nameFilter.length === 0) {
                this.nameFilter = null;
              }
              this.refreshFilter();
            })
          )]
        );
      }
      if (isDefined(this.options.typeFilters)) {
        this.filters.append(
          ["Type", this.filterTypeInput = new SelectList(
            identity,
            this.options.typeFilters.getTypeLabel,
            this.options.typeFilters.getTypeLabel,
            "Filter by type"
          )]
        );
        this.filterTypeInput.values = this.options.typeFilters.getTypes();
        this.filterTypeInput.addEventListener("itemselected", (evt) => {
          this.typeFilter = evt.item;
          this.refreshFilter();
        });
      }
      this.filters.append(
        ButtonSecondarySmall(
          "Clear filter",
          onClick(() => this.clearFilter())
        )
      );
    }
    if (this.canChangeOrder) {
      let draggedElement = null;
      let dropElement = null;
      let hoverTimer = null;
      let delta3 = 0;
      let lastTarget = null;
      const clearTarget = () => {
        if (hoverTimer) {
          clearTimeout(hoverTimer);
        }
        lastTarget = null;
        if (dropElement) {
          dropElement.highlighted = null;
          dropElement = null;
        }
        delta3 = 0;
      };
      elementApply(
        this.children,
        onDragStart((evt) => {
          clearTarget();
          draggedElement = this.findElement(evt.target);
          draggedElement.element.style.opacity = "0.5";
        }),
        onDragOver((evt) => {
          const target = evt.target;
          const targetChanged = target !== lastTarget;
          const elem = this.findElement(target);
          if (targetChanged) {
            clearTarget();
            lastTarget = target;
          }
          if (elem && this.canReparent(elem, draggedElement, target)) {
            dropElement = elem;
            if (target === elem.upper) {
              delta3 = -1;
            } else if (target === elem.lower) {
              delta3 = 1;
            } else {
              delta3 = 0;
            }
            dropElement.highlighted = delta3;
            if (targetChanged && delta3 === 0 && !elem.isOpen) {
              hoverTimer = setTimeout(() => elem.isOpen = true, 1e3);
            }
            evt.preventDefault();
          }
        }),
        onDrop((evt) => {
          if (this.canReparent(dropElement, draggedElement, lastTarget)) {
            evt.preventDefault();
            this.reparentNode(draggedElement.node, dropElement.node, delta3);
          }
          clearTarget();
        }),
        onDragEnd(() => {
          if (draggedElement) {
            draggedElement.element.style.opacity = "1";
          }
          clearTarget();
        })
      );
    }
    if (this.options.replaceElement) {
      elementReplace(this.options.replaceElement, this);
    }
  }
  clearFilter() {
    if (isDefined(this.filterNameInput)) {
      this.filterNameInput.value = "";
      this.nameFilter = null;
    }
    if (isDefined(this.filterTypeInput)) {
      this.filterTypeInput.selectedValue = null;
      this.typeFilter = null;
    }
    this.refreshFilter();
  }
  refreshFilter() {
    const included = /* @__PURE__ */ new Set();
    for (const node of this.rootNode.depthFirst()) {
      const nameMatch = isNullOrUndefined(this.nameFilter) || this.options.getLabel(node.value).toLocaleLowerCase().indexOf(this.nameFilter) >= 0;
      const typeMatch = isNullOrUndefined(this.typeFilter) || this.options.typeFilters.getTypeFor(node.value) === this.typeFilter;
      const isMatch = nameMatch && typeMatch;
      const show = isMatch || included.has(node);
      const elem = this.nodes2Elements.get(node);
      elementSetDisplay(elem, show, "block");
      elem._filtered = included.has(node) && !isMatch;
      elem.isOpen = true;
      if (show && isDefined(node.parent)) {
        included.add(node.parent);
      }
    }
    if (isDefined(this.selectedElement)) {
      this.selectedElement.scrollIntoView();
    }
  }
  canReparent(parent, child, target) {
    return !this.readonly && isDefined(parent) && isDefined(child) && (parent.canHaveChildren && this.options.canParent(parent.node, child.node) || target === parent.upper || target === parent.lower) && !child.node.contains(parent.node) && child.node.parent !== parent.node;
  }
  get canChangeOrder() {
    return !this.readonly && this._canChangeOrder;
  }
  get enabled() {
    return !this.disabled;
  }
  set enabled(v) {
    this.disabled = !v;
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    this.expandButton.disabled = this.collapseButton.disabled = this.filters.disabled = this._disabled = v;
    for (const element of this.elements) {
      element.disabled = v;
    }
  }
  async withLock(action) {
    const isEnabled = this.enabled;
    if (this.enabled) {
      try {
        await action();
      } finally {
        this.enabled = isEnabled;
      }
    }
  }
  findAll(predicate) {
    return Array.from(this.rootNode.searchAll((node) => predicate(node.value)));
  }
  enableOnlyValues(values) {
    for (const element of this.elements) {
      element.disabled = values.indexOf(element.node.value) === -1;
      element.specialSelectMode = true;
    }
  }
  enableAllElements() {
    for (const element of this.elements) {
      element.enabled = true;
      element.specialSelectMode = false;
    }
  }
  get values() {
    return this.rootNode.children.flatMap((f2) => Array.from(f2.breadthFirst())).map((n2) => n2.value);
  }
  set values(arr) {
    this.rootNode = buildTree(
      arr,
      this.options.getParent,
      this.options.getOrder
    );
  }
  get rootNode() {
    return this._rootNode;
  }
  set rootNode(v) {
    if (v !== this.rootNode) {
      this.locked = true;
      for (const element of this.elements) {
        element.removeScope(this);
        element.removeBubbler(this);
      }
      elementClearChildren(this.children);
      arrayClear(this.elements);
      this.nodes2Elements.clear();
      this.htmlElements2Nodes.clear();
      this.htmlElements2Elements.clear();
      this._rootNode = v;
      if (this.rootNode) {
        for (const node of this.rootNode.breadthFirst()) {
          this.createElement(node);
        }
        const rootElement = this.nodes2Elements.get(this.rootNode);
        elementApply(this.children, rootElement);
      }
      this.locked = false;
      for (const elem of this.elements) {
        if (elem.canHaveChildren) {
          this.reorderChildren(elem);
        }
      }
      if (this.rootNode) {
        this.nodes2Elements.get(this.rootNode).refresh();
      }
    }
  }
  clear() {
    this.rootNode = null;
  }
  get selectedValue() {
    const node = this.selectedNode;
    if (node) {
      return node.value;
    }
    return null;
  }
  findNode(data) {
    return this.rootNode.find(data);
  }
  set selectedValue(v) {
    if (v !== this.selectedValue) {
      this.selectedNode = this.rootNode.find(v);
    }
  }
  get selectedNode() {
    const elem = this.selectedElement;
    if (elem) {
      return elem.node;
    }
    return null;
  }
  set selectedNode(v) {
    if (v !== this.selectedNode) {
      this.selectedElement = this.nodes2Elements.get(v);
    }
  }
  get selectedElement() {
    for (const elem of this.elements) {
      if (elem.selected) {
        return elem;
      }
    }
    return null;
  }
  set selectedElement(e2) {
    if (isDefined(e2)) {
      e2._select(false);
      let here = e2;
      while (isDefined(here)) {
        here.isOpen = true;
        here = this.nodes2Elements.get(here.node.parent);
      }
      e2.scrollIntoView();
    } else {
      e2 = this.selectedElement;
      if (isDefined(e2)) {
        e2._selected = false;
      }
      this.dispatchEvent(new TreeViewNodeSelectedEvent(null));
    }
  }
  findElement(target) {
    let here = target;
    while (here !== null) {
      const node = this.htmlElements2Elements.get(here);
      if (isDefined(node)) {
        return node;
      }
      here = here.parentElement;
      if (here === this.children) {
        return null;
      }
    }
    return null;
  }
  reorderChildren(parentElement) {
    if (!this.locked && this.canChangeOrder) {
      const numChildren = parentElement.children.children.length;
      for (let i = 0; i < numChildren; ++i) {
        const htmlElem = parentElement.children.children[i];
        const node = this.htmlElements2Nodes.get(htmlElem);
        const elem = this.nodes2Elements.get(node);
        const index = this.options.getOrder(node.value);
        if (index !== i) {
          this.dispatchEvent(new TreeViewNodeMovedEvent(node, i));
        }
        elem.refresh();
      }
      parentElement.refresh();
    }
  }
  createElement(node) {
    const element = new TreeViewNode(
      node,
      this.options.defaultLabel,
      this.options.getLabel,
      this.options.getDescription,
      this.options.canReorder,
      this.options.getChildDescription,
      this.options.canHaveChildren,
      this.createElement
    );
    element.addScopedEventListener(this, "select", (evt) => {
      for (const elem of this.elements) {
        elem._selected = elem.node === evt.node;
      }
    });
    element.addBubbler(this);
    this.elements.push(element);
    this.nodes2Elements.set(node, element);
    this.htmlElements2Nodes.set(element.element, node);
    this.htmlElements2Elements.set(element.element, element);
    const parentNode = node.parent;
    if (parentNode) {
      const parentElement = this.nodes2Elements.get(parentNode);
      if (parentElement) {
        if (!this.canChangeOrder) {
          elementApply(parentElement.children, element);
        } else {
          const index = this.options.getOrder(node.value);
          let nextNodeIndex = Number.MAX_SAFE_INTEGER;
          let nextNode = null;
          for (const sibling of parentNode.children) {
            if (sibling !== node) {
              const sibIndex = this.options.getOrder(sibling.value);
              if (sibIndex > index && sibIndex < nextNodeIndex) {
                nextNode = sibling;
                nextNodeIndex = sibIndex;
              }
            }
          }
          const nextElement = this.nodes2Elements.has(nextNode) && this.nodes2Elements.get(nextNode).element || null;
          elementInsertBefore(parentElement.children, element, nextElement);
          this.reorderChildren(parentElement);
        }
      }
    }
    return element;
  }
  addValue(value2) {
    const parent = this.options.getParent(value2);
    const parentNode = isNullOrUndefined(parent) ? this.rootNode : this.rootNode.find(parent);
    const parentElement = this.nodes2Elements.get(parentNode);
    parentElement.add(value2);
  }
  updateNode(node) {
    const element = this.nodes2Elements.get(node);
    if (element) {
      element.refresh();
    }
  }
  reparentNode(node, newParentNode, delta3) {
    const curParent = node.parent;
    const curElement = this.nodes2Elements.get(node);
    const curParentElement = this.nodes2Elements.get(curParent);
    let nextParentElement = this.nodes2Elements.get(newParentNode);
    let nextSiblingElement = null;
    if (delta3 !== 0) {
      nextSiblingElement = nextParentElement;
      newParentNode = newParentNode.parent;
      nextParentElement = this.nodes2Elements.get(newParentNode);
      if (delta3 === 1) {
        const index = elementGetIndexInParent(nextSiblingElement) + 1;
        const nextSiblingHTMLElement = nextParentElement.children.children[index];
        nextSiblingElement = this.htmlElements2Elements.get(nextSiblingHTMLElement);
      }
    } else if (this.canChangeOrder) {
      const curOrder = this.options.getOrder(node.value);
      for (let i = 0; i < newParentNode.children.length && nextSiblingElement === null; ++i) {
        const nextSiblingNode = newParentNode.children[i];
        const nextOrder = this.options.getOrder(nextSiblingNode.value);
        if (nextOrder > curOrder) {
          nextSiblingElement = this.nodes2Elements.get(nextSiblingNode);
        }
      }
    }
    elementInsertBefore(nextParentElement.children, curElement, nextSiblingElement);
    if (nextParentElement !== curParentElement) {
      newParentNode.connectTo(node);
      this.reorderChildren(curParentElement);
      this.reorderChildren(nextParentElement);
      this.dispatchEvent(new TreeViewNodeReparentedEvent(node, newParentNode));
    } else {
      this.reorderChildren(curParentElement);
    }
    nextParentElement.isOpen = true;
  }
  removeValue(value2) {
    this.removeNode(this.rootNode.find(value2));
  }
  removeNode(node) {
    const element = this.nodes2Elements.get(node);
    if (element.selected) {
      this.dispatchEvent(new TreeViewNodeSelectedEvent(null));
    }
    const parentElement = this.nodes2Elements.get(node.parent);
    element.removeScope(this);
    element.removeBubbler(this);
    element.element.remove();
    node.removeFromParent();
    arrayRemove(this.elements, element);
    this.nodes2Elements.delete(node);
    this.htmlElements2Nodes.delete(element.element);
    this.htmlElements2Elements.delete(element.element);
    this.reorderChildren(parentElement);
  }
  collapseAll() {
    for (const element of this.elements) {
      if (element.node.isChild && element.canHaveChildren) {
        element.isOpen = false;
      }
    }
  }
  expandAll(maxDepth = null) {
    for (const element of this.elements) {
      if (element.node.isChild && element.canHaveChildren && (isNullOrUndefined(maxDepth) || element.node.depth <= maxDepth)) {
        element.isOpen = true;
      }
    }
  }
};

// src/dom-apps/editor/AssetList.ts
var AssetList = class extends TreeView {
  constructor(...styleProps) {
    super(
      {
        showNameFilter: true,
        typeFilters: {
          getTypes: () => DeletableAssetKindValues,
          getTypeLabel: (type2) => assetNames.get(type2),
          getTypeFor: (asset) => getAssetKind(asset)
        },
        getLabel: (asset) => {
          const kind = getAssetKind(asset);
          const name3 = this.getAssetName(asset);
          if (isNullOrUndefined(name3)) {
            return questionMark.emojiStyle + "N/A";
          }
          let icon = assetIcons.get(kind);
          if (this.isStartStation(asset)) {
            icon += star.emojiStyle;
          }
          return icon + " " + name3;
        },
        getParent: (v) => this.getAssetParent(v),
        getOrder: (v) => this.getAssetOrder(v),
        getDescription: (asset) => getAssetKind(asset) || "N/A",
        canReorder: (asset) => isZone(asset) || isStation(asset) || isAmbientAudio(asset),
        getChildDescription: (asset) => isNullOrUndefined(asset) && "scenario" || isScenario(asset) && "zone" || isZone(asset) && "station/ambient audio" || isStation(asset) && "connection/sign/audio/video/text/model",
        canHaveChildren: (node) => isScenario(node.value) || isZone(node.value) || isStation(node.value),
        canParent: (parent, child) => isScenario(parent.value) && isZone(child.value) || isZone(parent.value) && (isStation(child.value) || isAmbientAudio(child.value)) || isStation(parent.value) && (isVoiceOver(child.value) || isVideo(child.value) || isSign(child.value) || isText(child.value) || isModel(child.value) || isConnection(child.value))
      },
      ...styleProps
    );
    this._scenario = null;
  }
  getAssetName(asset) {
    const kind = getAssetKind(asset);
    if (isNullOrUndefined(kind)) {
      return null;
    }
    let name3 = "";
    if (isScenario(asset)) {
      name3 += asset.name;
    } else if (isZone(asset)) {
      name3 += asset || "Default";
      if (asset === "") {
        name3 += lockedWithKey.emojiStyle;
      }
    } else if (isStation(asset) || isAmbientAudio(asset) || isSign(asset) || isAudio(asset) || isVideo(asset) || isText(asset) || isModel(asset)) {
      name3 += asset.fileName;
    } else if (isConnection(asset)) {
      if (asset.label && asset.label !== " \u2B06\uFE0E\uFE0E ") {
        name3 += asset.label;
      } else if (this.scenario) {
        const station = this.scenario.getStation(asset.toStationID);
        if (station) {
          name3 += station.fileName;
        } else {
          name3 += "XXX BROKEN CONNECTION XXX";
        }
      }
    }
    return name3;
  }
  get scenario() {
    return this._scenario;
  }
  set scenario(v) {
    if (v !== this.scenario) {
      this.clear();
      this._scenario = v;
      this.readonly = !this.scenario || this.scenario.published;
      if (isDefined(this.scenario)) {
        const values = [
          this.scenario,
          ...this.scenario.zones.map((z) => z || ""),
          ...this.scenario.stations,
          ...this.scenario.audios,
          ...this.scenario.videos,
          ...this.scenario.texts,
          ...this.scenario.signs,
          ...this.scenario.models,
          ...this.scenario.connections
        ];
        if (this.scenario.zones.length === 0) {
          arrayInsertAt(values, "", 0);
        }
        const root = buildTree(
          values,
          (v2) => this.getAssetParent(v2),
          (v2) => this.getAssetOrder(v2)
        ).children[0];
        root.removeFromParent();
        this.rootNode = root;
        this.expandAll(1);
      }
    }
  }
  getAssetParent(asset) {
    if (isNullOrUndefined(asset) || isScenario(asset)) {
      return null;
    } else if (isZone(asset)) {
      return this.scenario;
    } else if (isStation(asset) || isAmbientAudio(asset)) {
      return asset.zone;
    } else {
      const transform2 = this.scenario.getTransform(asset.transformID);
      return this.scenario.findStation(transform2);
    }
  }
  getAssetOrder(asset) {
    return isScenario(asset) && -1 || isZone(asset) && (asset === "" ? 0 : 1) || isStation(asset) && (this.isStartStation(asset) ? 2 : 3) || isAmbientAudio(asset) && 4 || isVoiceOver(asset) && 5 || isSign(asset) && 6 || isVideo(asset) && 7 || isText(asset) && 8 || isModel(asset) && 9;
  }
  isStartStation(asset) {
    return isStation(asset) && isDefined(this.scenario) && this.scenario.startStationID === asset.transformID;
  }
};

// src/dom-apps/editor/FileDetailDialog.ts
var FileDetailDialog = class extends DialogBox {
  constructor() {
    super("File detail");
    elementSetDisplay(this.cancelButton, false);
    elementSetText(this.confirmButton, "Close");
    elementApply(
      this.contentArea,
      this.iframe = IFrame(
        border("none"),
        width(em(40)),
        height(em(50)),
        title("File detail")
      )
    );
  }
  async showFile(fileID) {
    this.iframe.src = `/Editor/Files/Detail/${fileID}?hideBanner`;
    await this.showDialog();
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/ScrollPanel/index.ts
function isRule2(obj2) {
  return obj2 instanceof CssElementStyleProp || obj2 instanceof Attr;
}
function isElem(obj2) {
  return !isRule2(obj2);
}
var ScrollPanel = class {
  constructor(...rest) {
    const rules = rest.filter(isRule2);
    const elems = rest.filter(isElem);
    this.element = Div(
      className("scroll-panel"),
      ...rules,
      Div(
        className("scroll-panel-inner"),
        ...elems
      )
    );
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/TipBox.ts
var TipBox = class {
  constructor(tipBoxID, ...tips) {
    const storageKey = `Juniper:Widgets:TipBox:${tipBoxID}`;
    this.element = Details(
      id(tipBoxID),
      className("tip"),
      Summary("Tips:"),
      open(localStorage.getItem(storageKey) !== "closed"),
      UL(
        ...tips.map((tip) => LI(tip))
      ),
      onToggle(() => localStorage.setItem(
        storageKey,
        this.element.open ? "open" : "closed"
      ))
    );
  }
};

// src/dom-apps/editor/views/BaseEditorView.ts
var BaseEditorView = class extends TypedEventBase {
  constructor() {
    super();
    this._element = null;
    this._enabled = true;
    this.refresh = debounce(() => this.onRefresh());
  }
  get visible() {
    return elementIsDisplayed(this.element);
  }
  set visible(v) {
    elementSetDisplay(this.element, v);
  }
  get element() {
    return this._element;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(v) {
    if (v !== this.enabled) {
      this._enabled = v;
      this.refresh();
    }
  }
  get disabled() {
    return !this.enabled;
  }
  set disabled(v) {
    this.enabled = !v;
  }
};

// src/dom-apps/editor/views/BaseScenarioView.ts
var BaseScenarioView = class extends BaseEditorView {
  constructor(title2, tips) {
    super();
    this.title = title2;
    this._scenario = null;
    this._element = Div(
      className("section"),
      this.scrollPanel = new ScrollPanel(
        this.properties = PropertyList.create()
      ),
      this.assetControls = Div(
        className("controls")
      )
    );
    if (isDefined(tips) && tips.length > 0) {
      elementInsertBefore(
        this.element,
        new TipBox(title2 + "Tips", ...tips),
        this.scrollPanel
      );
    }
  }
  addProperties(...rest) {
    this.properties.append(...rest);
  }
  addAssetControls(...rest) {
    for (let i = rest.length - 1; i >= 0; --i) {
      elementInsertBefore(this.assetControls, rest[i], this.assetControls.children[0]);
    }
  }
  get scenario() {
    return this._scenario;
  }
  set scenario(v) {
    if (v !== this.scenario) {
      const oldScenario = this.scenario;
      this._scenario = v;
      this.onScenarioChanged(oldScenario);
    }
  }
  get hasScenario() {
    return !!this.scenario;
  }
  get canEdit() {
    return this.enabled && this.hasScenario;
  }
  onRefresh() {
    let rowTemplateParts = new Array();
    for (let i = 0; i < this.element.childElementCount; ++i) {
      const child = this.element.children[i];
      if (child === this.scrollPanel.element) {
        rowTemplateParts.push(fr(1));
      } else {
        rowTemplateParts.push("auto");
      }
    }
    this.element.style.gridTemplateRows = rowTemplateParts.join(" ");
    this.properties.disabled = !this.canEdit;
  }
};

// src/dom-apps/editor/views/BaseScenarioObjectView.ts
var DEFAULT_WARNING = "renameWarning";
var BaseScenarioObjectView = class extends BaseScenarioView {
  constructor(title2, tips, autoRename = true) {
    super(title2, tips);
    this._value = null;
    this.addProperties(
      [
        "Name",
        this.nameInput = InputText(
          classList("form-control"),
          placeHolder(title2 + " name")
        )
      ],
      group(DEFAULT_WARNING, Div(
        className("alert alert-warning"),
        `Cannot rename ${title2} to `,
        this.renameWarningText = Span()
      ))
    );
    this.addAssetControls(
      this.deleteButton = ButtonDangerSmall(
        "Delete " + title2,
        onClick(() => this.dispatchEvent(new AssetDeleteEvent(this.value)))
      )
    );
    const rename = () => {
      this.refresh();
      if (this.canRename) {
        this.dispatchEvent(new AssetRenameEvent(this.value, this.nameInput.value));
      }
    };
    if (autoRename) {
      this.nameInput.addEventListener("input", rename);
    } else {
      this.nameInput.addEventListener("change", rename);
      onEnterKeyPressed(rename).applyToElement(this.nameInput);
    }
    this.properties.setGroupVisible(DEFAULT_WARNING, false);
  }
  onScenarioChanged(_oldScenario) {
    this._value = null;
    this.refreshValues();
  }
  get value() {
    return this._value;
  }
  set value(v) {
    if (v !== this.value) {
      this._value = v;
      this.refreshValues();
    }
  }
  get hasValue() {
    return isDefined(this.value);
  }
  get canEdit() {
    return super.canEdit && this.hasValue && this.hasScenario && !this.scenario.published;
  }
  get canDelete() {
    return this.canEdit;
  }
  get name() {
    return this.nameInput.value;
  }
  get nameChanged() {
    return this.getValueName(this.value) !== this.name;
  }
  get canRename() {
    return this.canEdit && this.nameChanged && this.name.trim().length > 0;
  }
  onValueChanged() {
    if (this.hasValue) {
      this.nameInput.value = this.getValueName(this.value);
    } else {
      this.nameInput.value = null;
    }
  }
  refreshValues() {
    this.onValueChanged();
    this.refresh();
  }
  onRefresh() {
    super.onRefresh();
    elementSetText(this.renameWarningText, `'${this.name}'`);
    this.properties.setGroupVisible(
      DEFAULT_WARNING,
      this.canEdit && this.nameChanged && !this.canRename
    );
    this.nameInput.disabled = !this.canEdit;
    this.deleteButton.disabled = !this.canDelete;
  }
};

// src/dom-apps/editor/views/BaseScenarioResetableObjectView.ts
var BaseScenarioResetableObjectView = class extends BaseScenarioObjectView {
  constructor(title2, resetButtonText, tips) {
    super(title2, tips);
    this.addAssetControls(
      this.resetButton = ButtonDangerSmall(
        resetButtonText,
        onClick(() => this.dispatchEvent(new AssetResetEvent(this.value)))
      )
    );
    elementApply(
      this.element
    );
  }
  onRefresh() {
    super.onRefresh();
    this.resetButton.disabled = !this.canEdit;
  }
  getTransformModes(_value) {
    return [
      "Orbit" /* Orbit */,
      "Global Rotate" /* RotateGlobalSpace */,
      "Object Rotate" /* RotateObjectSpace */,
      "View Rotate" /* RotateViewSpace */,
      "Resize" /* Resize */,
      "Global Move" /* MoveGlobalSpace */,
      "Object Move" /* MoveObjectSpace */,
      "View Move" /* MoveViewSpace */
    ];
  }
  updateTransformView(value2) {
    if (value2 === this.value) {
      this.refreshValues();
    }
    if (!isConnection(value2)) {
      const transform2 = this.scenario.getTransform(value2.transformID);
      this.scenario.transformAdapter.updateMarker(transform2, value2);
    }
  }
  saveTransform(value2) {
    const transform2 = this.scenario.getTransform(value2.transformID);
    return this.scenario.transformAdapter.saveMatrix(transform2);
  }
};

// src/dom-apps/editor/views/BaseScenarioFileObjectView.ts
var BaseScenarioFileObjectView = class extends BaseScenarioResetableObjectView {
  constructor(title2, resetButtonText, filePicker, fileTypes, fileTags, tips) {
    super(title2, resetButtonText, tips);
    this.filePicker = filePicker;
    this.fileTypes = fileTypes;
    this.fileTags = fileTags;
    this.addAssetControls(
      this.detailButton = ButtonPrimarySmall(
        "View File Detail",
        onClick(() => this.dispatchEvent(new AssetViewFileEvent(this.value)))
      )
    );
  }
  async reloadFile() {
    await this.scenario.env.fetcher.evict(this.value.filePath);
    await this.value.reload(this.scenario.env.loadingBar);
  }
  onRefresh() {
    super.onRefresh();
    this.detailButton.disabled = !this.canEdit;
  }
  async createValue(parent, prog) {
    if (!this.validateParent(parent)) {
      throw new Error("Incorrect parent type.");
    }
    const file = await this.getFile(parent);
    if (isDefined(file)) {
      return await this.onFileSelection(parent, file, prog);
    }
    return null;
  }
  async getFile(_parent) {
    this.filePicker.setTypeFilters(...this.fileTypes);
    this.filePicker.setTags(...this.fileTags);
    if (await this.filePicker.showDialog() && isDefined(this.filePicker.selectedFile)) {
      return this.filePicker.selectedFile;
    }
    return null;
  }
};

// src/dom-apps/editor/views/AudiosView.ts
var AudiosView = class extends BaseScenarioFileObjectView {
  constructor(filePicker) {
    super(
      "Audio",
      "Reset Audio",
      filePicker,
      [
        Audio_Mpeg,
        Audio_Webm
      ],
      [
        "voiceover"
      ],
      [
        "Upload MP3 or WEBA files"
      ]
    );
    const saver = () => {
      this.scenario.audioAdapter.updateThrottled(this.value, {
        enabled: this.trackEnabled,
        label: this.label,
        volume: this.volume
      });
    };
    this.addProperties(
      [
        "Enabled",
        this.enabledInput = InputCheckbox(onInput(saver))
      ],
      [
        "Label",
        this.labelInput = TextArea(
          placeHolder("Enter label"),
          classList("form-control"),
          wrap("soft"),
          autoComplete(false),
          customData("lpignore", "true"),
          onInput(saver)
        )
      ],
      [
        "Volume",
        this.volumeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(100),
          step(1),
          placeHolder("Volume"),
          onInput(saver)
        )
      ]
    );
    Object.seal(this);
    this.refreshValues();
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.audioAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    await this.scenario.audioAdapter.reset(value2, this.scenario.env.defaultAvatarHeight);
  }
  deleteValue(value2) {
    return this.scenario.audioAdapter.delete(value2);
  }
  validateParent(parent) {
    return isStation(parent);
  }
  onFileSelection(parent, file, prog) {
    return this.scenario.audioAdapter.create(parent, file, prog);
  }
  get canEdit() {
    return super.canEdit && isNullOrUndefined(this.value.error);
  }
  get label() {
    return this.labelInput.value;
  }
  set label(v) {
    this.labelInput.value = v;
  }
  get volume() {
    return parseVolume(this.volumeInput.value);
  }
  set volume(v) {
    this.volumeInput.value = formatVolume(v);
  }
  get trackEnabled() {
    if (this.enabledInput.indeterminate) {
      return null;
    } else {
      return this.enabledInput.checked;
    }
  }
  set trackEnabled(v) {
    this.enabledInput.indeterminate = isNullOrUndefined(v);
    this.enabledInput.checked = isDefined(v) && v;
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      this.label = this.value.label;
      this.volume = this.value.volume;
      this.trackEnabled = this.value.enabled;
    } else {
      this.label = "";
      this.volume = null;
      this.trackEnabled = null;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.labelInput.disabled = this.volumeInput.disabled = this.enabledInput.disabled = !this.canEdit;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/widgets/GroupPanel/index.ts
var GroupPanel = class {
  constructor(...rest) {
    const elems = rest.filter(isElements);
    const colExpr = elems.map((_, i) => i === 0 ? fr(1) : "auto");
    this.element = Div(
      className("group-panel"),
      gridTemplateColumns(...colExpr),
      ...rest
    );
    Object.seal(this);
  }
};

// src/dom-apps/editor/views/ConnectionsView.ts
var ConnectionStartedEvent = class extends TypedEvent {
  constructor(connectables) {
    super("connectionstarted");
    this.connectables = connectables;
  }
};
var ConnectionsView = class extends BaseScenarioResetableObjectView {
  constructor() {
    super("Connection", "Reset Connection");
    this.toStationSelection = new Task(false);
    this.fromStation = null;
    this.toStation = null;
    this.addProperties(
      [
        "To Station",
        new GroupPanel(
          columnGap(px(5)),
          this.toStationName = Run(),
          this.selectStationButton = ButtonSecondarySmall(
            "Select",
            onClick(() => this.dispatchEvent(new AssetSelectedEvent(this.toStation, false)))
          )
        )
      ]
    );
    document.addEventListener("keydown", (evt) => {
      if (evt.key === "Escape") {
        this.cancelConnection();
      }
    });
    Object.seal(this);
    this.refreshValues();
  }
  getValueName(value2) {
    return value2.label || "";
  }
  renameValue(value2, newName) {
    this.scenario.connectionAdapter.updateThrottled(value2, newName);
  }
  async resetValue(value2) {
    await this.scenario.connectionAdapter.reset(value2);
  }
  get isConnecting() {
    return this.toStationSelection.running;
  }
  connectTo(toStation) {
    if (this.isConnecting) {
      this.toStationSelection.resolve(toStation);
    }
  }
  cancelConnection() {
    if (this.isConnecting) {
      this.toStationSelection.resolve(null);
    }
  }
  async createValue(fromStation) {
    this.toStationSelection.restart();
    const connectables = this.scenario.connectionAdapter.getConnectableStations(fromStation);
    this.dispatchEvent(new ConnectionStartedEvent(connectables));
    const toStation = await this.toStationSelection;
    this.dispatchEvent(new TypedEvent("connectionending"));
    if (isNullOrUndefined(toStation)) {
      console.warn("Station connection selection cancelled");
      return null;
    }
    if (connectables.indexOf(toStation) === -1) {
      console.warn(`Invalid connection: "${fromStation.fileName}" -> "${toStation.fileName}"`);
      return null;
    }
    await this.scenario.connectionAdapter.create(fromStation, toStation);
    return this.scenario.connectionAdapter.findConnection(fromStation, toStation);
  }
  async deleteValue(value2) {
    const fromStation = this.scenario.getStation(value2.fromStationID);
    const toStation = this.scenario.getStation(value2.toStationID);
    await this.scenario.connectionAdapter.disconnect(fromStation, toStation);
  }
  get hasFromStation() {
    return !!this.fromStation;
  }
  get hasToStation() {
    return !!this.toStation;
  }
  get canEdit() {
    return super.canEdit && this.hasFromStation && this.hasToStation;
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      this.fromStation = this.scenario.getStation(this.value.fromStationID);
      this.toStation = this.scenario.getStation(this.value.toStationID);
    } else {
      this.fromStation = null;
      this.toStation = null;
    }
    elementSetText(
      this.toStationName,
      this.hasToStation ? this.toStation.fileName : "N/A"
    );
  }
  onRefresh() {
    super.onRefresh();
    this.selectStationButton.disabled = this.disabled || !this.hasToStation;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/tslib/units/unitless.ts
function percent2Ratio(v) {
  return v * 0.01;
}
function ratio2Percent(v) {
  return v * 100;
}

// src/dom-apps/editor/views/EnvironmentAudioView.ts
var EnvironmentAudioView = class extends BaseScenarioFileObjectView {
  constructor(filePicker, mapView) {
    super(
      "Environment Audio",
      "Reset",
      filePicker,
      [
        Audio_Mpeg,
        Audio_Webm
      ],
      [
        "ambient"
      ],
      [
        "Center the map on an empty space",
        "Upload MP3 or WEBA files"
      ]
    );
    this.mapView = mapView;
    this.rangeOverlay = null;
    this.lock = false;
    const saver = () => {
      this.scenario.audioAdapter.updateThrottled(this.value, {
        enabled: this.trackEnabled,
        volume: this.volume,
        effect: this.effect,
        minDistance: this.minDistance,
        maxDistance: this.maxDistance
      });
      this.refreshOverlay();
    };
    this.addProperties(
      [
        "Enabled",
        this.enabledInput = InputCheckbox(
          onInput(saver)
        )
      ],
      [
        "Latitude",
        this.latitudeBox = Run()
      ],
      [
        "Longitude",
        this.longitudeBox = Run()
      ],
      [
        "Elevation",
        new GroupPanel(
          this.elevationInput = InputNumber(
            classList("form-control"),
            onInput(() => this.scenario.audioAdapter.changeElevationThrottled(this.value, this.elevation)),
            placeHolder("Elevation"),
            step(1e-3)
          ),
          this.resetButton
        )
      ],
      [
        "Volume",
        this.volumeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(500),
          placeHolder("Volume"),
          onInput(saver)
        )
      ],
      [
        "Effect",
        this.effectInput = Select(
          classList("custom-select"),
          onInput(saver)
        )
      ],
      [
        "Min dist",
        this.minDistanceInput = InputNumber(
          classList("form-control"),
          min(0),
          max(1e3),
          step(0.01),
          placeHolder("Minimum distance"),
          onInput(saver)
        )
      ],
      [
        "Max dist",
        this.maxDistanceInput = InputNumber(
          classList("form-control"),
          min(0),
          max(1e3),
          step(0.01),
          placeHolder("Maximum distance"),
          onInput(saver)
        )
      ]
    );
    elementApply(
      this.effectInput,
      Option("NONE"),
      ...Array.from(effectStore.keys()).map((effectName) => Option(effectName, value(effectName)))
    );
    Object.seal(this);
    this.refreshValues();
  }
  getTransformModes() {
    return [
      "Global Move" /* MoveGlobalSpace */,
      "Object Move" /* MoveObjectSpace */,
      "View Move" /* MoveViewSpace */,
      "Global Rotate" /* RotateGlobalSpace */,
      "Object Rotate" /* RotateObjectSpace */,
      "View Rotate" /* RotateViewSpace */
    ];
  }
  updateTransformView(value2) {
    super.updateTransformView(value2);
    value2.updateAudioPosition();
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.audioAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    const marker = this.scenario.fileMarkers.get(value2.transformID);
    const latLng = marker.getPosition();
    const elevation = await this.mapView.getElevation(g2y(latLng));
    await this.scenario.audioAdapter.changeElevation(value2, elevation);
  }
  deleteValue(value2) {
    return this.scenario.audioAdapter.delete(value2);
  }
  validateParent(parent) {
    return isZone(parent);
  }
  async onFileSelection(parent, file, prog) {
    const target = await this.mapView.getCenter();
    await this.scenario.resolveOrigin(target);
    const value2 = await this.scenario.audioAdapter.create(null, file, prog);
    await this.scenario.audioAdapter.update(value2, { zone: parent });
    const transform2 = this.scenario.getTransform(value2.transformID);
    await this.scenario.moveTransformByGeo(transform2, target.lat, target.lng, target.alt);
    this.scenario.transformAdapter.updateMarker(transform2, value2);
    return value2;
  }
  get canEdit() {
    return super.canEdit && isNullOrUndefined(this.value.error);
  }
  get elevation() {
    if (this.hasValue) {
      return this.elevationInput.valueAsNumber;
    } else {
      return null;
    }
  }
  set elevation(v) {
    if (isDefined(v)) {
      v = millimeters2Meters(Math.round(meters2Millimeters(v)));
    }
    if (v !== this.elevation) {
      if (isDefined(v)) {
        this.elevationInput.valueAsNumber = v;
      }
    }
  }
  get volume() {
    return percent2Ratio(this.volumeInput.valueAsNumber);
  }
  set volume(v) {
    this.volumeInput.valueAsNumber = Math.round(ratio2Percent(v));
  }
  get minDistance() {
    return parseNumber(this.minDistanceInput.value);
  }
  set minDistance(v) {
    this.minDistanceInput.value = formatNumber(v, 2);
  }
  get maxDistance() {
    return parseNumber(this.maxDistanceInput.value);
  }
  set maxDistance(v) {
    this.maxDistanceInput.value = formatNumber(v, 2);
  }
  get effect() {
    if (this.effectInput.selectedIndex === 0) {
      return null;
    } else {
      return this.effectInput.value;
    }
  }
  set effect(v) {
    if (v) {
      this.effectInput.value = v;
    } else {
      this.effectInput.selectedIndex = 0;
    }
  }
  get trackEnabled() {
    if (this.enabledInput.indeterminate) {
      return null;
    } else {
      return this.enabledInput.checked;
    }
  }
  set trackEnabled(v) {
    this.enabledInput.indeterminate = isNullOrUndefined(v);
    this.enabledInput.checked = isDefined(v) && v;
  }
  get canMove() {
    return this.canEdit && this.scenario.stations.length > 0;
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      const pos = this.scenario.getTransformPosition(this.value.transformID);
      const [lat, lng] = new LatLngPoint(pos).toDMSArray(2);
      elementSetText(this.latitudeBox, lat);
      elementSetText(this.longitudeBox, lng);
      this.elevation = pos.alt;
      this.trackEnabled = this.value.enabled;
      this.volume = this.value.volume;
      this.minDistance = this.value.minDistance;
      this.maxDistance = this.value.maxDistance;
      this.effect = this.value.effect;
    } else {
      elementSetText(this.latitudeBox, "N/A");
      elementSetText(this.longitudeBox, "N/A");
      this.elevation = null;
      this.trackEnabled = null;
      this.volume = null;
      this.minDistance = null;
      this.maxDistance = null;
      this.effect = null;
    }
    this.refreshOverlay();
  }
  async refreshOverlay() {
    if (!this.lock) {
      this.lock = true;
      if (isDefined(this.rangeOverlay)) {
        this.rangeOverlay.setMap(null);
      }
      if (this.hasValue) {
        const { maxDistance, minDistance } = this.value;
        const pos = this.scenario.getTransformPosition(this.value.transformID);
        const radiusPX = 500;
        const steps = radiusPX / 5;
        const graph = createUtilityCanvas(2 * radiusPX, 2 * radiusPX);
        const radiusM = 10 * maxDistance;
        const minDistancePX = minDistance * radiusPX / radiusM;
        const maxDistancePX = maxDistance * radiusPX / radiusM;
        const context = graph.getContext("2d");
        const gradient = context.createRadialGradient(radiusPX, radiusPX, 0, radiusPX, radiusPX, radiusPX);
        for (let i = 0; i <= steps; ++i) {
          const p = i / steps;
          const dist4 = p * radiusM;
          const gain = this.value.clip.spatializer.getGainAtDistance(dist4);
          const total = gain * this.value.volume;
          const color2 = hsla(deg(30), perc(100), perc(50), total);
          gradient.addColorStop(p, color2);
        }
        context.fillStyle = gradient;
        context.beginPath();
        context.arc(radiusPX, radiusPX, radiusPX, 0, Tau);
        context.fill();
        context.lineWidth = 1;
        context.strokeStyle = hsla(deg(30), perc(100), perc(37.5), 1);
        context.beginPath();
        context.arc(radiusPX, radiusPX, minDistancePX, 0, Tau);
        context.stroke();
        context.lineWidth = 2;
        context.strokeStyle = hsla(deg(30), perc(100), perc(25), 1);
        context.beginPath();
        context.arc(radiusPX, radiusPX, maxDistancePX, 0, Tau);
        context.stroke();
        this.rangeOverlay = await this.mapView.createOverlay(pos, radiusM, radiusM, graph);
      }
      this.lock = false;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.volumeInput.disabled = this.minDistanceInput.disabled = this.maxDistanceInput.disabled = this.enabledInput.disabled = this.effectInput.disabled = !this.canEdit;
    this.elevationInput.disabled = !this.canMove;
  }
};

// node_modules/@googlemaps/js-api-loader/dist/index.esm.js
var fastDeepEqual = function equal(a, b) {
  if (a === b)
    return true;
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor)
      return false;
    var length8, i, keys;
    if (Array.isArray(a)) {
      length8 = a.length;
      if (length8 != b.length)
        return false;
      for (i = length8; i-- !== 0; )
        if (!equal(a[i], b[i]))
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys = Object.keys(a);
    length8 = keys.length;
    if (length8 !== Object.keys(b).length)
      return false;
    for (i = length8; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
        return false;
    for (i = length8; i-- !== 0; ) {
      var key = keys[i];
      if (!equal(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
};
var DEFAULT_ID = "__googleMapsScriptId";
var LoaderStatus;
(function(LoaderStatus2) {
  LoaderStatus2[LoaderStatus2["INITIALIZED"] = 0] = "INITIALIZED";
  LoaderStatus2[LoaderStatus2["LOADING"] = 1] = "LOADING";
  LoaderStatus2[LoaderStatus2["SUCCESS"] = 2] = "SUCCESS";
  LoaderStatus2[LoaderStatus2["FAILURE"] = 3] = "FAILURE";
})(LoaderStatus || (LoaderStatus = {}));
var Loader2 = class {
  /**
   * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set
   * using this library, instead the defaults are set by the Google Maps
   * JavaScript API server.
   *
   * ```
   * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});
   * ```
   */
  constructor({ apiKey, authReferrerPolicy, channel, client, id: id2 = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url: url2 = "https://maps.googleapis.com/maps/api/js", version: version5 }) {
    this.CALLBACK = "__googleMapsCallback";
    this.callbacks = [];
    this.done = false;
    this.loading = false;
    this.errors = [];
    this.apiKey = apiKey;
    this.authReferrerPolicy = authReferrerPolicy;
    this.channel = channel;
    this.client = client;
    this.id = id2 || DEFAULT_ID;
    this.language = language;
    this.libraries = libraries;
    this.mapIds = mapIds;
    this.nonce = nonce;
    this.region = region;
    this.retries = retries;
    this.url = url2;
    this.version = version5;
    if (Loader2.instance) {
      if (!fastDeepEqual(this.options, Loader2.instance.options)) {
        throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader2.instance.options)}`);
      }
      return Loader2.instance;
    }
    Loader2.instance = this;
  }
  get options() {
    return {
      version: this.version,
      apiKey: this.apiKey,
      channel: this.channel,
      client: this.client,
      id: this.id,
      libraries: this.libraries,
      language: this.language,
      region: this.region,
      mapIds: this.mapIds,
      nonce: this.nonce,
      url: this.url,
      authReferrerPolicy: this.authReferrerPolicy
    };
  }
  get status() {
    if (this.errors.length) {
      return LoaderStatus.FAILURE;
    }
    if (this.done) {
      return LoaderStatus.SUCCESS;
    }
    if (this.loading) {
      return LoaderStatus.LOADING;
    }
    return LoaderStatus.INITIALIZED;
  }
  get failed() {
    return this.done && !this.loading && this.errors.length >= this.retries + 1;
  }
  /**
   * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].
   *
   * @ignore
   */
  createUrl() {
    let url2 = this.url;
    url2 += `?callback=${this.CALLBACK}`;
    if (this.apiKey) {
      url2 += `&key=${this.apiKey}`;
    }
    if (this.channel) {
      url2 += `&channel=${this.channel}`;
    }
    if (this.client) {
      url2 += `&client=${this.client}`;
    }
    if (this.libraries.length > 0) {
      url2 += `&libraries=${this.libraries.join(",")}`;
    }
    if (this.language) {
      url2 += `&language=${this.language}`;
    }
    if (this.region) {
      url2 += `&region=${this.region}`;
    }
    if (this.version) {
      url2 += `&v=${this.version}`;
    }
    if (this.mapIds) {
      url2 += `&map_ids=${this.mapIds.join(",")}`;
    }
    if (this.authReferrerPolicy) {
      url2 += `&auth_referrer_policy=${this.authReferrerPolicy}`;
    }
    return url2;
  }
  deleteScript() {
    const script = document.getElementById(this.id);
    if (script) {
      script.remove();
    }
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   */
  load() {
    return this.loadPromise();
  }
  /**
   * Load the Google Maps JavaScript API script and return a Promise.
   *
   * @ignore
   */
  loadPromise() {
    return new Promise((resolve, reject) => {
      this.loadCallback((err) => {
        if (!err) {
          resolve(window.google);
        } else {
          reject(err.error);
        }
      });
    });
  }
  /**
   * Load the Google Maps JavaScript API script with a callback.
   */
  loadCallback(fn) {
    this.callbacks.push(fn);
    this.execute();
  }
  /**
   * Set the script on document.
   */
  setScript() {
    if (document.getElementById(this.id)) {
      this.callback();
      return;
    }
    const url2 = this.createUrl();
    const script = document.createElement("script");
    script.id = this.id;
    script.type = "text/javascript";
    script.src = url2;
    script.onerror = this.loadErrorCallback.bind(this);
    script.defer = true;
    script.async = true;
    if (this.nonce) {
      script.nonce = this.nonce;
    }
    document.head.appendChild(script);
  }
  /**
   * Reset the loader state.
   */
  reset() {
    this.deleteScript();
    this.done = false;
    this.loading = false;
    this.errors = [];
    this.onerrorEvent = null;
  }
  resetIfRetryingFailed() {
    if (this.failed) {
      this.reset();
    }
  }
  loadErrorCallback(e2) {
    this.errors.push(e2);
    if (this.errors.length <= this.retries) {
      const delay = this.errors.length * Math.pow(2, this.errors.length);
      console.log(`Failed to load Google Maps script, retrying in ${delay} ms.`);
      setTimeout(() => {
        this.deleteScript();
        this.setScript();
      }, delay);
    } else {
      this.onerrorEvent = e2;
      this.callback();
    }
  }
  setCallback() {
    window.__googleMapsCallback = this.callback.bind(this);
  }
  callback() {
    this.done = true;
    this.loading = false;
    this.callbacks.forEach((cb) => {
      cb(this.onerrorEvent);
    });
    this.callbacks = [];
  }
  execute() {
    this.resetIfRetryingFailed();
    if (this.done) {
      this.callback();
    } else {
      if (window.google && window.google.maps && window.google.maps.version) {
        console.warn("Google Maps already loaded outside @googlemaps/js-api-loader.This may result in undesirable behavior as options and script parameters may not match.");
        this.callback();
        return;
      }
      if (this.loading)
        ;
      else {
        this.loading = true;
        this.setCallback();
        this.setScript();
      }
    }
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/events/Promisifier.ts
var Promisifier = class {
  constructor(resolveRejectTest, selectValue, selectRejectionReason) {
    this.callback = null;
    this.promise = new Promise((resolve, reject) => {
      this.callback = (...args) => {
        if (resolveRejectTest(...args)) {
          resolve(selectValue(...args));
        } else {
          reject(selectRejectionReason(...args));
        }
      };
    });
  }
  get [Symbol.toStringTag]() {
    return this.promise.toString();
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.promise.catch(onrejected);
  }
  finally(onfinally) {
    return this.promise.finally(onfinally);
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/google-maps/PlacesAsync.ts
var statusTest = (_, status) => status === google.maps.places.PlacesServiceStatus.OK;
var getResults = (results, _) => results;
var getStatus = (_, status) => status;
var PlacesAsync = class {
  constructor(places) {
    this.places = places;
  }
  nearbySearch(request) {
    const task = new Promisifier(statusTest, getResults, getStatus);
    this.places.nearbySearch(request, task.callback);
    return task;
  }
  textSearch(request) {
    const task = new Promisifier(statusTest, getResults, getStatus);
    this.places.textSearch(request, task.callback);
    return task;
  }
  findPlaceFromQuery(request) {
    const task = new Promisifier(statusTest, getResults, getStatus);
    this.places.findPlaceFromQuery(request, task.callback);
    return task;
  }
};

// ../Juniper/src/Juniper.TypeScript/@juniper-lib/google-maps/StreetViewAsync.ts
var StreetViewAsync = class extends TypedEventBase {
  constructor(streetView) {
    super();
    this.streetView = streetView;
    this.publicChangedEvt = new TypedEvent("positionchanged");
    this.privateChangedEvt = new TypedEvent("_positionchanged");
    this.firePublicEvt = true;
    this.streetView.addListener("position_changed", () => {
      this.dispatchEvent(this.privateChangedEvt);
      if (this.firePublicEvt) {
        this.visible = true;
        this.dispatchEvent(this.publicChangedEvt);
      }
    });
  }
  async hasChanged(pano) {
    const task = once(this, "_positionchanged", 3e3);
    this.streetView.setPano(pano);
    await task;
  }
  async searchPano(pano) {
    const changing = pano !== this.streetView.getPano();
    await this.setPano(pano);
    if (changing) {
      this.dispatchEvent(this.publicChangedEvt);
    }
  }
  async setPano(pano) {
    this.firePublicEvt = false;
    pano = pano || null;
    this.visible = !!pano;
    const changing = pano !== this.streetView.getPano();
    if (changing && pano) {
      try {
        await this.hasChanged(pano);
      } catch {
        console.warn("TIMEOUT");
        this.visible = false;
      }
    }
    this.firePublicEvt = true;
  }
  close() {
    this.streetView.setPano(null);
    this.visible = false;
  }
  getPano() {
    if (this.visible) {
      return this.streetView.getPano();
    } else {
      return null;
    }
  }
  getLocation() {
    return this.streetView.getLocation();
  }
  get visible() {
    return this.streetView.getVisible();
  }
  set visible(v) {
    this.streetView.setVisible(v);
  }
};

// src/dom-apps/editor/GSVMetadata.ts
var GSVMetadata = class {
  constructor(fetcher2) {
    this.fetcher = fetcher2;
  }
  getGSV(fileID) {
    return this.fetcher.get(`/Editor/Photospheres/${fileID.toFixed(0)}`).object();
  }
  searchGSV(pano) {
    return this.fetcher.get(`/Editor/Photospheres/Search/${pano}`).object();
  }
  requestGSV(pano) {
    return this.fetcher.get(`/Editor/Google/StreetView/Metadata/${pano}/`).object();
  }
  async uploadGSV(file, fileName, pano, latitude, longitude, copyright, date, prog) {
    const form = new FormData();
    form.append("FormFile", file, fileName);
    form.append("Pano", pano);
    form.append("Latitude", latitude.toFixed(10));
    form.append("Longitude", longitude.toFixed(10));
    form.append("Copyright", copyright);
    form.append("Date", date);
    const id2 = await this.fetcher.post("/Editor/Photospheres/Create/").body(form).progress(prog).object();
    return id2;
  }
  async replaceGSV(id2, file, fileName, pano, latitude, longitude, copyright, date, prog) {
    const form = new FormData();
    form.append("FormFile", file, fileName);
    form.append("Pano", pano);
    form.append("Latitude", latitude.toFixed(10));
    form.append("Longitude", longitude.toFixed(10));
    form.append("Copyright", copyright);
    form.append("Date", date);
    const response = await this.fetcher.post(`/Editor/Photospheres/Update/${id2}`).body(form).progress(prog).exec();
    return translateResponse(response, () => id2);
  }
};

// src/dom-apps/editor/PlaceResultsDialog.ts
var PlaceResultsDialog = class extends DialogBox {
  constructor() {
    super("Map results");
    this.element.classList.add("places-results");
    elementSetDisplay(this.confirmButton, false);
    elementApply(
      this.contentArea,
      Div(
        className("table"),
        Div(
          className("table-head"),
          Div(
            className("table-row"),
            Div(className("table-cell")),
            Div(className("table-cell"), "Name"),
            Div(className("table-cell"), "Address"),
            Div(className("table-cell"))
          )
        ),
        this.results = Div(
          className("table-body"),
          Div(
            className("table-row"),
            Div(
              className("table-cell"),
              "Searching..."
            )
          )
        )
      )
    );
  }
  async selectResult(results) {
    let selection = null;
    elementClearChildren(this.results);
    elementApply(this.results, ...results.map(
      (r) => Div(
        className("table-row"),
        Div(
          className("table-cell"),
          Img(
            className("thumbnail"),
            title("Place icon"),
            src(r.icon)
          )
        ),
        Div(className("table-cell"), r.name),
        Div(className("table-cell"), r.formatted_address),
        Div(
          className("table-cell"),
          ButtonPrimarySmall(
            "Select",
            onClick(() => {
              selection = r;
              this.confirmButton.click();
            })
          )
        )
      )
    ));
    if (await this.showDialog()) {
      return selection;
    } else {
      return null;
    }
  }
};

// src/dom-apps/editor/views/MapView.ts
var MAX_IMAGE_SIZE = toBytes(9, "MiB");
var StreetViewCaptureStartEvent = class extends TypedEvent {
  constructor() {
    super("capturestart");
  }
};
var StreetViewCaptureCompleteEvent = class extends TypedEvent {
  constructor(metadata) {
    super("capturecomplete");
    this.metadata = metadata;
  }
};
var MapView = class extends BaseEditorView {
  constructor(fetcher2, streetViewContainer, env) {
    super();
    this.fetcher = fetcher2;
    this.streetViewContainer = streetViewContainer;
    this.env = env;
    this.resultsDialog = new PlaceResultsDialog();
    this.map = null;
    this.elevation = null;
    this.places = null;
    this.targetMarker = null;
    this.markersVisible = true;
    this._scenario = null;
    this._metadata = null;
    this.streetView = null;
    this.files = new GSVMetadata(this.fetcher);
    this._element = Div(
      className("map"),
      width(perc(100)),
      height(perc(100)),
      new GroupPanel(
        this.searchBox = InputText(
          id("mapSearch"),
          classList("form-control"),
          placeHolder("Search map and Street View"),
          onKeyUp(makeEnterKeyEventHandler(() => this.search(this.searchBox.value, true))),
          onInput(() => this.searchButton.disabled = this.searchBox.value.length === 0)
        ),
        this.searchButton = ButtonPrimarySmall(
          FAIcon("search-location"),
          title("Search"),
          onClick(() => this.search(this.searchBox.value, true))
        ),
        this.toggleMarkersButton = ButtonSecondarySmall(
          "Hide Labels",
          onClick(() => {
            this.markersVisible = !this.markersVisible;
            elementSetText(this.toggleMarkersButton, this.markersVisible ? "Hide Labels" : "Show Labels");
            this.scenario.toggleMarkers();
          })
        )
      ),
      new GroupPanel(
        this.sphereNameInput = InputText(
          id("sphereName"),
          classList("form-control"),
          placeHolder("Enter station name"),
          onInput(() => this.refresh())
        ),
        this.copyrightLabel = Run(
          id("streetViewCopyright"),
          padding(px(5))
        ),
        this.addButton = ButtonPrimarySmall(
          "Add",
          onClick(() => this.addStreetView())
        ),
        this.captureButton = ButtonPrimarySmall(
          id("streetViewCaptureButton"),
          "Capture",
          onClick(() => this.captureStreetView(false))
        )
      ),
      this.mapContainer = Div(
        className("detail"),
        id("mapView")
      )
    );
    Object.seal(this);
  }
  get zoom() {
    return this.map && this.map.getZoom();
  }
  set zoom(v) {
    if (this.map) {
      this.map.setZoom(v);
    }
  }
  async getCenter() {
    if (isNullOrUndefined(this.map)) {
      return void 0;
    }
    const center = g2y(this.map.getCenter());
    if (isDefined(center)) {
      center.alt = await this.getElevation(center);
    }
    return center;
  }
  async getElevation(latLng) {
    const response = await this.elevation.getElevationForLocations({
      locations: [y2g(latLng)]
    });
    if (response.results.length > 0) {
      return response.results[0].elevation;
    } else {
      return 0;
    }
  }
  setTarget(v) {
    if (this.map && this.targetMarker) {
      if (v) {
        const u2 = y2g(v);
        this.targetMarker.setMap(this.map);
        this.targetMarker.setPosition(u2);
        this.panTo(u2);
      } else {
        this.targetMarker.setMap(null);
      }
    }
  }
  panTo(v) {
    if (this.map) {
      if (v instanceof google.maps.LatLng) {
        v = g2y(v);
      }
      this.map.panTo(v);
    }
  }
  fitBounds(...points) {
    const bounds = new google.maps.LatLngBounds();
    points.map(y2g).forEach((p) => bounds.extend(p));
    this.map.fitBounds(bounds);
  }
  async load(prog) {
    if (prog) {
      prog.start();
    }
    const apiKey = await this.fetcher.get("/Editor/Google/APIKey/").object().then(unwrapResponse);
    const gmapsLoader = new Loader2({
      apiKey,
      version: "weekly",
      libraries: [
        "drawing",
        "places"
      ]
    });
    await gmapsLoader.load();
    this.map = new google.maps.Map(this.mapContainer, {
      zoom: 12,
      streetView: new google.maps.StreetViewPanorama(this.streetViewContainer, {
        addressControl: false,
        clickToGo: true,
        fullscreenControl: true,
        motionTracking: false
      })
    });
    this.elevation = new google.maps.ElevationService();
    this.streetView = new StreetViewAsync(this.map.getStreetView());
    this.streetView.addEventListener("positionchanged", () => {
      this.search(this.streetView.getPano(), false);
    });
    this.places = new PlacesAsync(new google.maps.places.PlacesService(this.map));
    this.targetMarker = new google.maps.Marker({
      icon: {
        url: "/images/markers/up-arrow.png",
        size: new google.maps.Size(32, 32),
        origin: new google.maps.Point(0, 0),
        anchor: new google.maps.Point(16, 0)
      },
      clickable: false,
      draggable: false,
      optimized: false
    });
    if (prog) {
      prog.end();
    }
  }
  closeStreetView() {
    this.streetView.close();
  }
  async search(query, showError) {
    if (this.map && this.places && this.streetView) {
      this.enabled = false;
      try {
        const m = await this.files.searchGSV(query).then(unwrapResponse) || await this.files.requestGSV(query).then(unwrapResponse);
        if (isDefined(m) && m.status !== "ZERO_RESULTS") {
          await this.setMetadata(m);
        } else {
          const results = await this.places.textSearch({
            query,
            bounds: this.map.getBounds()
          });
          const result = await this.selectResult(results);
          if (result) {
            this.setTarget(g2y(result.geometry.location));
          } else {
            throw "No results";
          }
        }
      } catch (status) {
        const error = `ERROR: ${status}`;
        if (showError) {
          this.searchBox.value = error;
        }
      }
      this.enabled = true;
    }
  }
  async selectResult(results) {
    if (results.length === 0) {
      return null;
    } else if (results.length === 1) {
      return results[0];
    }
    return await this.resultsDialog.selectResult(results);
  }
  async createOverlay(location2, width2, height2, image2) {
    if (isCanvas(image2)) {
      const blob = await canvasToBlob(image2, Image_Png);
      image2 = blobToObjectURL(blob);
    }
    if (image2 instanceof URL) {
      image2 = image2.href;
    }
    const center = new google.maps.LatLng(y2g(location2));
    const north = google.maps.geometry.spherical.computeOffset(center, height2, 0);
    const east = google.maps.geometry.spherical.computeOffset(center, width2, 90);
    const south = google.maps.geometry.spherical.computeOffset(center, height2, 180);
    const west = google.maps.geometry.spherical.computeOffset(center, width2, 270);
    const bounds = {
      north: north.lat(),
      east: east.lng(),
      south: south.lat(),
      west: west.lng()
    };
    return new google.maps.GroundOverlay(image2, bounds, {
      map: this.map
    });
  }
  async createMarker(location2, label, icon) {
    if (isCanvas(icon)) {
      const blob = await canvasToBlob(icon, Image_Png);
      icon = blobToObjectURL(blob);
    }
    if (icon instanceof URL) {
      icon = icon.href;
    }
    const opts = {
      map: this.map,
      position: y2g(location2),
      label,
      icon
    };
    return new google.maps.Marker(opts);
  }
  createLine(path) {
    return new google.maps.Polyline({
      map: this.map,
      path: path.map(y2g),
      geodesic: true,
      strokeColor: "red",
      strokeOpacity: 1,
      strokeWeight: 2
    });
  }
  async loadMetadataForFile(fileID) {
    await this.setMetadata(await this.getMetadataForFile(fileID));
  }
  getMetadataForFile(fileID) {
    return this.files.getGSV(fileID).then(unwrapResponse);
  }
  get pano() {
    return this.metadata && this.metadata.pano_id || null;
  }
  get hasPano() {
    return this.pano && this.pano.length > 0;
  }
  get metadata() {
    return this._metadata;
  }
  async setMetadata(v) {
    if (v !== this.metadata) {
      this._metadata = v;
      await this.streetView.setPano(this.pano);
      this.dispatchEvent(new TypedEvent("streetviewopened"));
      const gsvLocation = this.hasPano && this.streetView.getLocation();
      const description = gsvLocation && (gsvLocation.shortDescription || gsvLocation.description);
      const fileName = v && v.fileName;
      this.sphereName = description || fileName || null;
      this.searchBox.value = this.hasPano ? this.metadata.pano_id : "";
      let dateString = "";
      if (this.hasMetadata) {
        const date = new Date(this.metadata.date);
        dateString = `${this.metadata.copyright}, ${date.toLocaleDateString()}`;
      }
      elementSetText(
        this.copyrightLabel,
        dateString
      );
      this.refresh();
    }
  }
  get scenario() {
    return this._scenario;
  }
  set scenario(v) {
    this._scenario = v;
    this.refresh();
  }
  get hasScenario() {
    return isDefined(this.scenario);
  }
  get sphereName() {
    return this.sphereNameInput.value;
  }
  set sphereName(v) {
    if (v !== this.sphereName) {
      this.sphereNameInput.value = v;
      this.refresh();
    }
  }
  get enabled() {
    return super.enabled && this.hasScenario && !this.scenario.published;
  }
  set enabled(v) {
    super.enabled = v;
  }
  get canCapture() {
    return this.enabled && this.hasPano && this.sphereNameInput.value.length > 0;
  }
  get hasMetadata() {
    return isDefined(this.metadata);
  }
  get isCaptured() {
    return this.hasMetadata && this.metadata.fileID > 0;
  }
  get canAdd() {
    return this.enabled && this.isCaptured && this.scenario.stations.filter((s) => s.fileID === this.metadata.fileID).length === 0;
  }
  get canSetName() {
    return this.enabled && this.hasPano && !this.isCaptured;
  }
  addStreetView() {
    if (this.canAdd) {
      this.dispatchEvent(new StreetViewCaptureCompleteEvent(this.metadata));
    }
  }
  async captureStreetView(saveAsLink) {
    if (this.canCapture) {
      this.dispatchEvent(new StreetViewCaptureStartEvent());
      await this.env.withFade(async () => {
        let progUpload;
        let blob;
        if (saveAsLink) {
          blob = new Blob([this.pano], {
            type: Image_Vendor_Google_StreetView_Pano.value
          });
          progUpload = this.env.loadingBar;
        } else {
          const [capture, encode, upload] = progressSplitWeighted(this.env.loadingBar, [15, 1, 5]);
          progUpload = upload;
          const canv = await this.scenario.rig.loadCanvas(this.pano, 45 /* High */, capture);
          for (let quality = 1; quality >= 0.5; quality -= 0.05) {
            encode.report(2 * (1 - quality), 1, "encoding");
            blob = await canvasToBlob(canv, Image_Jpeg, quality);
            if (blob.size <= MAX_IMAGE_SIZE) {
              break;
            }
          }
          encode.end("encoding");
        }
        const save = this.isCaptured ? this.files.replaceGSV.bind(this.files, this.metadata.fileID) : this.files.uploadGSV.bind(this.files);
        this.metadata.fileName = this.sphereName;
        this.metadata.fileID = await save(
          blob,
          this.metadata.fileName,
          this.metadata.pano_id,
          this.metadata.location.lat,
          this.metadata.location.lng,
          this.metadata.copyright,
          this.metadata.date,
          progUpload
        ).then(unwrapResponse);
        this.metadata.filePath = `/vr/file/${this.metadata.fileID.toFixed(0)}`;
        this.scenario.clearCache();
        this.env.loadingBar.end("done");
      });
      this.dispatchEvent(new StreetViewCaptureCompleteEvent(this.metadata));
    }
  }
  onRefresh() {
    this.searchButton.disabled = this.disabled || this.searchBox.value.length === 0;
    this.searchBox.disabled = this.disabled;
    this.sphereNameInput.disabled = !this.canSetName;
    this.addButton.disabled = !this.canAdd;
    elementSetClass(this.captureButton, this.isCaptured, "btn-danger");
    elementSetClass(this.captureButton, !this.isCaptured, "btn-primary");
    buttonSetEnabled(
      this.captureButton,
      this.canCapture,
      this.isCaptured ? "Recapture" : "Capture",
      this.isCaptured ? "Download photosphere again and replace it" : "Download photosphere"
    );
  }
};

// src/dom-apps/editor/views/ModelsView.ts
var ModelsView = class extends BaseScenarioFileObjectView {
  constructor(filePicker) {
    super(
      "Model",
      "Reset Model",
      filePicker,
      [
        Model_Gltf_Binary,
        Model_Gltf_Json
      ],
      [
        "model"
      ],
      [
        "Upload GLTF or GLB files",
        "Make sure 3D models are authored in units of meters"
      ]
    );
    const rotate2 = async () => this.scenario.modelAdapter.setRotation(this.value, this.rotationX, this.rotationY, this.rotationZ);
    this.addProperties(
      [
        "Size",
        this.sizeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(10),
          step(0.1),
          placeHolder("Size"),
          onInput(() => this.scenario.modelAdapter.setSize(this.value, this.size))
        )
      ],
      [
        "Pitch",
        this.rotationXInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Yaw",
        this.rotationYInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Roll",
        this.rotationZInput = new InputRangeWithNumber(
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ]
    );
    Object.seal(this);
    this.refreshValues();
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.modelAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    await this.scenario.modelAdapter.reset(value2, this.scenario.env.defaultAvatarHeight);
  }
  deleteValue(value2) {
    return this.scenario.modelAdapter.delete(value2);
  }
  validateParent(parent) {
    return isStation(parent);
  }
  onFileSelection(parent, file, prog) {
    return this.scenario.modelAdapter.create(parent, file, prog);
  }
  get canEdit() {
    return super.canEdit && isNullOrUndefined(this.value.error);
  }
  get size() {
    return parseNumber(this.sizeInput.value);
  }
  set size(v) {
    this.sizeInput.value = formatNumber(v, 3);
  }
  get rotationX() {
    return parseNumber(this.rotationXInput.value);
  }
  set rotationX(v) {
    this.rotationXInput.value = formatNumber(v);
  }
  get rotationY() {
    return parseNumber(this.rotationYInput.value);
  }
  set rotationY(v) {
    this.rotationYInput.value = formatNumber(v);
  }
  get rotationZ() {
    return parseNumber(this.rotationZInput.value);
  }
  set rotationZ(v) {
    this.rotationZInput.value = formatNumber(v);
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      this.size = this.value.size;
      this.rotationX = this.value.rotationX;
      this.rotationY = this.value.rotationY;
      this.rotationZ = this.value.rotationZ;
    } else {
      this.size = null;
      this.rotationX = null;
      this.rotationY = null;
      this.rotationZ = null;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.sizeInput.disabled = this.rotationXInput.disabled = this.rotationYInput.disabled = this.rotationZInput.disabled = !this.canEdit;
  }
};

// src/dom-apps/editor/views/ScenarioView.ts
var LoadScenarioEvent = class extends TypedEvent {
  constructor(scenarioID) {
    super("loadscenario");
    this.scenarioID = scenarioID;
  }
};
var ForkScenarioEvent = class extends TypedEvent {
  constructor(scenarioID) {
    super("forkscenario");
    this.scenarioID = scenarioID;
  }
};
var PublishScenarioEvent = class extends TypedEvent {
  constructor(scenarioID) {
    super("publishscenario");
    this.scenarioID = scenarioID;
  }
};
var ScenarioView = class extends BaseScenarioView {
  constructor() {
    super("Scenario");
    this.addProperties(
      ["Name", this.nameBox = Run()],
      ["Version", this.versionBox = Run()],
      ["Published", this.isPublishedBox = Run()],
      ["Latitude", this.latitudeBox = Run()],
      ["Longitude", this.longitudeBox = Run()],
      ["Zones", this.zonesCountBox = Run()],
      ["Stations", this.stationsCountBox = Run()],
      ["Voice overs", this.voiceOversCountBox = Run()],
      ["Videos", this.videosCountBox = Run()],
      ["Texts", this.textsCountBox = Run()],
      ["Signs", this.signsCountBox = Run()],
      ["3D Models", this.modelsCountBox = Run()],
      ["Connections", this.connectionsCountBox = Run()],
      ["", this.editOrPublishButton = ButtonPrimary(
        "",
        onClick(() => {
          if (this.hasScenario) {
            if (this.scenario.published) {
              this.dispatchEvent(new ForkScenarioEvent(this.scenario.id));
            } else {
              this.dispatchEvent(new PublishScenarioEvent(this.scenario.id));
            }
          }
        })
      )],
      ["Other versions", this.previousVersionsBox = Run()]
    );
    Object.seal(this);
    Object.assign(window, { scenarios: this });
    this.refresh();
  }
  onScenarioChanged(_oldScenario) {
    const editAction = this.hasScenario ? this.scenario.published ? "Create new version" : "Publish" : "No scenario available";
    const isPublished = this.hasScenario && this.scenario.published;
    const isPublishable = this.hasScenario && !this.scenario.published;
    buttonSetEnabled(this.editOrPublishButton, this.hasScenario, editAction, editAction);
    elementSetClass(this.editOrPublishButton, isPublished, "btn-danger");
    elementSetClass(this.editOrPublishButton, isPublishable, "btn-primary");
    elementClearChildren(this.previousVersionsBox);
    if (this.hasScenario) {
      elementSetText(this.nameBox, this.scenario.name);
      elementSetText(this.versionBox, this.scenario.version.toFixed(0));
      elementSetText(this.isPublishedBox, this.scenario.published ? "Yes" : "No");
      elementApply(
        this.previousVersionsBox,
        ...this.scenario.versions.filter((v) => v.version !== this.scenario.version).map((v) => ButtonPrimary(
          `${v.version} (${v.published ? "Published" : "Not published"})`,
          onClick(() => this.dispatchEvent(new LoadScenarioEvent(v.id)))
        ))
      );
    } else {
      elementSetText(this.nameBox, "N/A");
      elementSetText(this.versionBox, "N/A");
      elementSetText(this.isPublishedBox, "N/A");
    }
    if (this.previousVersionsBox.childElementCount === 0) {
      elementSetText(this.previousVersionsBox, "N/A");
    }
  }
  get value() {
    return this.scenario;
  }
  set value(v) {
    this.scenario = v;
  }
  get hasValue() {
    return this.hasScenario;
  }
  onRefresh() {
    super.onRefresh();
    if (this.hasScenario) {
      elementSetText(this.zonesCountBox, this.value.zones.length.toFixed(0));
      elementSetText(this.stationsCountBox, this.value.stations.length.toFixed(0));
      elementSetText(this.voiceOversCountBox, this.value.audios.filter((v) => !v.spatialize).length.toFixed(0));
      elementSetText(this.videosCountBox, this.value.videos.length.toFixed(0));
      elementSetText(this.textsCountBox, this.value.texts.length.toFixed(0));
      elementSetText(this.signsCountBox, this.value.signs.length.toFixed(0));
      elementSetText(this.modelsCountBox, this.value.models.length.toFixed(0));
      elementSetText(this.connectionsCountBox, (this.value.connections.length / 2).toFixed(0));
      if (isDefined(this.value.originLL)) {
        const [lat, lng] = this.value.originLL.toDMSArray(2);
        elementSetText(this.latitudeBox, lat);
        elementSetText(this.longitudeBox, lng);
      } else {
        elementSetText(this.latitudeBox, "???");
        elementSetText(this.longitudeBox, "???");
      }
    } else {
      elementSetText(this.zonesCountBox, "N/A");
      elementSetText(this.stationsCountBox, "N/A");
      elementSetText(this.voiceOversCountBox, "N/A");
      elementSetText(this.videosCountBox, "N/A");
      elementSetText(this.textsCountBox, "N/A");
      elementSetText(this.signsCountBox, "N/A");
      elementSetText(this.modelsCountBox, "N/A");
      elementSetText(this.connectionsCountBox, "N/A");
      elementSetText(this.latitudeBox, "N/A");
      elementSetText(this.longitudeBox, "N/A");
    }
  }
};

// src/dom-apps/editor/views/SignsView.ts
var SignsView = class extends BaseScenarioFileObjectView {
  constructor(filePicker) {
    super(
      "Sign",
      "Reset Sign",
      filePicker,
      [
        Image_Jpeg,
        Image_Png,
        Application_Pdf
      ],
      [
        "sign"
      ],
      [
        "Upload PNG, JPEG, or PDF files",
        "Signs should be authored at the dimensions they would appear in the real world.",
        `PNG or JPEG files should be authored at ${DEMO_PPI} pixels per inch, e.g. a ${DEMO_DIM} in wide sign should be ${DEMO_PX} px wide.`,
        "Callout signs will not be visible in the app until the user clicks on the expand icon."
      ]
    );
    const rotate2 = async () => this.scenario.signAdapter.setRotation(this.value, this.rotationX, this.rotationY, this.rotationZ);
    this.addProperties(
      [
        "Width",
        this.sizeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(10),
          step(0.1),
          placeHolder("Size"),
          onInput(() => this.scenario.signAdapter.setSize(this.value, this.size))
        )
      ],
      [
        "Is Callout",
        this.isCalloutInput = InputCheckbox(
          onInput(async () => {
            await this.scenario.signAdapter.update(this.value, { isCallout: this.isCalloutInput.checked });
            this.refreshValues();
          })
        )
      ],
      [
        "Always Visible",
        this.alwaysVisibleInput = InputCheckbox(
          onInput(async () => {
            await this.scenario.signAdapter.update(this.value, { alwaysVisible: this.alwaysVisibleInput.checked });
            this.refreshValues();
          })
        )
      ],
      [
        "Pitch",
        this.rotationXInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Yaw",
        this.rotationYInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Roll",
        this.rotationZInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ]
    );
    Object.seal(this);
    this.refresh();
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.signAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    await this.scenario.signAdapter.reset(value2, this.scenario.env.defaultAvatarHeight);
  }
  deleteValue(value2) {
    return this.scenario.signAdapter.delete(value2);
  }
  validateParent(parent) {
    return isStation(parent);
  }
  onFileSelection(parent, file, prog) {
    return this.scenario.signAdapter.create(parent, file, prog);
  }
  get canEdit() {
    return super.canEdit && isNullOrUndefined(this.value.error);
  }
  get size() {
    return parseNumber(this.sizeInput.value);
  }
  set size(v) {
    this.sizeInput.value = formatNumber(v, 3);
  }
  get isCallout() {
    if (this.isCalloutInput.indeterminate) {
      return null;
    } else {
      return this.isCalloutInput.checked;
    }
  }
  set isCallout(v) {
    this.isCalloutInput.indeterminate = isNullOrUndefined(v);
    this.isCalloutInput.checked = isDefined(v) && v;
  }
  get alwaysVisible() {
    if (this.alwaysVisibleInput.indeterminate) {
      return null;
    } else {
      return this.alwaysVisibleInput.checked;
    }
  }
  set alwaysVisible(v) {
    this.alwaysVisibleInput.indeterminate = isNullOrUndefined(v);
    this.alwaysVisibleInput.checked = isDefined(v) && v;
  }
  get rotationX() {
    return parseNumber(this.rotationXInput.value);
  }
  set rotationX(v) {
    this.rotationXInput.value = formatNumber(v);
  }
  get rotationY() {
    return parseNumber(this.rotationYInput.value);
  }
  set rotationY(v) {
    this.rotationYInput.value = formatNumber(v);
  }
  get rotationZ() {
    return parseNumber(this.rotationZInput.value);
  }
  set rotationZ(v) {
    this.rotationZInput.value = formatNumber(v);
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      this.size = this.value.size;
      this.isCallout = this.value.isCallout;
      this.alwaysVisible = this.value.alwaysVisible;
      this.rotationX = this.value.rotationX;
      this.rotationY = this.value.rotationY;
      this.rotationZ = this.value.rotationZ;
    } else {
      this.size = null;
      this.isCallout = null;
      this.alwaysVisible = null;
      this.rotationX = null;
      this.rotationY = null;
      this.rotationZ = null;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.sizeInput.disabled = this.isCalloutInput.disabled = this.alwaysVisibleInput.disabled = this.rotationXInput.disabled = this.rotationYInput.disabled = this.rotationZInput.disabled = !this.canEdit;
  }
};

// src/dom-apps/editor/views/StationView.ts
var StationViewEvent = class extends TypedEvent {
  constructor(type2, station) {
    super(type2);
    this.station = station;
  }
};
var StationViewMarkStartEvent = class extends StationViewEvent {
  constructor(station) {
    super("stationmarkstart", station);
  }
};
var StationCreateConnectionEvent = class extends StationViewEvent {
  constructor(station) {
    super("createconnection", station);
  }
};
var GOOGLE_METADATA = "googleMetadataGroup";
var START_STATION_ROTATION = "startStationRotationGroup";
var StationView = class extends BaseScenarioFileObjectView {
  constructor(filePicker, mapView) {
    super(
      "Station",
      "Reset",
      filePicker,
      [
        Image_Jpeg
      ],
      [
        "photosphere"
      ],
      [
        "Avoid crowded areas",
        "Avoid photospheres with objects in arms-reach"
      ]
    );
    this.mapView = mapView;
    this.stationTransformDummy = new Object3D();
    this._metadata = null;
    const rotationSaver = () => {
      this.stationTransformDummy.quaternion.copy(this.rotationQuat);
      this.saveRotation();
    };
    this.addProperties(
      group(
        GOOGLE_METADATA,
        [
          "Google Pano ID",
          new GroupPanel(
            this.googlePanoIDBox = Run(
              overflow("hidden"),
              whiteSpace("nowrap"),
              textOverflow("ellipsis"),
              maxWidth(em(10))
            ),
            this.viewStreetViewButton = ButtonPrimarySmall(
              "View",
              onClick(() => {
                this.mapView.setMetadata(this.metadata);
              })
            )
          )
        ]
      ),
      group(
        START_STATION_ROTATION,
        [
          "Start rotation",
          this.startRotationBox = new InputRangeWithNumber(
            classList("form-control"),
            min(0),
            max(360),
            step(0.1),
            placeHolder("degrees"),
            onInput(() => {
              if (this.isStartStation) {
                this.scenario.stationAdapter.setStartRotation(this.value, deg2rad(this.startRotationBox.valueAsNumber));
                this.scenario.env.avatar.setHeadingImmediate(this.scenario.startRotation);
              }
            })
          )
        ]
      ),
      [
        "Label",
        this.labelInput = TextArea(
          classList("form-control"),
          placeHolder("Enter label"),
          wrap("soft"),
          autoComplete(false),
          customData("lpignore", "true"),
          onInput(() => this.scenario.stationAdapter.updateThrottled(this.value, {
            label: this.label
          }))
        )
      ],
      [
        "Latitude",
        this.latitudeBox = Run()
      ],
      [
        "Longitude",
        this.longitudeBox = Run()
      ],
      [
        "Elevation",
        new GroupPanel(
          this.elevationInput = InputNumber(
            "Reset",
            classList("form-control"),
            onInput(() => this.scenario.stationAdapter.moveThrottled(this.value, this.value.location.lat, this.value.location.lng, this.elevation, false)),
            placeHolder("Elevation"),
            step(1e-3)
          ),
          this.resetButton
        )
      ],
      [
        "Pitch",
        this.rotationXInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotationSaver)
        )
      ],
      [
        "Yaw",
        this.rotationYInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotationSaver)
        )
      ],
      [
        "Roll",
        this.rotationZInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotationSaver)
        )
      ]
    );
    elementInsertBefore(
      this.element,
      Div(
        className("controls"),
        this.markStartButton = ButtonPrimarySmall(
          "Mark Start",
          onClick(() => this.dispatchEvent(new StationViewMarkStartEvent(this.value)))
        ),
        this.connectButton = ButtonPrimarySmall(
          "Connect",
          onClick(() => this.dispatchEvent(new StationCreateConnectionEvent(this.value)))
        )
      ),
      this.scrollPanel
    );
    Object.seal(this);
    this.refreshValues();
  }
  updateRotationFromTransformer() {
    this.rotationQuat = this.scenario.env.skybox.rotation = this.stationTransformDummy.quaternion;
  }
  saveRotation() {
    this.scenario.stationAdapter.updateThrottled(this.value, { rotation: this.rotationArray });
  }
  getTransformModes() {
    return [
      "View Rotate" /* RotateViewSpace */,
      "Global Rotate" /* RotateGlobalSpace */,
      "Object Rotate" /* RotateObjectSpace */
    ];
  }
  onScenarioChanged(oldScenario) {
    if (isDefined(oldScenario)) {
      this.stationTransformDummy.removeFromParent();
      oldScenario.removeScope(this);
    }
    if (isDefined(this.scenario)) {
      this.scenario.env.worldUISpace.add(this.stationTransformDummy);
      this.stationTransformDummy.position.z = -3;
      this.scenario.addScopedEventListener(this, "stationmarkermoved", async (evt) => {
        const elevation = await this.mapView.getElevation(evt.latLng);
        await this.scenario.stationAdapter.move(
          evt.station,
          evt.latLng.lat,
          evt.latLng.lng,
          elevation,
          false
        );
        if (evt.station === this.value) {
          this.refreshValues();
        }
      });
    }
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.stationAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    const elevation = await this.mapView.getElevation(value2.location);
    await this.scenario.stationAdapter.move(value2, value2.location.lat, value2.location.lng, elevation, true);
  }
  deleteValue(value2) {
    return this.scenario.stationAdapter.delete(value2);
  }
  validateParent(parent) {
    return isZone(parent);
  }
  async onFileSelection(parent, file, prog) {
    const target = await this.mapView.getCenter();
    await this.scenario.resolveOrigin(target);
    const value2 = await this.scenario.stationAdapter.create(file.id, file.name, target.lat, target.lng, target.alt, prog);
    await this.scenario.stationAdapter.update(value2, { zone: parent });
    return value2;
  }
  get metadata() {
    return this._metadata;
  }
  set metadata(v) {
    if (v !== this.metadata) {
      this._metadata = v;
      this.refresh();
    }
  }
  get hasMetadata() {
    return isDefined(this.metadata);
  }
  get label() {
    if (this.hasValue) {
      return this.labelInput.value;
    } else {
      return null;
    }
  }
  set label(v) {
    this.labelInput.value = v;
  }
  get elevation() {
    if (this.hasValue) {
      return this.elevationInput.valueAsNumber;
    } else {
      return null;
    }
  }
  set elevation(v) {
    if (isDefined(v)) {
      v = millimeters2Meters(Math.round(meters2Millimeters(v)));
    }
    if (v !== this.elevation) {
      this.elevationInput.valueAsNumber = v;
    }
  }
  get rotationEuler() {
    return new Euler().set(
      deg2rad(this.rotationX),
      deg2rad(this.rotationY),
      deg2rad(this.rotationZ),
      "XYZ"
    );
  }
  set rotationEuler(euler) {
    this.rotationX = rad2deg(euler.x);
    this.rotationY = rad2deg(euler.y);
    this.rotationZ = rad2deg(euler.z);
  }
  get rotationQuat() {
    return new Quaternion().setFromEuler(this.rotationEuler);
  }
  set rotationQuat(v) {
    this.rotationEuler = new Euler().setFromQuaternion(v);
  }
  get rotationArray() {
    return this.rotationQuat.toArray();
  }
  set rotationArray(v) {
    this.rotationQuat = new Quaternion().fromArray(v);
  }
  get rotationX() {
    return parseNumber(this.rotationXInput.value);
  }
  set rotationX(v) {
    this.rotationXInput.value = formatNumber(v);
  }
  get rotationY() {
    return parseNumber(this.rotationYInput.value);
  }
  set rotationY(v) {
    this.rotationYInput.value = formatNumber(v);
  }
  get rotationZ() {
    return parseNumber(this.rotationZInput.value);
  }
  set rotationZ(v) {
    this.rotationZInput.value = formatNumber(v);
  }
  get isStartStation() {
    return this.hasScenario && this.hasValue && this.scenario.startStation === this.value;
  }
  get canMarkStartStation() {
    return this.canEdit && !this.isStartStation;
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      const [lat, lng] = new LatLngPoint(this.value.location).toDMSArray(2);
      elementSetText(this.latitudeBox, lat);
      elementSetText(this.longitudeBox, lng);
      this.label = this.value.label;
      this.elevation = this.value.location.alt;
      this.rotationArray = this.value.rotation;
      this.mapView.getMetadataForFile(this.value.fileID).then((m) => this.metadata = m);
    } else {
      elementSetText(this.latitudeBox, "N/A");
      elementSetText(this.longitudeBox, "N/A");
      this.label = null;
      this.elevation = null;
      this.rotationX = null;
      this.rotationY = null;
      this.rotationZ = null;
      this.metadata = null;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.properties.setGroupVisible(GOOGLE_METADATA, this.hasMetadata);
    if (this.hasMetadata) {
      elementSetText(this.googlePanoIDBox, this.metadata.pano_id);
      elementSetTitle(this.googlePanoIDBox, this.metadata.pano_id);
    }
    this.properties.setGroupVisible(START_STATION_ROTATION, this.isStartStation);
    if (this.isStartStation) {
      this.startRotationBox.value = formatNumber(rad2deg(this.scenario.startRotation), 1);
    }
    this.markStartButton.disabled = !this.canMarkStartStation;
    this.viewStreetViewButton.disabled = this.startRotationBox.disabled = this.labelInput.disabled = this.elevationInput.disabled = this.rotationXInput.disabled = this.rotationYInput.disabled = this.rotationZInput.disabled = this.connectButton.disabled = !this.canEdit;
  }
};

// src/dom-apps/editor/views/TextsView.ts
var TextsView = class extends BaseScenarioFileObjectView {
  constructor(filePicker) {
    super(
      "Text",
      "Reset Text",
      filePicker,
      [
        Text_Plain
      ],
      [
        "text"
      ],
      [
        "Upload TXT files",
        "Text item will not be visible in the app until the user clicks on the expand icon."
      ]
    );
    const rotate2 = async () => this.scenario.textAdapter.setRotation(this.value, this.rotationX, this.rotationY, this.rotationZ);
    this.addProperties(
      [
        "Text",
        this.textInput = TextArea(
          onInput(async () => {
            if (this.hasValue) {
              await this.scenario.textAdapter.updateThrottled(this.value, { text: this.textInput.value });
              this.refreshValues();
            }
          })
        )
      ],
      [
        "Width",
        this.sizeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(10),
          step(0.1),
          placeHolder("Size"),
          onInput(() => this.scenario.textAdapter.setSize(this.value, this.size))
        )
      ],
      [
        "Is Callout",
        this.isCalloutInput = InputCheckbox(
          onInput(async () => {
            await this.scenario.textAdapter.update(this.value, { isCallout: this.isCalloutInput.checked });
            this.refreshValues();
          })
        )
      ],
      [
        "Always Visible",
        this.alwaysVisibleInput = InputCheckbox(
          onInput(async () => {
            await this.scenario.textAdapter.update(this.value, { alwaysVisible: this.alwaysVisibleInput.checked });
            this.refreshValues();
          })
        )
      ],
      [
        "Pitch",
        this.rotationXInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Yaw",
        this.rotationYInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Roll",
        this.rotationZInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ]
    );
    Object.seal(this);
    this.refresh();
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.textAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    await this.scenario.textAdapter.reset(value2, this.scenario.env.defaultAvatarHeight);
  }
  deleteValue(value2) {
    return this.scenario.textAdapter.delete(value2);
  }
  validateParent(parent) {
    return isStation(parent);
  }
  async getFile(parent) {
    const form = new FormData();
    const siblings = this.scenario.textsByStation.get(parent) || [];
    const siblingNames = new Set(siblings.map((t2) => t2.fileName));
    let fileName = null;
    for (let i = 0; fileName === null; ++i) {
      fileName = `Text Label ${i}`;
      if (siblingNames.has(fileName)) {
        fileName = null;
      }
    }
    fileName = Text_Plain.addExtension(fileName);
    const emptyFile = new File(["<Enter text>"], fileName, {
      type: Text_Plain.value
    });
    form.set("FormFile", emptyFile, fileName);
    form.set("Copyright", "Diplomatic Language Services");
    form.set("CopyrightDate", new Date(Date.now()).toDateString());
    form.set("TagString", "text");
    return this.scenario.env.fetcher.post("/editor/files/create").body(form).object().then(unwrapResponse);
  }
  onFileSelection(parent, file, prog) {
    return this.scenario.textAdapter.create(parent, file, prog);
  }
  get canEdit() {
    return super.canEdit && isNullOrUndefined(this.value.error);
  }
  get text() {
    return this.textInput.value;
  }
  set text(v) {
    this.textInput.value = v;
  }
  get size() {
    return parseNumber(this.sizeInput.value);
  }
  set size(v) {
    this.sizeInput.value = formatNumber(v, 3);
  }
  get isCallout() {
    if (this.isCalloutInput.indeterminate) {
      return null;
    } else {
      return this.isCalloutInput.checked;
    }
  }
  set isCallout(v) {
    this.isCalloutInput.indeterminate = isNullOrUndefined(v);
    this.isCalloutInput.checked = isDefined(v) && v;
  }
  get alwaysVisible() {
    if (this.alwaysVisibleInput.indeterminate) {
      return null;
    } else {
      return this.alwaysVisibleInput.checked;
    }
  }
  set alwaysVisible(v) {
    this.alwaysVisibleInput.indeterminate = isNullOrUndefined(v);
    this.alwaysVisibleInput.checked = isDefined(v) && v;
  }
  get rotationX() {
    return parseNumber(this.rotationXInput.value);
  }
  set rotationX(v) {
    this.rotationXInput.value = formatNumber(v);
  }
  get rotationY() {
    return parseNumber(this.rotationYInput.value);
  }
  set rotationY(v) {
    this.rotationYInput.value = formatNumber(v);
  }
  get rotationZ() {
    return parseNumber(this.rotationZInput.value);
  }
  set rotationZ(v) {
    this.rotationZInput.value = formatNumber(v);
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      this.text = this.value.text;
      this.size = this.value.size;
      this.isCallout = this.value.isCallout;
      this.alwaysVisible = this.value.alwaysVisible;
      this.rotationX = this.value.rotationX;
      this.rotationY = this.value.rotationY;
      this.rotationZ = this.value.rotationZ;
    } else {
      this.text = null;
      this.size = null;
      this.isCallout = null;
      this.alwaysVisible = null;
      this.rotationX = null;
      this.rotationY = null;
      this.rotationZ = null;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.textInput.disabled = this.sizeInput.disabled = this.isCalloutInput.disabled = this.alwaysVisibleInput.disabled = this.rotationXInput.disabled = this.rotationYInput.disabled = this.rotationZInput.disabled = !this.canEdit;
  }
};

// src/dom-apps/editor/views/VideosView.ts
var VideosView = class extends BaseScenarioFileObjectView {
  constructor(filePicker) {
    super(
      "Video",
      "Reset Video",
      filePicker,
      [
        Video_Mp4,
        Video_Mpeg,
        Video_Webm,
        Video_Vnd_DlsDc_YtDlp_Json
      ],
      [
        "video"
      ],
      [
        "Link to videos hosted on YouTube, or",
        "Upload WEBM, MP4, or MPG files."
      ]
    );
    const setType = () => {
      if (!this.scenario.videoAdapter.setSphereEncodingAndLayout(this.value, this.sphereEncoding, this.stereoLayout)) {
        this.sphereEncoding = this.value.sphereEncodingName;
        this.stereoLayout = this.value.stereoLayoutName;
      }
    };
    const saver = () => {
      this.scenario.videoAdapter.updateThrottled(this.value, {
        enabled: this.clipEnabled,
        label: this.label,
        volume: this.volume
      });
    };
    const rotate2 = () => {
      this.scenario.videoAdapter.setRotation(this.value, this.rotationX, this.rotationY, this.rotationZ);
    };
    this.addProperties(
      [
        "Enabled",
        this.enabledInput = InputCheckbox(
          onInput(saver)
        )
      ],
      [
        "Label",
        this.labelInput = TextArea(
          classList("form-control"),
          placeHolder("Enter label"),
          wrap("soft"),
          autoComplete(false),
          customData("lpignore", "true"),
          onInput(saver)
        )
      ],
      [
        "Volume",
        this.volumeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(100),
          step(1),
          placeHolder("Volume"),
          onInput(saver)
        )
      ],
      [
        "Type",
        this.sphereEncodingInput = Select(
          classList("custom-select"),
          onInput(setType),
          ...SphereEncodingNames.map((n2) => Option(n2, value(n2)))
        )
      ],
      [
        "Layout",
        this.stereoLayoutInput = Select(
          classList("custom-select"),
          onInput(setType),
          ...StereoLayoutNames.map((n2) => Option(n2, value(n2)))
        )
      ],
      [
        "Width",
        this.sizeInput = new InputRangeWithNumber(
          classList("form-control"),
          min(0),
          max(10),
          step(0.1),
          placeHolder("Size"),
          onInput(() => this.scenario.videoAdapter.setSize(this.value, this.size))
        )
      ],
      [
        "Pitch",
        this.rotationXInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Yaw",
        this.rotationYInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ],
      [
        "Roll",
        this.rotationZInput = new InputRangeWithNumber(
          classList("form-control"),
          min(-180),
          max(180),
          step(0.1),
          onInput(rotate2)
        )
      ]
    );
    Object.seal(this);
    this.refreshValues();
  }
  getValueName(value2) {
    return value2.fileName;
  }
  renameValue(value2, newName) {
    this.scenario.videoAdapter.updateThrottled(value2, { fileName: newName });
  }
  async resetValue(value2) {
    await this.scenario.videoAdapter.reset(value2, this.scenario.env.defaultAvatarHeight);
  }
  deleteValue(value2) {
    return this.scenario.videoAdapter.delete(value2);
  }
  validateParent(parent) {
    return isStation(parent);
  }
  onFileSelection(parent, file, prog) {
    return this.scenario.videoAdapter.create(parent, file, prog);
  }
  get canEdit() {
    return super.canEdit && isNullOrUndefined(this.value.error);
  }
  get clipEnabled() {
    if (this.enabledInput.indeterminate) {
      return null;
    } else {
      return this.enabledInput.checked;
    }
  }
  set clipEnabled(v) {
    this.enabledInput.indeterminate = isNullOrUndefined(v);
    this.enabledInput.checked = isDefined(v) && v;
  }
  get label() {
    return this.labelInput.value;
  }
  set label(v) {
    this.labelInput.value = v;
  }
  get volume() {
    return parseVolume(this.volumeInput.value);
  }
  set volume(v) {
    this.volumeInput.value = formatVolume(v);
  }
  get sphereEncoding() {
    return this.sphereEncodingInput.value;
  }
  set sphereEncoding(v) {
    this.sphereEncodingInput.value = v;
  }
  get stereoLayout() {
    return this.stereoLayoutInput.value;
  }
  set stereoLayout(v) {
    this.stereoLayoutInput.value = v;
  }
  get size() {
    return parseNumber(this.sizeInput.value);
  }
  set size(v) {
    this.sizeInput.value = formatNumber(v, 3);
  }
  get rotationX() {
    return parseNumber(this.rotationXInput.value);
  }
  set rotationX(v) {
    this.rotationXInput.value = formatNumber(v);
  }
  get rotationY() {
    return parseNumber(this.rotationYInput.value);
  }
  set rotationY(v) {
    this.rotationYInput.value = formatNumber(v);
  }
  get rotationZ() {
    return parseNumber(this.rotationZInput.value);
  }
  set rotationZ(v) {
    this.rotationZInput.value = formatNumber(v);
  }
  onValueChanged() {
    super.onValueChanged();
    if (this.hasValue) {
      this.clipEnabled = this.value.enabled;
      this.label = this.value.label;
      this.volume = this.value.volume;
      this.sphereEncoding = this.value.sphereEncodingName;
      this.stereoLayout = this.value.stereoLayoutName;
      this.size = this.value.size;
      this.rotationX = this.value.rotationX;
      this.rotationY = this.value.rotationY;
      this.rotationZ = this.value.rotationZ;
    } else {
      this.clipEnabled = null;
      this.label = null;
      this.volume = null;
      this.sphereEncoding = null;
      this.stereoLayout = null;
      this.size = null;
      this.rotationX = null;
      this.rotationY = null;
      this.rotationZ = null;
    }
  }
  onRefresh() {
    super.onRefresh();
    this.sizeInput.disabled = this.rotationXInput.disabled = this.rotationYInput.disabled = this.rotationZInput.disabled = this.sphereEncodingInput.disabled = this.stereoLayoutInput.disabled = !this.canEdit;
  }
};

// src/dom-apps/editor/views/ZoneView.ts
function isDefault(v) {
  return /^default$/i.test(v);
}
var ZoneView = class extends BaseScenarioObjectView {
  constructor() {
    super("Zone", [
      "Use zones to group environment audio and stations",
      "Environment audio will only be played when the user is in a station grouped in the same zone as the audio",
      "The Default zone cannot be renamed or deleted",
      "Empty zones won't be saved"
    ], false);
    Object.seal(this);
    Object.assign(window, { zones: this });
    this.refreshValues();
  }
  getValueName(value2) {
    return value2 || "Default";
  }
  deleteValue(value2) {
    this.renameValue(value2, "");
    return Promise.resolve();
  }
  renameValue(value2, newName) {
    this.scenario.audios.filter((audio2) => audio2.spatialize && audio2.zone === value2).forEach((audio2) => this.scenario.audioAdapter.updateThrottled(audio2, { zone: newName }));
    this.scenario.stations.filter((station) => station.zone === value2).forEach((station) => this.scenario.stationAdapter.updateThrottled(station, { zone: newName }));
    this.scenario.refreshZones();
  }
  createValue() {
    let counter = 0;
    let name3 = null;
    do {
      name3 = counter === 0 ? "New Zone" : `New Zone - ${counter}`;
      ++counter;
    } while (this.scenario.zones.indexOf(name3) > -1);
    this.scenario.zones.push(name3);
    return Promise.resolve(name3);
  }
  get canEdit() {
    return super.canEdit && !isDefault(this.getValueName(this.value));
  }
  get canRename() {
    return super.canRename && this.name.length > 0 && !isDefault(this.name.toLowerCase());
  }
};

// src/dom-apps/editor/EditorView.ts
var scenarioIDPattern = /\/\d+\/?$/;
var EditorView = class {
  constructor(fetcher2, logger2) {
    this.logger = logger2;
    this.fileDetailDialog = new FileDetailDialog();
    this._scenario = null;
    this._disabled = false;
    this.selecting = false;
    const frontBuffer = Canvas(id("frontBuffer"));
    const environmentView = Div(
      id("appContainer"),
      frontBuffer
    );
    this.env = new Environment({
      canvas: frontBuffer,
      fetcher: fetcher2,
      dialogFontFamily: defaultFont.fontFamily,
      getAppUrl: getAppScriptUrl,
      uiImagePaths: getUIImagePaths(),
      buttonFillColor: DLSBlue,
      labelFillColor: BasicLabelColor,
      defaultFOV: 75,
      enableFullResolution,
      DEBUG: true,
      watchModelPath: "/models/watch1.glb"
    });
    this.transformer = new TransformEditor(this.env);
    this.transformer.addEventListener("moving", () => {
      if (this.transformer.target === this.stationView.stationTransformDummy) {
        this.stationView.updateRotationFromTransformer();
      } else if (this.transformer.target instanceof Transform) {
        const asset = this.scenario.getAssetForTransform(this.transformer.target);
        if (isDefined(asset)) {
          const view = this.getViewFor(asset);
          view.updateTransformView(asset);
        }
      }
    });
    this.transformer.addEventListener("moved", () => {
      if (this.transformer.target === this.stationView.stationTransformDummy) {
        this.stationView.updateRotationFromTransformer();
        this.stationView.saveRotation();
      } else if (this.transformer.target instanceof Transform) {
        const asset = this.scenario.getAssetForTransform(this.transformer.target);
        if (isDefined(asset)) {
          const view = this.getViewFor(asset);
          this.withLock(() => view.saveTransform(asset));
        }
      }
    });
    elementApply(
      this.env.subMenu,
      ...this.transformer.modeButtons
    );
    this.env.foreground.add(this.transformer.object);
    const streetViewContainer = Div(id("streetViewPreview"));
    this.mapView = new MapView(fetcher2, streetViewContainer, this.env);
    const filePicker = new FilePicker(fetcher2, this.env);
    this.stationView = new StationView(filePicker, this.mapView);
    const filePropertyViews = /* @__PURE__ */ new Map([
      ["station", this.stationView],
      ["ambientAudio", new EnvironmentAudioView(filePicker, this.mapView)],
      ["audio", new AudiosView(filePicker)],
      ["video", new VideosView(filePicker)],
      ["text", new TextsView(filePicker)],
      ["sign", new SignsView(filePicker)],
      ["model", new ModelsView(filePicker)]
    ]);
    const resetablePropertyViews = new Map([
      ...Array.from(filePropertyViews.entries()),
      ["connection", this.connectionView = new ConnectionsView()]
    ]);
    const objPropertyViews = new Map([
      ...Array.from(resetablePropertyViews.entries()),
      ["zone", new ZoneView()]
    ]);
    this.propertyViews = new Map([
      ...Array.from(objPropertyViews.entries()),
      ["scenario", this.scenarioView = new ScenarioView()]
    ]);
    this.scenarioView.addEventListener("loadscenario", (evt) => this.withLock(async () => {
      this.scenario = null;
      await this.loadScenario(evt.scenarioID);
    }));
    this.scenarioView.addEventListener("forkscenario", () => this.withLock(async () => {
      const scenario = this.scenario;
      this.scenario = null;
      const newScenarioID = await scenario.fork().then(unwrapResponse);
      await this.loadScenario(newScenarioID);
    }));
    this.scenarioView.addEventListener("publishscenario", (evt) => this.withLock(async () => {
      const scenario = this.scenario;
      this.scenario = null;
      await scenario.publish();
      await this.loadScenario(evt.scenarioID);
    }));
    const onViewAsset = (evt) => {
      this.withLock(async () => {
        const asset = evt.asset;
        const view = this.getViewFor(asset);
        await this.fileDetailDialog.showFile(asset.fileID);
        await view.reloadFile();
      });
    };
    for (const view of filePropertyViews.values()) {
      view.addEventListener("assetviewfile", onViewAsset);
    }
    const onResetAsset = (evt) => {
      this.withLock(async () => {
        const kind = getAssetKind(evt.asset);
        const view = resetablePropertyViews.get(kind);
        await view.resetValue(evt.asset);
        view.refreshValues();
      });
    };
    for (const view of resetablePropertyViews.values()) {
      view.addEventListener("assetreset", onResetAsset);
    }
    const onDeleteAsset = (evt) => {
      this.deleteAsset(evt.asset);
    };
    const onRenameAsset = (evt) => {
      const { newName, asset: oldName } = evt;
      if (newName !== oldName) {
        const view = this.getViewFor(oldName);
        view.renameValue(oldName, newName);
        if (isZone(oldName)) {
          const oldZoneNode = this.assetsList.findNode(oldName);
          let newZoneNode = this.assetsList.findNode(newName);
          if (isNullOrUndefined(newZoneNode)) {
            this.assetsList.addValue(newName);
            newZoneNode = this.assetsList.findNode(newName);
          }
          this.moveZoneChildren(oldZoneNode, newZoneNode);
          this.assetsList.removeNode(oldZoneNode);
        } else {
          const node = this.assetsList.findNode(oldName);
          this.assetsList.updateNode(node);
        }
      }
    };
    for (const view of objPropertyViews.values()) {
      view.addEventListener("assetdelete", onDeleteAsset);
      view.addEventListener("assetrename", onRenameAsset);
    }
    elementApply(
      document.body,
      this.contextMenu = new ContextMenu()
    );
    this.element = DockPanel(
      "Yarrow.Editor2",
      resizable(true),
      rearrangeable(true),
      classList("editor"),
      DockGroupRow(
        DockGroupColumn(
          customData("proportion", 2),
          DockCell(
            "Assets",
            this.assetsList = new AssetList()
          ),
          DockCell(
            "Properties",
            ...this.propertyViews.values()
          )
        ),
        DockCell(
          "Map",
          customData("proportion", 3),
          this.mapView
        ),
        DockCell(
          Span(".", color("transparent")),
          overflow("visible"),
          customData("proportion", 6),
          this.viewTabs = TabPanel.create(
            ["appContainer", "Preview", environmentView],
            ["streetview", "Google StreetView", streetViewContainer]
          )
        )
      )
    );
    for (const view of this.propertyViews.values()) {
      view.visible = false;
    }
    this.scenarioView.visible = true;
    this.assetsList.addEventListener("select", (evt) => {
      this.selectValue(isDefined(evt.node) && isDefined(evt.node.value) ? evt.node.value : this.scenario);
    });
    widgetRemoveFromParent(this.env.quitButton);
    widgetRemoveFromParent(this.env.settingsButton);
    widgetRemoveFromParent(this.env.muteEnvAudioButton);
    const onMenu = async (evt) => {
      await this.onMenu(evt.parent.node, evt.type === "contextmenu");
      evt.complete();
    };
    this.assetsList.addEventListener("add", onMenu);
    this.assetsList.addEventListener("contextmenu", onMenu);
    this.assetsList.addEventListener("delete", (evt) => {
      this.deleteAsset(evt.node.value);
    });
    this.assetsList.addEventListener("reparented", (evt) => {
      if (evt.node.parent) {
        if (isZone(evt.node.parent.value)) {
          if (isAmbientAudio(evt.node.value)) {
            this.scenario.audioAdapter.updateThrottled(evt.node.value, { zone: evt.node.parent.value });
          } else if (isStation(evt.node.value)) {
            this.scenario.stationAdapter.updateThrottled(evt.node.value, { zone: evt.node.parent.value });
          }
        }
      }
    });
    this.stationView.addEventListener("stationmarkstart", (evt) => {
      this.withLock(async () => {
        const oldStart = this.scenario.startStation;
        await this.scenario.stationAdapter.markStart(evt.station);
        const oldNode = this.assetsList.findNode(oldStart);
        const newNode = this.assetsList.findNode(evt.station);
        this.assetsList.updateNode(oldNode);
        this.assetsList.updateNode(newNode);
      });
    });
    this.stationView.addEventListener("createconnection", (evt) => {
      this.withLock(() => this.createAsset("connection", evt.station));
    });
    this.connectionView.addEventListener("assetselected", (evt) => {
      if (!evt.isContextMenu) {
        this.selectValue(evt.asset);
      }
    });
    this.connectionView.addEventListener("connectionstarted", (evt) => {
      this.assetsList.enabled = true;
      this.assetsList.enableOnlyValues(evt.connectables);
      this.scenario.makeOnlyStationsSelectable(evt.connectables);
    });
    this.connectionView.addEventListener("connectionending", () => {
      this.scenario.makeAllMarkersSelectable();
      this.assetsList.enableAllElements();
      this.assetsList.enabled = false;
    });
    this.mapView.addEventListener("capturestart", () => {
      this.disabled = true;
      this.viewTabs.select("appContainer");
    });
    this.mapView.addEventListener("capturecomplete", (evt) => {
      this.withLock(async () => {
        const elevation = await this.mapView.getElevation(evt.metadata.location);
        const station = await this.scenario.stationAdapter.create(
          evt.metadata.fileID,
          evt.metadata.fileName,
          evt.metadata.location.lat,
          evt.metadata.location.lng,
          elevation
        );
        this.assetsList.addValue(station);
        await this.selectValue(station);
      });
    });
    this.mapView.addEventListener("streetviewopened", () => {
      this.viewTabs.select("streetview");
    });
    this.viewTabs.addEventListener("tabselected", (evt) => {
      if (evt.tabname !== "streetview") {
        this.mapView.closeStreetView();
      }
    });
    this.withLock(() => this.load());
  }
  moveZoneChildren(oldZoneNode, newZoneNode) {
    for (const childNode of oldZoneNode.children) {
      this.assetsList.reparentNode(childNode, newZoneNode, 0);
    }
  }
  deleteAsset(asset) {
    if (isScenario(asset)) {
      return Promise.reject("Can't delete the scenario");
    }
    return this.withLock(async () => {
      const kind = getAssetKind(asset);
      const view = this.getView(kind);
      const node = this.assetsList.findNode(asset);
      const parent = node.parent;
      const name3 = assetNames.get(kind);
      if (await this.env.confirmationDialog.prompt(warning.emojiStyle + " Confirm Delete", `Are you sure you want to delete ${name3}: ${this.assetsList.getAssetName(asset)}`)) {
        view.value = null;
        if (isZone(asset)) {
          const defaultZoneNode = this.assetsList.findNode("");
          this.moveZoneChildren(node, defaultZoneNode);
        } else if (isStation(asset)) {
          const backConnections = this.assetsList.findAll((value2) => isConnection(value2) && value2.toStationID === asset.transformID);
          for (const connection of backConnections) {
            this.assetsList.removeNode(connection);
          }
        } else if (isConnection(asset)) {
          const backConnections = this.assetsList.findAll((value2) => isConnection(value2) && value2.toStationID === asset.fromStationID && value2.fromStationID == asset.toStationID);
          for (const connection of backConnections) {
            this.assetsList.removeNode(connection);
          }
        }
        const selectParent = this.assetsList.selectedNode === node;
        this.assetsList.removeNode(node);
        await view.deleteValue(asset);
        if (selectParent) {
          await this.selectNode(parent);
        }
      }
    });
  }
  async getSelection(parent, fromContextMenu) {
    this.connectionView.cancelConnection();
    if (this.scenario.published) {
      return await this.contextMenu.show(
        assetDisplayNames,
        "readonly"
      );
    } else {
      const value2 = parent.value;
      if (parent.isRoot || isScenario(value2)) {
        if (fromContextMenu) {
          return await this.contextMenu.show(
            assetDisplayNames,
            "zone"
          );
        } else {
          return "zone";
        }
      } else if (isZone(value2)) {
        if (fromContextMenu && value2 !== "") {
          return await this.contextMenu.show(
            assetDisplayNames,
            "ambientAudio",
            "station",
            HR(),
            "delete"
          );
        } else {
          return await this.contextMenu.show(
            assetDisplayNames,
            "ambientAudio",
            "station"
          );
        }
      } else if (isStation(value2)) {
        if (fromContextMenu) {
          return await this.contextMenu.show(
            assetDisplayNames,
            "audio",
            "sign",
            "video",
            "text",
            "model",
            "connection",
            HR(),
            "delete"
          );
        } else {
          return await this.contextMenu.show(
            assetDisplayNames,
            "audio",
            "sign",
            "video",
            "text",
            "model",
            "connection"
          );
        }
      } else {
        if (fromContextMenu) {
          return await this.contextMenu.show(
            assetDisplayNames,
            "delete"
          );
        } else {
          return "cancel";
        }
      }
    }
  }
  async onMenu(node, isContextMenu) {
    await this.contextMenu.cancel();
    await this.withLock(async () => {
      const selection = await this.getSelection(node, isContextMenu);
      const parent = node.value;
      if (selection === "cancel" || selection === "readonly") {
        console.warn("Cancelled");
      } else if (selection === "delete") {
        await this.deleteAsset(parent);
      } else {
        await this.createAsset(selection, parent);
      }
    });
  }
  async createAsset(selection, parent) {
    if (selection === "connection") {
      await this.selectValue(parent);
    }
    const view = this.getView(selection);
    const newAsset = await view.createValue(parent, this.env.loadingBar);
    if (isDefined(newAsset)) {
      this.assetsList.addValue(newAsset);
      if (isConnection(newAsset)) {
        if (!isStation(parent)) {
          throw new Error("Connections must be created for Stations only");
        }
        const toStation = this.scenario.getStation(newAsset.toStationID);
        const backConnection = this.scenario.connectionAdapter.findConnection(toStation, parent);
        this.assetsList.addValue(backConnection);
        await this.selectValue(toStation);
      } else {
        await this.selectValue(newAsset);
      }
    }
  }
  async load() {
    const pathParts = document.location.pathname.split("/");
    if (pathParts.length === 0) {
      throw new Error("Illegal path");
    }
    const scenarioIDStr = pathParts[pathParts.length - 1];
    if (!/^\d+$/.test(scenarioIDStr)) {
      throw new Error("Illegal ID");
    }
    const progs = progressSplitWeighted(this.env.loadingBar, [1, 9]);
    const scenarioID = parseFloat(scenarioIDStr);
    await this.mapView.load(progs[0]);
    await this.loadScenario(scenarioID, progs[1]);
  }
  async loadScenario(scenarioID, prog) {
    prog = prog || this.env.loadingBar;
    const loc = new URLBuilder(location.href).pathPop(scenarioIDPattern).pathPush(scenarioID.toString()).toString();
    history.replaceState(null, null, loc);
    const scenarioAsset = new AssetEditableScenario(this.env, this.logger, this.mapView, scenarioID);
    await this.env.load(prog, scenarioAsset);
    this.scenario = scenarioAsset.result;
    this.env.menuButton.disabled = this.scenario.published;
  }
  get scenario() {
    return this._scenario;
  }
  set scenario(v) {
    const oldScenario = this.scenario;
    if (isDefined(oldScenario)) {
      oldScenario.removeScope(this);
    }
    this.assetsList.scenario = this.mapView.scenario = this._scenario = v;
    for (const view of this.propertyViews.values()) {
      view.scenario = v;
    }
    if (isDefined(oldScenario)) {
      oldScenario.dispose();
    }
    if (isDefined(this.scenario)) {
      this.scenario.addScopedEventListener(this, "assetselected", async (evt) => {
        if (evt.isContextMenu) {
          const node = this.assetsList.findNode(evt.asset);
          await this.onMenu(node, true);
        } else {
          this.selectValue(evt.asset);
        }
      });
      this.scenario.addScopedEventListener(this, "assetupdated", (evt) => {
        if (evt.asset === this.assetsList.selectedValue) {
          const view = this.getViewFor(evt.asset);
          view.refreshValues();
        }
      });
      this.showScenario();
    }
  }
  showScenario() {
    if (this.scenario.stations.length > 1) {
      this.mapView.fitBounds(...this.scenario.stations.map((s) => s.location));
    } else if (isDefined(this.scenario.originLL)) {
      this.mapView.panTo(y2g(this.scenario.originLL));
    } else if (this.scenario.stations.length > 0) {
      this.mapView.zoom = 15;
      if (this.scenario.startStation) {
        this.mapView.panTo(this.scenario.startStation.location);
      } else {
        this.mapView.panTo(this.scenario.stations[0].location);
      }
    } else {
      this.withLock(async () => {
        await this.mapView.search(this.scenario.name, false);
      });
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(v) {
    this._disabled = v;
    this.mapView.disabled = this.assetsList.disabled = v;
    for (const view of this.propertyViews.values()) {
      view.disabled = v;
    }
  }
  async withLock(action) {
    this.disabled = true;
    try {
      await action();
    } finally {
      this.disabled = false;
    }
  }
  getView(kind) {
    return this.propertyViews.get(kind);
  }
  getViewFor(asset) {
    const kind = getAssetKind(asset);
    return this.getView(kind);
  }
  async selectValue(asset) {
    const node = this.assetsList.findNode(asset);
    await this.selectNode(node);
  }
  async selectNode(node) {
    if (this.connectionView.isConnecting) {
      if (isDefined(node) && isStation(node.value)) {
        this.connectionView.connectTo(node.value);
      }
    } else if (!this.selecting) {
      this.selecting = true;
      try {
        await this.withLock(async () => {
          this.transformer.setTarget(null);
          this.assetsList.selectedNode = node;
          for (const view of this.propertyViews.values()) {
            view.visible = false;
          }
          if (isDefined(node) && isDefined(node.value)) {
            const asset = node.value;
            const view = this.getViewFor(asset);
            view.visible = true;
            view.value = asset;
            if (isScenario(asset)) {
              this.showScenario();
            } else if (isZone(asset)) {
              this.transformer.setTarget(null);
              this.mapView.setTarget(null);
            } else {
              const transform2 = this.scenario.getTransform(asset.transformID);
              if (!isAmbientAudio(asset)) {
                const station = this.scenario.findStation(transform2);
                this.viewTabs.select("appContainer");
                this.mapView.closeStreetView();
                await this.scenario.showStationNow(station);
                const view2 = this.getViewFor(asset);
                if (isStation(asset)) {
                  this.stationView.stationTransformDummy.quaternion.fromArray(station.rotation);
                  this.transformer.setTarget(this.stationView.stationTransformDummy, view2.getTransformModes(asset));
                } else {
                  this.transformer.setTarget(transform2, view2.getTransformModes(asset));
                }
              }
              const pos = this.scenario.getTransformPosition(asset.transformID);
              this.mapView.setTarget(pos);
              if (!isStation(asset)) {
                this.env.avatar.lookAt(transform2);
              }
            }
          }
        });
      } finally {
        this.selecting = false;
      }
    }
  }
};

// src/dom-apps/editor/index.ts
var fetcher = createFetcher();
var logger = createDataLogger(fetcher);
var editor = new EditorView(fetcher, logger);
elementApply(
  getElement("#layoutForm"),
  width(perc(100)),
  height(perc(100)),
  editor
);
Object.assign(window, { editor });
//# sourceMappingURL=index.js.map
