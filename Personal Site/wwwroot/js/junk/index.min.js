var{ACESFilmicToneMapping:pe,AddEquation:me,AddOperation:he,AdditiveAnimationBlendMode:Se,AdditiveBlending:ge,AlphaFormat:ye,AlwaysDepth:ve,AlwaysStencilFunc:xe,AmbientLight:be,AmbientLightProbe:Be,AnimationClip:_e,AnimationLoader:Ae,AnimationMixer:Me,AnimationObjectGroup:Le,AnimationUtils:we,ArcCurve:Ge,ArrayCamera:Ce,ArrowHelper:Te,Audio:Fe,AudioAnalyser:Ee,AudioContext:De,AudioListener:Re,AudioLoader:Ue,AxesHelper:Pe,BackSide:Oe,BasicDepthPacking:ze,BasicShadowMap:Ie,Bone:He,BooleanKeyframeTrack:Ne,Box2:We,Box3:M,Box3Helper:Ve,BoxBufferGeometry:je,BoxGeometry:qe,BoxHelper:ke,BufferAttribute:Ke,BufferGeometry:Qe,BufferGeometryLoader:Xe,ByteType:Ze,Cache:Je,Camera:Ye,CameraHelper:$e,CanvasTexture:et,CapsuleBufferGeometry:tt,CapsuleGeometry:rt,CatmullRomCurve3:nt,CineonToneMapping:it,CircleBufferGeometry:ot,CircleGeometry:at,ClampToEdgeWrapping:st,Clock:lt,Color:ct,ColorKeyframeTrack:dt,ColorManagement:ut,CompressedTexture:ft,CompressedTextureLoader:pt,ConeBufferGeometry:mt,ConeGeometry:ht,CubeCamera:St,CubeReflectionMapping:gt,CubeRefractionMapping:yt,CubeTexture:vt,CubeTextureLoader:xt,CubeUVReflectionMapping:bt,CubicBezierCurve:Bt,CubicBezierCurve3:_t,CubicInterpolant:At,CullFaceBack:Mt,CullFaceFront:Lt,CullFaceFrontBack:wt,CullFaceNone:Gt,Curve:Ct,CurvePath:Tt,CustomBlending:Ft,CustomToneMapping:Et,CylinderBufferGeometry:Dt,CylinderGeometry:Rt,Cylindrical:Ut,Data3DTexture:Pt,DataArrayTexture:Ot,DataTexture:zt,DataTexture2DArray:It,DataTexture3D:Ht,DataTextureLoader:Nt,DataUtils:Wt,DecrementStencilOp:Vt,DecrementWrapStencilOp:jt,DefaultLoadingManager:qt,DepthFormat:kt,DepthStencilFormat:Kt,DepthTexture:Qt,DirectionalLight:Xt,DirectionalLightHelper:Zt,DiscreteInterpolant:Jt,DodecahedronBufferGeometry:Yt,DodecahedronGeometry:$t,DoubleSide:er,DstAlphaFactor:tr,DstColorFactor:rr,DynamicCopyUsage:nr,DynamicDrawUsage:ir,DynamicReadUsage:or,EdgesGeometry:ar,EllipseCurve:sr,EqualDepth:lr,EqualStencilFunc:cr,EquirectangularReflectionMapping:dr,EquirectangularRefractionMapping:ur,Euler:fr,EventDispatcher:pr,ExtrudeBufferGeometry:mr,ExtrudeGeometry:hr,FileLoader:Sr,FlatShading:gr,Float16BufferAttribute:yr,Float32BufferAttribute:z,Float64BufferAttribute:vr,FloatType:xr,Fog:br,FogExp2:Br,Font:_r,FontLoader:Ar,FramebufferTexture:Mr,FrontSide:Lr,Frustum:wr,GLBufferAttribute:Gr,GLSL1:Cr,GLSL3:Tr,GreaterDepth:Fr,GreaterEqualDepth:Er,GreaterEqualStencilFunc:Dr,GreaterStencilFunc:Rr,GridHelper:Ur,Group:Pr,HalfFloatType:Or,HemisphereLight:zr,HemisphereLightHelper:Ir,HemisphereLightProbe:Hr,IcosahedronBufferGeometry:Nr,IcosahedronGeometry:Wr,ImageBitmapLoader:Vr,ImageLoader:jr,ImageUtils:qr,ImmediateRenderObject:kr,IncrementStencilOp:Kr,IncrementWrapStencilOp:Qr,InstancedBufferAttribute:Xr,InstancedBufferGeometry:k,InstancedInterleavedBuffer:L,InstancedMesh:Zr,Int16BufferAttribute:Jr,Int32BufferAttribute:Yr,Int8BufferAttribute:$r,IntType:en,InterleavedBuffer:tn,InterleavedBufferAttribute:S,Interpolant:rn,InterpolateDiscrete:nn,InterpolateLinear:on,InterpolateSmooth:an,InvertStencilOp:sn,KeepStencilOp:ln,KeyframeTrack:cn,LOD:dn,LatheBufferGeometry:un,LatheGeometry:fn,Layers:pn,LessDepth:mn,LessEqualDepth:hn,LessEqualStencilFunc:Sn,LessStencilFunc:gn,Light:yn,LightProbe:vn,Line:xn,Line3:K,LineBasicMaterial:bn,LineCurve:Bn,LineCurve3:_n,LineDashedMaterial:An,LineLoop:Mn,LineSegments:Ln,LinearEncoding:wn,LinearFilter:Gn,LinearInterpolant:Cn,LinearMipMapLinearFilter:Tn,LinearMipMapNearestFilter:Fn,LinearMipmapLinearFilter:En,LinearMipmapNearestFilter:Dn,LinearSRGBColorSpace:Rn,LinearToneMapping:Un,Loader:Pn,LoaderUtils:On,LoadingManager:zn,LoopOnce:In,LoopPingPong:Hn,LoopRepeat:Nn,LuminanceAlphaFormat:Wn,LuminanceFormat:Vn,MOUSE:jn,Material:qn,MaterialLoader:kn,MathUtils:Q,Matrix3:Kn,Matrix4:X,MaxEquation:Qn,Mesh:Z,MeshBasicMaterial:Xn,MeshDepthMaterial:Zn,MeshDistanceMaterial:Jn,MeshLambertMaterial:Yn,MeshMatcapMaterial:$n,MeshNormalMaterial:ei,MeshPhongMaterial:ti,MeshPhysicalMaterial:ri,MeshStandardMaterial:ni,MeshToonMaterial:ii,MinEquation:oi,MirroredRepeatWrapping:ai,MixOperation:si,MultiplyBlending:li,MultiplyOperation:ci,NearestFilter:di,NearestMipMapLinearFilter:ui,NearestMipMapNearestFilter:fi,NearestMipmapLinearFilter:pi,NearestMipmapNearestFilter:mi,NeverDepth:hi,NeverStencilFunc:Si,NoBlending:gi,NoColorSpace:yi,NoToneMapping:vi,NormalAnimationBlendMode:xi,NormalBlending:bi,NotEqualDepth:Bi,NotEqualStencilFunc:_i,NumberKeyframeTrack:Ai,Object3D:J,ObjectLoader:Mi,ObjectSpaceNormalMap:Li,OctahedronBufferGeometry:wi,OctahedronGeometry:Gi,OneFactor:Ci,OneMinusDstAlphaFactor:Ti,OneMinusDstColorFactor:Fi,OneMinusSrcAlphaFactor:Ei,OneMinusSrcColorFactor:Di,OrthographicCamera:Ri,PCFShadowMap:Ui,PCFSoftShadowMap:Pi,PMREMGenerator:Oi,ParametricGeometry:zi,Path:Ii,PerspectiveCamera:Hi,Plane:Ni,PlaneBufferGeometry:Wi,PlaneGeometry:Vi,PlaneHelper:ji,PointLight:qi,PointLightHelper:ki,Points:Ki,PointsMaterial:Qi,PolarGridHelper:Xi,PolyhedronBufferGeometry:Zi,PolyhedronGeometry:Ji,PositionalAudio:Yi,PropertyBinding:$i,PropertyMixer:eo,QuadraticBezierCurve:to,QuadraticBezierCurve3:ro,Quaternion:no,QuaternionKeyframeTrack:io,QuaternionLinearInterpolant:oo,REVISION:ao,RGBADepthPacking:so,RGBAFormat:lo,RGBAIntegerFormat:co,RGBA_ASTC_10x10_Format:uo,RGBA_ASTC_10x5_Format:fo,RGBA_ASTC_10x6_Format:po,RGBA_ASTC_10x8_Format:mo,RGBA_ASTC_12x10_Format:ho,RGBA_ASTC_12x12_Format:So,RGBA_ASTC_4x4_Format:go,RGBA_ASTC_5x4_Format:yo,RGBA_ASTC_5x5_Format:vo,RGBA_ASTC_6x5_Format:xo,RGBA_ASTC_6x6_Format:bo,RGBA_ASTC_8x5_Format:Bo,RGBA_ASTC_8x6_Format:_o,RGBA_ASTC_8x8_Format:Ao,RGBA_BPTC_Format:Mo,RGBA_ETC2_EAC_Format:Lo,RGBA_PVRTC_2BPPV1_Format:wo,RGBA_PVRTC_4BPPV1_Format:Go,RGBA_S3TC_DXT1_Format:Co,RGBA_S3TC_DXT3_Format:To,RGBA_S3TC_DXT5_Format:Fo,RGBFormat:Eo,RGB_ETC1_Format:Do,RGB_ETC2_Format:Ro,RGB_PVRTC_2BPPV1_Format:Uo,RGB_PVRTC_4BPPV1_Format:Po,RGB_S3TC_DXT1_Format:Oo,RGFormat:zo,RGIntegerFormat:Io,RawShaderMaterial:Ho,Ray:No,Raycaster:Wo,RectAreaLight:Vo,RedFormat:jo,RedIntegerFormat:qo,ReinhardToneMapping:ko,RepeatWrapping:Ko,ReplaceStencilOp:Qo,ReverseSubtractEquation:Xo,RingBufferGeometry:Zo,RingGeometry:Jo,SRGBColorSpace:Yo,Scene:$o,ShaderChunk:ea,ShaderLib:w,ShaderMaterial:Y,ShadowMaterial:ta,Shape:ra,ShapeBufferGeometry:na,ShapeGeometry:ia,ShapePath:oa,ShapeUtils:aa,ShortType:sa,Skeleton:la,SkeletonHelper:ca,SkinnedMesh:da,SmoothShading:ua,Source:fa,Sphere:D,SphereBufferGeometry:pa,SphereGeometry:ma,Spherical:ha,SphericalHarmonics3:Sa,SplineCurve:ga,SpotLight:ya,SpotLightHelper:va,Sprite:xa,SpriteMaterial:ba,SrcAlphaFactor:Ba,SrcAlphaSaturateFactor:_a,SrcColorFactor:Aa,StaticCopyUsage:Ma,StaticDrawUsage:La,StaticReadUsage:wa,StereoCamera:Ga,StreamCopyUsage:Ca,StreamDrawUsage:Ta,StreamReadUsage:Fa,StringKeyframeTrack:Ea,SubtractEquation:Da,SubtractiveBlending:Ra,TOUCH:Ua,TangentSpaceNormalMap:Pa,TetrahedronBufferGeometry:Oa,TetrahedronGeometry:za,TextGeometry:Ia,Texture:Ha,TextureLoader:Na,TorusBufferGeometry:Wa,TorusGeometry:Va,TorusKnotBufferGeometry:ja,TorusKnotGeometry:qa,Triangle:ka,TriangleFanDrawMode:Ka,TriangleStripDrawMode:Qa,TrianglesDrawMode:Xa,TubeBufferGeometry:Za,TubeGeometry:Ja,UVMapping:Ya,Uint16BufferAttribute:$a,Uint32BufferAttribute:es,Uint8BufferAttribute:ts,Uint8ClampedBufferAttribute:rs,Uniform:ns,UniformsGroup:is,UniformsLib:G,UniformsUtils:I,UnsignedByteType:os,UnsignedInt248Type:as,UnsignedIntType:ss,UnsignedShort4444Type:ls,UnsignedShort5551Type:cs,UnsignedShortType:ds,VSMShadowMap:us,Vector2:$,Vector3:p,Vector4:C,VectorKeyframeTrack:fs,VideoTexture:ps,WebGL1Renderer:ms,WebGL3DRenderTarget:hs,WebGLArrayRenderTarget:Ss,WebGLCubeRenderTarget:gs,WebGLMultipleRenderTargets:ys,WebGLMultisampleRenderTarget:vs,WebGLRenderTarget:xs,WebGLRenderer:bs,WebGLUtils:Bs,WireframeGeometry:ee,WrapAroundEnding:_s,ZeroCurvatureEnding:As,ZeroFactor:Ms,ZeroSlopeEnding:Ls,ZeroStencilOp:ws,_SRGBAFormat:Gs,sRGBEncoding:Cs}=THREE;var te=new M,R=new p,x=class extends k{constructor(){super(),this.type="LineSegmentsGeometry";let e=[-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],t=[-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],n=[0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5];this.setIndex(n),this.setAttribute("position",new z(e,3)),this.setAttribute("uv",new z(t,2))}applyMatrix4(e){let t=this.attributes.instanceStart,n=this.attributes.instanceEnd;return t!==void 0&&(t.applyMatrix4(e),n.applyMatrix4(e),t.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}setPositions(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));let n=new L(t,6,1);return this.setAttribute("instanceStart",new S(n,3,0)),this.setAttribute("instanceEnd",new S(n,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let t;e instanceof Float32Array?t=e:Array.isArray(e)&&(t=new Float32Array(e));let n=new L(t,6,1);return this.setAttribute("instanceColorStart",new S(n,3,0)),this.setAttribute("instanceColorEnd",new S(n,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new ee(e.geometry)),this}fromLineSegments(e){let t=e.geometry;if(t.isGeometry){console.error("LineSegmentsGeometry no longer supports Geometry. Use BufferGeometry instead.");return}else t.isBufferGeometry&&this.setPositions(t.attributes.position.array);return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new M);let e=this.attributes.instanceStart,t=this.attributes.instanceEnd;e!==void 0&&t!==void 0&&(this.boundingBox.setFromBufferAttribute(e),te.setFromBufferAttribute(t),this.boundingBox.union(te))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new D),this.boundingBox===null&&this.computeBoundingBox();let e=this.attributes.instanceStart,t=this.attributes.instanceEnd;if(e!==void 0&&t!==void 0){let n=this.boundingSphere.center;this.boundingBox.getCenter(n);let r=0;for(let a=0,c=e.count;a<c;a++)R.fromBufferAttribute(e,a),r=Math.max(r,n.distanceToSquared(R)),R.fromBufferAttribute(t,a),r=Math.max(r,n.distanceToSquared(R));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}applyMatrix(e){return console.warn("LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(e)}};x.prototype.isLineSegmentsGeometry=!0;G.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new $(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}};w.line={uniforms:I.merge([G.common,G.fog,G.line]),vertexShader:`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segements overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,fragmentShader:`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`};var b=class extends Y{constructor(e){super({type:"LineMaterial",uniforms:I.clone(w.line.uniforms),vertexShader:w.line.vertexShader,fragmentShader:w.line.fragmentShader,clipping:!0}),Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},worldUnits:{enumerable:!0,get:function(){return"WORLD_UNITS"in this.defines},set:function(t){t===!0?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashed:{enumerable:!0,get:function(){return Boolean("USE_DASH"in this.defines)},set(t){Boolean(t)!==Boolean("USE_DASH"in this.defines)&&(this.needsUpdate=!0),t===!0?this.defines.USE_DASH="":delete this.defines.USE_DASH}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}},alphaToCoverage:{enumerable:!0,get:function(){return Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)},set:function(t){Boolean(t)!==Boolean("USE_ALPHA_TO_COVERAGE"in this.defines)&&(this.needsUpdate=!0),t===!0?(this.defines.USE_ALPHA_TO_COVERAGE="",this.extensions.derivatives=!0):(delete this.defines.USE_ALPHA_TO_COVERAGE,this.extensions.derivatives=!1)}}}),this.setValues(e)}};b.prototype.isLineMaterial=!0;var re=new p,ne=new p,i=new C,o=new C,u=new C,H=new p,N=new X,l=new K,ie=new p,m=new M,U=new D,f=new C;function oe(g,e,t,n){return f.set(0,0,-e,1).applyMatrix4(g.projectionMatrix),f.multiplyScalar(1/f.w),f.x=t/n.width,f.y=t/n.height,f.applyMatrix4(g.projectionMatrixInverse),f.multiplyScalar(1/f.w),Math.abs(Math.max(f.x,f.y))}var T=class extends Z{constructor(e=new x,t=new b({color:Math.random()*16777215})){super(e,t),this.type="LineSegments2"}computeLineDistances(){let e=this.geometry,t=e.attributes.instanceStart,n=e.attributes.instanceEnd,r=new Float32Array(2*t.count);for(let c=0,s=0,d=t.count;c<d;c++,s+=2)re.fromBufferAttribute(t,c),ne.fromBufferAttribute(n,c),r[s]=s===0?0:r[s-1],r[s+1]=r[s]+re.distanceTo(ne);let a=new L(r,2,1);return e.setAttribute("instanceDistanceStart",new S(a,1,0)),e.setAttribute("instanceDistanceEnd",new S(a,1,1)),this}raycast(e,t){e.camera===null&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');let n=e.params.Line2!==void 0&&e.params.Line2.threshold||0,r=e.ray,a=e.camera,c=a.projectionMatrix,s=this.matrixWorld,d=this.geometry,W=this.material,h=W.resolution,P=W.linewidth+n,O=d.attributes.instanceStart,V=d.attributes.instanceEnd,B=-a.near;d.boundingSphere===null&&d.computeBoundingSphere(),U.copy(d.boundingSphere).applyMatrix4(s);let ae=Math.max(a.near,U.distanceToPoint(r.origin)),se=oe(a,ae,P,h);if(U.radius+=se,e.ray.intersectsSphere(U)===!1)return;d.boundingBox===null&&d.computeBoundingBox(),m.copy(d.boundingBox).applyMatrix4(s);let le=Math.max(a.near,m.distanceToPoint(r.origin)),_=oe(a,le,P,h);if(m.max.x+=_,m.max.y+=_,m.max.z+=_,m.min.x-=_,m.min.y-=_,m.min.z-=_,e.ray.intersectsBox(m)!==!1){r.at(1,u),u.w=1,u.applyMatrix4(a.matrixWorldInverse),u.applyMatrix4(c),u.multiplyScalar(1/u.w),u.x*=h.x/2,u.y*=h.y/2,u.z=0,H.copy(u),N.multiplyMatrices(a.matrixWorldInverse,s);for(let y=0,de=O.count;y<de;y++){i.fromBufferAttribute(O,y),o.fromBufferAttribute(V,y),i.w=1,o.w=1,i.applyMatrix4(N),o.applyMatrix4(N);var ce=i.z>B&&o.z>B;if(ce)continue;if(i.z>B){let A=i.z-o.z,v=(i.z-B)/A;i.lerp(o,v)}else if(o.z>B){let A=o.z-i.z,v=(o.z-B)/A;o.lerp(i,v)}i.applyMatrix4(c),o.applyMatrix4(c),i.multiplyScalar(1/i.w),o.multiplyScalar(1/o.w),i.x*=h.x/2,i.y*=h.y/2,o.x*=h.x/2,o.y*=h.y/2,l.start.copy(i),l.start.z=0,l.end.copy(o),l.end.z=0;let j=l.closestPointToPointParameter(H,!0);l.at(j,ie);let q=Q.lerp(i.z,o.z,j),ue=q>=-1&&q<=1,fe=H.distanceTo(ie)<P*.5;if(ue&&fe){l.start.fromBufferAttribute(O,y),l.end.fromBufferAttribute(V,y),l.start.applyMatrix4(s),l.end.applyMatrix4(s);let A=new p,v=new p;r.distanceSqToSegment(l.start,l.end,v,A),t.push({point:v,pointOnLine:A,distance:r.origin.distanceTo(v),object:this,face:null,faceIndex:y,uv:null,uv2:null})}}}}};T.prototype.isLineSegments2=!0;var F=class extends x{constructor(){super(),this.type="LineGeometry"}setPositions(e){for(var t=e.length-3,n=new Float32Array(2*t),r=0;r<t;r+=3)n[2*r]=e[r],n[2*r+1]=e[r+1],n[2*r+2]=e[r+2],n[2*r+3]=e[r+3],n[2*r+4]=e[r+4],n[2*r+5]=e[r+5];return super.setPositions(n),this}setColors(e){for(var t=e.length-3,n=new Float32Array(2*t),r=0;r<t;r+=3)n[2*r]=e[r],n[2*r+1]=e[r+1],n[2*r+2]=e[r+2],n[2*r+3]=e[r+3],n[2*r+4]=e[r+4],n[2*r+5]=e[r+5];return super.setColors(n),this}fromLine(e){var t=e.geometry;if(t.isGeometry){console.error("LineGeometry no longer supports Geometry. Use BufferGeometry instead.");return}else t.isBufferGeometry&&this.setPositions(t.attributes.position.array);return this}};F.prototype.isLineGeometry=!0;var E=class extends T{constructor(e=new F,t=new b({color:Math.random()*16777215})){super(e,t),this.type="Line2"}};E.prototype.isLine2=!0;console.log(E);console.log(new J);
